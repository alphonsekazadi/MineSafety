/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import * as T from "react";
import { MS_PER_DAY as E, getDate as S, addDays as W, ZonedDate as g, firstDayInWeek as _, addMonths as y, MS_PER_MINUTE as x } from "@progress/kendo-date-math";
import { mapTree as A, extendDataItem as L, getter as f, classNames as z } from "@progress/kendo-react-common";
import { orderBy as N, filterBy as b } from "@progress/kendo-react-data-tools";
import { createDataTree as C } from "@progress/kendo-react-treelist";
import { DEFAULT_TASK_MODEL_FIELDS as I, DEFAULT_DEPENDENCY_MODEL_FIELDS as H, HOUR_DATE_FORMAT as O, DAY_DATE_FORMAT as h, MONTH_DATE_FORMAT as F, YEAR_DATE_FORMAT as B, DAYS_IN_WEEK_COUNT as U } from "../constants/index.mjs";
const te = N, ne = b, ae = A, re = L, oe = C, se = (e) => ({ fields: { ...I, ...e } }), de = (e) => ({ fields: { ...H, ...e } }), ce = (e) => S(e), Y = (e, t) => S(W(e, t || 1)), me = (e, t, n, o) => n < t && e <= o;
function $(e) {
  return new Date(
    Date.UTC(
      e.getFullYear(),
      e.getMonth(),
      e.getDate(),
      e.getHours(),
      e.getMinutes(),
      e.getSeconds(),
      e.getMilliseconds()
    )
  );
}
const l = 4, p = 10, ie = (e, t, n, o) => {
  const r = [];
  let s = 0, a = 0;
  const d = p, i = Math.floor(n / 2), u = e.top < t.top, c = () => r.push({ left: a, top: s });
  if (o === 0 || o === 3) {
    const m = o === 3 ? "start" : "end";
    s = e.top, a = e[m], c(), a = Math[m === "start" ? "min" : "max"](e[m], t[m]), a = m === "start" ? a - d : a + d, c(), s = t.top, c(), a = m === "start" ? t[m] - l : t[m] + l, c(), w(s, a, r, m !== "start");
  } else {
    const m = o === 2 ? "start" : "end", D = o === 2 ? "end" : "start", k = o === 2 ? e[m] - p * 2 >= t[D] : e[m] + p * 2 <= t[D];
    s = e.top, a = e[m], c(), a = m === "start" ? a - d : a + d, c(), k || (s = u ? s + i : s - i, c(), a = m === "start" ? t[D] + d : t[D] - d, c()), s = t.top, c(), a = D === "start" ? t[D] - l : t[D] + l, c(), w(s, a, r, D !== "start");
  }
  return r;
}, w = (e, t, n, o) => o ? R(e, t, n) : P(e, t, n), R = (e, t, n) => {
  n.push({
    top: e - l / 2,
    left: t
  }), n.push({
    top: e,
    left: t - l + 1
  }), n.push({
    top: e + l / 2,
    left: t
  }), n.push({
    top: e,
    left: t
  });
}, P = (e, t, n) => {
  n.push({
    top: e + l / 2,
    left: t
  }), n.push({
    top: e,
    left: t + l - 1
  }), n.push({
    top: e - l / 2,
    left: t
  }), n.push({
    top: e,
    left: t
  });
}, ge = (e) => {
  if (e.workWeekStart === void 0 || e.workWeekEnd === void 0)
    return [];
  const t = [];
  let n = e.workWeekStart;
  for (t.push(n); e.workWeekEnd !== n; )
    n > 6 ? n -= 7 : n++, t.push(n);
  return t;
}, K = (e, t) => {
  const n = e.getDay();
  return t.indexOf(n) > -1;
}, M = (e, { step: t, timezone: n }) => {
  const o = [], r = g.fromLocalDate(e.start, n), s = g.fromLocalDate(e.end, n);
  let a = r.clone();
  for (; a.getTime() < s.getTime(); ) {
    const d = a.clone(), i = d.clone().addTime(t), u = new Date(d.getTime()), m = {
      end: new Date(i.getTime()),
      start: u,
      zonedStart: d,
      zonedEnd: i
    };
    o.push(m), a = a.addTime(t);
  }
  return o;
}, Z = (e, { timezone: t }, n) => {
  const o = [], r = g.fromLocalDate(e.start, t), s = g.fromLocalDate(e.end, t);
  for (let a = r.clone(); a.getTime() < s.getTime(); ) {
    const d = a.clone(), i = Y(_(S(d), n.firstDay()), U), u = g.fromUTCDate($(i), t), c = u.getTime() > s.getTime() ? s.clone() : u;
    a = c.clone();
    const m = new Date(d.getTime()), k = {
      end: new Date(c.getTime()),
      start: m,
      zonedStart: d,
      zonedEnd: c
    };
    o.push(k);
  }
  return o;
}, v = (e, { timezone: t }) => {
  const n = [], o = g.fromLocalDate(e.start, t), r = g.fromLocalDate(e.end, t);
  for (let s = o.clone(); s.getTime() < r.getTime(); ) {
    const a = s.clone(), d = g.fromLocalDate(y(new Date(a.getTime()), 1), t);
    s = d.clone();
    const i = new Date(a.getTime()), c = {
      end: new Date(d.getTime()),
      start: i,
      zonedStart: a,
      zonedEnd: d
    };
    n.push(c);
  }
  return n;
}, j = (e, { timezone: t }) => {
  const n = [], o = g.fromLocalDate(e.start, t), r = g.fromLocalDate(e.end, t);
  for (let s = o.clone(); s.getTime() < r.getTime(); ) {
    const a = s.clone(), d = g.fromLocalDate(y(new Date(a.getTime()), 12), t);
    s = d.clone();
    const i = new Date(a.getTime()), c = {
      end: new Date(d.getTime()),
      start: i,
      zonedStart: a,
      zonedEnd: d
    };
    n.push(c);
  }
  return n;
}, le = (e, t, n) => {
  const o = n.parseDate(t.workDayStart).getHours(), r = n.parseDate(t.workDayEnd).getHours();
  return M(e, { step: x * t.slotDuration, timezone: t.timezone }).map((a) => {
    const d = a.zonedStart.getHours();
    return {
      range: a,
      isWork: d >= o && d < r,
      span: 1,
      text: n.formatDate(a.zonedStart, O),
      type: "time"
    };
  });
}, De = (e, t, n) => M(e, { step: E, timezone: t.timezone }).map((r) => ({
  range: r,
  isWork: K(r.start, t.workDays),
  span: 1,
  text: n.formatDate(r.zonedStart, h),
  type: "day"
})), Te = (e, t, n) => Z(e, { timezone: t.timezone }, n).map((r) => {
  const s = Math.round((r.zonedEnd.getTime() - r.zonedStart.getTime()) / E);
  return {
    range: r,
    isWork: !1,
    span: s,
    text: `${n.formatDate(r.zonedStart, h)} - ${n.formatDate(
      r.zonedEnd,
      h
    )}`,
    type: "week"
  };
}), ue = (e, t, n) => v(e, { timezone: t.timezone }).map((r) => {
  const s = Math.round((r.zonedEnd.getTime() - r.zonedStart.getTime()) / E);
  return {
    range: r,
    isWork: !1,
    span: s,
    text: n.formatDate(r.zonedStart, F),
    type: "month"
  };
}), Ee = (e, t, n) => j(e, { timezone: t.timezone }).map((r) => {
  const s = Math.round((r.zonedEnd.getTime() - r.zonedStart.getTime()) / E);
  return {
    range: r,
    isWork: !1,
    span: s,
    text: n.formatDate(r.zonedStart, B),
    type: "year"
  };
}), ke = (e, t, n) => {
  const o = n;
  return /* @__PURE__ */ T.createElement("table", { className: "k-table k-table-md", ref: t, "aria-hidden": !0 }, /* @__PURE__ */ T.createElement("tbody", { className: "k-table-tbody" }, e.map((r, s) => /* @__PURE__ */ T.createElement("tr", { className: "k-table-row", key: s }, r.map((a, d) => /* @__PURE__ */ T.createElement(
    "td",
    {
      key: a.range.start.getTime(),
      colSpan: a.span,
      className: z("k-table-th", {
        "k-header": !0,
        "k-nonwork-hour": !a.isWork
      })
    },
    o ? /* @__PURE__ */ T.createElement(
      o,
      {
        rowIndex: s,
        index: d,
        range: a.range,
        text: a.text,
        isWork: a.isWork,
        type: a.type
      }
    ) : a.text
  ))))));
}, pe = (e, t) => {
  const n = e[e.length - 1];
  return /* @__PURE__ */ T.createElement("table", { className: "k-table k-table-md k-gantt-columns", ref: t, "aria-hidden": !0 }, /* @__PURE__ */ T.createElement("tbody", { className: "k-table-tbody" }, /* @__PURE__ */ T.createElement("tr", { className: "k-table-row" }, n.map((o) => /* @__PURE__ */ T.createElement(
    "td",
    {
      key: o.range.start.getTime(),
      colSpan: o.span,
      className: z("k-table-td", {
        "k-nonwork-hour": !o.isWork
      })
    }
  )))));
}, he = (e, t) => {
  const n = e[e.length - 1];
  let o = 0, r = 0;
  return n.forEach((s) => {
    const a = s.span;
    r += a, a > o && (o = a);
  }), Math.round(r * t / o);
}, q = (e, t) => !!f(t)(e), G = (e, t) => !!f(t)(e), Se = (e, t) => (n) => q(n, e) && G(n, t) ? [...f(t)(n)] : [];
export {
  l as ARROW_SIZE,
  p as MIN_LINE_WIDTH,
  w as addArrow,
  P as addArrowEast,
  R as addArrowWest,
  oe as createDataTree,
  ie as dependencyCoordinates,
  Se as expandedChildren,
  re as extendDataItem,
  ne as filterBy,
  De as getDaySlots,
  de as getDependencyModelFields,
  Y as getEndDate,
  le as getHourSlots,
  ue as getMonthSlots,
  ce as getStartDate,
  se as getTaskModelFields,
  pe as getTimelineContent,
  ke as getTimelineHeader,
  he as getTimelineWidth,
  Te as getWeekSlots,
  ge as getWorkDays,
  Ee as getYearSlots,
  G as hasChildren,
  q as isExpanded,
  me as isInRange,
  K as isWorkDay,
  ae as mapTree,
  te as orderBy,
  v as toMonthRanges,
  M as toRanges,
  $ as toUTCDateTime,
  Z as toWeekRanges,
  j as toYearRanges
};
