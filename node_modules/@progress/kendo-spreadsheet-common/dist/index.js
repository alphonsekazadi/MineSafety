(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@progress/kendo-drawing'), require('@progress/kendo-date-math'), require('@progress/kendo-common'), require('@progress/jszip-esm')) :
    typeof define === 'function' && define.amd ? define(['exports', '@progress/kendo-drawing', '@progress/kendo-date-math', '@progress/kendo-common', '@progress/jszip-esm'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.KendoSpreadsheetCommon = {}, global.KendoDrawing, global.KendoDateMath, global.KendoCommon, global.JSZip));
})(this, (function (exports, kendoDrawing, kendoDateMath, kendoCommon, JSZip) { 'use strict';

    /* eslint-disable camelcase */
    /* eslint-disable no-nested-ternary */
    /* eslint-disable max-params */
    /* eslint-disable no-unused-vars */
    /* eslint-disable no-else-return */
    /* eslint-disable no-param-reassign */
    /* eslint-disable eqeqeq */
    /* eslint-disable no-bitwise */

    // WARNING
    // == into === to make JSHint happy will break functionality.

    function columnName(colIndex) {
        const letter = Math.floor(colIndex / 26) - 1;
        return (letter >= 0 ? columnName(letter) : '') + String.fromCharCode(65 + (colIndex % 26));
    }
    function displaySheet(sheet) {
        if (/^[a-z_][a-z0-9_]*$/i.test(sheet)) {
            return sheet;
        }
        return "'" + sheet.replace(/\x27/g, "\\'") + "'";
    }
    function displayRef(sheet, row, col, rel) {
        let aa = "";
        ++row;

        if (!isFinite(row)) {
            row = "";
        } else if (rel != null && !(rel & 2)) {
            row = "$" + row;
        }

        if (!isFinite(col)) {
            col = "";
        } else {
            aa = columnName(col);
            if (rel != null && !(rel & 1)) {
                aa = "$" + aa;
            }
        }
        if (sheet) {
            return displaySheet(sheet) + "!" + aa + row;
        } else {
            return aa + row;
        }
    }

    /* -----[ References ]----- */

    class Ref {
        constructor() {
            this.type = "ref";
            this.sheet = "";
        }

        clone() {
            return this;
        }
        hasSheet() {
            return this._hasSheet;
        }
        simplify() {
            return this;
        }
        setSheet(sheet, hasSheet) {
            this.sheet = sheet;
            if (hasSheet != null) {
                this._hasSheet = hasSheet;
            }
            return this;
        }
        absolute(_arow, _acol) {
            return this;
        }
        relative(..._args) {
            return this;
        }
        adjust(_row, _col, _trow, _tcol, _forRow, _start, _delta) {
            return this;
        }
        toString() {
            return this.relative(0, 0, 3, 3).print(0, 0);
        }
        forEach(callback, obj) {
            callback.call(obj, this);
        }
        map(callback, obj) {
            return callback.call(obj, this);
        }
        intersect(_ref) {
            return this;
        }
        intersects(ref) {
            return this.intersect(ref) !== NULLREF;
        }
        isCell() {
            return false;
        }
        toRow(_row) {
            return this;
        }
        toColumn(_col) {
            return this;
        }
        // UnionRef overrides these, to access its subranges.
        first() {
            return this;
        }
        lastRange() {
            return this;
        }
        size() {
            return 1;
        }
        rangeAt(_index) {
            return this;
        }
        nextRangeIndex(_index) {
            return 0;
        }
        previousRangeIndex(_index) {
            return 0;
        }
        eq(reference) {
            let r1 = this;
            let r2 = reference;
            if (r1 === NULLREF || r2 === NULLREF) {
                return r1 === r2;
            }
            // make positions consistent
            if ((r2 instanceof CellRef) || (r2 instanceof RangeRef && !(r1 instanceof CellRef))) {
                r1 = reference;
                r2 = this;
            }
            if (r1 instanceof CellRef) { // cell eq *
                r2 = r2.simplify();
                return r2 instanceof CellRef && r1.row == r2.row && r1.col == r2.col && r1.sheet == r2.sheet;
            } else if (r1 instanceof RangeRef) { // range eq range/union
                if (r2 instanceof RangeRef) {
                    return r2.topLeft.eq(r1.topLeft) && r2.bottomRight.eq(r1.bottomRight);
                }
                if (r2 instanceof UnionRef) {
                    return r2.single() && r1.eq(r2.refs[0]);
                }
            } else if (r1 instanceof UnionRef && r2 instanceof UnionRef) { // union eq union
                const refs1 = r1.refs;
                const refs2 = r2.refs;
                if (refs1.length != refs2.length) {
                    return false;
                }
                for (let i = 0, len = refs1.length; i < len; i++) {
                    if (!refs1[i].eq(refs2[i])) {
                        return false;
                    }
                }
                return true;
            }
            return r1 === r2;   // XXX'll support it.
        }
        concat(ref) {
            return new UnionRef([this, ref]);
        }
        replaceAt(_index, ref) {
            return ref;
        }
        forEachColumnIndex(callback) {
            this.forEachAxisIndex('col', callback);
        }
        forEachRowIndex(callback) {
            this.forEachAxisIndex('row', callback);
        }
        forEachRow(_callback) {
            //
        }
        forEachColumn(_callback) {
            //
        }
        forEachAxisIndex(axis, callback) {
            let sorted = [];
            let method = axis === 'row' ? 'forEachRow' : 'forEachColumn';

            this[method](function(ref) {
                let index = ref.first()[axis];
                if (sorted.indexOf(index) === -1) {
                    sorted.push(index);
                }
            });

            sorted.sort(function(a, b) {
                return a > b ? 1 : (a < b ? -1 : 0);
            }).forEach(callback);
        }
        valid() {
            return false;
        }
        renameSheet(oldSheetName, newSheetName) {
            if (this.sheet && this.sheet.toLowerCase() == oldSheetName.toLowerCase()) {
                this.sheet = newSheetName;
                return true;
            }
        }
    }

    Ref.display = displayRef;

    /* -----[ Null reference ]----- */
    class NULLREFClass extends Ref {
        print() {
            return "#NULL!";
        }
        eq(ref) {
            return ref === this;
        }
        forEach() {}
    }
    const NULLREF = new NULLREFClass();

    /* -----[ Name reference ]----- */

    class NameRef extends Ref {
        constructor(name) {
            super();
            this.name = name;
            this.ref = "name";
        }

        clone() {
            return new NameRef(this.name)
                .setSheet(this.sheet, this.hasSheet());
        }
        print() {
            let ret = displaySheet(this.name);
            if (this.hasSheet()) {
                ret = displaySheet(this.sheet) + "!" + ret;
            }
            return ret;
        }
    }

    /* -----[ Cell reference ]----- */

    class CellRef extends Ref {
        constructor(row, col, rel) {
            super();
            this.row = row;
            this.col = col;
            this.rel = rel || 0;
            this.ref = "cell";
        }

        clone() {
            return new CellRef(this.row, this.col, this.rel)
                .setSheet(this.sheet, this.hasSheet());
        }

        intersect(ref) {
            if (ref instanceof CellRef) {
                if (this.eq(ref)) {
                    return this;
                } else {
                    return NULLREF;
                }
            }
            return ref.intersect(this);
        }

        print(trow, tcol, mod) {
            let col = this.col, row = this.row, rel = this.rel, abs;
            if (trow == null && rel) {
                let sheet = this.hasSheet() ? displaySheet(this.sheet) + "!" : "";
                if (isFinite(col)) {
                    col = rel & 1 ? ("C[" + col + "]") : ("C" + (col + 1));
                } else {
                    col = "";
                }
                if (isFinite(row)) {
                    row = rel & 2 ? ("R[" + row + "]") : ("R" + (row + 1));
                } else {
                    row = "";
                }
                return sheet + row + col;
            } else {
                abs = this.absolute(trow, tcol);
                if (mod) {
                    // Hacks`absolute()`
                    row = abs.row % 0x100000;
                    col = abs.col % 0x4000;
                    if (row < 0) {
                        row += 0x100000;
                    }
                    if (col < 0) {
                        col += 0x4000;
                    }
                    return displayRef(this._hasSheet && this.sheet, row, col, rel);
                }
                return abs.valid() ? displayRef(this._hasSheet && this.sheet, abs.row, abs.col, rel) : "#REF!";
            }
        }
        absolute(arow, acol) {
            let ret = this.clone();
            if ((ret.rel & 3) === 0) {
                return ret;    // already absolute
            }

            // Hacks0x4000 (max col) and 0x100000 (max row).  This
            // fixes importing relative references in definedName-s from Excel.  Example in
            // Excel3, open the Name Manager (in Formula tab) and define name
            // TEST with value Sheet1!A1:C3.  The serialization of this name in XLSX is:
            //
            //     <definedName name="TEST">Sheet1!XFA1048575:XFC1</definedName>
            //
            // This is insane, of course, but oh well.  Excel.  If you type in E3 =SUM(TEST) it
            // works (it actually sums the cells), but if you type =SUM(Sheet1!XFA1048575:XFC1)
            // you get back zero.  Let's see why SUM(TEST) works:
            //
            //     XFA1048575:XFC1                   E3
            //     (zero-based indexes below)
            //
            //     R[1048574]C[16380]:R[0]C[16382] + R2C4 = R1048576C16384:R2C16386
            //                                            % (0x100000, 0x4000)
            //                                            = R0C0:R2C2 (== A1:C3)
            //
            // So XFA1048575:XFC1 is relocated to E3 at evaluation time, and because we take
            // rows modulo 0x100000 and cols modulo 0x4000, we get back the correct range.
            //
            // IMO Excel should disallow A1-style relative references in name definitions
            // (simply because the meaning of the A1:C3 you type in Name Manager depends on the
            // active cell) and only allow R1C1 notation — that's unambiguous.  But it doesn't.
            // Moreover, R1C1-style refs in XLSX are explicitly forbidden by the spec, and the
            // hacks above are not documented — how else could we have fun implementing a XLSX
            // reader?
            if (ret.rel & 1) {
                // relative col, add anchor
                ret.col = (ret.col + acol) % 0x4000;
            }
            if (ret.rel & 2) {
                // relative row, add anchor
                ret.row = (ret.row + arow) % 0x100000;
            }

            ret.rel = 0;
            return ret;
        }
        toRangeRef() {
            return new RangeRef(this, this);
        }
        relative(arow, acol, rel) {
            if (rel == null) {
                rel = this.rel;
            }
            let row = rel & 2 ? this.row - arow : this.row;
            let col = rel & 1 ? this.col - acol : this.col;
            return new CellRef(row, col, rel)
                .setSheet(this.sheet, this.hasSheet());
        }
        height() {
            return 1;
        }
        width() {
            return 1;
        }
        toString() {
            return displayRef(null, this.row, this.col, 3);
        }
        isCell() {
            return true;
        }
        leftColumn() {
            return this;
        }
        rightColumn() {
            return this;
        }
        topRow() {
            return this;
        }
        bottomRow() {
            return this;
        }
        forEachRow(callback) {
            callback(this.toRangeRef());
        }
        forEachColumn(callback) {
            callback(this.toRangeRef());
        }
        adjust(row, col, trow, tcol, forRow, start, delta) {
            let ref = this.absolute(row, col);
            if (forRow) {
                if (ref.row >= start) {
                    if (delta < 0 && ref.row < start - delta) {
                        return NULLREF;
                    }
                    ref.row += delta;
                }
            } else {
                if (ref.col >= start) {
                    if (delta < 0 && ref.col < start - delta) {
                        return NULLREF;
                    }
                    ref.col += delta;
                }
            }
            if (trow != null && tcol != null) {
                ref = ref.relative(trow, tcol, this.rel);
            }
            return ref;
        }
        valid() {
            if (this.rel) {
                throw new Error("valid() called on relative reference");
            }
            let col = this.col, row = this.row;
            return !((isFinite(col) && col < 0) || (isFinite(row) && row < 0));
        }
    }

    /* -----[ Range reference ]----- */

    class RangeRef extends Ref {
        constructor(tl, br) {
            super();
            this.ref = "range";
            if (tl._hasSheet && br._hasSheet && tl.sheet.toLowerCase() != br.sheet.toLowerCase()) {
                // "3D" reference
                this.endSheet = br.sheet;
            }
            // we want to drop any sheet information from the cells here.
            this.topLeft = new CellRef(tl.row, tl.col, tl.rel);
            this.bottomRight = new CellRef(br.row, br.col, br.rel);
            this.normalize();
        }
        clone() {
            return new RangeRef(this.topLeft.clone(), this.bottomRight.clone()).setSheet(this.sheet, this.hasSheet());
        }
        _containsRange(range) {
            return this._containsCell(range.topLeft)
                    && this._containsCell(range.bottomRight);
        }
        _containsCell(cell) {
            return cell.sheet == this.sheet
                    && cell.row >= this.topLeft.row
                    && cell.col >= this.topLeft.col
                    && cell.row <= this.bottomRight.row
                    && cell.col <= this.bottomRight.col;
        }
        contains(ref) {
            if (ref instanceof Array) {
                let that = this;

                return ref.some(function(_ref) { return Boolean(that.contains(_ref)); });
            }
            if (ref instanceof CellRef) {
                return this._containsCell(ref);
            }
            if (ref instanceof RangeRef) {
                return this._containsRange(ref);
            }
            return false;
        }
        _intersectRange(ref) {
            if (this.sheet != ref.sheet) {
                return NULLREF;
            }
            let a_left = this.topLeft.col;
            let a_top = this.topLeft.row;
            let a_right = this.bottomRight.col;
            let a_bottom = this.bottomRight.row;
            let b_left = ref.topLeft.col;
            let b_top = ref.topLeft.row;
            let b_right = ref.bottomRight.col;
            let b_bottom = ref.bottomRight.row;
            if (a_left <= b_right &&
                    b_left <= a_right &&
                    a_top <= b_bottom &&
                    b_top <= a_bottom) {
                return new RangeRef(
                    // topLeft
                    new CellRef(Math.max(a_top, b_top),
                                Math.max(a_left, b_left)),
                    // bottomRight
                    new CellRef(Math.min(a_bottom, b_bottom),
                                Math.min(a_right, b_right))
                ).setSheet(this.sheet, this.hasSheet());
            } else {
                return NULLREF;
            }
        }
        intersect(ref) {
            if (ref instanceof CellRef) {
                return this._containsCell(ref) ? ref : NULLREF;
            }
            if (ref instanceof RangeRef) {
                return this._intersectRange(ref).simplify();
            }
            if (ref instanceof UnionRef) {
                return ref.intersect(this);
            }
            return NULLREF;        // can't handle NameRef-s here.
        }
        simplify() {
            if (this.isCell()) {
                return new CellRef(
                    this.topLeft.row,
                    this.topLeft.col,
                    this.topLeft.rel
                ).setSheet(this.sheet, this.hasSheet());
            }
            return this;
        }
        normalize() {
            let a = this.topLeft, b = this.bottomRight;
            let r1 = a.row, c1 = a.col, r2 = b.row, c2 = b.col;
            let rr1 = a.rel & 2, rc1 = a.rel & 1;
            let rr2 = b.rel & 2, rc2 = b.rel & 1;
            let tmp, changes = false;
            // do not attempt to normalize unless relativeness of rows and cols are the same.
            // https://github.com/telerik/kendo-ui-core/issues/4278
            if (rr1 === rr2 && rc1 === rc2) {
                if (r1 > r2) {
                    changes = true;
                    tmp = r1; r1 = r2; r2 = tmp;
                    tmp = rr1; rr1 = rr2; rr2 = tmp;
                }
                if (c1 > c2) {
                    changes = true;
                    tmp = c1; c1 = c2; c2 = tmp;
                    tmp = rc1; rc1 = rc2; rc2 = tmp;
                }
                if (changes) {
                    this.topLeft = new CellRef(r1, c1, rc1 | rr1);
                    this.bottomRight = new CellRef(r2, c2, rc2 | rr2);
                }
            }
            return this;
        }
        print(trow, tcol, mod) {
            if (mod || this.absolute(trow, tcol).valid()) {
                let ret = this.topLeft.print(trow, tcol, mod)
                        + ":"
                        + this.bottomRight.print(trow, tcol, mod);
                if (this.hasSheet()) {
                    ret = displaySheet(this.sheet)
                            + (this.endSheet ? ":" + displaySheet(this.endSheet) : "")
                            + "!" + ret;
                }
                return ret;
            }
            return "#REF!";
        }
        absolute(arow, acol) {
            return new RangeRef(
                this.topLeft.absolute(arow, acol),
                this.bottomRight.absolute(arow, acol)
            ).setSheet(this.sheet, this.hasSheet());
        }
        relative(arow, acol, relTL, relBR) {
            if (relBR == null) {
                relBR = relTL;
            }
            return new RangeRef(
                this.topLeft.relative(arow, acol, relTL),
                this.bottomRight.relative(arow, acol, relBR)
            ).setSheet(this.sheet, this.hasSheet());
        }
        height() {
            if (this.topLeft.rel != this.bottomRight.rel) {
                throw new Error("Mixed relative/absolute references");
            }
            return this.bottomRight.row - this.topLeft.row + 1;
        }
        width() {
            if (this.topLeft.rel != this.bottomRight.rel) {
                throw new Error("Mixed relative/absolute references");
            }
            return this.bottomRight.col - this.topLeft.col + 1;
        }
        collapse() {
            return this.topLeft.toRangeRef();
        }
        leftColumn() {
            return new RangeRef(this.topLeft, new CellRef(this.bottomRight.row, this.topLeft.col));
        }
        rightColumn() {
            return new RangeRef(new CellRef(this.topLeft.row, this.bottomRight.col), this.bottomRight);
        }
        topRow() {
            return new RangeRef(this.topLeft, new CellRef(this.topLeft.row, this.bottomRight.col));
        }
        bottomRow() {
            return new RangeRef(new CellRef(this.bottomRight.row, this.topLeft.col), this.bottomRight);
        }
        toRangeRef() {
            return this;
        }
        toRow(row) {
            row += Math.max(0, this.topLeft.row);
            return new RangeRef(
                new CellRef(row, this.topLeft.col),
                new CellRef(row, this.bottomRight.col)
            ).setSheet(this.sheet, this.hasSheet());
        }
        toColumn(col) {
            col += Math.max(0, this.topLeft.col);
            return new RangeRef(
                new CellRef(this.topLeft.row, col),
                new CellRef(this.bottomRight.row, col)
            ).setSheet(this.sheet, this.hasSheet());
        }
        toCell(row, col) {
            row += Math.max(0, this.topLeft.row);
            col += Math.max(0, this.topLeft.col);
            return new CellRef(row, col, 0)
                .setSheet(this.sheet, this.hasSheet());
        }
        forEachRow(callback) {
            let startRow = this.topLeft.row;
            let endRow = this.bottomRight.row;
            let startCol = this.topLeft.col;
            let endCol = this.bottomRight.col;

            for (let i = startRow; i <= endRow; i++) {
                callback(new RangeRef(
                    new CellRef(i, startCol),
                    new CellRef(i, endCol)
                ));
            }
        }
        forEachColumn(callback) {
            let startRow = this.topLeft.row;
            let endRow = this.bottomRight.row;
            let startCol = this.topLeft.col;
            let endCol = this.bottomRight.col;

            for (let i = startCol; i <= endCol; i++) {
                callback(new RangeRef(
                    new CellRef(startRow, i),
                    new CellRef(endRow, i)
                ));
            }
        }
        intersecting(refs) {
            return refs.filter((ref) => ref.toRangeRef().intersects(this));
        }

        union(refs, callback) {
            let intersecting = this.intersecting(refs);

            let topLeftRow = this.topLeft.row;
            let topLeftCol = this.topLeft.col;
            let bottomRightRow = this.bottomRight.row;
            let bottomRightCol = this.bottomRight.col;

            let modified = false;

            intersecting.forEach(function(ref) {
                ref = ref.toRangeRef();
                if (ref.topLeft.row < topLeftRow) {
                    modified = true;
                    topLeftRow = ref.topLeft.row;
                }

                if (ref.topLeft.col < topLeftCol) {
                    modified = true;
                    topLeftCol = ref.topLeft.col;
                }

                if (ref.bottomRight.row > bottomRightRow) {
                    modified = true;
                    bottomRightRow = ref.bottomRight.row;
                }

                if (ref.bottomRight.col > bottomRightCol) {
                    modified = true;
                    bottomRightCol = ref.bottomRight.col;
                }

                if (callback) {
                    callback(ref);
                }
            });

            let result = new RangeRef(
                new CellRef(topLeftRow, topLeftCol),
                new CellRef(bottomRightRow, bottomRightCol)
            );

            if (modified) {
                return result.union(refs, callback);
            } else {
                return result;
            }
        }
        resize(options) {
            let limit = Math.max.bind(Math, 0);
            function num(value) { return value || 0; }

            let top = this.topLeft.row + num(options.top);
            let left = this.topLeft.col + num(options.left);
            let bottom = this.bottomRight.row + num(options.bottom);
            let right = this.bottomRight.col + num(options.right);

            if (left < 0 && right < 0 || top < 0 && bottom < 0) {
                return NULLREF;
            } else if (top <= bottom && left <= right) {
                return new RangeRef(new CellRef(limit(top), limit(left)),
                                    new CellRef(limit(bottom), limit(right)));
            } else {
                return NULLREF;
            }
        }
        move(rows, cols) {
            return new RangeRef(
                new CellRef(this.topLeft.row + rows,
                            this.topLeft.col + cols),
                new CellRef(this.bottomRight.row + rows,
                            this.bottomRight.col + cols)
            );
        }
        first() {
            return this.topLeft.clone().setSheet(this.sheet, this.hasSheet());
        }
        isCell() {
            return !this.endSheet && this.topLeft.eq(this.bottomRight);
        }
        toString() {
            return this.topLeft + ":" + this.bottomRight;
        }
        adjust(row, col, trow, tcol, forRow, start, delta) {
            let tl = this.topLeft.adjust(row, col, trow, tcol, forRow, start, delta);
            let tr = this.bottomRight.adjust(row, col, trow, tcol, forRow, start, delta);
            if (tl === NULLREF && tr === NULLREF) {
                return NULLREF;
            }
            if (tl === NULLREF) {
                tl = this.topLeft.absolute(row, col);
                if (forRow) {
                    tl.row = start;
                } else {
                    tl.col = start;
                }
                if (trow != null && tcol != null) {
                    tl = tl.relative(trow, tcol, this.topLeft.rel);
                }
            } else if (tr === NULLREF) {
                tr = this.bottomRight.absolute(row, col);
                if (forRow) {
                    tr.row = start - 1;
                } else {
                    tr.col = start - 1;
                }
                if (trow != null && tcol != null) {
                    tr = tr.relative(trow, tcol, this.bottomRight.rel);
                }
            }
            return new RangeRef(tl, tr)
                .setSheet(this.sheet, this.hasSheet())
                .simplify();
        }
        valid() {
            return this.topLeft.valid() && this.bottomRight.valid();
        }
    }

    /* -----[ Union reference ]----- */

    class UnionRef extends Ref {
        constructor(refs) {
            super();
            this.refs = refs;
            this.length = refs.length;
        }
        clone() {
            return new UnionRef(this.refs.slice());
        }
        intersect(ref) {
            let a = [];
            for (let i = 0; i < this.length; ++i) {
                let x = ref.intersect(this.refs[i]);
                if (x !== NULLREF) {
                    a.push(x);
                }
            }
            if (a.length > 0) {
                return new UnionRef(a).simplify();
            }
            return NULLREF;
        }
        simplify() {
            // eslint-disable-next-line max-len
            let u = new UnionRef(this.refs.reduce(function(a, ref) {
                ref = ref.simplify();
                if (ref !== NULLREF) {
                    a.push(ref);
                }
                return a;
            }, []));
            if (u.empty()) {
                return NULLREF;
            }
            if (u.single()) {
                return u.refs[0];
            }
            return u;
        }
        absolute(arow, acol) {
            return new UnionRef(this.refs.map(function(ref) {
                return ref.absolute(arow, acol);
            }));
        }
        forEach(callback, obj) {
            this.refs.forEach(function(ref) {
                if (ref instanceof UnionRef) {
                    ref.forEach(callback, obj);
                } else {
                    callback.call(obj, ref);
                }
            }, obj);
        }
        toRangeRef() {
            return this.refs[0].toRangeRef();
        }
        contains(theRef) {
            return this.refs.some(function(ref) { return ref.contains(theRef); });
        }
        map(callback, obj) {
            let refs = [];
            this.forEach(function(ref) {
                refs.push(callback.call(obj, ref));
            });
            return new UnionRef(refs);
        }
        first() {
            return this.refs[0].first();
        }
        lastRange() {
            return this.refs[this.length - 1];
        }
        size() {
            return this.length;
        }
        single() {
            return this.length == 1;
        }
        empty() {
            return this.length === 0;
        }
        isCell() {
            return this.single() && this.refs[0].isCell();
        }
        rangeAt(index) {
            return this.refs[index];
        }
        nextRangeIndex(index) {
            if (index === this.length - 1) {
                return 0;
            } else {
                return index + 1;
            }
        }
        previousRangeIndex(index) {
            if (index === 0) {
                return this.length - 1;
            } else {
                return index - 1;
            }
        }
        concat(ref) {
            return new UnionRef(this.refs.concat([ref]));
        }
        print(row, col, mod) {
            return this.refs.map(function(ref) { return ref.print(row, col, mod); }).join(",");
        }

        replaceAt(index, ref) {
            let newRefs = this.refs.slice();
            newRefs.splice(index, 1, ref);
            return new UnionRef(newRefs);
        }

        leftColumn() {
            return this.map(function(ref) {
                return ref.leftColumn();
            });
        }
        rightColumn() {
            return this.map(function(ref) {
                return ref.rightColumn();
            });
        }
        topRow() {
            return this.map(function(ref) {
                return ref.topRow();
            });
        }
        bottomRow() {
            return this.map(function(ref) {
                return ref.bottomRow();
            });
        }
        forEachRow(callback) {
            this.forEach(function(ref) {
                ref.forEachRow(callback);
            });
        }
        forEachColumn(callback) {
            this.forEach(function(ref) {
                ref.forEachColumn(callback);
            });
        }
        adjust(row, col, trow, tcol, forRow, start, delta) {
            return this.map(function(ref) {
                return ref.adjust(row, col, trow, tcol, forRow, start, delta);
            }).simplify();
        }
        toString() {
            return this.refs.map(function(ref) {
                return ref.toString();
            }).join(", ");
        }
        valid() {
            for (let i = this.refs.length; --i >= 0;) {
                if (this.refs[i].valid()) {
                    return false;
                }
            }
            return true;
        }
        renameSheet(oldSheetName, newSheetName) {
            this.refs.forEach(function(ref) {
                ref.renameSheet(oldSheetName, newSheetName);
            });
        }
    }

    const FIRSTREF = new CellRef(0, 0);

    const SHEETREF = new RangeRef(new CellRef(0, 0), new CellRef(Infinity, Infinity));
    SHEETREF.print = function() {
        return "#SHEET";
    };

    /* eslint-disable key-spacing */
    const messages = {};
    messages.view = {
        nameBox: "Name Box",
        errors: {
            modifyMerged: "Cannot change part of a merged cell.",
            openUnsupported: "Unsupported format. Please select an .xlsx file.",
            shiftingNonblankCells: "Cannot insert cells due to data loss possibility. Select another insert location or delete the data from the end of your worksheet.",
            insertColumnWhenRowIsSelected: "Cannot insert column when all columns are selected.",
            insertRowWhenColumnIsSelected: "Cannot insert row when all rows are selected.",
            filterRangeContainingMerges: "Cannot create a filter within a range containing merges",
            sortRangeContainingMerges: "Cannot sort a range containing merges",
            cantSortMultipleSelection: "Cannot sort multiple selection",
            cantSortNullRef: "Cannot sort empty selection",
            cantSortMixedCells: "Cannot sort range containing cells of mixed shapes",
            validationError: "The value that you entered violates the validation rules set on the cell.",
            cannotModifyDisabled: "Cannot modify disabled cells.",
            insertRowBelowLastRow: "Cannot insert row below the last row.",
            insertColAfterLastCol: "Cannot insert column to the right of the last column."
        },
        tabs: {
            home: "Home",
            insert: "Insert",
            data: "Data"
        }
    };

    messages.menus = {
        "cut"          : "Cut",
        "copy"         : "Copy",
        "paste"        : "Paste",
        "merge"        : "Merge",
        "unmerge"      : "Unmerge",
        "delete"       : "Delete",
        "hide"         : "Hide",
        "unhide"       : "Unhide",
        "bringToFront" : "Bring to front",
        "sendToBack"   : "Send to back"
    };

    messages.workbook = {
        defaultSheetName: "Sheet"
    };

    const options = {
        name: "Spreadsheet",
        toolbar: true,
        sheetsbar: true,
        rows: 200,
        columns: 50,
        rowHeight: 20,
        columnWidth: 64,
        headerHeight: 20,
        headerWidth: 32,
        excel: {
            fileName: "Workbook.xlsx",
            forceProxy: false,
            proxyURL: "",
        },
        messages: messages,
        pdf: {
            // which part of the workbook to be exported
            area: "workbook",
            fileName: "Workbook.pdf",
            proxyURL: "",
            // paperSize can be an usual name, i.e. "A4", or an array of two Number-s specifying the
            // width/height in points (1pt = 1/72in), or strings including unit, i.e. "10mm".  Supported
            // units are "mm", "cm", "in" and "pt".  The default "auto" means paper size is determined
            // by content.
            paperSize: "a4",
            // True to reverse the paper dimensions if needed such that width is the larger edge.
            landscape: true,
            // An object containing { left, top, bottom, right } margins with units.
            margin: null,
            // Optional information for the PDF Info dictionary; all strings except for the date.
            title: null,
            author: null,
            subject: null,
            keywords: null,
            creator: "Kendo UI PDF Generator",
            // Creation Date; defaults to new Date()
            date: null
        },
        defaultCellStyle: {
            fontFamily: "Arial",
            fontSize: 12
        },
        useCultureDecimals: false,
        locale: 'en'
    };

    const ALL_REASONS = {
        recalc: true,
        selection: true,
        activeCell: true,
        layout: true,
        sheetSelection: true,
        resize: true,
        editorChange: false,
        editorClose: false
    };

    const keys = {
        INSERT: 45,
        DELETE: 46,
        BACKSPACE: 8,
        TAB: 9,
        ENTER: 13,
        ESC: 27,
        LEFT: 37,
        UP: 38,
        RIGHT: 39,
        DOWN: 40,
        END: 35,
        HOME: 36,
        SPACEBAR: 32,
        PAGEUP: 33,
        PAGEDOWN: 34,
        F2: 113,
        F10: 121,
        F11: 122,
        F12: 123,
        NUMPAD_PLUS: 107,
        NUMPAD_MINUS: 109,
        NUMPAD_DOT: 110,
        B: 66,
        I: 73,
        U: 85,
        N: 78,
        H: 72,
        A: 65,
        R: 82
    };

    /* eslint-disable no-nested-ternary */
    /* eslint-disable no-param-reassign */
    /* eslint-disable no-prototype-builtins */

    const RX_UNICODE_LETTER = new RegExp("[\\u0041-\\u005A\\u0061-\\u007A\\u00AA\\u00B5\\u00BA\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]");

    function isUnicodeLetter(ch) {
        return RX_UNICODE_LETTER.test(ch);
    }

    function memoize(f) {
        let cache = Object.create(null);
        return function() {
            let id = "";
            for (let i = arguments.length; --i >= 0;) {
                id += ":" + arguments[i];
            }
            return id in cache ? cache[id] : (cache[id] = f.apply(this, arguments));
        };
    }

    function arabicToRoman(n) {
        let literals = {
            1: "i", 10: "x", 100: "c",
            2: "ii", 20: "xx", 200: "cc",
            3: "iii", 30: "xxx", 300: "ccc",
            4: "iv", 40: "xl", 400: "cd",
            5: "v", 50: "l", 500: "d",
            6: "vi", 60: "lx", 600: "dc",
            7: "vii", 70: "lxx", 700: "dcc",
            8: "viii", 80: "lxxx", 800: "dccc",
            9: "ix", 90: "xc", 900: "cm",
            1000: "m"
        };
        let values = [ 1000,
                       900 , 800, 700, 600, 500, 400, 300, 200, 100,
                       90 , 80 , 70 , 60 , 50 , 40 , 30 , 20 , 10 ,
                       9 , 8 , 7 , 6 , 5 , 4 , 3 , 2 , 1 ];
        let roman = "";
        while (n > 0) {
            if (n < values[0]) {
                values.shift();
            } else {
                roman += literals[values[0]];
                n -= values[0];
            }
        }
        return roman;
    }

    function romanToArabic(r) {
        r = r.toLowerCase();
        let digits = {
            i: 1,
            v: 5,
            x: 10,
            l: 50,
            c: 100,
            d: 500,
            m: 1000
        };
        let value = 0, prev = 0;
        for (let i = 0; i < r.length; ++i) {
            let v = digits[r.charAt(i)];
            if (!v) {
                return null;
            }
            value += v;
            if (v > prev) {
                value -= 2 * prev;
            }
            prev = v;
        }
        return value;
    }

    function withExit(f, obj) {
        try {
            return f.call(obj, function(value) {
                throw new Return(value);
            });
        } catch (ex) {
            if (ex instanceof Return) {
                return ex.value;
            }
            throw ex;
        }
        function Return(value) {
            this.value = value;
        }
    }

    const getterCache = {};

    getterCache["undefined"] = (obj) => obj;

    const FIELD_REGEX = /\[(?:(\d+)|['"](.*?)['"])\]|((?:(?!\[.*?\]|\.).)+)/g;
    function getter(field, safe) {
        const key = field + safe;

        if (getterCache[key]) {
            return getterCache[key];
        }

        const fields = [];
        field.replace(FIELD_REGEX, (_, index, indexAccessor, field) => {
            fields.push(isPresent(index) ? index : indexAccessor || field);
            return undefined;
        });

        getterCache[key] = (obj) => {
            let result = obj;
            for (let idx = 0; idx < fields.length; idx++) {
                result = result[fields[idx]];
                if (!isPresent(result) && safe) {
                    return result;
                }
            }

            return result;
        };

        return getterCache[key];
    }

    function deepExtend(destination) {
        let i = 1,
            length = arguments.length;

        for (i = 1; i < length; i++) {
            deepExtendOne(destination, arguments[i]);
        }

        return destination;
    }

    function deepExtendOne(destination, source) {
        let property,
            propValue,
            propType,
            destProp;

        for (property in source) {
            if (property === '__proto__' || property === 'constructor') {
                continue;
            }

            propValue = source[property];
            propType = typeof propValue;

            if (propValue instanceof Date) {
                destination[property] = new Date(propValue.getTime());
            } else if (isFunction(propValue?.clone)) {
                destination[property] = propValue.clone();
            } else if (propType === 'object' && propValue !== null && isPlainObject(propValue)) {
                // Check if the property is a plain object before attempting to merge deeply
                destProp = destination[property];
                if (typeof destProp !== 'object' || destProp === null) {
                    destination[property] = {};
                }

                deepExtendOne(destination[property], propValue);
            } else if (propType !== 'undefined') {
                destination[property] = propValue;
            }
        }

        return destination;
    }

    function guid() {
        let id = "", i, random, chars = "abcdef";

        id += chars[Math.floor(Math.random() * Math.floor(chars.length))];

        for (i = 1; i < 32; i++) {
            random = Math.random() * 16 | 0;

            if (i === 8 || i === 12 || i === 16 || i === 20) {
                id += "-";
            }
            id += (i === 12 ? 4 : (i === 16 ? (random & 3 | 8) : random)).toString(16);
        }

        return id;
    }

    const support = {};

    const scrollbar = function(refresh) {
        if (!isNaN(support._scrollbar) && !refresh) {
            return support._scrollbar;
        }

        let div = document.createElement("div"),
            result;

        div.style.overflow = "scroll";
        div.style.overflowX = "hidden";
        div.style.zoom = "1";
        div.style.clear = "both";
        div.style.display = "block";

        div.innerHTML = "&nbsp;";
        document.body.appendChild(div);

        support._scrollbar = result = div.offsetWidth - div.scrollWidth;

        document.body.removeChild(div);

        return result;
    };

    function toCamelCase(str) {
        return str.replace(/\-(\w)/g, function(strMatch, g1) {
            return g1.toUpperCase();
        });
    }

    function size(obj) {
        let result = 0, key;
        for (key in obj) {
            if (obj.hasOwnProperty(key) && key !== "toJSON") { // Ignore fake IE7 toJSON.
                result++;
            }
        }

        return result;
    }

    const kendoGetComputedStyles = function(element, properties) {
        let styles = {}, computedStyle;

        if (document.defaultView && document.defaultView.getComputedStyle) {
            computedStyle = document.defaultView.getComputedStyle(element, "");

            if (properties) {
                properties.forEach(function(value) {
                    styles[value] = computedStyle.getPropertyValue(value);
                });
            }
        } else {
            computedStyle = element.currentStyle;

            if (properties) {
                properties.forEach(function(value) {
                    styles[value] = computedStyle[toCamelCase(value)];
                });
            }
        }

        if (!size(styles)) {
            styles = computedStyle;
        }

        return styles;
    };

    const insertAfter = function(newElement, after) {
        after.parentNode.insertBefore(newElement, after.nextSibling);
    };

    const _activeElement$1 = function() {
        try {
            return document.activeElement;
        } catch (e) {
            return document.documentElement.activeElement;
        }
    };

    const isPresent = (value) => value !== null && value !== undefined;
    const isBlank = (value) => !isPresent(value);
    const isDate = (value) => value && value.getTime;
    const isString = (value) => typeof value === "string";
    const isNumeric = (value) => !isNaN(value - parseFloat(value));
    const isFunction = (fn) => typeof fn === "function";
    const isPlainObject = function(obj) {
        if (!obj || toString.call(obj) !== "[object Object]") {
            return false;
        }

        const proto = Object.getPrototypeOf(obj);
        return proto === null || proto.constructor === Object;
    };

    class CalcError {

        constructor(code) {
            if (code instanceof CalcError) {
                return code;
            }
            this.code = code;
        }

        toString() {
            return '#' + this.code + (this.code === 'NAME' ? '?' : '!');
        }
    }

    let intlValue = {};

    const intl = (value) => {
        if (value) {
            intlValue = value;
        } else {
            return intlValue;
        }
    };

    const culture = () => {
        return intl().localeInfo();
    };

    function createKendoObj(calc, CalcError, Ref, CellRef, RangeRef) {
        const kendo = {};
        kendo.spreadsheet = { calc, CalcError, Ref, CellRef, RangeRef };
        kendo.culture = () => culture();

        return kendo;
    }

    /* eslint-disable max-params */
    /* eslint-disable complexity */
    /* eslint-disable no-unused-vars */


    let calc = {
        runtime: {
            FUNCS: Object.create(null),
        }
    };

    let FUNCS$1 = calc.runtime.FUNCS;

    /* -----[ Context ]----- */

    class Context {
        constructor(callback, formula, ss, parent) {
            this.callback = callback;
            this.formula = formula;
            this.ss = ss;
            this.parent = parent;
        }

        resolve(val) {
            var self = this;
            if (val instanceof Ref) {
                self.resolveCells([ val ], function() {
                    self._resolve(val);
                });
            } else {
                self._resolve(val);
            }
        }

        error(val) {
            return new CalcError(val);
        }

        _resolve(val) {
            if (val === undefined) {
                val = null;
            } else if (Array.isArray(val)) {
                val = this.asMatrix(val);
            } else {
                val = maybeRoundFloatErrors(val);
            }
            var f = this.formula;
            if (f.arrayFormulaRange) {
                // when this is an array formula, make sure we return a Matrix.  The value already
                // *should* be a Matrix, so this won't incur speed penalty in normal cases.
                val = this.asMatrix(val) || this.asMatrix([[ val ]]);
            } else if (val instanceof RangeRef) {
                val = this._arrayArg(val);
            }
            f.value = val;
            if (this.ss.onFormula(f) && this.callback) {
                this.callback.call(f, val);
            }
        }

        resolveCells(a, f) {
            var context = this, formulas = [];

            (function loop(a) {
                for (var i = 0; i < a.length; ++i) {
                    var x = a[i];
                    if (x instanceof Ref) {
                        add(context.getRefCells(x));
                    }
                    if (Array.isArray(x)) {
                        // make sure we resolve cells in literal matrices
                        loop(x);
                    }
                }
            })(a);

            if (!formulas.length) {
                return f.call(context);
            }

            for (var pending = formulas.length, i = 0; i < formulas.length; ++i) {
                fetch(formulas[i]);
            }
            function fetch(formula) {
                formula.exec(context.ss, function() {
                    if (!--pending) {
                        f.call(context);
                    }
                }, context);
            }
            function add(a) {
                for (var i = 0; i < a.length; ++i) {
                    var cell = a[i];
                    if (cell.formula) {
                        formulas.push(cell.formula);
                    }
                }
                return true;
            }
        }

        cellValues(a, wantNulls) {
            var ret = [];
            for (var i = 0; i < a.length; ++i) {
                var val = a[i];
                if (val instanceof Ref) {
                    val = this.getRefData(val, wantNulls);
                    ret = ret.concat(val);
                } else if (Array.isArray(val)) {
                    ret = ret.concat(this.cellValues(val, wantNulls));
                } else if (val instanceof Matrix) {
                    ret = ret.concat(this.cellValues(val.data, wantNulls));
                } else {
                    ret.push(val);
                }
            }
            return ret;
        }

        fetchName(ref, callback) {
            var f = this.formula;
            var val = this.ss.nameValue(ref, f.sheet, f.row, f.col);
            if (val instanceof Formula$1) {
                // clone and relocate to calling formula, so that relative references in a named
                // formula would work as expected.
                val = val.clone(f.sheet, f.row, f.col, true);

                // XXX: I don't like this dependency here; basically we only need ss.onFormula to
                // return true and do nothing else.
                var ss = new calc.ValidationFormulaContext(this.ss.workbook);

                val.exec(ss, callback, this);
            } else {
                if (val instanceof Ref) {
                    // relocate for relative refs
                    val = val.absolute(f.row, f.col);
                    if (val instanceof RangeRef && this.ss.isMerged(val)) {
                        val = val.topLeft;
                    }
                    if (!val.sheet) {
                        val.sheet = f.sheet;
                    }
                }
                callback(val == null ? new CalcError("NAME") : val);
            }
        }

        force(val) {
            if (val instanceof Ref) {
                return this.getRefData(val);
            }
            return val;
        }

        func(fname, callback, args) {
            fname = fname.toLowerCase();
            var f = FUNCS$1[fname];
            if (f) {
                return f.call(this, callback, args);
            }
            callback(new CalcError("NAME"));
        }

        bool(val) {
            if (val instanceof Ref) {
                val = this.getRefData(val);
            }
            if (typeof val == "string") {
                return val.toLowerCase() == "true";
            }
            if (typeof val == "number") {
                return val !== 0;
            }
            if (typeof val == "boolean") {
                return val;
            }
            return val != null;
        }

        _arrayArg(ref) { // not necessarily a reference though
            var f = this.formula;
            if (!f.arrayFormulaRange && ref instanceof RangeRef) {
                // if formula wasn't saved with Ctrl-Shift-Enter but a range is passed, Excel does
                // something special:
                //
                // - if range is Wx1 (horizontal array) and current formula resides within the
                //   horizontal bounds of the range, the appropriate cell is selected.  Example:
                //   A1..D1 contain 1, 2, 3, 4 and we have in B2: =A1:D1, then B2 will get 2 (the
                //   value in A2).  If the same formula is typed outside the horizontal span of the
                //   range, say in E2: =A1:D1, then #VALUE! is returned.
                //
                // - similarly, if the range is 1xH (vertical array), the formula must reside within
                //   the vertical bounds of the range and it gets the corresponding cell; otherwise,
                //   #VALUE!.
                if (ref.height() == 1 && f.col >= ref.topLeft.col && f.col <= ref.bottomRight.col) {
                    return this.getRefData(new CellRef(ref.topLeft.row, f.col).setSheet(ref.sheet));
                }
                if (ref.width() == 1 && f.row >= ref.topLeft.row && f.row <= ref.bottomRight.row) {
                    return this.getRefData(new CellRef(f.row, ref.topLeft.col).setSheet(ref.sheet));
                }
                return new CalcError("VALUE");
            } else {
                return this.asMatrix(ref);
            }
        }

        asMatrix(range) {
            if (range instanceof Matrix) {
                return range;
            }
            let self = this;
            if (range instanceof RangeRef) {
                let tl = range.topLeft;
                let top = tl.row, left = tl.col;
                let cells = self.getRefCells(range);
                let m = new Matrix(self);
                if (isFinite(range.width())) {
                    m.width = range.width();
                }
                if (isFinite(range.height())) {
                    m.height = range.height();
                }
                if (!isFinite(top)) {
                    top = 0;
                }
                if (!isFinite(left)) {
                    left = 0;
                }
                cells.forEach(function(cell) {
                    m.set(cell.row - top,
                          cell.col - left,
                          cell.value);
                });
                return m;
            }
            if (Array.isArray(range) && range.length > 0) {
                let m = new Matrix(self), row = 0;
                range.forEach(function(line) {
                    let col = 0;
                    let h = 1;
                    line.forEach(function(el) {
                        let isRange = el instanceof RangeRef;
                        if (el instanceof Ref && !isRange) {
                            el = self.getRefData(el);
                        }
                        if (isRange || Array.isArray(el)) {
                            el = self.asMatrix(el);
                        }
                        if (el instanceof Matrix) {
                            el.each(function(el, r, c) {
                                m.set(row + r, col + c, el);
                            });
                            h = Math.max(h, el.height);
                            col += el.width;
                        } else {
                            if (typeof el === "string" && el.length && !isNaN(el)) {
                                el = Number(el);
                            }

                            m.set(row, col++, el);
                        }
                    });
                    row += h;
                });
                return m;
            }
        }

        getRefCells(refs, hiddenInfo, wantNulls) {
            var f = this.formula;
            return this.ss.getRefCells(refs, hiddenInfo, f.sheet, f.row, f.col, wantNulls);
        }

        getRefData(ref, wantNulls) {
            var f = this.formula;
            return this.ss.getData(ref, f.sheet, f.row, f.col, wantNulls);
        }

        workbook() {
            return this.ss.workbook;
        }
    }

    function argmax(i, end, f) {
        var max = f(i), pos = i;
        while (++i < end) {
            var v = f(i);
            if (v > max) {
                max = v;
                pos = i;
            }
        }
        return pos;
    }

    class Matrix {
        constructor(context) {
            this.context = context;
            this.height = 0;
            this.width = 0;
            this.data = [];
        }
        clone() {
            var m = new Matrix(this.context);
            m.height = this.height;
            m.width = this.width;
            m.data = this.data.map(function(row) { return row.slice(); });
            return m;
        }
        get(row, col) {
            var line = this.data[row];
            var val = line ? line[col] : null;
            return val instanceof Ref ? this.context.getRefData(val) : val;
        }
        getNA(row, col) {
            if (this.height == 1) {
                row = 0;
            }
            if (this.width == 1) {
                col = 0;
            }
            if (row < this.height && col < this.width) {
                return this.get(row, col);
            }
            return new CalcError("N/A");
        }
        set(row, col, data) {
            if (col === '__proto__' || col === 'constructor' || col === 'prototype' 
                || row === '__proto__' || row === 'constructor' || row === 'prototype') {
                return;
            }
            var line = this.data[row];
            if (line == null) {
                line = this.data[row] = [];
            }
            line[col] = data;
            if (row >= this.height) {
                this.height = row + 1;
            }
            if (col >= this.width) {
                this.width = col + 1;
            }
        }
        each(f, includeEmpty) {
            for (var row = 0; row < this.height; ++row) {
                for (var col = 0; col < this.width; ++col) {
                    var val = this.get(row, col);
                    if (includeEmpty || val != null) {
                        val = f.call(this.context, val, row, col);
                        if (val !== undefined) {
                            return val;
                        }
                    }
                }
            }
        }
        map(f, includeEmpty) {
            var m = new Matrix(this.context);
            this.each(function(el, row, col) {
                // here `this` is actually the context
                m.set(row, col, f.call(this, el, row, col));
            }, includeEmpty);
            return m;
        }
        eachRow(f) {
            for (var row = 0; row < this.height; ++row) {
                var val = f.call(this.context, row);
                if (val !== undefined) {
                    return val;
                }
            }
        }
        eachCol(f) {
            for (var col = 0; col < this.width; ++col) {
                var val = f.call(this.context, col);
                if (val !== undefined) {
                    return val;
                }
            }
        }
        mapRow(f) {
            var m = new Matrix(this.context);
            this.eachRow(function(row) {
                m.set(row, 0, f.call(this.context, row));
            });
            return m;
        }
        mapCol(f) {
            var m = new Matrix(this.context);
            this.eachCol(function(col) {
                m.set(0, col, f.call(this.context, col));
            });
            return m;
        }
        toString() {
            return JSON.stringify(this.data);
        }
        transpose() {
            var m = new Matrix(this.context);
            this.each(function(el, row, col) {
                m.set(col, row, el);
            });
            return m;
        }
        unit(n) {
            this.width = this.height = n;
            var a = this.data = new Array(n);
            for (var i = n; --i >= 0;) {
                var row = a[i] = new Array(n);
                for (var j = n; --j >= 0;) {
                    row[j] = i == j ? 1 : 0;
                }
            }
            return this;
        }
        multiply(b) {
            var a = this, m = new Matrix(a.context);
            for (var row = 0; row < a.height; ++row) {
                for (var col = 0; col < b.width; ++col) {
                    var s = 0;
                    for (var i = 0; i < a.width; ++i) {
                        var va = a.get(row, i);
                        var vb = b.get(i, col);
                        if (typeof va != "number" || typeof vb != "number") {
                            throw new CalcError("VALUE");
                        }
                        s += va * vb;
                    }
                    m.set(row, col, s);
                }
            }
            return m;
        }
        adds(b, s) {
            var a = this, m = new Matrix(a.context);
            var sign = s ? -1 : 1;
            for (var row = 0; row < a.height; ++row) {
                for (var col = 0; col < a.width; ++col) {
                    var x = a.get(row, col),
                        y = b.get(row, col);
                    m.set(row, col, x + sign * y);
                }
            }
            return m;
        }
        determinant() {
            var a = this.clone().data;
            var n = a.length;
            var d = 1, C, L, i, k;
            for (C = 0; C < n; C++) {
                for (L = C; (L < n) && (!a[L][C]); L++);
                if (L == n) {
                    return 0;
                }
                if (L != C) {
                    d = -d;
                    for (k = C; k < n; k++) {
                        var t = a[C][k];
                        a[C][k] = a[L][k];
                        a[L][k] = t;
                    }
                }
                for (i = C + 1; i < n; i++) {
                    for (k = C + 1; k < n; k++) {
                        a[i][k] -= a[C][k] * a[i][C] / a[C][C];
                    }
                }
                d *= a[C][C];
            }
            return d;
        }
        inverse() {
            let n = this.width;
            let m = this.augment(new Matrix(this.context).unit(n));
            let a = m.data;
            let tmp;

            // Gaussian elimination
            // https://en.wikipedia.org/wiki/Gaussian_elimination#Finding_the_inverse_of_a_matrix

            // 1. Get zeros below main diagonal
            for (let k = 0; k < n; ++k) {
                let imax = argmax(k, n, function(i) { return a[i][k]; });
                if (!a[imax][k]) {
                    return null; // singular matrix
                }
                if (k != imax) {
                    tmp = a[k];
                    a[k] = a[imax];
                    a[imax] = tmp;
                }
                for (let i = k + 1; i < n; ++i) {
                    for (let j = k + 1; j < 2 * n; ++j) {
                        a[i][j] -= a[k][j] * a[i][k] / a[k][k];
                    }
                    a[i][k] = 0;
                }
            }

            // 2. Get 1-s on main diagonal, dividing by pivot
            for (let i = 0; i < n; ++i) {
                for (let f = a[i][i], j = 0; j < 2 * n; ++j) {
                    a[i][j] /= f;
                }
            }

            // 3. Get zeros above main diagonal.  Actually, we only care to compute the right side
            // here (that will be the inverse), so in the inner loop below we go while j >= n,
            // instead of j >= k.
            for (let k = n; --k >= 0;) {
                for (let i = k; --i >= 0;) {
                    if (a[i][k]) {
                        for (let j = 2 * n; --j >= n;) {
                            a[i][j] -= a[k][j] * a[i][k];
                        }
                    }
                }
            }

            return m.slice(0, n, n, n);
        }
        augment(m) {
            var ret = this.clone(), n = ret.width;
            m.each(function(val, row, col) {
                ret.set(row, col + n, val);
            });
            return ret;
        }
        slice(row, col, height, width) {
            var m = new Matrix(this.context);
            for (var i = 0; i < height; ++i) {
                for (var j = 0; j < width; ++j) {
                    m.set(i, j, this.get(row + i, col + j));
                }
            }
            return m;
        }

        // XXX: debug
        // dump() {
        //     this.data.forEach(function(row){
        //         window.console.log(row.map(function(val){
        //             var str = val.toFixed(3).replace(/\.?0*$/, function(s){
        //                 return [ "", " ", "  ", "   ", "    " ][s.length];
        //             });
        //             if (val >= 0) { str = " " + str; }
        //             return str;
        //         }).join("  "));
        //     });
        // }
    }

    /* -----[ Formula ]----- */

    function sameRef(r1, r2) {
        // note: r1.eq(r2) will not do, because it returns true for A1 and A1:A1 (CellRef
        // vs. RangeRef).  To properly undo we need to assert that the references are exactly the
        // same (including type).
        if (r1.constructor !== r2.constructor) {
            return false;
        }
        if (r1 instanceof CellRef) {
            return r1.sheet == r2.sheet
                && r1.row == r2.row
                && r1.col == r2.col
                && r1.rel == r2.rel;
        }
        if (r1 instanceof RangeRef) {
            return sameRef(r1.topLeft , r2.topLeft)
                && sameRef(r1.bottomRight , r2.bottomRight)
                && r1.endSheet == r2.endSheet;
        }
        if (r1 instanceof UnionRef) {
            var i = r1.refs.length;
            if (i != r2.refs.length) {
                return false;
            }
            while (--i >= 0) {
                if (!sameRef(r1.refs[i], r2.refs[i])) {
                    return false;
                }
            }
        }
        return true;
    }

    let Formula$1 = class Formula {
        constructor(refs, handler, printer, sheet, row, col, arrayFormulaRange) {
            this.refs = refs;
            this.handler = handler;
            this.print = printer;
            this.absrefs = null;
            this.sheet = sheet;
            this.row = row;
            this.col = col;
            this.onReady = [];
            this.pending = false;
            this.arrayFormulaRange = arrayFormulaRange;
        }
        setArrayFormulaRange(ref) {
            this.arrayFormulaRange = ref.clone().setSheet(this.sheet);
        }
        clone(sheet, row, col, forceRefs) {
            var lcsheet = sheet.toLowerCase();
            var refs = this.refs;
            var range = this.arrayFormulaRange;
            if (forceRefs || lcsheet != this.sheet.toLowerCase()) {
                refs = refs.map(function(ref) {
                    if (!ref.hasSheet() && (!ref.sheet || ref.sheet.toLowerCase() != lcsheet)) {
                        ref = ref.clone().setSheet(sheet);
                    }
                    return ref;
                });
                if (range) {
                    range = range.clone().setSheet(sheet);
                }
            }
            return new Formula(refs, this.handler, this.print, sheet, row, col, range);
        }
        deepClone() {
            var refs = this.refs.map(function(ref) { return ref.clone(); });
            return new Formula(refs, this.handler, this.print, this.sheet, this.row, this.col, this.arrayFormulaRange);
        }
        resolve(val) {
            this.pending = false;
            this.onReady.forEach(function(callback) {
                callback(val);
            });
        }
        exec(ss, callback, parentContext) {
            if ("value" in this) {
                if (callback) {
                    callback(this.value);
                }
            } else {
                if (callback) {
                    this.onReady.push(callback);
                }

                var ctx = new Context(this.resolve, this, ss, parentContext);
                var level = 0;
                // if the call chain leads back to this same formula, we have a circular dependency.
                while (parentContext) {
                    if (parentContext.formula === this) {
                        this.pending = false;
                        ctx.resolve(new CalcError("CIRCULAR"));
                        return;
                    }
                    parentContext = parentContext.parent;
                    ++level;
                }

                // pending is still useful for ASYNC formulas
                if (this.pending) {
                    return;
                }
                this.pending = true;

                var next = function() {
                    // compute and cache the absolute references
                    if (!this.absrefs) {
                        this.absrefs = this.refs.map(function(ref) {
                            return ref.absolute(this.row, this.col);
                        }, this);
                    }

                    // finally invoke the handler given to us by the compiler in calc.js
                    this.handler.call(ctx);
                }.bind(this);

                if (level < 20) {
                    next();
                } else {
                    setTimeout(next, 0);
                }
            }
        }
        reset() {
            this.onReady = [];
            this.pending = false;
            delete this.value;
        }
        renameSheet(oldSheetName, newSheetName) {
            oldSheetName = oldSheetName.toLowerCase();
            this.absrefs = null;
            if (this.sheet.toLowerCase() == oldSheetName) {
                this.sheet = newSheetName;
            }
            this.refs.forEach(function(ref) {
                ref.renameSheet(oldSheetName, newSheetName);
            });
        }
        adjust(affectedSheet, operation, start, delta) {
            affectedSheet = affectedSheet.toLowerCase();
            var formulaRow = this.row;
            var formulaCol = this.col;
            var formulaSheet = this.sheet.toLowerCase();
            var formulaMoves = false;
            if (formulaSheet == affectedSheet) {
                // move formula if it's after the change point
                if (operation == "row" && formulaRow >= start) {
                    this.row += delta;
                    formulaMoves = true;
                }
                if (operation == "col" && formulaCol >= start) {
                    this.col += delta;
                    formulaMoves = true;
                }
            }
            var newFormulaRow = this.row;
            var newFormulaCol = this.col;
            this.absrefs = null;
            var prevRefs = this.refs;
            var modified = formulaMoves;
            this.refs = prevRefs.map(function(ref) {
                var newRef = adjust(ref);
                if (!modified && !sameRef(newRef, ref)) {
                    modified = true;
                }
                return newRef;
            });

            var prevRange = this.arrayFormulaRange;
            if (prevRange) {
                this.arrayFormulaRange = adjust(prevRange);
                if (!modified && !sameRef(prevRange, this.arrayFormulaRange)) {
                    modified = true;
                }
            }

            if (modified) {
                // return a clone of the original formula.  needed to undo operations like
                // deleteRow, which can transform a reference into NULL.
                return new Formula(prevRefs, this.handler, this.print, this.sheet, formulaRow, formulaCol, prevRange);
            }

            function adjust(ref) {
                if (ref === NULLREF) {
                    return ref;
                }
                if (ref.sheet.toLowerCase() != affectedSheet) {
                    if (formulaMoves) {
                        // a reference to another sheet should still point to the same location
                        // after adjustment; thus if row/col was removed before formula, relative
                        // references must be adjusted by delta.
                        if (operation == "row" && formulaRow >= start) {
                            ref = ref.relative(delta, 0);
                        }
                        if (operation == "col" && formulaCol >= start) {
                            ref = ref.relative(0, delta);
                        }
                    }
                    return ref;
                }
                return ref.adjust(
                    formulaRow, formulaCol,
                    newFormulaRow, newFormulaCol,
                    operation == "row",
                    start, delta
                );
            }
        }
        toString() {
            return this.print(this.row, this.col);
        }
    };

    // spreadsheet functions --------

    FUNCS$1["if"] = function(callback, args) {
        var self = this;
        var co = args[0], th = args[1], el = args[2];
        // XXX: I don't like this resolveCells here.  We should try to declare IF with
        // defineFunction.
        this.resolveCells([ co ], function() {
            var comatrix = self.asMatrix(co);
            if (comatrix) {
                // XXX: calling both branches in this case, since we'll typically need values from
                // both.  We could optimize and call them only when first needed, but oh well.
                th(function(th) {
                    el(function(el) {
                        var thmatrix = self.asMatrix(th);
                        var elmatrix = self.asMatrix(el);
                        callback(comatrix.map(function(val, row, col) {
                            if (val instanceof CalcError) {
                                return val;
                            } else if (self.bool(val)) {
                                return thmatrix ? thmatrix.get(row, col) : th;
                            } else {
                                return elmatrix ? elmatrix.get(row, col) : el;
                            }
                        }));
                    });
                });
            } else {
                co = this.force(co);
                if (co instanceof CalcError) {
                    callback(co);
                } else if (self.bool(co)) {
                    th(callback);
                } else {
                    el(callback);
                }
            }
        });
    };

    FUNCS$1["φ"] = function(callback) {
        callback((1 + Math.sqrt(5)) / 2);
    };

    // Lasciate ogni speranza, voi ch'entrate.
    //
    // XXX: document this function.
    function compileArgumentChecks(functionName, args) {
        var arrayArgs = "function arrayArgs(args) { var xargs = [], width = 0, height = 0, arrays = [], i = 0; ";
        var resolve = "function resolve(args, callback) { var toResolve = [], i = 0; ";
        var name, forced, main = "'use strict'; function check(args) { var stack = [], tmp, xargs = [], i = 0, m, err = 'VALUE'; ", haveForced = false;
        var canBeArrayArg = false, hasArrayArgs = false;
        main += args.map(comp).join("");
        main += "if (i < args.length) return new CalcError('N/A'); ";
        main += "return xargs; } ";
        arrayArgs += "return { args: xargs, width: width, height: height, arrays: arrays }; } ";

        var f;
        if (haveForced) {
            resolve += "this.resolveCells(toResolve, callback); } ";
            f = new Function("kendo", "CalcError", "round", main + resolve + arrayArgs + " return { resolve: resolve, check: check, arrayArgs: arrayArgs };");
        } else {
            f = new Function("kendo", "CalcError", "round", main + " return { check: check };");
        }
        f = f(calc.kendo, CalcError, limitPrecision$1);
        if (!hasArrayArgs) {
            delete f.arrayArgs;
        }
        return f;

        function comp(x) {
            name = x[0];
            var code = "{ ";
            if (Array.isArray(name)) {
                arrayArgs += "while (i < args.length) { ";
                resolve += "while (i < args.length) { ";
                code += "xargs.push(tmp = []); stack.push(xargs); xargs = tmp; ";
                code += "while (i < args.length) { ";
                code += x.map(comp).join("");
                code += "} ";
                code += "xargs = stack.pop(); ";
                resolve += "} ";
                arrayArgs += "} ";
            } else if (name == "+") {
                arrayArgs += "while (i < args.length) { ";
                resolve += "while (i < args.length) { ";
                code += "if (i >= args.length) return new CalcError('N/A'); ";
                code += "xargs.push(tmp = []); stack.push(xargs); xargs = tmp; ";
                code += "do { ";
                code += x.slice(1).map(comp).join("");
                code += "} while (i < args.length); ";
                code += "xargs = stack.pop(); ";
                resolve += "} ";
                arrayArgs += "} ";
            } else if (name == "?") {
                // standalone assertion without a new argument
                code += "if (!(" + cond(x[1]) + ")) return new CalcError(err); ";
            } else {
                var type = x[1];
                if (Array.isArray(type) && /^#?collect/.test(type[0])) {
                    var wantNulls = /!$/.test(type[0]);
                    var n = type[2];
                    force();
                    code += "try {"
                        + "var $" + name + " = this.cellValues(args.slice(i";
                    if (n) {
                        code += ", i + " + n;
                    }
                    code += ")" + (wantNulls ? ",true" : "") + ").reduce(function(ret, $" + name + "){ ";
                    if (type[0].charAt(0) != "#") {
                        code += "if ($" + name + " instanceof CalcError) throw $" + name + "; ";
                    }
                    code += "if (" + cond(type[1]) + ") ret.push($" + name + "); ";
                    code += "return ret; ";
                    code += "}.bind(this), []); ";
                    if (n) {
                        code += "i += " + n + "; ";
                    } else {
                        code += "i = args.length; ";
                    }
                    code += "xargs.push($" + name + ")"
                        + "} catch(ex) { if (ex instanceof CalcError) return ex; throw ex; } ";
                    resolve += "toResolve.push(args.slice(i)); ";
                } else if (type == "rest") {
                    code += "xargs.push(args.slice(i)); i = args.length; ";
                } else {
                    if ((canBeArrayArg = /^\*/.test(name))) {
                        hasArrayArgs = true;
                        name = name.substr(1);
                    }
                    code += "var $" + name + " = args[i++]; ";
                    var allowError = false;
                    if (/!$/.test(type)) {
                        type = type.substr(0, type.length - 1);
                        allowError = true;
                    } else {
                        code += "if ($" + name + " instanceof CalcError) return $" + name + "; ";
                    }
                    code += typeCheck(type, allowError) + "xargs.push($" + name + "); ";
                }
            }
            code += "} ";
            return code;
        }

        function force() {
            if (forced) {
                return "$" + name + "";
            }
            haveForced = true;
            forced = true;
            resolve += "toResolve.push(args[i++]); ";
            return "($" + name + " = this.force($" + name + "))";
        }

        function forceNum(round) {
            return "("
                + (round
                   ? ("(typeof " + force() + " == 'number' ? ($" + name + " = round($" + name + "), true) : false) || ")
                   : ("(typeof " + force() + " == 'number') || "))
                + "(typeof $" + name + " == 'boolean' ? ($" + name + " = +$" + name + ", true) : false) || "
                + "(typeof $" + name + " == 'string' && !/^(?:=|true|false)/i.test($" + name + ") ? ("
                + "tmp = kendo.spreadsheet.calc.parse(0, 0, 0, $" + name + "), "
                + "/^date|number|percent$/.test(tmp.type) ? ($" + name + " = +tmp.value, true) : false"
                + ") : false)"
                + ")";
        }

        function typeCheck(type, allowError) {
            forced = false;
            var ret = "if (!(" + cond(type) + ")) { ";
            if (forced && !allowError) {
                ret += " if ($" + name + " instanceof CalcError) return $" + name + "; ";
            }
            ret += "return new CalcError(err); } ";
            if (!forced) {
                resolve += "i++; ";
            }
            if (canBeArrayArg) {
                arrayArgs += "var $" + name + " = this._arrayArg(args[i]); "
                    + "if ($" + name + ") { "
                    + "xargs.push($" + name + "); "
                    + "width = Math.max(width, $" + name + ".width); "
                    + "height = Math.max(height, $" + name + ".height); "
                    + "arrays.push(true) } else { "
                    + "xargs.push(args[i]); "
                    + "arrays.push(false); } i++; ";
            } else {
                arrayArgs += "xargs.push(args[i++]); arrays.push(false); ";
            }
            return ret;
        }

        function cond(type) {
            if (Array.isArray(type)) {
                if (type[0] == "or") {
                    return "(" + type.slice(1).map(cond).join(") || (") + ")";
                }
                if (type[0] == "and") {
                    return "(" + type.slice(1).map(cond).join(") && (") + ")";
                }
                if (type[0] == "values") {
                    return "(" + type.slice(1).map(function(val) {
                        return force() + " === " + val;
                    }).join(") || (") + ")";
                }
                if (type[0] == "null") {
                    return "(" + cond("null") + " ? (($" + name + " = " + type[1] + "), true) : false)";
                }
                if (type[0] == "between" || type[0] == "[between]") {
                    return "(" + force() + " >= " + type[1] + " && " + "$" + name + " <= " + type[2] + " ? true : ((err = 'NUM'), false))";
                }
                if (type[0] == "(between)") {
                    return "(" + force() + " > " + type[1] + " && " + "$" + name + " < " + type[2] + " ? true : ((err = 'NUM'), false))";
                }
                if (type[0] == "(between]") {
                    return "(" + force() + " > " + type[1] + " && " + "$" + name + " <= " + type[2] + " ? true : ((err = 'NUM'), false))";
                }
                if (type[0] == "[between)") {
                    return "(" + force() + " >= " + type[1] + " && " + "$" + name + " < " + type[2] + " ? true : ((err = 'NUM'), false))";
                }
                if (type[0] == "assert") {
                    var err = type[2] || "N/A";
                    return "((" + type[1] + ") ? true : (err = " + JSON.stringify(err) + ", false))";
                }
                if (type[0] == "not") {
                    return "!(" + cond(type[1]) + ")";
                }
                throw new Error("Unknown array type condition: " + type[0]);
            }
            if (type == "number" || type == "datetime") {
                return forceNum(true);
            }
            if (type == "number!") {
                return "(typeof " + force() + " == 'number' ? ($" + name + " = round($" + name + "), true) : false)";
            }
            if (type == "integer" || type == "date") {
                return "(" + forceNum() + " && (($" + name + " |= 0), true))";
            }
            if (type == "divisor") {
                return "(" + forceNum(true) + " && ($" + name + " == 0 ? ((err = 'DIV/0'), false) : true))";
            }
            if (type == "number+") {
                return "(" + forceNum(true) + " && ($" + name + " >= 0 ? true : ((err = 'NUM'), false)))";
            }
            if (type == "integer+") {
                return "(" + forceNum() + " && (($" + name + " |= 0) >= 0 ? true : ((err = 'NUM'), false)))";
            }
            if (type == "number++") {
                return "(" + forceNum(true) + " && ($" + name + " > 0 ? true : ((err = 'NUM'), false)))";
            }
            if (type == "integer++") {
                return "(" + forceNum() + " && (($" + name + " |= 0) > 0 ? true : ((err = 'NUM'), false)))";
            }
            if (type == "string") {
                return "((typeof " + force() + " == 'string' || typeof $" + name + " == 'boolean' || typeof $" + name + " == 'number') ? ($" + name + " += '', true) : ($" + name + " === undefined ? (($" + name + " = ''), true) : false))";
            }
            if (type == "boolean") {
                return "(typeof " + force() + " == 'boolean')";
            }
            if (type == "logical") {
                return "(typeof " + force() + " == 'boolean' || (typeof $" + name + " == 'number' ? ($" + name + " = !!$" + name + ", true) : false))";
            }
            if (type == "matrix") {
                force();
                return "((m = this.asMatrix($" + name + ")) ? ($" + name + " = m) : false)";
            }
            if (type == "#matrix") {
                return "((m = this.asMatrix($" + name + ")) ? ($" + name + " = m) : false)";
            }
            if (type == "ref") {
                return "($" + name + " instanceof kendo.spreadsheet.Ref)";
            }
            if (type == "area") {
                return "($" + name + " instanceof kendo.spreadsheet.CellRef || $" + name + " instanceof kendo.spreadsheet.RangeRef)";
            }
            if (type == "cell") {
                return "($" + name + " instanceof kendo.spreadsheet.CellRef)";
            }
            if (type == "null") {
                return "(" + force() + " == null)";
            }
            if (type == "anyvalue") {
                return "(" + force() + " != null && i <= args.length)";
            }
            if (type == "forced") {
                return "(" + force() + ", i <= args.length)";
            }
            if (type == "anything") {
                return "(i <= args.length)";
            }
            if (type == "blank") {
                return "(" + force() + " == null || $" + name + " === '')";
            }
            throw new Error("Can't check for type: " + type);
        }
    }

    function limitPrecision$1(num, digits) {
        return num === parseInt(num, 10) ? num : +num.toPrecision(digits || 16);
    }

    function maybeRoundFloatErrors(num, digits) {
        if (typeof num == "number") {
            return limitPrecision$1(num, digits);
        } else {
            return num;
        }
    }

    function withErrorHandling(obj, f, args) {
        if (args instanceof CalcError) {
            return args;
        }
        try {
            return f.apply(obj, args);
        } catch (ex) {
            if (ex instanceof CalcError) {
                return ex;
            } else {
                throw ex;
            }
        }
    }

    function makeSyncFunction(handler, resolve, check, arrayArgs) {
        return function(callback, args) {
            function doit() {
                if (arrayArgs) {
                    let x = arrayArgs.call(this, args);
                    args = x.args;
                    if (x.width > 0 && x.height > 0) {
                        let result = new Matrix(this);
                        for (let row = 0; row < x.height; ++row) {
                            for (let col = 0; col < x.width; ++col) {
                                let xargs = [];
                                for (let i = 0; i < args.length; ++i) {
                                    if (x.arrays[i]) {
                                        xargs[i] = args[i].getNA(row, col);
                                    } else {
                                        xargs[i] = args[i];
                                    }
                                }
                                xargs = check.call(this, xargs);
                                result.set(row, col, withErrorHandling(this, handler, xargs));
                            }
                        }
                        return callback(result);
                    }
                }
                let xargs = check.call(this, args);
                callback(withErrorHandling(this, handler, xargs));
            }
            if (resolve) {
                resolve.call(this, args, doit);
            } else {
                doit.call(this);
            }
        };
    }

    function makeAsyncFunction(handler, resolve, check, arrayArgs) {
        return function(callback, args) {
            function doit() {
                if (arrayArgs) {
                    let x = arrayArgs.call(this, args);
                    args = x.args;
                    if (x.width > 0 && x.height > 0) {
                        let result = new Matrix(this);
                        let count = x.width * x.height;
                        let makeCallback = function(row, col) {
                            return function(value) {
                                result.set(row, col, value);
                                --count;
                                if (count === 0) {
                                    return callback(result);
                                }
                            };
                        };
                        for (let row = 0; row < x.height && count > 0; ++row) {
                            for (let col = 0; col < x.width && count > 0; ++col) {
                                let xargs = [];
                                for (let i = 0; i < args.length; ++i) {
                                    if (x.arrays[i]) {
                                        xargs[i] = args[i].getNA(row, col);
                                    } else {
                                        xargs[i] = args[i];
                                    }
                                }
                                xargs = check.call(this, xargs);
                                if (xargs instanceof CalcError) {
                                    result.set(row, col, xargs);
                                    --count;
                                    if (count === 0) {
                                        return callback(result);
                                    }
                                } else {
                                    xargs.unshift(makeCallback(row, col));
                                    handler.apply(this, xargs);
                                }
                            }
                        }
                        return;
                    }
                }
                let x = check.call(this, args);
                if (x instanceof CalcError) {
                    callback(x);
                } else {
                    x.unshift(callback);
                    handler.apply(this, x);
                }
            }
            if (resolve) {
                resolve.call(this, args, doit);
            } else {
                doit.call(this);
            }
        };
    }

    function defineFunction(name, func) {
        name = name.toLowerCase();
        FUNCS$1[name] = func;
        return {
            args: function(args, log) {
                var code = compileArgumentChecks(name, args);
                // XXX: DEBUG
                if (log) {
                    if (code.arrayArgs) {window.console.log(code.arrayArgs.toString());}
                    if (code.resolve) {window.console.log(code.resolve.toString());}
                    if (code.check) {window.console.log(code.check.toString());}
                }
                var f = FUNCS$1[name] = makeSyncFunction(func, code.resolve, code.check, code.arrayArgs);
                f.kendoSpreadsheetArgs = args;
                return this;
            },
            argsAsync: function(args, log) {
                var code = compileArgumentChecks(name, args);
                // XXX: DEBUG
                if (log) {
                    if (code.arrayArgs) {window.console.log(code.arrayArgs.toString());}
                    if (code.resolve) {window.console.log(code.resolve.toString());}
                    if (code.check) {window.console.log(code.check.toString());}
                }
                var f = FUNCS$1[name] = makeAsyncFunction(func, code.resolve, code.check, code.arrayArgs);
                f.kendoSpreadsheetArgs = args;
                return this;
            }
        };
    }

    function defineBuiltinFunction$1(name, isAsync, x, impl) {
        FUNCS$1[name] = isAsync
            ? makeAsyncFunction(impl, x.resolve, x.check, x.arrayArgs)
            : makeSyncFunction(impl, x.resolve, x.check, x.arrayArgs);
    }

    /* -----[ date calculations ]----- */

    // Julian days algorithms from http://www.hermetic.ch/cal_stud/jdn.htm#comp

    function dateToJulianDays(y, m, d) {
        m++;
        return ((1461 * (y + 4800 + ((m - 14) / 12 | 0))) / 4 | 0) +
            ((367 * (m - 2 - 12 * ((m - 14) / 12 | 0))) / 12 | 0) -
            ((3 * (((y + 4900 + ((m - 14) / 12 | 0)) / 100 | 0))) / 4 | 0) +
            d - 32075;
    }

    function julianDaysToDate(jd) {
        var l, n, j, i, m, d, y;
        l = jd + 68569;
        n = (4 * l) / 146097 | 0;
        l = l - ((146097 * n + 3) / 4 | 0);
        i = (4000 * (l + 1) / 1461001) | 0;
        l = l - ((1461 * i) / 4 | 0) + 31;
        j = (80 * l) / 2447 | 0;
        d = l - ((2447 * j) / 80 | 0);
        l = j / 11 | 0;
        m = j + 2 - (12 * l);
        y = 100 * (n - 49) + i + l;
        m--;
        return {
            year  : y,
            month : m,
            date  : d,
            day   : (jd + 1) % 7,
            ord   : ORDINAL_ADD_DAYS[isLeapYear$1(y)][m] + d
        };
    }

    // This uses the Google Spreadsheet approach: treat 1899-12-31 as day 1, allowing to avoid
    // implementing the "Leap Year Bug" yet still be Excel compatible for dates starting 1900-03-01.
    var BASE_DATE = dateToJulianDays(1900, 0, -1);

    var DAYS_IN_MONTH = [ 31, 28, 31,
                          30, 31, 30,
                          31, 31, 30,
                          31, 30, 31 ];

    var ORDINAL_ADD_DAYS = [
        [ 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334 ], // non-leap year
        [ 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335 ]  // leap year
    ];

    function isLeapYear$1(yr) {
        if (yr % 4) {
            return 0;
        }
        if (yr % 100) {
            return 1;
        }
        if (yr % 400) {
            return 0;
        }
        return 1;
    }

    function daysInYear$1(yr) {
        return isLeapYear$1(yr) ? 366 : 365;
    }

    function daysInMonth$1(yr, mo) {
        return (isLeapYear$1(yr) && mo == 1) ? 29 : DAYS_IN_MONTH[mo];
    }

    function validDate(yr, mo, da) {
        return mo >= 1 && mo <= 12 && da >= 1 && da <= daysInMonth$1(yr, mo - 1);
    }

    function unpackDate$2(serial) {
        return julianDaysToDate((serial | 0) + BASE_DATE);
    }

    function packDate$2(year, month, date) {
        return dateToJulianDays(year, month, date) - BASE_DATE;
    }

    var MS_IN_MIN = 60 * 1000;
    var MS_IN_HOUR = 60 * MS_IN_MIN;
    var MS_IN_DAY = 24 * MS_IN_HOUR;

    function unpackTime$1(serial) {
        var frac = serial - (serial | 0);
        if (frac < 0) {
            frac++;
        }
        var ms = Math.round(MS_IN_DAY * frac);
        var hours = Math.floor(ms / MS_IN_HOUR);
        ms -= hours * MS_IN_HOUR;
        var minutes = Math.floor(ms / MS_IN_MIN);
        ms -= minutes * MS_IN_MIN;
        var seconds = Math.floor(ms / 1000);
        ms -= seconds * 1000;
        return {
            hours: hours,
            minutes: minutes,
            seconds: seconds,
            milliseconds: ms
        };
    }

    function serialToDate$2(serial) {
        var d = unpackDate$2(serial), t = unpackTime$1(serial);
        return new Date(d.year, d.month, d.date,
                        t.hours, t.minutes, t.seconds, t.milliseconds);
    }

    function packTime$1(hh, mm, ss, ms) {
        return (hh + (mm + (ss + ms / 1000) / 60) / 60) / 24;
    }

    function dateToSerial$2(date) {
        var time = packTime$1(date.getHours(),
                            date.getMinutes(),
                            date.getSeconds(),
                            date.getMilliseconds());
        date = packDate$2(date.getFullYear(),
                        date.getMonth(),
                        date.getDate());
        if (date < 0) {
            return date - 1 + time;
        } else {
            return date + time;
        }
    }

    function parseDate(str, format) {
        if (format) {
            format = calc.formatting.makeDateFormat(format);
        }
        const parseExactDate = intl().parseDate;
        return parseExactDate(str, format)
            || parseExactDate(str)
            || parseExactDate(str, [
                "MMMM dd yyyy",
                "MMMM dd yy",
                "MMM dd yyyy",
                "MMM dd yy",
                "dd MMMM yyyy",
                "dd MMMM yy",
                "dd MMM yyyy",
                "dd MMM yy",
                "MMMM dd, yyyy",
                "MMMM dd, yy",
                "MMM dd, yyyy",
                "MMM dd, yy",
                "MMMM dd",
                "MMM dd",
                "MMMM yyyy",
                "MMM yyyy",
                "dd MMMM",
                "dd MMM"
            ]);
    }

    function defineAlias$1(alias, name) {
        var orig = FUNCS$1[name];
        if (!orig) {
            throw new Error("Function " + name + " is not yet defined");
        }
        if (!orig.kendoSpreadsheetAliases) {
            orig.kendoSpreadsheetAliases = [ name ];
        }
        orig.kendoSpreadsheetAliases.push(alias);
        FUNCS$1[alias] = orig;
    }

    class ParseError {
        constructor(message, pos) {
            this.message = message;
            this.pos = pos;
        }
        toString() {
            return this.message;
        }
    }

    function InputStream(input) {
        let pos = 0;
        return {
            next        : next,
            peek        : peek,
            eof         : eof,
            croak       : croak,
            readWhile   : readWhile,
            readEscaped : readEscaped,
            lookingAt   : lookingAt,
            skip        : skip,
            forward     : forward,
            pos         : location
        };
        function location() {
            return pos;
        }
        function next() {
            let ch = input.charAt(pos++);
            return ch;
        }
        function peek() {
            return input.charAt(pos);
        }
        function eof() {
            return peek() === "";
        }
        function croak(msg) {
            throw new ParseError(msg + " (input: " + input + ")", pos);
        }
        function skip(ch) {
            if (typeof ch == "string") {
                if (input.substr(pos, ch.length) !== ch) {
                    croak("Expected " + ch);
                }
                forward(ch.length);
            } else if (ch instanceof RegExp) {
                let m = ch.exec(input.substr(pos));
                if (m) {
                    forward(m[0].length);
                    return m;
                }
            } else {
                // assuming RegExp match data
                forward(ch[0].length);
            }
        }
        function forward(n) {
            while (n-- > 0) {
                next();
            }
        }
        function readEscaped(end) {
            let escaped = false, str = "";
            while (!eof()) {
                let ch = next();
                if (escaped) {
                    str += ch;
                    escaped = false;
                } else if (ch === "\\") {
                    escaped = true;
                } else if (ch === end) {
                    break;
                } else {
                    str += ch;
                }
            }
            return str;
        }
        function readWhile(predicate) {
            let str = "";
            while (!eof() && predicate(peek(), str)) {
                str += next();
            }
            return str;
        }
        function lookingAt(rx) {
            return rx.exec(input.substr(pos));
        }
    }

    /* -----[ exports ]----- */

    calc.runtime.CalcError = CalcError;
    calc.runtime.Formula = Formula$1;
    calc.runtime.Matrix = Matrix;
    calc.runtime.packDate = packDate$2;
    calc.runtime.unpackDate = unpackDate$2;
    calc.runtime.packTime = packTime$1;
    calc.runtime.unpackTime = unpackTime$1;
    calc.runtime.serialToDate = serialToDate$2;
    calc.runtime.dateToSerial = dateToSerial$2;
    calc.runtime.daysInMonth = daysInMonth$1;
    calc.runtime.validDate = validDate;
    calc.runtime.isLeapYear = isLeapYear$1;
    calc.runtime.daysInYear = daysInYear$1;
    calc.runtime.parseDate = parseDate;
    calc.runtime.limitPrecision = limitPrecision$1;
    calc.runtime.defineBuiltinFunction = defineBuiltinFunction$1;
    calc.runtime.defineAlias = defineAlias$1;
    calc.runtime.InputStream = InputStream;
    calc.runtime.ParseError = ParseError;

    /* eslint-disable indent */

    function Node() {
        this.node = null;
    }
    Node.prototype = {
        remove: function() {
            if (this.node.parentNode) {
                this.node.parentNode.removeChild(this.node);
            }
            this.attr = {};
        },
        attr: {},
        text: function() {
            return "";
        }
    };
    function NullNode() {
    }
    NullNode.prototype = {
        nodeName: "#null",
        attr: { style: {} },
        children: [],
        remove: function() {
        }
    };
    let NULL_NODE = new NullNode();
    function Element(nodeName, attr, children) {
        this.nodeName = nodeName;
        this.attr = attr || {};
        this.children = children || [];
    }
    Element.prototype = new Node();
    Element.prototype.appendTo = function(parent) {
        let node = typeof(this.nodeName) === "string" ? document.createElement(this.nodeName) : this.nodeName;
        let children = this.children;
        for (let index = 0; index < children.length; index++) {
            children[index].render(node, NULL_NODE);
        }
        parent.appendChild(node);
        return node;
    };
    Element.prototype.render = function(parent, cached) {
        let node;
        if (cached.nodeName !== this.nodeName) {
            cached.remove();
            node = this.appendTo(parent);
        } else {
            node = cached.node;
            let index;
            let children = this.children;
            let length = children.length;
            let cachedChildren = cached.children;
            let cachedLength = cachedChildren.length;
            if (Math.abs(cachedLength - length) > 2) {
                this.render({
                    appendChild: function(node) {
                        parent.replaceChild(node, cached.node);
                    }
                }, NULL_NODE);
                return;
            }
            for (index = 0; index < length; index++) {
                children[index].render(node, cachedChildren[index] || NULL_NODE);
            }
            for (index = length; index < cachedLength; index++) {
                cachedChildren[index].remove();
            }
        }
        this.node = node;
        this.syncAttributes(cached.attr);
        this.removeAttributes(cached.attr);
    };
    Element.prototype.syncAttributes = function(cachedAttr) {
        let attr = this.attr;
        for (let name in attr) {
            let value = attr[name];
            let cachedValue = cachedAttr[name];
            if (name === "style") {
                this.setStyle(value, cachedValue);
            } else if (value !== cachedValue) {
                this.setAttribute(name, value, cachedValue);
            }
        }
    };
    Element.prototype.setStyle = function(style, cachedValue) {
        let node = this.node;
        let key;
        if (cachedValue) {
            for (key in style) {
                if (style[key] !== cachedValue[key]) {
                    node.style[key] = style[key];
                }
            }
        } else {
            for (key in style) {
                node.style[key] = style[key];
            }
        }
    };
    Element.prototype.removeStyle = function(cachedStyle) {
        let style = this.attr.style || {};
        let node = this.node;
        for (let key in cachedStyle) {
            if (style[key] === undefined) {
                node.style[key] = "";
            }
        }
    };
    Element.prototype.removeAttributes = function(cachedAttr) {
        let attr = this.attr;
        for (let name in cachedAttr) {
            if (name === "style") {
                this.removeStyle(cachedAttr.style);
            } else if (attr[name] === undefined) {
                this.removeAttribute(name);
            }
        }
    };
    Element.prototype.removeAttribute = function(name) {
        let node = this.node;
        if (name === "style") {
            node.style.cssText = "";
        } else if (name === "className") {
            node.className = "";
        } else {
            node.removeAttribute(name);
        }
    };
    Element.prototype.setAttribute = function(name, value) {
        let node = this.node;
        if (node[name] !== undefined) {
            node[name] = value;
        } else {
            node.setAttribute(name, value);
        }
    };
    Element.prototype.text = function() {
        let str = "";
        for (let i = 0; i < this.children.length; ++i) {
            str += this.children[i].text();
        }
        return str;
    };
    function TextNode(nodeValue) {
        this.nodeValue = String(nodeValue);
    }
    TextNode.prototype = new Node();
    TextNode.prototype.nodeName = "#text";
    TextNode.prototype.render = function(parent, cached) {
        let node;
        if (cached.nodeName !== this.nodeName) {
            cached.remove();
            node = document.createTextNode(this.nodeValue);
            parent.appendChild(node);
        } else {
            node = cached.node;
            if (this.nodeValue !== cached.nodeValue) {
                if (node.parentNode) {
                    // sometimes in IE parentNode is null (reason unknown),
                    // and IE throws an error when you try to set a
                    // parentless' nodeValue, because why not.
                    node.nodeValue = this.nodeValue;
                }
            }
        }
        this.node = node;
    };
    TextNode.prototype.text = function() {
        return this.nodeValue;
    };
    function HtmlNode(html) {
        this.html = html;
    }
    HtmlNode.prototype = {
        nodeName: "#html",
        attr: {},
        remove: function() {
            for (let index = 0; index < this.nodes.length; index++) {
               let el = this.nodes[index];
               if (el.parentNode) {
                   el.parentNode.removeChild(el);
               }
           }
        },
        render: function(parent, cached) {
            if (cached.nodeName !== this.nodeName || cached.html !== this.html) {
               cached.remove();
               let lastChild = parent.lastChild;
               insertHtml(parent, this.html);
               this.nodes = [];
               for (let child = lastChild ? lastChild.nextSibling : parent.firstChild; child; child = child.nextSibling) {
                   this.nodes.push(child);
               }
           } else {
               this.nodes = cached.nodes.slice(0);
           }
        }
    };

    function insertHtml(node, html) {
        const HTML_CONTAINER = document.createElement("div");
        HTML_CONTAINER.innerHTML = html;
        while (HTML_CONTAINER.firstChild) {
            node.appendChild(HTML_CONTAINER.firstChild);
        }
    }
    function html(value) {
        return new HtmlNode(value);
    }
    function element(nodeName, attrs, children) {
        return new Element(nodeName, attrs, children);
    }
    function text$1(value) {
        return new TextNode(value);
    }
    function Tree(root) {
        this.root = root;
        this.children = [];
    }
    Tree.prototype = {
        html: html,
        element: element,
        text: text$1,
        render: function(children) {
            let cachedChildren = this.children;
            let index;
            let length;
            for (index = 0, length = children.length; index < length; index++) {
                let cached = cachedChildren[index];
                if (!cached) {
                    cached = NULL_NODE;
                } else if (!cached.node || !cached.node.parentNode) {
                    cached.remove();
                    cached = NULL_NODE;
                }
                children[index].render(this.root, cached);
            }
            for (index = length; index < cachedChildren.length; index++) {
                cachedChildren[index].remove();
            }
            this.children = children;
        }
    };

    const dom = {
        html: html,
        text: text$1,
        element: element,
        Tree: Tree,
        Node: Node
    };

    //--------------------------------------------------- custom number format.


    let RX_COLORS = /^\[(black|green|white|blue|magenta|yellow|cyan|red)\]/i;
    let RX_CONDITION = /^\[(<=|>=|<>|<|>|=)(-?[0-9.]+)\]/;

    /* eslint-disable complexity */

    /* The proper amount of suffering for whoever designed the Excel
       Custom Number Format would be to have him implement the
       formatter himself. */

    function parse$2(input) {
        input = calc.runtime.InputStream(input);
        let sections = [], haveConditional = false, decimalPart;
        while (!input.eof()) {
            let sec = readSection();
            sections.push(sec);
            if (sec.cond) {
                haveConditional = true;
            }
        }
        // From https://support.office.com/en-us/article/Create-or-delete-a-custom-number-format-78f2a361-936b-4c03-8772-09fab54be7f4:
        //
        //    A number format can have up to four sections of code, separated by semicolons. These
        //    code sections define the format for positive numbers, negative numbers, zero values,
        //    and text, in that order.
        //
        //    You do not have to include all code sections in your custom number format. If you
        //    specify only two code sections for your custom number format, the first section is
        //    used for positive numbers and zeros, and the second section is used for negative
        //    numbers. If you specify only one code section, it is used for all numbers. If you want
        //    to skip a code section and include a code section that follows it, you must include
        //    the ending semicolon for the section that you skip.
        //
        // However, if sections have conditionals, it is not clear if:
        //
        //    - still at most four are allowed
        //    - is the last section still for text
        //
        // We will assume that if no sections have conditionals, then there must be at most 4, and
        // they will be interpreted in the order above.  If the first section contains a
        // conditional, then there can be any number of them; if the last one is not conditional
        // then it will be interpreted as text format.
        if (!haveConditional) {
            if (sections.length === 1) {
                sections[0].cond = "num";
            } else if (sections.length === 2) {
                sections[0].cond = { op: ">=", value: 0 };
                sections[1].cond = { op: "<", value: 0 };
            } else if (sections.length >= 3) {
                sections[0].cond = { op: ">", value: 0 };
                sections[1].cond = { op: "<", value: 0 };
                sections[2].cond = { op: "=", value: 0 };
                if (sections.length > 3) {
                    sections[3].cond = "text";
                    sections = sections.slice(0, 4);
                }
            }
        }
        return sections;
        function maybeColor() {
            let m = input.skip(RX_COLORS);
            if (m) {
                return m[1].toLowerCase();
            }
        }
        function maybeCondition() {
            let m = input.skip(RX_CONDITION);
            if (m) {
                let val = parseFloat(m[2]);
                if (!isNaN(val)) {
                    return { op: m[1], value: val, custom: true };
                }
            }
        }
        function readFormat() {
            let format = [], tok, prev = null;
            while (!input.eof() && (tok = readNext())) {
                // disambiguate: m/mm might mean month or minutes depending on surrounding context.
                if (tok.type === "date") {
                    if (prev && /^(el)?time$/.test(prev.type) && prev.part === "h"
                        && tok.part === "m" && tok.format < 3) {
                        // m or mm that follows hours should display minutes
                        tok.type = "time";
                    }
                } else if (/^(el)?time$/.test(tok.type) && tok.part === "s") {
                    if (prev && prev.type === "date" && prev.part === "m"
                        && prev.format < 3) {
                        // m or mm followed by seconds should display minutes
                        prev.type = "time";
                    }
                }
                if (!(/^(?:str|space|fill)$/.test(tok.type))) {
                    prev = tok;
                }
                format.push(tok);
            }
            return format;
        }
        function maybeFraction(tok) {
            if (tok.type !== "date" || (tok.part === "m" && tok.format < 3)) {
                let m = input.skip(/^\.(0+)/);
                if (m) {
                    tok.fraction = m[1].length;
                    if (tok.type === "date") {
                        tok.type = "time";
                    }
                }
            }
            return tok;
        }
        function readNext() {
            let ch, m;
            // numbers
            if ((m = input.skip(/^([#0?]+)(?:,([#0?]+))+/))) {
                // thousands separator.  seems convenient to treat
                // this as a single token.
                return { type: "digit", sep: true, format: m[1] + m[2], decimal: decimalPart };
            }
            if ((m = input.skip(/^[#0?]+/))) {
                return { type: "digit", sep: false, format: m[0], decimal: decimalPart };
            }
            // XXX: handle this one!
            if ((m = input.skip(/^(e)([+-])/i))) {
                return { type: "exp", ch: m[1], sign: m[2] };
            }
            // dates
            if ((m = input.skip(/^(d{1,4}|m{1,5}|yyyy|yy|y)/i))) {
                m = m[1].toLowerCase();
                return maybeFraction({ type: "date", part: m.charAt(0), format: m.length });
            }
            // time (interpret as a date)
            if ((m = input.skip(/^(hh?|ss?)/i))) { // m and mm are handled above
                m = m[1].toLowerCase();
                return maybeFraction({ type: "time", part: m.charAt(0), format: m.length });
            }
            // elapsed time (interpret as interval of days)
            if ((m = input.skip(/^\[(hh?|mm?|ss?)\]/i))) {
                m = m[1].toLowerCase();
                return maybeFraction({ type: "eltime", part: m.charAt(0), format: m.length });
            }
            if ((m = input.skip(/^(a[.]?m[.]?\/p[.]?m[.]?|a\/p)/i))) {
                m = m[1].split("/");
                return { type: "ampm", am: m[0], pm: m[1] };
            }
            switch ((ch = input.next())) { // JSHint sadness
              case ";":
                return null;
              case "\\":
                // quotes next character
                return { type: "str", value: input.next() };
              case '"':
                return { type: "str", value: input.readEscaped(ch) };
              case "@":
                return { type: "text" };
              case "_":
                // whitespace of the width of following character
                return { type: "space", value: input.next() };
              case "*":
                // fills cell width with the following character
                return { type: "fill", value: input.next() };
              case ".":
                if (input.lookingAt(/^\s*[#0?]/)) {
                    decimalPart = true;
                    return { type: "dec" };
                }
                return { type: "str", value: "." };
              case "%":
                return { type: "percent" };
              case ",":
                return { type: "comma" };
            }
            // whatever we can't make sense of, output literally.
            return { type: "str", value: ch };
        }
        function readSection() {
            decimalPart = false;
            let color = maybeColor(), cond = maybeCondition();
            if (!color && cond) {
                color = maybeColor();
            }
            return {
                color: color,
                cond: cond,
                body: readFormat()
            };
        }
    }

    function print$1(sections) {
        return sections.map(printSection).join(";");
        function printSection(sec) {
            let out = "";
            if (sec.color) {
                out += "[" + sec.color + "]";
            }
            if (sec.cond) {
                if (!(sec.cond === "text" || sec.cond === "num")) {
                    out += "[" + sec.cond.op + sec.cond.value + "]";
                }
            }
            out += sec.body.map(printToken).join("");
            return out;
        }
        function maybeFraction(fmt, tok) {
            if (tok.fraction) {
                fmt += "." + padLeft("", tok.fraction, "0");
            }
            return fmt;
        }
        function printToken(tok) {
            if (tok.type === "digit") {
                if (tok.sep) {
                    return tok.format.charAt(0) + "," + tok.format.substr(1);
                } else {
                    return tok.format;
                }
            } else if (tok.type === "exp") {
                return tok.ch + tok.sign;
            } else if (tok.type === "date" || tok.type === "time") {
                return maybeFraction(padLeft("", tok.format, tok.part), tok);
            } else if (tok.type === "eltime") {
                return maybeFraction("[" + padLeft("", tok.format, tok.part) + "]", tok);
            } else if (tok.type === "ampm") {
                return tok.am + "/" + tok.pm;
            } else if (tok.type === "str") {
                return JSON.stringify(tok.value);
            } else if (tok.type === "text") {
                return "@";
            } else if (tok.type === "space") {
                return "_" + tok.value;
            } else if (tok.type === "fill") {
                return "*" + tok.value;
            } else if (tok.type === "dec") {
                return ".";
            } else if (tok.type === "percent") {
                return "%";
            } else if (tok.type === "comma") {
                return ",";
            }
        }
    }

    function adjustDecimals(sections, x) {
        sections.forEach(function(sec) {
            let diff = x;
            if (sec.cond === "text") {
                return;
            }
            let body = sec.body, adjusted = false, i = body.length;
            while (diff !== 0 && --i >= 0) {
                let tok = body[i];
                if (tok.type === "digit") {
                    if (tok.decimal) {
                        adjusted = true;
                        if (diff > 0) {
                            tok.format += padLeft("", diff, "0");
                        } else if (diff < 0) {
                            let tmp = tok.format.length;
                            tok.format = tok.format.substr(0, tmp + diff);
                            diff += tmp - tok.format.length;
                        }
                        if (tok.format.length === 0) {
                            body.splice(i, 1);
                            while (--i >= 0) {
                                tok = body[i];
                                if (tok.type === "digit" && tok.decimal) {
                                    ++i;
                                    break;
                                }
                                if (tok.type === "dec") {
                                    body.splice(i, 1);
                                    break;
                                }
                            }
                        }
                    }
                    if (diff > 0) {
                        break;
                    }
                }
            }
            if (!adjusted && diff > 0) {
                // no decimal part was found, insert one after the last digit token.
                body.splice(
                    i + 1, 0, {
                        type    : "dec"
                    }, {
                        type    : "digit",
                        sep     : false,
                        decimal : true,
                        format  : padLeft("", diff, "0")
                    }
                );
            }
        });
    }

    function TokenStream2(parts) {
        let index = 0;
        return {
            next: function() {
                return parts[index++];
            },
            eof: function() {
                return index >= parts.length;
            },
            ahead: function(n, f) {
                if (index + n <= parts.length) {
                    let val = f.apply(null, parts.slice(index, index + n));
                    if (val) {
                        index += n;
                    }
                    return val;
                }
            },
            restart: function() {
                index = 0;
            }
        };
    }

    let runtime$1 = {
        unpackDate: calc.runtime.unpackDate,
        unpackTime: calc.runtime.unpackTime,

        date: function(culture, d, part, length) {
            switch (part) {
              case "d":
                switch (length) {
                case 1: return d.date;
                case 2: return padLeft(d.date, 2, "0");
                case 3: return culture.calendar.days.format.abbreviated[d.day];
                case 4: return culture.calendar.days.format.wide[d.day];
                }
                break;
              case "m":
                switch (length) {
                case 1: return d.month + 1;
                case 2: return padLeft(d.month + 1, 2, "0");
                case 3: return culture.calendar.months.format.abbreviated[d.month];
                case 4: return culture.calendar.months.format.wide[d.month];
                case 5: return culture.calendar.months.format.narrow[d.month];
                }
                break;
              case "y":
                switch (length) {
                case 1: return d.year;
                case 2: return d.year % 100;
                case 4: return d.year;
                }
                break;
            }
            return "##";
        },

        time: function(t, part, length, ampm, fraclen) {
            let ret, fraction;
            switch (part) {
              case "h":
                ret = padLeft(ampm ? t.hours % 12 || 12 : t.hours, length, "0");
                if (fraclen) {
                    fraction = (t.minutes + (t.seconds + t.milliseconds / 1000) / 60) / 60;
                }
                break;
              case "m":
                ret = padLeft(t.minutes, length, "0");
                if (fraclen) {
                    fraction = (t.seconds + t.milliseconds / 1000) / 60;
                }
                break;
              case "s":
                ret = padLeft(t.seconds, length, "0");
                if (fraclen) {
                    fraction = t.milliseconds / 1000;
                }
                break;
            }
            if (fraction) {
                ret += runtime$1.toFixed(fraction, fraclen).replace(/^0+/, "");
            }
            return ret;
        },

        eltime: function(value, part, length, fraclen) {
            let ret, fraction;
            switch (part) {
              case "h":
                ret = value * 24;
                break;
              case "m":
                ret = value * 24 * 60;
                break;
              case "s":
                ret = value * 24 * 60 * 60;
                break;
            }
            if (fraclen) {
                fraction = ret - (ret | 0);
            }
            ret = padLeft(ret | 0, length, "0");
            if (fraction) {
                ret += runtime$1.toFixed(fraction, fraclen).replace(/^0+/, "");
            }
            return ret;
        },

        fill: function(ch) {
            // XXX: how to implement this?
            return ch;
        },

        // formatting integer part is slightly different than decimal
        // part, so they're implemented in two functions.  For the
        // integer part we need to walk the value and the format
        // backwards (right-to-left).

        formatInt: function(culture, value, parts, declen, sep) {
            // toFixed is perfect for rounding our value; if there is
            // no format for decimals, for example, we want the number
            // rounded up.
            value = runtime$1.toFixed(value, declen).replace(/\..*$/, "");
            let lastPart = parts[parts.length - 1];

            if (declen > 0 && lastPart[parts.length - 1] != "0") {
                // if the rounded number is zero and we have decimal
                // format, consider it a non-significant digit (Excel
                // won't display the leading zero for 0.2 in format #.#).
                // the zero won't e omitted if using 0.0 format
                if (value === "0") { value = ""; }
                else if (value === "-0") { value = "-"; }
            }

            let shouldInsertMinus = false;
            let iv = value.length - 1;
            let result = [];
            let len = 0, str;

            function add(ch, skipMinus) {
                if (sep && len && len % 3 === 0 && /^[0-9]$/.test(ch)) {
                    str = culture.numbers.symbols.group + str;
                }
                if (skipMinus && ch === "-") {
                    shouldInsertMinus = true;
                    ch = "0";
                }
                str = ch + str;
                len++;
            }

            for (let j = parts.length; --j >= 0;) {
                let format = parts[j];
                str = "";
                for (let k = format.length; --k >= 0;) {
                    let chf = format.charAt(k);
                    if (iv < 0) {
                        if (chf == "0") {
                            add("0");
                        } else if (chf == "?") {
                            add(" ");
                        }
                    } else {
                        if (value == "0" && chf == "?") {
                            add(" ");
                        } else if (chf == "0") {
                            add(value.charAt(iv), true);
                        } else {
                            add(value.charAt(iv));
                        }
                        iv--;
                    }
                }
                if (j === 0) {
                    while (iv >= 0) {
                        add(value.charAt(iv--));
                    }
                }
                result.unshift(str);
            }

            if (shouldInsertMinus) {
                result[0] = "-" + result[0];
            }

            return result;
        },

        // for decimal part we walk in normal direction and pad on the
        // right if required (for '0' or '?' chars).

        formatDec: function(value, parts, declen) {
            value = runtime$1.toFixed(value, declen);
            let pos = value.indexOf(".");
            if (pos >= 0) {
                value = value.substr(pos + 1).replace(/0+$/, "");
            } else {
                value = "";
            }

            let iv = 0;
            let result = [];

            for (let j = 0; j < parts.length; ++j) {
                let format = parts[j];
                let str = "";
                for (let k = 0; k < format.length; ++k) {
                    let chf = format.charAt(k);
                    if (iv < value.length) {
                        str += value.charAt(iv++);
                    } else if (chf == "0") {
                        str += "0";
                    } else if (chf == "?") {
                        str += " ";
                    }
                }
                result.push(str);
            }

            return result;
        },

        // JS's toFixed is broken, it's only OK to use it on integers.
        toFixed: function(value, decimals) {
            return (function toFixed(value, last) {
                if (!isFinite(value)) {
                    return "#NUM!";
                }

                // deal early with the trivial cases
                if (value < 0) {    // JS's Math.round is broken with negative numbers
                    return "-" + toFixed(-value);
                }

                if (decimals === 0) { // no decimals
                    return String(Math.round(value));
                }

                if (value === Math.round(value) && !/e/i.test(String(value))) { // value is integer and not too big
                    return value.toFixed(decimals);
                }

                // this handles cases like 0.3.toFixed(20) == "0.29999999999999998890", or
                // 2.1825.toFixed(20) = "2.18250000000000010658".
                // https://github.com/telerik/kendo-ui-core/issues/3520#issuecomment-333768221
                // https://twitter.com/mcbazon/status/1035828655652593665
                let num = digNumber(value);
                let intpart = num.intpart;
                let decpart = num.decpart;
                if (decpart.length <= decimals) {
                    while (decpart.length < decimals) {
                        decpart += "0";
                    }
                    return intpart + "." + decpart;
                }

                if (last) {
                    // "we should definitely not get here" (famous last words).  Let's MAKE SURE
                    // there's no more recursion.
                    return intpart + "." + decpart.substr(0, decimals);
                }

                // if there are more decimals than wanted, round and try again.
                // it should not recurse more than once.
                let f = Math.pow(10, decimals);
                return toFixed(Math.round(value * f) / f, true);

            })(Number(value.toFixed(14))); /* restrict to 14 decimals, because 0.1 + 0.2 ===
                                            * 0.30000000000000004 */
        }

    };

    function checkCondition(condition, a, b) {
        switch (condition.op) {
          case "=":
            return a == b;
          case "<":
            return a < b;
          case ">":
            return a > b;
          case "<=":
            return a <= b;
          case ">=":
            return a >= b;
        }
        throw new Error(`Unknown condition operator: ${JSON.stringify(condition)}`);
    }

    function compileFormatPart(format) {
        let input = TokenStream2(format.body);
        let hasDate = false;
        let hasTime = false;
        let hasAmpm = false;
        let percentCount = 0;
        let currency = /[\$\xA2-\xA5\u058F\u060B\u09F2\u09F3\u09FB\u0AF1\u0BF9\u0E3F\u17DB\u20A0-\u20BD\uA838\uFDFC\uFE69\uFF04\uFFE0\uFFE1\uFFE5\uFFE6]/;
        let scaleCount = 0;
        let separeThousands = false;
        let declen = 0;
        let intFormat = [], decFormat = [];
        let condition = format.cond;

        function checkComma(a, b) {
            if ((a.type === "digit" && b.type === "comma") || (a.type === "comma" && a.hidden && b.type === "comma")) {
                b.hidden = true;
                scaleCount++;
            }
        }
        while (!input.eof()) {
            input.ahead(2, checkComma);
            let tok = input.next();
            if (tok.type === "percent") {
                percentCount++;
            }
            else if (tok.type === "digit") {
                if (tok.decimal) {
                    declen += tok.format.length;
                    decFormat.push(tok.format);
                } else {
                    intFormat.push(tok.format);
                    if (tok.sep) {
                        separeThousands = true;
                    }
                }
            }
            else if (tok.type === "time") {
                hasTime = true;
            }
            else if (tok.type === "date") {
                hasDate = true;
            }
            else if (tok.type === "ampm") {
                hasAmpm = hasTime = true;
            }
        }

        return function interpret(result, value, culture) {
            let intPart, decPart, isNegative, date, time;
            if (condition === "text") {
                if (!(typeof value == "string" || value instanceof CalcError)) {
                    return false;
                }
            }
            else if (condition === "num") {
                if (typeof value != "number") {
                    return false;
                }
            }
            else if (condition) {
                if (typeof value != "number") {
                    return false;
                }
                if (!checkCondition(condition, value, condition.value)) {
                    return false;
                }
                if (!condition.custom) {
                    value = Math.abs(value);
                }
            }
            if (percentCount > 0 || scaleCount > 0 || intFormat.length || decFormat.length || hasDate || hasTime) {
                if (typeof value != "number") {
                    return false;
                }
            }
            if (format.color) {
                result.color = format.color;
            }
            if (percentCount > 0) {
                value *= Math.pow(100, percentCount);
            }
            if (scaleCount > 0) {
                value /= Math.pow(1000, scaleCount);
            }
            if (intFormat.length) {
                intPart = runtime$1.formatInt(culture, value, intFormat, declen, separeThousands);
                isNegative = parseInt(intPart[0]) < 0;
            }
            if (decFormat.length) {
                decPart = runtime$1.formatDec(value, decFormat, declen);
            }
            if (intFormat.length || decFormat.length) {
                result.type = "number";
            }
            if (hasDate) {
                date = runtime$1.unpackDate(value);
            }
            if (hasTime) {
                time = runtime$1.unpackTime(value);
            }
            if (hasDate || hasTime) {
                result.type = "date";
            }
            let matchedCurrency = false, output = "";
            input.restart();
            while (!input.eof()) {
                let tok = input.next();
                if (tok.type === "dec") {
                    output += culture.numbers.symbols.decimal;
                }
                else if (tok.type === "comma" && !tok.hidden) {
                    output += ',';
                }
                else if (tok.type === "percent") {
                    result.type = "percent";
                    output += culture.numbers.symbols.percentSign;
                }
                else if (tok.type === "str") {
                    if (currency.test(tok.value)) {
                        result.type = "currency";
                        if (isNegative) {
                            output += "-";
                            matchedCurrency = true;
                        }
                    }
                    output += tok.value;
                }
                else if (tok.type === "text") {
                    result.type = "text";
                    output += value; // XXX: sure not `tok.value`?
                }
                else if (tok.type === "space") {
                    if (output) {
                        result.body.push(output);
                    }
                    output = "";
                    result.body.push(tok);
                }
                else if (tok.type === "fill") {
                    output += runtime$1.fill(tok.value);
                }
                else if (tok.type === "digit") {
                    if (isNegative && intPart[0] && matchedCurrency) {
                        intPart[0] = intPart[0].replace("-", "");
                    }
                    output += tok.decimal ? decPart.shift() : intPart.shift();
                }
                else if (tok.type === "date") {
                    output += runtime$1.date(culture, date, tok.part, tok.format);
                }
                else if (tok.type === "time") {
                    output += runtime$1.time(time, tok.part, tok.format, hasAmpm, tok.fraction);
                }
                else if (tok.type === "eltime") {
                    output += runtime$1.eltime(value, tok.part, tok.format, tok.fraction);
                }
                else if (tok.type === "ampm") {
                    // XXX: should use culture?  As per the "spec", Excel
                    // displays whatever the token was (AM/PM, a/p etc.)
                    output += time.hours < 12 ? tok.am : tok.pm;
                }
            }
            if (output) {
                result.body.push(output);
            }
            return true;
        };
    }

    let TEXT = compileFormatPart({ cond: "text", body: [ { type: "text" } ] });

    let compile = memoize(function(format) {
        let tree = parse$2(format);
        let parts = tree.map(compileFormatPart);
        parts.push(TEXT);
        return function(value, localCulture = culture()) {
            let result = { body: [] };
            for (let i = 0; i < parts.length; ++i) {
                if (parts[i](result, value, localCulture)) {
                    break;
                }
            }
            return result;
        };
    });

    // Attempts to produce a format compatible with kendo.parseDate from our Excel format.  Needed
    // in runtime.parseDate (passing Excel format to kendo.parseDate will mess up the month or
    // minutes).  https://github.com/telerik/kendo-ui-core/issues/3797
    let makeDateFormat = memoize(function(format) {
        let tree = parse$2(format);
        let section, found = false, hasAmpm = false;
        // locate a section that contains date/time formatting.  only the first will be converted.
        for (let i = 0; i < tree.length; ++i) {
            section = tree[i];
            for (let j = 0; j < section.body.length; ++j) {
                if (/^(?:date|time|ampm)$/.test(section.body[j].type)) {
                    found = true;
                    if (section.body[j].type === "ampm") {
                        hasAmpm = true;
                    }
                }
            }
            if (found) {
                break;
            }
        }
        if (!found) {
            return null;
        }
        return section.body.map(printToken).join("");
        // a little copy/paste goes a long way
        function maybeFraction(fmt, tok) {
            if (tok.fraction) {
                fmt += padLeft("", Math.max(tok.fraction, 3), "f");
            }
            return fmt;
        }
        function printToken(tok) {
            if (tok.type === "digit") {
                if (tok.sep) {
                    return tok.format.charAt(0) + "," + tok.format.substr(1);
                } else {
                    return tok.format;
                }
            }
            else if (tok.type === "exp") {
                return tok.ch + tok.sign;
            }
            else if (tok.type === "date" || tok.type === "time") {
                let part = tok.part;
                if (tok.type === "date" && /^m/.test(part)) {
                    part = "M"; // month, not minutes
                }
                else if (tok.type === "time" && /^h/.test(part)) {
                    if (!hasAmpm) {
                        // 24-hours clock is H or HH
                        part = part.toUpperCase();
                    }
                }
                return maybeFraction(padLeft("", tok.format, part), tok);
            }
            else if (tok.type === "ampm") {
                return "tt";
            }
            else if (tok.type === "str") {
                // XXX: this is a bit wrong.  it doesn't look like kendo.toString / kendo.parseDate
                // support arbitrary text (in Excel formats that's quoted), for example:
                //    kendo.toString(new Date(), "here's the day dude: dd")
                //  → "3ere'8 t3e 19ay 19u19e: 19"   (it's 19th June, 3 o'clock, probably 8 seconds)
                return tok.value;
            }
            else if (tok.type === "space") {
                return " ";
            }
            else if (tok.type === "dec") {
                return ".";
            }
            else if (tok.type === "percent") {
                return "%";
            }
            else if (tok.type === "comma") {
                return ",";
            }
            else {
                return "";
            }
        }
    });

    function padLeft(val, width, ch) {
        val += "";
        while (val.length < width) {
            val = ch + val;
        }
        return val;
    }

    function padRight(val, width, ch) {
        val += "";
        while (val.length < width) {
            val += ch;
        }
        return val;
    }

    // given a number, return { intpart, decpart } as strings.  the main difficulty here is that JS
    // will stringify really large values in scientific notation (e.g. 1.23e+30, which is actually
    // the integer 1230000000000000000000000000000).
    function digNumber(num) {
        let str = String(num).toLowerCase();
        let intpart, decpart, m;
        let pos = str.indexOf(".");
        if (pos < 0) {
            pos = str.indexOf("e");
            if (pos < 0) {
                intpart = str;
                decpart = "";
            } else {
                intpart = str.substr(0, pos);
                decpart = str.substr(pos);
            }
        } else {
            intpart = str.substr(0, pos);
            decpart = str.substr(pos + 1);
        }
        if ((m = /(\d*)e([-+]?\d+)/.exec(decpart))) {
            let exp = parseInt(m[2], 10);
            if (exp >= 0) {
                decpart = padRight(m[1], exp, "0");
                intpart += decpart.substr(0, exp);
                decpart = decpart.substr(exp);
            } else {
                intpart = padLeft(intpart, -exp, "0");
                decpart = intpart.substr(exp) + m[1];
                intpart = intpart.substr(0, intpart.length + exp);
            }
        }
        return { intpart: intpart || "0", decpart: decpart };
    }

    /* -----[ exports ]----- */
    function text(f) {
        let a = f.body;
        let text = "";
        for (let i = 0; i < a.length; ++i) {
            let el = a[i];
            if (typeof el == "string") {
                text += el;
            } else if (el.type === "space") {
                text += " ";
            }
        }
        return text;
    }

    const formatting = {
        compile : compile,
        parse: parse$2,
        format: function(value, format, culture) {
            let f = compile(format)(value, culture);
            let span = dom.element("span");
            span.__dataType = f.type;
            let a = f.body;
            if (f.color) {
                span.attr.style = { color: f.color };
            }
            for (let i = 0; i < a.length; ++i) {
                let el = a[i];
                if (typeof el == "string") {
                    span.children.push(dom.text(el));
                } else if (el.type === "space") {
                    span.children.push(dom.element("span", {
                        style: { visibility: "hidden" }
                    }, [ dom.text(el.value) ]));
                }
            }
            return span;
        },
        text: function(value, format, culture) {
            let f = compile(format)(value, culture);
            return text(f);
        },
        textAndColor: function(value, format, culture) {
            let f = compile(format)(value, culture);
            return { text: text(f), color: f.color, type: f.type };
        },
        type: function(value, format, culture) {
            return compile(format)(value, culture).type;
        },
        adjustDecimals: function(format, diff) {
            let ast = parse$2(format);
            adjustDecimals(ast, diff);
            return print$1(ast);
        },
        makeDateFormat: makeDateFormat
    };

    /* eslint-disable no-nested-ternary */
    /* eslint-disable space-infix-ops */
    /* eslint-disable indent */
    /* eslint-disable no-empty */
    /* eslint-disable no-loop-func */
    /* eslint-disable consistent-return */
    /* eslint-disable block-scoped-var */
    /* eslint-disable no-redeclare */
    /* eslint-disable no-var */
    /* eslint-disable eqeqeq */
    /* eslint-disable complexity */
    /* eslint-disable max-params */
    /* eslint-disable no-implicit-coercion */
    /* eslint-disable key-spacing */
    /* eslint-disable default-case */
    /* eslint-disable camelcase */
    /* eslint-disable brace-style */
    /* eslint-disable no-else-return */
    /* eslint-disable no-constant-condition */
    /* eslint-disable no-param-reassign */
    /* eslint-disable space-before-blocks */
    /* eslint-disable no-unused-labels */


    const kendo = createKendoObj(calc, CalcError, Ref, CellRef, RangeRef);
    calc.kendo = kendo; // XXX
    calc.formatting = formatting;

    // --------------------------------------------calc.js

    // Excel formula parser and compiler to JS.
    // some code adapted from http://lisperator.net/pltut/

    // these two will hold the same operators, except that when the comma is used as decimal
    // separator, the union operator must be the semicolon (;) instead of comma.
    let OPERATORS_STANDARD = Object.create(null);
    let OPERATORS_COMMA = Object.create(null);

    (function(ops){
        ops.forEach(function(cls, i){
            cls.forEach(function(op){
                OPERATORS_STANDARD[op] = ops.length - i;
                OPERATORS_COMMA[op === "," ? ";" : op] = ops.length - i;
            });
        });
    })([
        [ ":" ],
        [ " " ],
        [ "," ],
        [ "%" ],
        [ "^" ],
        [ "*", "/" ],
        [ "+", "-" ],
        [ "&" ],
        [ "=", "<", ">", "<=", ">=", "<>" ]
    ]);

    let OPERATORS = OPERATORS_STANDARD;

    let SEPARATORS = {
        DEC: ".",
        ARG: ",",
        COL: ","
    };

    function setDecimalSeparator(sep) {
        SEPARATORS.DEC = sep;
        SEPARATORS.ARG = sep === "," ? ";" : ",";
        SEPARATORS.COL = sep === "," ? "\\" : ",";
        OPERATORS = sep === "," ? OPERATORS_COMMA : OPERATORS_STANDARD;
    }

    calc.withDecimalSeparator = function(sep, f) {
        if (SEPARATORS.DEC === sep) {
            return f();
        }
        let save = SEPARATORS.DEC;
        setDecimalSeparator(sep);
        try {
            return f();
        } finally {
            setDecimalSeparator(save);
        }
    };

    calc._separators = SEPARATORS;

    let TRUE = { type: "bool", value: true };
    let FALSE = { type: "bool", value: false };

    function getcol(str) {
        str = str.toUpperCase();
        let col = 0;
        for (let i = 0; i < str.length; ++i) {
            col = col * 26 + str.charCodeAt(i) - 64;
        }
        return col - 1;
    }

    function getrow(str) {
        return parseInt(str, 10) - 1;
    }

    function parseReference(name, noThrow) {
        if (name.toLowerCase() === "#sheet") {
            return SHEETREF;
        }
        OUT: {
            // this is redundant, but let's keep it fast for the most
            // common case — A1.  If this fails, we'll try to employ the
            // whole tokenizer.
            let m;
            if ((m = /^(\$)?([a-z]+)(\$)?(\d+)$/i.exec(name))) {
                let row = getrow(m[4]), col = getcol(m[2]);
                if (row < 0x100000 && col < 0x4000) {
                    return new CellRef(getrow(m[4]), getcol(m[2]));
                }
                // no NameRef-s from this function
                break OUT;
            }
            let stream = TokenStream(name, {});
            let a = [];
            while (true) {
                let ref = stream.next();
                if (ref instanceof CellRef) {
                    // this function always makes absolute references
                    ref.rel = 0;
                } else if (ref instanceof RangeRef) {
                    ref.topLeft.rel = 0;
                    ref.bottomRight.rel = 0;
                } else {
                    break OUT;
                }
                a.push(ref);
                if (stream.eof()) {
                    break;
                }
                if (!stream.is("op", SEPARATORS.ARG)) {
                    break OUT;
                }
                stream.next();
            }
            return a.length === 1 ? a[0] : new UnionRef(a);
        }
        if (!noThrow) {
            throw new Error("Cannot parse reference: " + name);
        }
    }

    function parseFormula(sheet, row, col, input) {
        let refs = [];
        input = TokenStream(input, { row: row, col: col });
        let is = input.is;

        return {
            type: "exp",
            ast: parseExpression(true),
            refs: refs,
            sheet: sheet,
            row: row,
            col: col
        };

        function addReference(ref) {
            ref.index = refs.length;
            refs.push(ref);
            return ref;
        }

        function skip(type, value, allowEOF) {
            if (is(type, value)) {
                return input.next();
            } else {
                let tok = input.peek();
                if (tok) {
                    input.croak("Expected " + type + " «" + value + "» but found " + tok.type + " «" + tok.value + "»");
                } else if (!allowEOF) {
                    input.croak("Expected " + type + " «" + value + "»");
                }
            }
        }

        function parseExpression(commas) {
            return maybeBinary(maybeIntersect(parseAtom()), 0, commas);
        }

        function parseSymbol(tok) {
            if (tok.upper === "TRUE" || tok.upper === "FALSE") {
                return tok.upper === "TRUE" ? TRUE : FALSE;
            }
            return addReference(new NameRef(tok.value));
        }

        function parseFuncall() {
            let fname = input.next();
            fname = fname.value;
            skip("punc", "(");
            let args = [];
            while (1) {
                if (is("punc", ")")) {
                    break;
                }
                if (is("op", SEPARATORS.ARG)) {
                    args.push({ type: "null" });
                    input.next();
                    continue;
                }
                args.push(parseExpression(false));
                if (input.eof() || is("punc", ")")) {
                    break;
                }
                skip("op", SEPARATORS.ARG);
            }
            skip("punc", ")", true);
            return {
                type: "func",
                func: fname,
                args: args
            };
        }

        function fixReference(ref) {
            if (!ref.hasSheet()) {
                ref.setSheet(sheet);
            }
            return addReference(ref);
        }

        function parseAtom() {
            let exp;
            if (is("ref")) {
                exp = fixReference(input.next());
            }
            else if (is("func")) {
                exp = parseFuncall();
            }
            else if (is("punc", "(")) {
                input.next();
                exp = parseExpression(true);
                skip("punc", ")", true);
            }
            else if (is("punc", "{")) {
                input.next();
                exp = parseArray();
                skip("punc", "}", true);
            }
            else if (is("num") || is("str") || is("error")) {
                exp = input.next();
            }
            else if (is("sym")) {
                exp = parseSymbol(input.next());
            }
            else if (is("op", "+") || is("op", "-")) {
                exp = {
                    type: "prefix",
                    op: input.next().value,
                    exp: parseAtom()
                };
            }
            else if (!input.peek()) {
                input.croak("Incomplete expression");
            }
            else if (is("punc", "[")) {
                input.croak("External reference not supported");
            }
            else {
                input.croak("Parse error");
            }
            return maybePercent(exp);
        }

        function parseArray() {
            let row = [], value = [ row ], first = true;
            while (!input.eof() && !is("punc", "}")) {
                if (first) {
                    first = false;
                } else if (is(null, ";")) {
                    value.push(row = []);
                    input.next();
                } else {
                    skip(null, SEPARATORS.COL);
                }
                row.push(parseExpression(false));
            }
            return {
                type: "matrix",
                value: value
            };
        }

        function maybeIntersect(exp) {
            if (is("punc", "(") || is("ref") || is("num") || is("func")) {
                return {
                    type: "binary",
                    op: " ",
                    left: exp,
                    right: parseExpression(false)
                };
            } else {
                return exp;
            }
        }

        function maybePercent(exp) {
            if (is("op", "%")) {
                input.next();
                return maybePercent({
                    type: "postfix",
                    op: "%",
                    exp: exp
                });
            } else {
                return exp;
            }
        }

        function maybeBinary(left, my_prec, commas) {
            let tok = is("op");
            if (tok && (commas || tok.value !== SEPARATORS.ARG)) {
                let his_prec = OPERATORS[tok.value];
                if (his_prec > my_prec) {
                    input.next();
                    let right = maybeBinary(parseAtom(), his_prec, commas);
                    return maybeBinary({
                        type: "binary",
                        op: tok.value === ";" ? "," : tok.value, // translate union back to comma
                        left: left,
                        right: right
                    }, my_prec, commas);
                }
            }
            return left;
        }
    }

    function parseNameDefinition(name, def) {
        let nameRef = parseFormula(null, 0, 0, name);
        if (!(nameRef.ast instanceof NameRef)) {
            throw new calc.runtime.ParseError("Invalid name: " + name);
        }
        nameRef = nameRef.ast;

        if (!(def instanceof Ref)) {
            let defAST = parseFormula(nameRef.sheet, 0, 0, def);
            if (defAST.ast instanceof Ref) {
                def = defAST.ast;   // single reference
            } else if (/^(?:str|num|bool|error)$/.test(defAST.ast.type)) {
                def = defAST.ast.value; // constant
            } else {
                def = makeFormula(defAST); // formula
            }
        }

        return {
            name: nameRef,
            value: def
        };
    }

    function print(exp, refs, row, col, mod) {
        return print(exp.ast, exp, 0);

        function print(node, parent, prec) {
            switch (node.type) {
              case "num":
                return calc._separators.DEC == "." ? JSON.stringify(node.value)
                    : JSON.stringify(node.value).replace(".", calc._separators.DEC);

              case "bool":
                return node.value;

              case "error":
                return "#" + node.value;

              case "str":
                return JSON.stringify(node.value);

              case "ref":
                return withParens(() =>
                    refs[node.index].print(row, col, mod));

              case "prefix":
                return withParens(() =>
                    node.op + print(node.exp, node, OPERATORS[node.op]));

              case "postfix":
                return withParens(() =>
                    print(node.exp, node, OPERATORS[node.op]) + node.op);

              case "binary":
                return withParens(() => {
                    let left = parenthesize(
                        print(node.left, node, OPERATORS[node.op]),
                        node.left instanceof NameRef && node.op === ":"
                    );
                    let right = parenthesize(
                        print(node.right, node, OPERATORS[node.op]),
                        node.right instanceof NameRef && node.op === ":"
                    );
                    if (/^[,;]/.test(node.op)) {
                        return left + calc._separators.ARG + right;
                    } else {
                        return left + node.op + right;
                    }
                });

              case "func":
                return node.func + "("
                    + node.args.map(arg => print(arg, node, 0)).join(calc._separators.ARG + " ") + ")";

              case "matrix":
                return "{ " + node.value.map(tr => tr.map(td => print(td, node, 0)).join(calc._separators.COL)).join("; ") + " }";

              case "null":
                return "";
            }

            throw new Error("Cannot print node " + node.type);

            function withParens(f) {
                let op = node.op;
                let needParens = (OPERATORS[op] < prec
                                  || (!prec && op === ",")
                                  || (parent.type === "prefix" && prec === OPERATORS[op] && parent.op === "-")
                                  || (parent.type === "binary" && prec === OPERATORS[op] && node === parent.right));
                return parenthesize(f(), needParens);
            }
        }

        function parenthesize(code, cond) {
            return cond ? "(" + code + ")" : code;
        }
    }

    function makePrinter(exp) {
        return function(row, col, mod) {
            return print(exp, this.refs, row, col, mod);
        };
    }

    /// BEGIN interpreter

    function evRef(ctx, node, k) {
        return node.ref === "name"
            ? ctx.fetchName(node, k)
            : k(ctx.formula.absrefs[node.index]);
    }

    function evFuncIf(ctx, co, th, el, k) {
        return evaluate(ctx, co, co => ctx.func("if", k, [
            co,
            k => evaluate(ctx, th, k),
            k => evaluate(ctx, el, k)
        ]));
    }

    function evFuncAnd(ctx, args, k) {
        return args.length === 0 ? k(true)
            : args.length === 1 ? evaluate(ctx, args[0], co => k(ctx.bool(co)))
            : evaluate(ctx, args[0], co =>
                ctx.bool(co)
                    ? evFuncAnd(ctx, args.slice(1), k)
                    : k(false));
    }

    function evFuncOr(ctx, args, k) {
        return args.length === 0 ? k(false)
            : args.length === 1 ? evaluate(ctx, args[0], co => k(ctx.bool(co)))
            : evaluate(ctx, args[0], co =>
                ctx.bool(co)
                    ? k(true)
                    : evFuncOr(ctx, args.slice(1), k));
    }

    function evFunc(ctx, node, k) {
        switch (node.func.toLowerCase()) {
          case "if":
            return evFuncIf(ctx, node.args[0], node.args[1] || TRUE, node.args[2] || FALSE, k);
          case "and":
            return evFuncAnd(ctx, node.args, k);
          case "or":
            return evFuncOr(ctx, node.args, k);
          case "true":
            return k(true);
          case "false":
            return k(false);
        }
        return evArguments(ctx, node.args, 0, args => ctx.func(node.func, k, args));
    }

    function evArguments(ctx, args, i, k, ret = []) {
        return i === args.length
            ? k(ret)
            : evaluate(ctx, args[i], val => (
                ret[i] = val,
                evArguments(ctx, args, i + 1, k, ret)
            ));
    }

    function evBinary(ctx, node, k) {
        return evaluate(ctx, node.left, left =>
            evaluate(ctx, node.right, right =>
                ctx.func("binary" + node.op, k, [ left, right ])));
    }

    function evUnary(ctx, node, k) {
        return evaluate(ctx, node.exp, exp =>
            ctx.func("unary" + node.op, k, [ exp ]));
    }

    function evMatrix(ctx, { value }, k) {
        let a = [];
        return (function loop(i){
            return i === value.length ? k(a)
                : evArguments(ctx, value[i], 0, row =>
                    (a[i] = row, loop(i + 1)));
        })(0);
    }

    function evaluate(ctx, node, k) {
        switch (node.type) {
          case "ref":
            return evRef(ctx, node, k);
          case "num":
          case "str":
          case "null":
          case "bool":
            return k(node.value);
          case "error":
            return k(ctx.error(node.value));
          case "prefix":
          case "postfix":
            return evUnary(ctx, node, k);
          case "binary":
            return evBinary(ctx, node, k);
          case "func":
            return evFunc(ctx, node, k);
          case "matrix":
            return evMatrix(ctx, node, k);
        }
        throw new Error("Cannot evaluate " + node.type);
    }

    function makeInterpreter({ ast }) {
        return function() {
            // `this` is the Context object (runtime.js), so don't attempt
            // to make this an arrow function.
            return evaluate(this, ast, val => this.resolve(val));
        };
    }

    /// END interpreter

    let FORMULA_CACHE = Object.create(null);

    function makeFormula(exp) {
        let printer = makePrinter(exp);
        let hash = printer.call(exp); // needs .refs
        let formula = FORMULA_CACHE[hash];
        if (formula) {
            // we need to clone because formulas cache the result; even if the formula is the same,
            // its value will depend on its location, hence we need different objects.  Still, using
            // this cache is a good idea because we'll reuse the same refs array, handler and
            // printer, instead of allocating new ones (and we skip compiling it).
            return formula.clone(exp.sheet, exp.row, exp.col);
        }

        formula = new calc.runtime.Formula(exp.refs, makeInterpreter(exp), printer, exp.sheet, exp.row, exp.col);
        FORMULA_CACHE[hash] = formula.clone(exp.sheet, exp.row, exp.col);
        return formula;
    }

    function identity$1(x) {
        return x;
    }

    function TokenStream(input, options) {
        input = RawTokenStream(calc.runtime.InputStream(input), options);
        let ahead = input.ahead;
        let skip = input.skip;
        let token = null;
        let fixCell = options.row != null && options.col != null
            ? function(cell) {
                if (cell.rel & 1) {
                    cell.col -= options.col;
                }
                if (cell.rel & 2) {
                    cell.row -= options.row;
                }
                return cell;
            }
            : identity$1;

        let addPos = options.forEditor
            ? function(thing, startToken, endToken) {
                thing.begin = startToken.begin;
                thing.end = endToken.end;
                return thing;
            }
            : identity$1;

        return {
            peek  : peek,
            next  : next,
            croak : input.croak,
            eof   : input.eof,
            is    : is
        };

        function is(type, value) {
            let tok = peek();
            return tok != null
                && (type == null || tok.type === type)
                && (value == null || tok.value === value)
                ? tok : null;
        }

        function peek() {
            if (token == null) {
                token = readNext();
            }
            return token;
        }

        function next() {
            if (token != null) {
                let tmp = token;
                token = null;
                return tmp;
            }
            return readNext();
        }

        function readNext() {
            let ret;
            let t = input.peek();
            if (t) {
                if (t.type === "sym" || t.type === "rc" || t.type === "num") {
                    ret = ahead(8, refRange3D)
                        || ahead(6, refCell3D)
                        || ahead(6, refSheetRange)
                        || ahead(4, refSheetCell)
                        || ahead(4, refRange)
                        || ahead(2, refCell)
                        || ahead(2, funcall);
                }
                if (!ret) {
                    ret = input.next();
                }
            }
            return ret;
        }

        function toCell(tok, isFirst) {
            if (tok.type === "rc") {
                // RC notation is read properly without knowing where
                // we are, so no need to fixCell on this one.
                // However, if only absolute refs were asked for (from
                // i.e. parseReference) I feel it's alright to yell
                // about it here.
                if (tok.rel && !options.forEditor && (options.row == null || options.col == null)) {
                    input.croak("Cannot read relative cell in RC notation");
                }
                return new CellRef(tok.row, tok.col, tok.rel);
            }
            if (tok.type === "num") {
                if (tok.value <= 1048577) {
                    // whole row
                    return fixCell(new CellRef(
                        getrow(tok.value),
                        isFirst ? -Infinity : +Infinity,
                        2
                    ));
                } else {
                    return null;
                }
            }
            // otherwise it's "sym".  The OOXML spec (SpreadsheetML
            // 18.2.5) defines the maximum value to be interpreted as
            // a cell reference to be XFD1048576.
            let name = tok.value;
            let m = /^(\$)?([a-z]+)(\$)?(\d+)$/i.exec(name);
            if (m) {
                let row = getrow(m[4]), col = getcol(m[2]);
                if (row <= 1048576 && col <= 16383) {
                    return fixCell(new CellRef(
                        getrow(m[4]),
                        getcol(m[2]),
                        (m[1] ? 0 : 1) | (m[3] ? 0 : 2)
                    ));
                } else {
                    return null;
                }
            }
            let abs = name.charAt(0) === "$";
            if (abs) {
                name = name.substr(1);
            }
            if (/^\d+$/.test(name)) {
                let row = getrow(name);
                if (row <= 1048576) {
                    return fixCell(new CellRef(
                        getrow(name),
                        isFirst ? -Infinity : +Infinity,
                        (abs ? 0 : 2)
                    ));
                }
            } else {
                let col = getcol(name);
                if (col <= 16383) {
                    return fixCell(new CellRef(
                        isFirst ? -Infinity : +Infinity,
                        getcol(name),
                        (abs ? 0 : 1)
                    ));
                }
            }
        }

        // Sheet1(a) :(b) Sheet2(c) !(d) A1(e) :(f) C3(g) not followed by paren (h)
        function refRange3D(a, b, c, d, e, f, g, h) {
            if (a.type === "sym" &&
                b.type === "op" && b.value === ":" &&
                c.type === "sym" &&
                d.type === "punc" && d.value === "!" &&
                (e.type === "sym" || e.type === "rc" || (e.type === "num" && e.value === e.value | 0)) &&
                f.type === "op" && f.value === ":" &&
                (g.type === "sym" || g.type === "rc" || (g.type === "num" && g.value === g.value | 0)) &&
                g.type === e.type &&
                !(h.type === "punc" && h.value === "(" && !g.space))
            {
                let tl = toCell(e, true), br = toCell(g, false);
                if (tl && br) {
                    // skip them except the last one, we only wanted to
                    // ensure it's not paren.
                    skip(7);
                    return addPos(new RangeRef(
                        tl.setSheet(a.value, true),
                        br.setSheet(c.value, true)
                    ).setSheet(a.value, true), a, g);
                }
            }
        }

        // Sheet1(a) :(b) Sheet2(c) !(d) A1(e) not followed by paren (f)
        function refCell3D(a, b, c, d, e, f) {
            if (a.type === "sym" &&
                b.type === "op" && b.value === ":" &&
                c.type === "sym" &&
                d.type === "punc" && d.value === "!" &&
                (e.type === "sym" || e.type === "rc" || (e.type === "num" && e.value === e.value | 0)) &&
                !(f.type === "punc" && f.value === "(" && !e.space))
            {
                let tl = toCell(e);
                if (tl) {
                    skip(5);
                    let br = tl.clone();
                    return addPos(new RangeRef(
                        tl.setSheet(a.value, true),
                        br.setSheet(c.value, true)
                    ).setSheet(a.value, true), a, e);
                }
            }
        }

        // Sheet1(a) !(b) A1(c) :(d) C3(e) not followed by paren (f)
        function refSheetRange(a, b, c, d, e, f) {
            if (a.type === "sym" &&
                b.type === "punc" && b.value === "!" &&
                (c.type === "sym" || c.type === "rc" || (c.type === "num" && c.value === c.value | 0)) &&
                d.type === "op" && d.value === ":" &&
                (e.type === "sym" || e.type === "rc" || (e.type === "num" && e.value === e.value | 0)) &&
                !(f.type === "punc" && f.value === "(" && !e.space))
            {
                let tl = toCell(c, true), br = toCell(e, false);
                if (tl && br) {
                    skip(5);
                    return addPos(new RangeRef(tl, br).setSheet(a.value, true), a, e);
                }
            }
        }

        // Sheet1(a) !(b) A1(c) not followed by paren (d)
        function refSheetCell(a, b, c, d) {
            if (a.type === "sym" &&
                b.type === "punc" && b.value === "!" &&
                (c.type === "sym" || c.type === "rc" || (c.type === "num" && c.value === c.value | 0)) &&
                !(d.type === "punc" && d.value === "(" && !c.space))
            {
                skip(3);
                let x = toCell(c);
                if (!x || !isFinite(x.row)) {
                    x = new NameRef(c.value);
                }
                return addPos(x.setSheet(a.value, true), a, c);
            }
        }

        // A1(a) :(b) C3(c) not followed by paren (d)
        function refRange(a, b, c, d) {
            if ((a.type === "sym" || a.type === "rc" || (a.type === "num" && a.value === a.value | 0)) &&
                (b.type === "op" && b.value === ":") &&
                (c.type === "sym" || c.type === "rc" || (c.type === "num" && c.value === c.value | 0)) &&
                !(d.type === "punc" && d.value === "(" && !c.space))
            {
                let tl = toCell(a, true), br = toCell(c, false);
                if (tl && br) {
                    skip(3);
                    return addPos(new RangeRef(tl, br), a, c);
                }
            }
        }

        // A1(a) not followed by paren (b)
        function refCell(a, b) {
            if ((a.type === "sym" || a.type === "rc") && !(b.type === "punc" && b.value === "(" && !a.space)) {
                let x = toCell(a);
                if (x && isFinite(x.row) && isFinite(x.col)) {
                    skip(1);
                    return addPos(x, a, a);
                }
            }
        }

        function funcall(a, b) {
            if (a.type === "sym" && b.type === "punc" && b.value === "(" && !a.space) {
                a.type = "func";
                skip(1);
                return a;       // already has position
            }
        }
    }

    function isWhitespace(ch) {
        return " \t\r\n\xa0\u200b".indexOf(ch) >= 0;
    }

    let EOF = { type: "eof" };

    function RawTokenStream(input, options) {
        let tokens = [], index = 0;
        let readWhile = input.readWhile;

        return {
            next  : next,
            peek  : peek,
            eof   : eof,
            croak : input.croak,
            ahead : ahead,
            skip  : skip
        };

        function isDigit(ch) {
            return (/[0-9]/i.test(ch));
        }

        function isIdStart(ch) {
            return (/[a-z$_]/i.test(ch) || isUnicodeLetter(ch));
        }

        function isId(ch) {
            return isIdStart(ch) || isDigit(ch) || ch === ".";
        }

        function isOpChar(ch) {
            return ch in OPERATORS;
        }

        function isPunc(ch) {
            return "\\!;(){}[]".indexOf(ch) >= 0;
        }

        function readNumber() {
            // XXX: TODO: exponential notation
            let has_dot = false;
            let number = readWhile(function(ch){
                if (ch === SEPARATORS.DEC) {
                    if (has_dot) {
                        return false;
                    }
                    has_dot = true;
                    return true;
                }
                return isDigit(ch);
            });
            if (number === SEPARATORS.DEC) {
                return { type: "punc", value: SEPARATORS.DEC };
            } else {
                return { type: "num", value: parseFloat(number.replace(SEPARATORS.DEC, ".")) };
            }
        }

        function symbol(id, quote) {
            return {
                type  : "sym",
                value : id,
                upper : id.toUpperCase(),
                space : isWhitespace(input.peek()),
                quote : quote
            };
        }

        function getRC(a, b, c) {
            if (!a && !b && !c) {
                return null;
            }
            if ((!a && !c) || (a && c)) {
                let num = b ? parseInt(b, 10) : 0;
                return a ? num : num - 1;
            }
        }

        function readSymbol() {
            let m = input.lookingAt(/^R(\[)?(-?[0-9]+)?(\])?C(\[)?(-?[0-9]+)?(\])?/i);
            if (m) {
                let row = getRC(m[1], m[2], m[3]);
                let col = getRC(m[4], m[5], m[6]);
                if (row != null && col != null) {
                    input.skip(m);
                    return {
                        type: "rc",
                        row: row,
                        col: col,
                        rel: ((m[4] || !(m[4] || m[5] || m[6]) ? 1 : 0) // col
                              |
                              (m[1] || !(m[1] || m[2] || m[3]) ? 2 : 0) // row
                             )
                    };
                }
            }
            return symbol(readWhile(isId));
        }

        function readString() {
            input.next();
            return { type: "str", value: input.readEscaped('"') };
        }

        function readSheetName() {
            input.next();
            return symbol(input.readEscaped("'"), true);
        }

        function readOperator() {
            return {
                type  : "op",
                value : readWhile(function(ch, op){
                    return (op + ch) in OPERATORS;
                })
            };
        }

        function readPunc() {
            return {
                type  : "punc",
                value : input.next()
            };
        }

        function readNext() {
            if (input.eof()) {
                return null;
            }
            let ch = input.peek(), m;
            if (ch === '"') {
                return readString();
            }
            if (ch === "'") {
                return readSheetName();
            }
            if (isDigit(ch) || ch === SEPARATORS.DEC) {
                return readNumber();
            }
            if (isIdStart(ch)) {
                return readSymbol();
            }
            if (isOpChar(ch)) {
                return readOperator();
            }
            if (isPunc(ch)) {
                return readPunc();
            }
            if ((m = input.lookingAt(/^#([a-z\/]+)[?!]?/i))) {
                input.skip(m);
                return { type: "error", value: m[1] };
            }
            if (!options.forEditor) {
                input.croak("Can't handle character with code: " + ch.charCodeAt(0));
            }
            return { type: "error", value: input.next() };
        }

        function peek() {
            while (tokens.length <= index) {
                readWhile(isWhitespace);
                let begin = input.pos();
                let tok = readNext();
                if (options.forEditor && tok) {
                    tok.begin = begin;
                    tok.end = input.pos();
                }
                tokens.push(tok);
            }
            return tokens[index];
        }

        function next() {
            let tok = peek();
            if (tok) {
                index++;
            }
            return tok;
        }

        function ahead(n, f) {
            let pos = index, a = [];
            while (n-- > 0) {
                a.push(next() || EOF);
            }
            index = pos;
            return f.apply(a, a);
        }

        function skip(n) {
            index += n;
        }

        function eof() {
            return peek() == null;
        }
    }

    //// exports

    let FORMAT_PARSERS = [];

    let registerFormatParser = calc.registerFormatParser = function(p) {
        FORMAT_PARSERS.push(p);
    };

    calc.parse = function(sheet, row, col, input, format) {
        if (input instanceof Date) {
            return { type: "date", value: calc.runtime.dateToSerial(input) };
        }
        if (typeof input == "number") {
            return { type: "number", value: input };
        }
        if (typeof input == "boolean") {
            return { type: "boolean", value: input };
        }
        input += "";
        if (/^'/.test(input)) {
            return {
                type: "string",
                value: input.substr(1)
            };
        }
        // trivial (integer) percent values; more complex formats are handled below via
        // registerFormatParser; this case could be dropped completely.
        if (/^-?[0-9]+%$/.test(input)) {
            let str = input.substr(0, input.length - 1);
            let num = parseFloat(str);
            if (!isNaN(num) && num === str) {
                return {
                    type: "percent",
                    value: num / 100
                };
            }
        }
        if (/^=/.test(input)) {
            input = input.substr(1);
            if (/\S/.test(input)) {
                return parseFormula(sheet, row, col, input);
            } else {
                return {
                    type: "string",
                    value: "=" + input
                };
            }
        }
        for (let i = 0; i < FORMAT_PARSERS.length; ++i) {
            let result = FORMAT_PARSERS[i](input, format);
            if (result) {
                return result;
            }
        }
        if (input.toLowerCase() === "true") {
            return { type: "boolean", value: true };
        }
        if (input.toLowerCase() === "false") {
            return { type: "boolean", value: false };
        }
        let date = calc.runtime.parseDate(input, format);
        if (date) {
            return { type: "date", value: calc.runtime.dateToSerial(date) };
        }
        let num = parseFloat(input);
        if (!isNaN(num) && input.length > 0 && num === input) {
            format = null;
            if (num !== Math.floor(num)) {
                format = "0." + String(num).split(".")[1].replace(/\d/g, "0");
            }
            return {
                type: "number",
                value: num,
                format: format
            };
        }
        return {
            type: "string",
            value: input
        };
    };

    function tokenize(input, row, col) {
        let tokens = [];
        input = TokenStream(input, { forEditor: true, row: row, col: col });
        while (!input.eof()) {
            tokens.push(next());
        }
        let tok = tokens[0];
        if (tok.type === "op" && tok.value === "=") {
            tok.type = "startexp";
        }
        return tokens;

        function next() {
            let tok = input.next();
            if (tok.type === "sym") {
                if (tok.upper === "TRUE") {
                    tok.type = "bool";
                    tok.value = true;
                } else if (tok.upper === "FALSE") {
                    tok.type = "bool";
                    tok.value = false;
                }
            } else if (tok.type === "ref") {
                tok = {
                    type  : "ref",
                    ref   : (row != null && col != null ? tok.absolute(row, col) : tok),
                    begin : tok.begin,
                    end   : tok.end
                };
            }
            return tok;
        }
    }

    // The `sqref` attribute in dataValidation (XLSX) will contain a space-separated list of
    // references.  This helper is called from excel-reader.js to parse them.
    function parseSqref(input, row, col) {
        row = row || 0;
        col = col || 0;
        input = TokenStream(input, { row: row, col: col });
        let refs = [];
        while (!input.eof()) {
            let ref = input.next();
            if (ref.type !== "ref") {
                throw new calc.runtime.ParseError("Expecting a reference but got: " + JSON.stringify(ref));
            }
            refs.push(ref.absolute(row, col));
        }
        return refs;
    }

    calc.parseNameDefinition = parseNameDefinition;
    calc.parseFormula = parseFormula;
    calc.parseReference = parseReference;
    calc.compile = makeFormula;
    calc.parseSqref = parseSqref;

    calc.tokenize = tokenize;

    /* -----[ a few special formats ]----- */

    // various time formats
    registerFormatParser(function(input, existingFormat){
        let m, date = 0, format = "";
        // have date part?
        if (!existingFormat) {
            existingFormat = culture().calendar.patterns.d;
        }
        if ((m = /^(\d+)([-/.])(\d+)\2(\d{2}(?:\d{2})?)(\s*)/.exec(input))) {
            let mo = parseInt(m[1], 10);
            let sep = m[2];
            let da = parseInt(m[3], 10);
            let yr = parseInt(m[4], 10);
            if (yr < 30) {
                yr += 2000;
            } else if (yr < 100) {
                yr += 1900;
            }
            let monthFirst = existingFormat ? existingFormat.indexOf("M") < existingFormat.indexOf("d") : true;
            if (mo > 12 || !monthFirst) {
                let tmp = mo;
                mo = da;
                da = tmp;
                monthFirst = false;
            }
            if (!calc.runtime.validDate(yr, mo, da)) {
                return null;
            }
            date = calc.runtime.packDate(yr, mo - 1, da);
            if (date < 0) { date--; }
            if (monthFirst) {
                format = ["mm", "dd", "yyyy"].join(sep);
            } else {
                format = ["dd", "mm", "yyyy"].join(sep);
            }
            format += m[5];
            input = input.substr(m[0].length); // skip the date
        }
        // hh:mm
        if ((m = /^(\d+):(\d+)$/.exec(input))) {
            let hh = parseInt(m[1], 10);
            let mm = parseInt(m[2], 10);
            return {
                type   : "date",
                format : format + "hh:mm",
                value  : date + calc.runtime.packTime(hh, mm, 0, 0)
            };
        }
        // mm:ss.ms
        if ((m = /^(\d+):(\d+)(\.\d+)$/.exec(input))) {
            let mm = parseInt(m[1], 10);
            let ss = parseInt(m[2], 10);
            let ms = parseFloat(m[3]) * 1000;
            return {
                type   : "date",
                format : format + "mm:ss.00",
                value  : date + calc.runtime.packTime(0, mm, ss, ms)
            };
        }
        // hh:mm:ss
        if ((m = /^(\d+):(\d+):(\d+)$/.exec(input))) {
            let hh = parseInt(m[1], 10);
            let mm = parseInt(m[2], 10);
            let ss = parseInt(m[3], 10);
            return {
                type   : "date",
                format : format + "hh:mm:ss",
                value  : date + calc.runtime.packTime(hh, mm, ss, 0)
            };
        }
        // hh:mm:ss.ms
        if ((m = /^(\d+):(\d+):(\d+)(\.\d+)$/.exec(input))) {
            let hh = parseInt(m[1], 10);
            let mm = parseInt(m[2], 10);
            let ss = parseInt(m[3], 10);
            let ms = parseFloat(m[4]) * 1000;
            return {
                type   : "date",
                format : format + "hh:mm:ss.00",
                value  : date + calc.runtime.packTime(hh, mm, ss, ms)
            };
        }
    });

    // Support numeric formats with thousands separator and/or currency symbol, like `1,234,567.00`,
    // `$1234`, `123,456.78 $` etc.  I apologize for this code.
    registerFormatParser(function(input){
        let m, n;
        const intlService = intl();
        var numbers = intlService.localeInfo().numbers;
        let comma = numbers.symbols.group;
        let dot = numbers.symbols.decimal;
        let localeCurrency = numbers.localeCurrency;
        if (!localeCurrency && intlService.localeCurrency) {
            localeCurrency = intlService.localeCurrency();
        }
        let currency = numbers.currencies[localeCurrency].symbol;
        let rxnum = getNumberRegexp(comma, dot);
        let rxcur = new RegExp("^\\s*\\" + currency + "\\s*");
        let sign = 1;
        let format = "";
        let suffix = "";
        let has_currency = false;
        let has_percent = false;

        input = calc.runtime.InputStream(input.replace(/^\s+|\s+$/g, ""));

        // has minus before currency?
        if (input.skip(/^-\s*/)) {
            sign = -1;
        }

        // has currency before number?
        if ((m = input.skip(rxcur))) {
            has_currency = true;
            format += '"' + m[0] + '"';
        }

        // has minus after currency?
        if (input.skip(/^-\s*/)) {
            if (sign < 0) {
                return null;    // not a number
            }
            sign = -1;
        }

        // read the number itself
        if (!(n = input.skip(rxnum))) {
            return null;        // not a number
        }
        format += "0";

        // has currency after number?
        if ((m = input.skip(rxcur))) {
            if (has_currency) {
                return null;    // either before or after, not both.
            }
            has_currency = true;
            suffix = '"' + m[0] + '"';
        }

        // has percent after number?
        if (!has_currency && (m = input.skip(/^\s*%\s*/))) {
            has_percent = true;
            suffix = m[0];      // no quotes this time, % is special in format
        }

        if (!input.eof()) {
            return null;        // should anything else follow, not a number
        }

        if (n[2] || has_currency) {
            format = format.replace("0", "#");
            format += ",0";
        }
        if (n[3]) {
            format += "." + repeat("0", n[3].length - 1);
        }
        let value = n[0]
            .replace(new RegExp("\\" + comma, "g"), "")
            .replace(new RegExp("\\" + dot, "g"), ".");

        value = parseFloat(value);
        if (has_percent) {
            value /= 100;
        }

        format += suffix;
        if (has_currency) {
            format += ';-' + format;
        }

        return {
            type: "number",
            currency: has_currency,
            format: format,
            value: sign * value
        };
    });

    registerFormatParser(function(input){
        let m;
        if ((m = /^([0-9]*)\.([0-9]+)(\s*%)$/.exec(input))) {
            return {
                type: "number",
                value: parseFloat(input) / 100,
                format: "0." + repeat("0", m[2].length) + m[3]
            };
        }
    });

    let NUMBER_FORMAT_RX = {};
    function getNumberRegexp(comma, dot) {
        let id = comma + dot;
        let rx = NUMBER_FORMAT_RX[id];
        if (!rx) {
            rx = "^(\\d+(COM\\d{3})*(DOT\\d+)?)";
            rx = rx.replace(/DOT/g, "\\" + dot).replace(/COM/g, "\\" + comma);
            rx = new RegExp(rx);
            NUMBER_FORMAT_RX[id] = rx;
        }
        return rx;
    }

    function repeat(str, len) {
        let out = "";
        while (len-- > 0) {
            out += str;
        }
        return out;
    }

    /*************************************************************************************/

    class FormulaContext {
        constructor(workbook) {
            this.workbook = workbook;
        }

        getRefCells(ref, hiddenInfo, fsheet, frow, fcol, wantNulls) {
            let sheet, formula, value, i;
            if (ref instanceof CellRef) {
                sheet = this.workbook.sheetByName(ref.sheet);
                if (!sheet || !ref.valid()) {
                    return [{
                        value: new CalcError("REF")
                    }];
                }
                formula = sheet.formula(ref);
                value = sheet.range(ref.row, ref.col).value();

                if (wantNulls || formula != null || value != null) {
                    return [{
                        formula: formula,
                        value: value,
                        row: ref.row,
                        col: ref.col,
                        sheet: ref.sheet,
                        hidden: hiddenInfo ? (sheet.columnWidth(ref.col) === 0 || sheet.rowHeight(ref.row) === 0) : false
                    }];
                } else {
                    return [];
                }
            }
            if (ref instanceof RangeRef) {
                i = this.workbook.sheetIndex(ref.sheet);
                let states = [], n = i;
                if (ref.endSheet) {
                    // "3D" reference.
                    n = this.workbook.sheetIndex(ref.endSheet);
                    if (i > n) {
                        let tmp = i;
                        i = n;
                        n = tmp;
                    }
                }

                if (i < 0 || n < 0 || !ref.valid()) {
                    return [{
                        value: new CalcError("REF")
                    }];
                }

                // XXX: This is nicer, but significantly slower.
                // Should investigate why, or add some options to make
                // it faster (i.e. probably because it adds all cell
                // properties, while we only need value and formula).
                //
                //     let add = function(row, col, data){
                //         data.row = row;
                //         data.col = col;
                //         data.sheet = sheet.name();
                //         states.push(data);
                //     };
                //     while (i <= n) {
                //         sheet = this.workbook.sheetByIndex(i++);
                //         sheet.forEach(ref, add);
                //     }
                //
                // For now keep doing it "manually".

                while (i <= n) {
                    sheet = this.workbook.sheetByIndex(i++);
                    let tl = sheet._grid.normalize(ref.topLeft);
                    let br = sheet._grid.normalize(ref.bottomRight);

                    let startCellIndex = sheet._grid.cellRefIndex(tl);
                    let endCellIndex = sheet._grid.cellRefIndex(br);

                    let values = sheet._properties.iterator("value", startCellIndex, endCellIndex);

                    for (let col = tl.col; col <= br.col; ++col) {
                        for (let row = tl.row; row <= br.row; ++row) {
                            let index = sheet._grid.index(row, col);
                            formula = sheet._properties.get("formula", index);
                            value = values.at(index);
                            if (wantNulls || formula != null || value != null) {
                                states.push({
                                    formula : formula,
                                    value   : value,
                                    row     : row,
                                    col     : col,
                                    sheet   : sheet.name(),
                                    hidden  : hiddenInfo ? (sheet.columnWidth(col) === 0 || sheet.rowHeight(row) === 0) : false
                                });
                            }
                        }
                    }
                }

                return states;
            }
            if (ref instanceof UnionRef) {
                let a = [];
                for (i = 0; i < ref.refs.length; ++i) {
                    a = a.concat(this.getRefCells(ref.refs[i], hiddenInfo, fsheet, frow, fcol));
                }
                return a;
            }
            if (ref instanceof NameRef) {
                let val = this.nameValue(ref, fsheet, frow, fcol);
                // XXX: revise this
                if (val instanceof Ref) {
                    return this.getRefCells(val, hiddenInfo, fsheet, frow, fcol);
                }
                return [{
                    value: val == null ? new CalcError("NAME") : val
                }];
            }
            return [];
        }

        isMerged(ref) {
            let sheet = this.workbook.sheetByName(ref.sheet);
            return sheet.isMerged(ref);
        }

        nameValue(ref, fsheet, frow, fcol) {
            let val;
            if (ref.hasSheet()) {
                // qualified name
                val = this.workbook.nameValue(this._displayString(ref.print()));
            } else {
                // try local name
                ref = ref.clone().setSheet(fsheet, true);
                val = this.workbook.nameValue(this._displayString(ref.print()));
                if (val == null) {
                    // try global name
                    val = this.workbook.nameValue(this._displayString(ref.name));
                }
                if (val == null) {
                    // try without _displayString
                    val = this.workbook.nameValue(ref.print()) || this.workbook.nameValue(ref.name);
                }
            }
            if (val instanceof Ref) {
                val = val.absolute(frow, fcol);
            }
            return val;
        }

        getData(ref, fsheet, frow, fcol, wantNulls) {
            let single = ref instanceof CellRef;
            if (ref instanceof NameRef) {
                single = this.workbook.nameValue(ref.name) instanceof CellRef;
            }
            let data = this.getRefCells(ref, false, fsheet, frow, fcol, wantNulls).map(function(cell) {
                let val = cell.value;
                if (val instanceof calc.runtime.Formula) {
                    val = val.value;
                }
                return val;
            });
            return single ? data[0] : data;
        }

        onFormula(f) {
            let sheet = this.workbook.sheetByName(f.sheet);
            let row = f.row, col = f.col, value = f.value;
            let currentFormula = sheet.formula({ row: row, col: col });
            if (currentFormula !== f) {
                // could have been deleted or modified in the mean time,
                // if the formula was asynchronous.  ignore this result.
                return false;
            }

            let arrayRange = f.arrayFormulaRange;
            if (arrayRange) {
                // `value` will always be a Matrix in this case;
                // enforced in runtime.js (Context::_resolve).  We
                // must fill only cells in arrayRange.
                let tlRow, tlCol;
                let width = value.width;
                let height = value.height;
                sheet.forEach(arrayRange, function(row, col) {
                    if (tlRow === undefined) {
                        tlRow = row;
                        tlCol = col;
                    }
                    let vrow = row - tlRow;
                    let vcol = col - tlCol;
                    let val;
                    if (vrow < height && vcol < width) {
                        val = value.get(vrow, vcol);
                    } else {
                        val = new CalcError("N/A");
                    }
                    sheet._value(row, col, val);
                });
            }
            else {
                // formulas may return references.  if a range or union,
                // we'll just save the first cell.
                if (value instanceof Ref) {
                    value = this.getData(value, f.sheet, row, col);
                    if (Array.isArray(value)) {
                        value = value[0];
                    }
                    if (value === undefined) {
                        value = null; // clear contents
                    }
                }

                // when not saved as an array formula, a formula
                // returning a Matrix will just save the first value.
                if (value instanceof calc.runtime.Matrix) {
                    value = value.get(0, 0);
                }

                sheet._value(row, col, value);
            }

            clearTimeout(sheet._formulaContextRefresh);
            sheet._formulaContextRefresh = setTimeout(function() {
                sheet.batch(function() {}, { layout: true });
            }, 50);

            return true;
        }
        _displayString(val) {
            if (/^[a-z_][a-z0-9_]*$/i.test(val)) {
                return val;
            }
            return "'" + val.replace(/\x27/g, "\\'") + "'";
        }
    }

    class ValidationFormulaContext extends FormulaContext {
        onFormula() {
            return true;
        }
    }

    calc.ValidationFormulaContext = ValidationFormulaContext;

    /* eslint-disable no-param-reassign */

    let KEY_NAMES$1 = {
        8: 'backspace',
        9: 'tab',
        13: 'enter',
        27: 'esc',
        37: 'left',
        38: 'up',
        39: 'right',
        40: 'down',
        35: 'end',
        36: 'home',
        32: 'spacebar',
        33: 'pageup',
        34: 'pagedown',
        46: 'delete',
        113: ':edit'
    };

    const Mac = () => navigator.platform.toUpperCase().indexOf('MAC') >= 0;

    let isAlphaNum = function(keyCode) {
        if ((keyCode > 47 && keyCode < 58) || // number keys
            (keyCode > 64 && keyCode < 91) || // letter keys
            (keyCode > 95 && keyCode < 112) || // numpad keys
            (keyCode > 185 && keyCode < 193) || // ;=,-./` (in order)
            (keyCode > 218 && keyCode < 223) || // [\]' (in order)
            (keyCode === 229)                   // combined key event?
            ) {
            return true;
        }

        return false;
    };

    let keyName = function(event) {
        let keyCode = event.keyCode;
        let name = KEY_NAMES$1[keyCode];

        if (!name && isAlphaNum(keyCode)) {
            name = ":alphanum";
        }

        // https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key
        //
        // Fix for https://github.com/telerik/kendo-ui-core/issues/2284
        // (starting editor with `=` on Firefox)
        if (!name && event.key && event.key.length === 1) {
            name = ":alphanum";
        }

        return name;
    };

    class EventListener {
        constructor(target, observer, handlers) {
            this._handlers = {};
            this.target = target;
            this._observer = observer || window;

            this.keyDownProxy = this.keyDown.bind(this);
            this.mouseProxy = this.mouse.bind(this);
            this.touchProxy = this.touch.bind(this);
            this.threshold = 5;
            this._pressLocation = null;

            this._attachEvent(target, "keydown", this.keyDownProxy);
            this._attachEvent(target, "contextmenu mousedown cut copy paste scroll wheel click dblclick focus", this.mouseProxy);
            this._attachEvent(target, "touchmove touchend", this.touchProxy);

            this._attachEvent(document.documentElement, "mousemove mouseup", this.mouseProxy);
            this._attachEvent(document.documentElement, "touchmove touchend", this.touchProxy);

            if (handlers) {
                for (let key in handlers) {
                    this.on(key, handlers[key]);
                }
            }
        }

        _attachEvent(element, events, handler) {
            events.split(' ').forEach(eventType => { element.addEventListener(eventType, handler); });
        }

        _removeEvent(element, events, handler) {
            events.split(' ').forEach(eventType => { element.removeEventListener(eventType, handler); });
        }

        keyDown(e) {
            // Do not handle keys for Toolbar Tab switch shortcuts
            if (e.altKey && (e.key === "n" || e.key === "h" || e.key === "a")) {
                return;
            }

            this.handleEvent(e, keyName(e));
        }

        touch(e) {
            this.handleEvent(e, e.type);
        }

        mouse(e) {
            let rightClick;

            if (e.which) {
                rightClick = (e.which === 3);
            } else if (e.button) {
                rightClick = (e.button === 2);
            }

            let type = e.type;

            if (type === "mousedown") {
                if (rightClick) {
                    type = "rightmousedown";
                } else {
                    this._pressLocation = { x: e.pageX, y: e.pageY };
                }
            }

            if (type === "mouseup") {
                if (!rightClick) {
                    this._pressLocation = null;
                }
            }

            if (type === "mousemove" && this._pressLocation) {
                let dx = this._pressLocation.x - e.pageX;
                let dy = this._pressLocation.y - e.pageY;
                let distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > this.threshold) {
                    type = "mousedrag";
                }
            }

            this.handleEvent(e, type);
        }

        handleEvent(e, name) {
            let eventKey = "";

            e.mod = Mac() ? e.metaKey : (e.ctrlKey && !e.altKey);

            if (e.altKey) {
                eventKey += "alt+";
            }

            if (e.shiftKey) {
                eventKey += "shift+";
            }

            if (e.ctrlKey) {
                eventKey += "ctrl+";
            }

            eventKey += name;

            let catchAllHandler = this._handlers['*+' + name];

            if (catchAllHandler) {
                catchAllHandler.call(this._observer, e, eventKey);
            }

            let handler = this._handlers[eventKey];

            if (handler) {
                handler.call(this._observer, e, eventKey);
            }
        }

        on(event, callback) {
            let handlers = this._handlers;

            if (typeof callback === "string") {
                callback = this._observer[callback];
            }

            if (typeof event === "string") {
                event = event.split(",");
            }

            event.forEach(function(e) {
                handlers[e] = callback;
            });
        }

        destroy() {
            this._removeEvent(this.target, "keydown", this.keyDownProxy);
            this._removeEvent(this.target, "contextmenu mousedown cut copy paste scroll wheel click dblclick focus", this.mouseProxy);
            this._removeEvent(this.target, "touchmove touchend", this.touchProxy);

            this._removeEvent(document.documentElement, "mousemove mouseup", this.mouseProxy);
            this._removeEvent(document.documentElement, "touchmove touchend", this.touchProxy);
        }
    }

    /* eslint-disable default-case */
    /* eslint-disable no-else-return */
    /* eslint-disable key-spacing */
    /* eslint-disable eqeqeq */
    /* eslint-disable brace-style */
    /* eslint-disable consistent-return */


    let alphaNumRegExp = /:alphanum$/;

    let ACTIONS = {
        "up": "up",
        "down": "down",
        "left": "left",
        "right": "right",
        "home": "first-col",
        "end": "last-col",
        "ctrl+left": "word-left",
        "ctrl+right": "word-right",
        "ctrl+up": "word-up",
        "ctrl+down": "word-down",
        "ctrl+home": "first",
        "ctrl+end": "last",
        "pageup": "prev-page",
        "pagedown": "next-page"
    };

    let ENTRY_ACTIONS = {
        "tab": "next",
        "shift+tab": "previous",
        "enter": "lower",
        "shift+enter": "upper",
        "delete": "clearContents",
        "backspace": "clearContents",
        "shift+:alphanum": "edit",
        "alt+:alphanum": "edit",
        ":alphanum": "edit",
        "ctrl+:alphanum": "ctrl",
        "alt+ctrl+:alphanum": "edit",
        ":edit": "edit"
    };

    let CONTAINER_EVENTS = {
        "wheel": "onWheel",
        "*+mousedown": "onMouseDown",
        "contextmenu": "onContextMenu",
        "*+mousedrag": "onMouseDrag",
        "*+mouseup": "onMouseUp",
        "*+dblclick": "onDblClick",
        "mousemove": "onMouseMove"
    };

    let CLIPBOARD_EVENTS = {
        "pageup": "onPageUp",
        "pagedown": "onPageDown",
        "mouseup": "onMouseUp",
        "*+cut": "onCut",
        "*+paste": "onPaste",
        "*+copy": "onCopy"
    };

    let EDITOR_EVENTS = {
        "esc": "onEditorEsc",
        "enter": "onEditorBlur",
        "alt+enter": "insertNewline",
        "shift+enter": "onEditorBlur",
        "tab": "onEditorBlur",
        "shift+tab": "onEditorBlur",
        "shift+ctrl+enter": "onEditorArrayFormula"
    };

    let FORMULABAR_EVENTS = Object.assign({ focus: "onEditorBarFocus" }, EDITOR_EVENTS);
    let FORMULAINPUT_EVENTS = Object.assign({ focus: "onEditorCellFocus" }, EDITOR_EVENTS);

    let SELECTION_MODES = {
        cell: "range",
        rowheader: "row",
        columnheader: "column",
        topcorner: "sheet",
        autofill: "autofill"
    };

    // function toActionSelector(selectors) {
    //     return selectors.map(function(action) {
    //         return '[data-action="' + action + '"]';
    //     }).join(",");
    // }

    // let COMPOSITE_UNAVAILABLE_ACTION_SELECTORS = toActionSelector([ 'cut', 'copy', 'paste', 'insert-left', 'insert-right', 'insert-above', 'insert-below' ]);
    // let UNHIDE_ACTION_SELECTORS = toActionSelector([ 'unhide-row', 'unhide-column' ]);

    let ACTION_KEYS = [];
    let SHIFT_ACTION_KEYS = [];
    let ENTRY_ACTION_KEYS = [];

    for (let key in ACTIONS) {
        ACTION_KEYS.push(key);
        SHIFT_ACTION_KEYS.push("shift+" + key);
    }

    for (let key in ENTRY_ACTIONS) {
        ENTRY_ACTION_KEYS.push(key);
    }

    CLIPBOARD_EVENTS[ACTION_KEYS] = "onAction";
    CLIPBOARD_EVENTS[SHIFT_ACTION_KEYS] = "onShiftAction";
    CLIPBOARD_EVENTS[ENTRY_ACTION_KEYS] = "onEntryAction";

    FORMULAINPUT_EVENTS[ACTION_KEYS] = "onEditorAction";
    FORMULAINPUT_EVENTS[SHIFT_ACTION_KEYS] = "onEditorShiftAction";

    class Controller {
        constructor(view, workbook) {
            this.view = view;
            this.workbook(workbook);
            this.container = view.container;
            this.clipboardElement = view.clipboard;
            // this.cellContextMenu = view.cellContextMenu;
            // this.rowHeaderContextMenu = view.rowHeaderContextMenu;
            // this.colHeaderContextMenu = view.colHeaderContextMenu;
            // this.drawingContextMenu = view.drawingContextMenu;
            this.scroller = view.scroller;
            this.tabstrip = view.tabstrip;
            this.sheetsbar = view.sheetsbar;

            view.nameEditor.bind("enter", this.onNameEditorEnter.bind(this));
            view.nameEditor.bind("cancel", this.onNameEditorCancel.bind(this));
            view.nameEditor.bind("select", this.onNameEditorSelect.bind(this));
            view.nameEditor.bind("delete", this.onNameEditorDelete.bind(this));

            this.editor = view.editor;
            this.editor.bind("change", this.onEditorChange.bind(this));
            this.editor.bind("activate", this.onEditorActivate.bind(this));
            this.editor.bind("deactivate", this.onEditorDeactivate.bind(this));
            this.editor.bind("update", this.onEditorUpdate.bind(this));

            this.listener = new EventListener(this.container, this, CONTAINER_EVENTS);

            this.scrollHandler = this.onScroll.bind(this);
            this.mouseDownHandler = this.onMouseDown.bind(this);

            view.scroller.addEventListener("scroll", this.scrollHandler);
            view.scroller.addEventListener("mousedown", this.mouseDownHandler);

            this._enableEditorEvents();

            if (this.sheetsbar) {
                this.sheetsbar.bind("select", this.onSheetBarSelect.bind(this));
                this.sheetsbar.bind("reorder", this.onSheetBarReorder.bind(this));
                this.sheetsbar.bind("rename", this.onSheetBarRename.bind(this));
                this.sheetsbar.bind("remove", this.onSheetBarRemove.bind(this));
            }

            // this.cellContextMenu.bind("select", this.onContextMenuSelect.bind(this));
            // this.rowHeaderContextMenu.bind("select", this.onContextMenuSelect.bind(this));
            // this.colHeaderContextMenu.bind("select", this.onContextMenuSelect.bind(this));
            // this.drawingContextMenu.bind("select", this.onContextMenuSelect.bind(this));

            // this is necessary for Windows to catch prevent context menu correctly
            // this.cellContextMenu.element
            //     .add(this.rowHeaderContextMenu.element)
            //     .add(this.colHeaderContextMenu.element)
            //     .add(this.drawingContextMenu.element)
            //     .on("contextmenu", false);

            // if (this.tabstrip) {
            //     this.tabstrip.bind("action", this.onCommandRequest.bind(this));
            //     this.tabstrip.bind("dialog", this.onDialogRequest.bind(this));
            // }
        }

        executeCommand(options) {
            return this._execute(options);
        }

        _enableEditorEvents(enable) {
            if (enable === undefined || enable) {
                this.keyListener = new EventListener(this.clipboardElement, this, CLIPBOARD_EVENTS);
                this.barKeyListener = new EventListener(this.editor.barElement(), this, FORMULABAR_EVENTS);
                this.inputKeyListener = new EventListener(this.editor.cellElement(), this, FORMULAINPUT_EVENTS);
            } else {
                this.keyListener.destroy();
                this.barKeyListener.destroy();
                this.inputKeyListener.destroy();
            }
        }

        _execute(options) {
            let result = this._workbook.execute(options);

            if (options.command === "EditCommand" && !result) {
                this._workbook.trigger("change", { editorClose: true });
            }

            if (result) {
                this._preventNavigation = true;
                if (result.reason === "error") {
                    this.editor.deactivate(true); // make sure we don't call any change hooks
                    this.view.showError(result, function() {
                        // we only get here in case of a validation error when the user decided to retry.
                        // this.activateEditor(false);
                        // reset to last input from user
                        // this.editor.value(this._lastEditorValue);
                        // however, set _value manually such that it'll detect change properly.  ugly :-\
                        // this.editor._value = this._workbook._inputForRef(this._workbook.activeSheet()._viewActiveCell());
                        // seems like a nice UX to have the whole input selected
                        // this.editor.select();
                    }.bind(this));
                } else {
                    this.view.openDialog(result.reason);
                }
            }

            return result;
        }

        _activeTooltip() {
            return this._workbook.activeSheet().activeCell().simplify().toString();
        }

        onContextMenuSelect(e) {
            let action = e.item.getAttribute('data-action'); // $(e.item).data("action");
            let command;
            switch (action) {
            case "cut":
                command = { command: "ToolbarCutCommand", options: { workbook: this._workbook } };
                break;
            case "copy":
                command = { command: "ToolbarCopyCommand", options: { workbook: this._workbook } };
                break;
            case "paste":
                command = { command: "ToolbarPasteCommand", options: { workbook: this._workbook } };
                break;
            case "delete-drawing":
                command = { command: "DeleteDrawingCommand", options: { drawing: this.navigator._sheet._activeDrawing } };
                break;
            case "bring-to-front":
                command = { command: "BringToFrontCommand", options: { drawing: this.navigator._sheet._activeDrawing } };
                break;
            case "send-to-back":
                command = { command: "SendToBackCommand", options: { drawing: this.navigator._sheet._activeDrawing } };
                break;
            case "unmerge":
                command = { command: "MergeCellCommand", options: { value: "unmerge" } };
                break;
            case "merge":
                this.view.openDialog("merge");
                break;
            case "hide-row":
                command = { command: "HideLineCommand", options: { axis: "row" } };
                break;
            case "hide-column":
                command = { command: "HideLineCommand", options: { axis: "column" } };
                break;
            case "unhide-row":
                command = { command: "UnHideLineCommand", options: { axis: "row" } };
                break;
            case "unhide-column":
                command = { command: "UnHideLineCommand", options: { axis: "column" } };
                break;
            case "delete-row":
                command = { command: "DeleteRowCommand" };
                break;
            case "delete-column":
                command = { command: "DeleteColumnCommand" };
                break;
            }

            if (command) {
                this._execute(command);
            }
        }

        onSheetBarRemove(e) {
            let sheet = this._workbook.sheetByName(e.name);

            //TODO: move to model!
            if (!sheet) {
                return;
            }

            this._workbook.removeSheet(sheet);
        }

        destroy() {
            this.view.scroller.removeEventListener("scroll", this.scrollHandler);
            this.view.scroller.removeEventListener("mousedown", this.mouseDownHandler);

            this.listener.destroy();
            this._enableEditorEvents(false);
            this.keyListener.destroy();
            this.inputKeyListener.destroy();
        }

        onSheetBarSelect(e) {
            let sheet;
            let workbook = this._workbook;

            if (e.isAddButton) {
                if (this._workbook.trigger("insertSheet")) {
                    return;
                }

                sheet = workbook.insertSheet();
            } else {
                sheet = workbook.sheetByName(e.name);
            }

            //TODO: move to model
            if (workbook.activeSheet().name() !== sheet.name()) {
                if (this._workbook.trigger("selectSheet", { sheet: sheet })) {
                    return;
                }

                if (!this.editor.canInsertRef(false)) {
                    this.editor.deactivate();
                }

                workbook.activeSheet(sheet);
            }
        }

        onSheetBarReorder(e) {
            let workbook = this._workbook;
            let sheet = workbook.sheetByIndex(e.oldIndex);
            let activeSheet = workbook.activeSheet();
            let activeSheetName = activeSheet.name();

            workbook.moveSheetToIndex(sheet, e.newIndex);

            if (activeSheetName !== sheet.name()) {
                if (workbook.trigger("selectSheet", { sheet: sheet })) {
                    workbook.activeSheet(activeSheet);
                    return;
                }

                if (!this.editor.canInsertRef(false)) {
                    this.editor.deactivate();
                }

                workbook.activeSheet(sheet);
            }
        }

        onSheetBarRename(e) {
            let sheet = this._workbook.sheetByIndex(e.sheetIndex);

            if (this._workbook.sheetByName(e.name)) {
                this.view.showError({ reason: "error", type: "duplicateSheetName" });
                return;
            }

            this._workbook.renameSheet(sheet, e.name);

            this.clipboardElement.focus({ preventScroll: true });
        }

        sheet(sheet) {
            this.navigator = sheet.navigator();
            this.axisManager = sheet.axisManager();
        }

        workbook(workbook) {
            this._workbook = workbook;
            this.clipboard = workbook.clipboard();
            workbook.bind("commandRequest", this.onCommandRequest.bind(this));
        }

        refresh() {
            let editor = this.editor;
            let workbook = this._workbook;
            let sheet = workbook.activeSheet();

            this._viewPortHeight = this.view.scroller.clientHeight;
            this.navigator.height(this._viewPortHeight);

            if (!editor.isActive() && !this.isEditorDisabled) {
                editor.enable(sheet.selection().enable() !== false);
                this.resetEditorValue();
            }

            let ref = sheet.selection()._ref.simplify();
            let def = this._workbook.nameForRef(ref, sheet.name());
            this.view.nameEditor.value(def.name);
        }

        onScroll() {
            this.view.render({ scroll: true });
        }

        onWheel(event) {
            let deltaX = event.deltaX;
            let deltaY = event.deltaY;

            if (event.deltaMode === 1) {
                deltaX *= 10;
                deltaY *= 10;
            }

            this.scrollWith(deltaX, deltaY);

            event.preventDefault();
        }

        onAction(event, action) {
            let sheet = this._workbook.activeSheet();
            sheet._activeDrawing = null;
            this.navigator.moveActiveCell(ACTIONS[action]);
            event.preventDefault();
        }

        onPageUp() {
            this.scrollDown(-this._viewPortHeight);
        }

        onPageDown() {
            this.scrollDown(this._viewPortHeight);
        }

        onEntryAction(event, action) {
            let sheet = this._workbook.activeSheet();

            if (event.mod) {
                let key = String.fromCharCode(event.keyCode);
                let shouldPrevent = true;

                switch (key) {
                case "A":
                    sheet._activeDrawing = null;
                    this.navigator.selectAll();
                    break;
                case "Y":
                    this._workbook.undoRedoStack.redo();
                    break;
                case "Z":
                    this._workbook.undoRedoStack.undo();
                    break;
                default:
                    shouldPrevent = false;
                    break;
                }
                if (shouldPrevent) {
                    event.preventDefault();
                }
            } else {
                let disabled = sheet.selection().enable() === false;
                let casual = action !== ":edit";

                if (action == "delete" || action == "backspace") {
                    if (sheet._activeDrawing) {
                        this._execute({
                            command: "DeleteDrawingCommand",
                            options: { drawing: sheet._activeDrawing }
                        });
                    } else if (!disabled) {
                        this._execute({ command: "ClearContentCommand" });
                    }
                    event.preventDefault();
                } else if (alphaNumRegExp.test(action) || !casual) {
                    sheet._activeDrawing = null;
                    if (disabled) {
                        event.preventDefault();
                        return;
                    }
                    if (casual) {
                        this.editor.value("");
                    }
                    this.activateEditor(casual);
                } else {
                    this.navigator.navigateInSelection(ENTRY_ACTIONS[action]);
                    event.preventDefault();
                }
            }
        }

        onShiftAction(event, action) {
            this.navigator.modifySelection(ACTIONS[action.replace("shift+", "")], this.appendSelection);
            event.preventDefault();
        }

        onMouseMove(event) {
            let sheet = this._workbook.activeSheet();

            if (sheet.resizingInProgress() || sheet.selectionInProgress()) {
                return;
            }

            let object = this.objectAt(event);
            if (object.type === "columnresizehandle" || object.type === "rowresizehandle") {
                sheet.positionResizeHandle(object.ref);
            } else {
                sheet.removeResizeHandle();
            }

            sheet._renderComment(object.type == "cell" ? object.ref : null);
        }

        onMouseDown(event) {
            let object = this.objectAt(event);
            if (object.pane) {
                this.originFrame = object.pane;
            }

            if (this._startResizingDrawing(event, object)) {
                event.stopPropagation();
                return;
            }

            let sheet = this._workbook.activeSheet();
            // let win = this.container.closest('[' + kendo.attr("role") + '="window"]');
            // if (win.length) {
            //     win = kendo.widgetInstance(win);
            //     if (win && win.options.modal) {
            //         event.stopPropagation();
            //     }
            // }

            sheet._activeDrawing = null;
            if (object.type === "drawing") {
                sheet._activeDrawing = object.drawing;
                object.copy = object.drawing.clone();
                object.startBox = sheet.drawingBoundingBox(object.copy);
                sheet.startDragging(object);
                sheet.triggerChange({ dragging: true });
                event.preventDefault();
                return;
            }

            if (object.type === "outside") {
                event.preventDefault();
                event.stopPropagation();
                return;
            }

            if (object.type === "editor") {
                // XXX: canceling the edits, because they might not
                // validate.  Not sure it's the Right Thing.
                this.onEditorEsc();
                this.openCustomEditor();
                event.preventDefault();
                return;
            }

            if (this.editor.canInsertRef(false) && object.ref) {
                this._workbook.activeSheet()._setFormulaSelections(this.editor.highlightedRefs());
                this.navigator.startSelection(object.ref, this._selectionMode, this.appendSelection, event.shiftKey, this.view);
                event.preventDefault();
                return;
            } else {
                this._preventNavigation = false;
                this.editor.deactivate();
                if (this._preventNavigation) {
                    return;     // validation error
                }
            }

            if (object.type === "columnresizehandle" || object.type === "rowresizehandle") {
                sheet.startResizing({ x: object.x, y: object.y });
                event.preventDefault();
                return;
            }

            if (object.type === "filtericon") {
                this.openFilterMenu(event);
                event.preventDefault();
                return;
            }

            this._selectionMode = SELECTION_MODES[object.type];
            this.appendSelection = event.mod;
            this.navigator.startSelection(object.ref, this._selectionMode, this.appendSelection, event.shiftKey, this.view);
        }

        _startResizingDrawing(event) {
            let handle = event.target.closest(".k-spreadsheet-drawing-handle");
            if (handle) {
                let location = this.translateCoords(event);
                let direction = handle.getAttribute("data-direction");
                let sheet = this._workbook.activeSheet();
                let drawing = sheet._activeDrawing;
                sheet.startDragging({
                    pane     : this.originFrame,
                    drawing  : drawing,
                    copy     : drawing.clone(),
                    startBox : sheet.drawingBoundingBox(drawing),
                    resize   : direction,
                    //aspect   : drawing.width / drawing.height,
                    startX   : location.x,
                    startY   : location.y
                });
                return true;
            }
        }

        onContextMenu(event) {
            let sheet = this._workbook.activeSheet();

            event.preventDefault();

            if (sheet.resizingInProgress() || sheet.draggingInProgress()) {
                return;
            }

            // emit close here if necessary

            let object = this.objectAt(event);

            if (object.type === "columnresizehandle" || object.type === "rowresizehandle") {
                return;
            }

            if (object.ref) {
                this.navigator.selectForContextMenu(object.ref, SELECTION_MODES[object.type]);
            } else if (object.type == "drawing") {
                this.navigator.selectDrawingForContextMenu(object.drawing);
            }

            let isComposite = this.navigator._sheet.select() instanceof UnionRef;
            let showUnhide = false;
            let showUnmerge = false;

            if (object.type == "columnheader") {
                showUnhide = !isComposite && this.axisManager.selectionIncludesHiddenColumns();
            } else if (object.type == "rowheader") {
                showUnhide = !isComposite && this.axisManager.selectionIncludesHiddenRows();
            } else if (object.type == "drawing") ; else {
                showUnmerge = this.navigator.selectionIncludesMergedCells();
            }

            this._workbook.trigger("contextmenu", {
                objectRef: object.ref,
                targetType: object.type,
                isComposite,
                showUnhide,
                showUnmerge,
                originalEvent: event
            });
        }

        prevent(event) {
            event.preventDefault();
        }

        constrainResize(type, ref) {
            let sheet = this._workbook.activeSheet();
            let resizeHandle = sheet.resizeHandlePosition();

            return !resizeHandle || type === "outside" || type === "topcorner" || ref.col < resizeHandle.col || ref.row < resizeHandle.row;
        }

        _dragDrawing(event) {
            let sheet = this._workbook.activeSheet();
            let drag = sheet.draggingInProgress();
            if (!drag) {
                return false;
            }

            let location = this.translateCoords(event);
            let drawing = drag.drawing;
            let deltaX = location.x - drag.startX;
            let deltaY = location.y - drag.startY;

            if (drag.resize == "SE") {
                if (drag.aspect) {
                    if (Math.abs(deltaX) > Math.abs(deltaY)) {
                        drawing.width = Math.max(drag.copy.width + deltaX, 20);
                        drawing.height = drawing.width / drag.aspect;
                    } else {
                        drawing.height = Math.max(drag.copy.height + deltaY, 20);
                        drawing.width = drawing.height * drag.aspect;
                    }
                } else {
                    drawing.width = Math.max(drag.copy.width + deltaX, 20);
                    drawing.height = Math.max(drag.copy.height + deltaY, 20);
                }
            }
            else if (drag.resize == "E") {
                drawing.width = Math.max(drag.copy.width + deltaX, 20);
            }
            else if (drag.resize == "S") {
                drawing.height = Math.max(drag.copy.height + deltaY, 20);
            }
            else if (drag.resize == "N") {
                if (drag.copy.height - deltaY > 20) {
                    drawing.height = drag.copy.height - deltaY;
                    drawing.offsetY = drag.copy.offsetY + deltaY;
                }
            }
            else if (drag.resize == "W") {
                if (drag.copy.width - deltaX > 20) {
                    drawing.width = drag.copy.width - deltaX;
                    drawing.offsetX = drag.copy.offsetX + deltaX;
                }
            }
            else if (drag.resize == "NE") {
                drawing.width = Math.max(drag.copy.width + deltaX, 20);
                if (drag.copy.height - deltaY > 20) {
                    drawing.height = drag.copy.height - deltaY;
                    drawing.offsetY = drag.copy.offsetY + deltaY;
                }
            }
            else if (drag.resize == "SW") {
                drawing.height = Math.max(drag.copy.height + deltaY, 20);
                if (drag.copy.width - deltaX > 20) {
                    drawing.width = drag.copy.width - deltaX;
                    drawing.offsetX = drag.copy.offsetX + deltaX;
                }
            }
            else if (drag.resize == "NW") {
                if (drag.copy.height - deltaY > 20) {
                    drawing.height = drag.copy.height - deltaY;
                    drawing.offsetY = drag.copy.offsetY + deltaY;
                }
                if (drag.copy.width - deltaX > 20) {
                    drawing.width = drag.copy.width - deltaX;
                    drawing.offsetX = drag.copy.offsetX + deltaX;
                }
            }
            // just moving (no resize)
            else {
                drawing.offsetX = drag.copy.offsetX + deltaX;
                drawing.offsetY = drag.copy.offsetY + deltaY;
            }

            sheet.triggerChange({ dragging: true });

            return true;
        }

        onMouseDrag(event) {
            if (this._selectionMode === "sheet") {
                return;
            }

            let location = { clientX: event.clientX, clientY: event.clientY };
            let sheet = this._workbook.activeSheet();

            if (this._dragDrawing(event)) {
                return;
            }

            let object = this.objectAt(location);

            if (sheet.resizingInProgress()) {

                if (!this.constrainResize(object.type, object.ref)) {
                    sheet.resizeHintPosition({ x: object.x, y: object.y });
                }

                return;
            }

            if (object.type === "outside") {
                this.startAutoScroll(object);
                return;
            }

            if (this.originFrame === object.pane) {
                this.selectToLocation(location);
            } else { // cross frame selection
                let frame = this.originFrame._grid;

                if (object.x > frame.right) ;

                if (object.y > frame.bottom) {
                    this.scrollTop();
                }

                if (object.y < frame.top || object.x < frame.left) {
                    this.startAutoScroll(object, location);
                } else {
                    this.selectToLocation(location);
                }
            }

            event.preventDefault();
        }

        onMouseUp(event) {
            let sheet = this._workbook.activeSheet();
            sheet.completeResizing();
            sheet.completeDragging();

            this.navigator.completeSelection();
            this.stopAutoScroll();

            let editor = this.editor.activeEditor();
            if (!editor) {
                return;
            }
            let el = event.target;
            while (el) {
                if (el === editor.element) {
                    return;
                }
                el = el.parentNode;
            }

            let object = this.objectAt(event);
            if (object && object.ref && editor.canInsertRef(false)) {
                editor.refAtPoint(sheet);
                sheet._setFormulaSelections(editor.highlightedRefs());
            }
        }

        onDblClick(event) {
            let object = this.objectAt(event);
            let disabled = this._workbook.activeSheet().selection().enable() === false;

            if (object.type !== "cell" || disabled) {
                return;
            }

            let sel = this._workbook.activeSheet().selection();
            this.activateEditor(!sel.value() && !sel.formula());
            this.onEditorUpdate();
        }

        onCut(e) {
            let self = this;
            setTimeout(function() {
                self.clipboard.menuInvoked = (e === undefined);
                self._execute({
                    command: "CutCommand",
                    options: { workbook: self.view._workbook, event: e }
                });
            });
        }

        clipBoardValue() {
            return this.clipboardElement.html();
        }

        _pasteImage(blob) {
            let self = this;
            let img = new window.Image();
            img.src = window.URL.createObjectURL(blob);
            img.onload = function() {
                self._execute({
                    command: "InsertImageCommand",
                    options: {
                        blob: blob,
                        width: img.width,
                        height: img.height
                    }
                });
            };
            setTimeout(function() {
                window.URL.revokeObjectURL(img.src);
            }, 10);
        }

        onPaste(e) {
            let self = this;
            let html = "";
            let plain = "";
            self.clipboard.menuInvoked = (e === undefined);
            if (e) {
                let clipboardData = e.clipboardData;
                if (clipboardData && clipboardData.getData) {
                    e.preventDefault();
                    let hasHTML = false;
                    let hasPlainText = false;
                    // Firefox uses DOMStringList, needs special handling
                    if (window.DOMStringList && clipboardData.types instanceof window.DOMStringList) {
                        hasHTML = clipboardData.types.contains("text/html");
                        hasPlainText = clipboardData.types.contains("text/plain");
                    } else if (Array.isArray(clipboardData.types)) {
                        hasHTML = clipboardData.types.indexOf("text/html") >= 0;
                        hasPlainText = clipboardData.types.indexOf("text/plain") >= 0;
                    } else {
                        hasHTML = /text\/html/.test(clipboardData.types);
                        hasPlainText = /text\/plain/.test(clipboardData.types);
                    }
                    if (hasHTML) {
                        html = clipboardData.getData('text/html').trim();
                    }
                    if (hasPlainText) {
                        plain = clipboardData.getData('text/plain').trim();
                    }
                    if (!html && !plain && clipboardData.items && clipboardData.items.length) {
                        for (let i = 0; i < clipboardData.items.length; ++i) {
                            let item = clipboardData.items[i];
                            if (item.kind === "file" && /^image\/(?:png|jpe?g|gif)$/i.test(item.type)) {
                                return self._pasteImage(item.getAsFile());
                            }
                        }
                    }
                } else {
                    if (window.clipboardData.files && window.clipboardData.files.length) {
                        let file = window.clipboardData.files[0];
                        if (/^image\/(?:png|jpe?g|gif)$/i.test(file.type)) {
                            return self._pasteImage(file);
                        }
                    }

                    plain = window.clipboardData.getData("Text");
                    if (plain) {
                        plain = plain.trim();
                    }

                    // There's no way to get the HTML clipboard contents in IE other than letting
                    // the browser handle the event (it pastes into our clipboardElement), and then
                    // we can read the HTML from there.  Need to allow a small timeout for this.
                    self.clipboardElement.empty();
                    setTimeout(function() {
                        html = self.clipboardElement.html();
                        if (html || plain) {
                            self.clipboard.external({ html: html, plain: plain });
                            self._execute({
                                command: "PasteCommand",
                                options: { workbook: self.view._workbook, event: e }
                            });
                        }
                    });

                    return;
                }
            } else {
                self.clipboard.menuInvoked = true;
            }

            if (!html && !plain) {
                return;
            }
            self.clipboard.external({ html: html, plain: plain });
            self._execute({
                command: "PasteCommand",
                options: { workbook: self.view._workbook, event: e }
            });
        }

        onCopy(e) {
            this.clipboard.menuInvoked = (e === undefined);
            this._execute({
                command: "CopyCommand",
                options: { workbook: this.view._workbook, event: e }
            });
        }

    ////////////////////////////////////////////////////////////////////

        scrollTop() {
            this.scroller.scrollTop = 0;
        }

        scrollLeft() {
            this.scroller.scrollLeft = 0;
        }

        scrollDown(value) {
            this.scroller.scrollTop += value;
        }

        scrollRight(value) {
            this.scroller.scrollLeft += value;
        }

        scrollWith(right, down) {
            this.scroller.scrollTop += down;
            this.scroller.scrollLeft += right;
        }

        translateCoords(location) {
            let box = this.container.getBoundingClientRect();
            return {
                x: location.clientX - box.left,
                y: location.clientY - box.top
            };
        }

        objectAt(location, noDrawing) {
            if (!location) {
                return;
            }
            const loc = this.translateCoords(location);
            return this.view.objectAt(loc.x, loc.y, noDrawing);
        }

        selectToLocation(cellLocation) {
            let object = this.objectAt(cellLocation, true);

            if (object.pane && object.ref) { // cell, rowheader or columnheader
                this.extendSelection(object);
                this.lastKnownCellLocation = cellLocation;
                this.originFrame = object.pane;
            }

            this.stopAutoScroll();
        }

        extendSelection(object) {
            this.navigator.extendSelection(object.ref, this._selectionMode);
        }

        autoScroll() {
            let x = this._autoScrollTarget.x;
            let y = this._autoScrollTarget.y;
            let boundaries = this.originFrame._grid;
            let scroller = this.view.scroller;
            let scrollStep = 8;

            let scrollLeft = scroller.scrollLeft;
            let scrollTop = scroller.scrollTop;

            if (x < boundaries.left) {
                this.scrollRight(-scrollStep);
            }
            if (x > boundaries.right) {
                this.scrollRight(scrollStep);
            }
            if (y < boundaries.top) {
                this.scrollDown(-scrollStep);
            }
            if (y > boundaries.bottom) {
                this.scrollDown(scrollStep);
            }

            if (scrollTop === scroller.scrollTop && scrollLeft === scroller.scrollLeft) {
                this.selectToLocation(this.finalLocation);
            } else {
                this.extendSelection(this.objectAt(this.lastKnownCellLocation));
            }
        }

        startAutoScroll(viewObject, location) {
            if (!this._scrollInterval) {
                this._scrollInterval = setInterval(this.autoScroll.bind(this), 50);
            }

            this.finalLocation = location || this.lastKnownCellLocation;

            this._autoScrollTarget = viewObject;
        }

        stopAutoScroll() {
            clearInterval(this._scrollInterval);
            this._scrollInterval = null;
        }

        openCustomEditor() {
            this.view.openCustomEditor();
        }

        openFilterMenu(event) {
            let object = this.objectAt(event);
            let sheet = this._workbook.activeSheet();
            let column = sheet.filterColumn(object.ref);
            let filterMenu = this.view.createFilterMenu(column);

            filterMenu.bind("action", this.onCommandRequest.bind(this));
            filterMenu.bind("action", filterMenu.close.bind(filterMenu));

            filterMenu.openFor(event.target, event);
        }

    ////////////////////////////////////////////////////////////////////

        _saveEditorValue(arrayFormula) {
            let sheet = this.editor._range.sheet();
            let value = this.editor.value();
            if (this._workbook.activeSheet() !== sheet) {
                // remove highlighted refs (XXX: which are mostly wrong, BTW)
                this._workbook.activeSheet()._setFormulaSelections();
                // go back to the original sheet
                this._workbook.activeSheet(sheet);
            }
            sheet.isInEditMode(false);
            this._lastEditorValue = value;
            this._execute({
                command: "EditCommand",
                options: {
                    value: value,
                    arrayFormula: arrayFormula
                }
            });
        }

        onEditorChange() {
            this._saveEditorValue(false);
        }

        onEditorArrayFormula() {
            this._saveEditorValue(true);
            this.editor.deactivate(true);
        }

        onEditorActivate() {
            let workbook = this._workbook;
            let sheet = workbook.activeSheet();

            sheet._setFormulaSelections(this.editor.highlightedRefs());
            sheet.isInEditMode(true);
        }

        onEditorDeactivate() {
            let sheet = this._workbook.activeSheet();

            sheet.isInEditMode(false);
            sheet._setFormulaSelections([]);
        }

        onEditorUpdate() {
            this._workbook.activeSheet()._setFormulaSelections(this.editor.highlightedRefs());
        }

        onEditorBarFocus() {
            let disabled = this._workbook.activeSheet().selection().enable() === false;
            if (disabled) {
                return;
            }
            this.editor
                .activate({
                    range: this._workbook.activeSheet().selection(),
                    rect: this.view.activeCellRectangle(),
                    tooltip: this._activeTooltip()
                });
        }

        onEditorCellFocus() {
            this.editor.scale();
        }

        onEditorEsc() {
            this.resetEditorValue();
            this.editor.deactivate();

            this.clipboardElement.focus({ preventScroll: true });
        }

        insertNewline(e) {
            e.preventDefault();
            this.editor.insertNewline();
        }

        onEditorBlur(e, action) {
            if (e.defaultPrevented || this.editor.isFiltered()) {
                return;
            }
            e.preventDefault();
            this._preventNavigation = false;
            this.editor.deactivate();

            if (!this._preventNavigation) {
                this.clipboardElement.focus({ preventScroll: true });
                this.navigator.navigateInSelection(ENTRY_ACTIONS[action]);
            }

            if (action === 'tab') {
                e.preventDefault();
            }
        }

        onEditorAction(event, action) {
            if (event.defaultPrevented) {
                return;
            }

            let editor = this.editor;
            let sheet = this._workbook.activeSheet();

            if (this._casualEditing && /^(?:up|right|down|left)$/.test(action)) {
                this.deactivateEditor();
                this.navigator.moveActiveCell(ACTIONS[action]);
                event.preventDefault();
            } else if (editor.canInsertRef(true)) {
                this.navigator.moveActiveCell(ACTIONS[action]);
                editor.activeEditor().refAtPoint(sheet);
                sheet._setFormulaSelections(editor.highlightedRefs());
                event.preventDefault();
            }
        }

        onEditorShiftAction(event, action) {
            let editor = this.editor;
            let sheet = this._workbook.activeSheet();

            if (editor.canInsertRef(true)) {
                this.navigator.modifySelection(ACTIONS[action.replace("shift+", "")], this.appendSelection);

                editor.activeEditor().refAtPoint(sheet);
                sheet._setFormulaSelections(editor.highlightedRefs());

                event.preventDefault();
            }
        }

    ////////////////////////////////////////////////////////////////////
        resetEditorValue() {
            let sheet = this._workbook.activeSheet();
            let ref = sheet.activeCell();
            let input = this._workbook._inputForRef(ref);
            let x = sheet.range(ref).intersectingArrayFormula();
            if (x) {
                input = "=" + x.formula;
            }
            this.editor.value(input, Boolean(x));
        }

        activateEditor(casual) {
            // This flag will be false when F2 has been pressed, and
            // true when editing is "casual", i.e., user just started
            // typing.  In this case we want arrow keys to do cell
            // navigation rather than move the cursor.
            // https://github.com/telerik/kendo-ui-core/issues/3644
            this._casualEditing = casual;

            this.editor.activate({
                range: this._workbook.activeSheet().selection(),
                rect: this.view.activeCellRectangle(),
                tooltip: this._activeTooltip()
            }).focus();
        }

        deactivateEditor() {
            this.view.editor.deactivate();
        }

        onCommandRequest(e) {
            if (e.command) {
                this._execute(e);
            } else {
                this._workbook.undoRedoStack[e.action]();
            }
        }

        onDialogRequest(e) {
            let additionalOptions = {
                pdfExport: this._workbook.options.pdf,
                excelExport: this._workbook.options.excel
            };

            if (e.options) {
                deepExtend(e.options, additionalOptions);
            } else {
                e.options = additionalOptions;
            }

            this.view.openDialog(e.name, e.options);
        }

        onNameEditorEnter({ value }) {
            let ref;
            let workbook = this._workbook;
            let sheet = workbook.activeSheet();
            let name = value !== undefined ? value : this.view.nameEditor.value();

            // 1. does it look like a reference, or already defined
            // name?  If so, just select it (don't define/modify any
            // names)
            ref = calc.parseReference(name, true) || workbook.nameValue(name);
            if (ref instanceof Ref) {
                if (ref.sheet && ref.sheet.toLowerCase() !== sheet.name().toLowerCase()) {
                    // reference points to another sheet, select it if found
                    let tmp = workbook.sheetByName(ref.sheet);
                    if (tmp) {
                        workbook.activeSheet(tmp);
                        sheet = tmp;
                    }
                }
                sheet.range(ref).select();
                return;
            }

            ref = sheet.selection()._ref.clone().simplify().setSheet(sheet.name(), true);

            // XXX: should we check if a name is already defined for this range, and update it instead?
            // Excel just adds a new one, and provides a more complete Name Manager dialog.
            //let def = workbook.nameForRef(ref, sheet.name());

            // just define new name
            this._execute({
                command: "DefineNameCommand",
                options: { name: name, value: ref }
            });

            this.clipboardElement.focus({ preventScroll: true });
        }
        onNameEditorCancel() {
            this.clipboardElement.focus({ preventScroll: true });
        }
        onNameEditorSelect(ev) {
            let name = ev.name;
            let workbook = this._workbook;
            let sheet = workbook.activeSheet();
            let ref = workbook.nameValue(name);
            if (ref instanceof Ref) {
                if (ref.sheet && ref.sheet.toLowerCase() !== sheet.name().toLowerCase()) {
                    // reference points to another sheet, select it if found
                    let tmp = workbook.sheetByName(ref.sheet);
                    if (tmp) {
                        workbook.activeSheet(tmp);
                        sheet = tmp;
                    }
                }
                sheet.range(ref).select();
                return;
            }
            this.clipboardElement.focus({ preventScroll: true });
        }
        onNameEditorDelete(ev) {
            this._execute({
                command: "DeleteNameCommand",
                options: { name: ev.name }
            });
            this.clipboardElement.focus({ preventScroll: true });
        }
    }

    class RangeTreeNode {
        constructor(level, value, left, right) {
            this.level = level;
            this.value = value;
            this.left = left;
            this.right = right;
        }
    }

    const NilNode = {
        left: undefined,
        right: undefined,
        level: 0
    };
    NilNode.left = NilNode;
    NilNode.right = NilNode;

    function skew(n) {
        let node = n;
        if (node.left.level === node.level) {
            let temp = node;
            node = node.left;
            temp.left = node.right;
            node.right = temp;
        }

        return node;
    }

    function split(n) {
        let node = n;
        if (node.right.right.level === node.level) {
            let temp = node;
            node = node.right;
            temp.right = node.left;
            node.left = temp;
            node.level += 1;
        }

        return node;
    }

    function insert(node, value) {
        if (node === NilNode) {
            return new RangeTreeNode(1, value, NilNode, NilNode);
        } else if (node.value.start > value.start) {
            node.left = insert(node.left, value);
        } else {
            node.right = insert(node.right, value);
        }

        return split(skew(node));
    }

    function remove(n, value) {
        let node = n;
        if (node === NilNode) {
            return node;
        }

        let diff = node.value.start - value.start;
        if (diff === 0) {
            if (node.left !== NilNode && node.right !== NilNode) {
                let heir = node.left;

                while (heir.right !== NilNode) {
                    heir = heir.right;
                }

                node.value = heir.value;
                node.left = remove(node.left, node.value);
            } else if (node.left === NilNode) {
                node = node.right;
            } else {
                node = node.left;
            }
        } else if (diff > 0) {
            node.left = remove(node.left, value);
        } else {
            node.right = remove(node.right, value);
        }

        if (node.left.level < (node.level - 1) || node.right.level < (node.level - 1)) {
            node.level -= 1;
            if (node.right.level > node.level) {
                node.right.level = node.level;
            }

            node = skew(node);
            node.right = skew(node.right);
            node.right.right = skew(node.right.right);
            node = split(node);
            node.right = split(node.right);
        }

        return node;
    }

    class ValueRange {
        // start;
        // end;
        // value;

        constructor(start, end, value) {
            this.start = start;
            this.end = end;
            this.value = value;
        }

        intersects(range) {
            return range.start <= this.end && range.end >= this.start;
        }

        clone() {
            return new ValueRange(this.start, this.end, this.value);
        }
    }

    class RangeTree {
        // root;
        constructor() {
            this.root = NilNode;
        }

        insert(value) {
            this.root = insert(this.root, value);
        }

        remove(value) {
            this.root = remove(this.root, value);
        }

        findrange(value) {
            let node = this.root;

            while (node !== NilNode) {
                if (value < node.value.start) {
                    node = node.left;
                } else if (value > node.value.end) {
                    node = node.right;
                } else {
                    return node.value;
                }
            }

            return null;
        }

        values() {
            let result = [];
            values(this.root, result);
            return result;
        }

        intersecting(start, end) {
            let ranges = [];
            intersecting(this.root, new ValueRange(start, end), ranges);
            return ranges;
        }

        map(callback) {
            let tree = new RangeTree();
            map(tree, this.root, callback);
            return tree;
        }

        forEach(callback) {
            forEach(this.root, callback);
        }

        clone() {
            return this.map(function(value) {
                return value.clone();
            });
        }

        first() {
            let first = this.root;
            while (first.left !== NilNode) {
                first = first.left;
            }

            return first;
        }

        last() {
            let last = this.root;
            while (last.right !== NilNode) {
                last = last.right;
            }

            return last;
        }
    }

    function values(node, result) {
        if (node === NilNode) {
            return;
        }

        values(node.left, result);
        result.push(node.value);
        values(node.right, result);
    }

    function intersecting(node, range, ranges) {
        if (node === NilNode) {
            return;
        }

        let value = node.value;

        if (range.start < value.start) {
            intersecting(node.left, range, ranges);
        }

        if (value.intersects(range)) {
            ranges.push(value);
        }

        if (range.end > value.end) {
            intersecting(node.right, range, ranges);
        }
    }

    function map(tree, root, callback) {
        if (root === NilNode) {
            return;
        }
        map(tree, root.left, callback);
        tree.insert(callback(root.value));
        map(tree, root.right, callback);
    }

    function forEach(root, callback) {
        if (root === NilNode) {
            return;
        }
        forEach(root.left, callback);
        callback(root.value);
        forEach(root.right, callback);
    }

    class RangeList {
        // tree;
        constructor(start, end, value) {
            if (end === undefined) {
                this.tree = start;
            } else {
                this.tree = new RangeTree();
                this.tree.insert(new ValueRange(start, end, value));
            }
        }

        values() {
            return this.tree.values();
        }

        map(callback) {
            return new RangeList(this.tree.map(callback));
        }

        forEach(callback) {
            this.tree.forEach(callback);
        }

        intersecting(start, end) {
            return this.tree.intersecting(start, end);
        }

        first() {
            return this.tree.first().value;
        }

        last() {
            return this.tree.last().value;
        }

        insert(start, end, value) {
            return this.tree.insert(new ValueRange(start, end, value));
        }

        value(s, e, value) {
            let start = s, end = e;
            if (value === undefined) {
                if (end === undefined) {
                    end = start;
                }
                return this.intersecting(start, end)[0].value;
            }

            let ranges = this.tree.intersecting(start - 1, end + 1);

            if (ranges.length) {
                let firstRange = ranges[0], lastRange = ranges[ranges.length - 1];

                if (firstRange.end < start) {
                    if (firstRange.value === value) {
                        start = firstRange.start;
                    } else {
                        ranges.shift();
                    }
                }

                if (lastRange.start > end) {
                    if (lastRange.value === value) {
                        end = lastRange.end;
                    } else {
                        ranges.pop();
                    }
                }

                for (let i = 0, length = ranges.length; i < length; i++) {
                    let range = ranges[i];
                    let rangeValue = range.value;
                    let rangeStart = range.start;
                    let rangeEnd = range.end;

                    this.tree.remove(range);

                    if (rangeStart < start) {
                        if (rangeValue !== value) {
                            this.insert(rangeStart, start - 1, rangeValue);
                        } else {
                            start = rangeStart;
                        }
                    }

                    if (rangeEnd > end) {
                        if (rangeValue !== value) {
                            this.insert(end + 1, rangeEnd, rangeValue);
                        } else {
                            end = rangeEnd;
                        }
                    }
                }
            }

            this.insert(start, end, value);
        }

        expandedValues(start, end) {
            let ranges = this.intersecting(start, end);
            let result = [];

            let rangeIndex = 0;

            for (let i = start; i <= end; i++) {
                if (ranges[rangeIndex].end < i) {
                    rangeIndex ++;
                }

                result.push({ index: i - start, value: ranges[rangeIndex].value });
            }

            return result;
        }

        sortedIndices(start, end, valueComparer, indices) {
            let result = this.expandedValues(start, end);

            let comparer = function(a, b) {
                if (a.value === b.value) {
                    return a.index - b.index;
                }

                return valueComparer(a.value, b.value);
            };

            if (indices) {
                comparer = function(a, b) {
                    let x = indices[a.index];
                    let y = indices[b.index];

                    if (x.value === y.value) {
                        return valueComparer(a.value, b.value);
                    }

                    return a.index - b.index;
                };
            }

            result.sort(comparer);

            return result;
        }

        sort(start, end, indices) {
            if (this.intersecting(start, end).length === 1) {
                return;
            }

            let expValues = this.expandedValues(start, end);

            for (let i = 0, len = indices.length; i < len; i++) {
                this.value(i + start, i + start, expValues[indices[i].index].value);
            }
        }

        copy(sourceStart, sourceEnd, targetStart) {
            let intValues = this.intersecting(sourceStart, sourceEnd);

            let start = targetStart;
            let end;

            for (let i = 0, len = intValues.length; i < len; i++) {
                let rangeStart = intValues[i].start;

                if (rangeStart < sourceStart) {
                    rangeStart = sourceStart;
                }

                let rangeEnd = intValues[i].end;

                if (rangeEnd > sourceEnd) {
                    rangeEnd = sourceEnd;
                }

                end = start + (rangeEnd - rangeStart);

                this.value(start, end, intValues[i].value);

                start = ++end;
            }
        }

        iterator(start, end) {
            return new Iterator(start, end, this.intersecting(start, end));
        }

        getState() {
            return this.tree.clone();
        }

        setState(state) {
            this.tree = state.clone();
        }

        toJSON() {
            return this.values();
        }

        fromJSON(vals) {
            vals.forEach((v) => {
                this.value(v.start, v.end, v.value);
            });
        }
    }

    class Iterator {
        constructor(start, end, ranges) {
            this.start = start;
            this.end = end;
            this.index = 0;
            this.ranges = ranges;
        }

        unique() {
            return this.ranges.map(function(range) {
                return range.value;
            });
        }

        at(index) {
            while (this.ranges[this.index] && this.ranges[this.index].end < index) {
                this.index ++;
            }

            return this.ranges[this.index] && this.ranges[this.index].value;
        }

        forEach(callback) {
            for (let i = this.start; i <= this.end; i++) {
                callback(this.at(i), i);
            }

            this.index = 0;
        }
    }

    class SparseRangeList extends RangeList {
        constructor(start, end, value) {
            super(start, end, value);
            this._defaultValue = value;
            this.tree = new RangeTree();
            this.range = new ValueRange(start, end, value);
        }

        intersecting(s, end) {
            let start = s;
            let ranges = this.tree.intersecting(start, end);
            let result = [];
            let range;

            if (!ranges.length) {
                return [this.range];
            }

            for (let i = 0, len = ranges.length; i < len; i++) {
                range = ranges[i];
                if (range.start > start) {
                    result.push(new ValueRange(start, range.start - 1, this.range.value));
                }

                result.push(range);
                start = range.end + 1;
            }

            if (range.end < end) {
                result.push(new ValueRange(range.end + 1, end, this.range.value));
            }

            return result;
        }

        insert(start, end, v) {
            let value = v;
            if (value == null) {
                value = this._defaultValue;
            }
            if (value !== this.range.value) {
                this.tree.insert(new ValueRange(start, end, value));
            }
        }

        lastRangeStart() {
            let node = this.tree.root;

            if (node === NilNode) {
                return this.range.start;
            }

            while (node.right !== NilNode) {
                node = node.right;
            }

            return node.value.end + 1;
        }
    }

    /* eslint-disable default-case */
    /* eslint-disable camelcase */
    /* eslint-disable no-param-reassign */


    class Property {
        constructor(list) {
            this.list = list;
        }

        get(index) {
            return this.parse(this.list.value(index, index));
        }

        set(start, end, value) {
            if (value === undefined) {
                value = end;
                end = start;
            }

            this.list.value(start, end, value);
        }

        parse(value) {
            return value;
        }

        copy(start, end, dst) {
            this.list.copy(start, end, dst);
        }

        iterator(start, end) {
            return this.list.iterator(start, end);
        }
    }
    class JsonProperty extends Property {
        set(start, end, value) {
            this.list.value(start, end, JSON.stringify(value));
        }

        parse(value) {
            return JSON.parse(value);
        }
    }
    class ValueProperty extends Property {
        constructor(values, formats) {
            super(values);
            this.formats = formats;
        }

        set(start, end, value) {
            if (value instanceof Date) {
                value = calc.runtime.dateToSerial(value);
                if (!this.formats.value(start,end)) {
                    this.formats.value(start, end, toExcelFormat$1(culture().calendar.patterns.d));
                }
            } else if (typeof value == "number") {
                value = calc.runtime.limitPrecision(value);
            }

            this.list.value(start, end, value);
        }
    }
    function toExcelFormat$1(format) {
        return format.replace(/M/g, "m").replace(/'/g, '"').replace(/tt/, "am/pm");
    }

    const propertyBagSpec = [
        { property: Property, name: "format", value: null, sortable: true, serializable: true },
        { property: ValueProperty, name: "value", value: null, sortable: true, serializable: true, depends: "format" },
        { property: Property, name: "formula", value: null, sortable: true, serializable: true },
        { property: Property, name: "background", value: null, sortable: true, serializable: true },
        { property: JsonProperty, name: "vBorders", value: null, sortable: false, serializable: false },
        { property: JsonProperty, name: "hBorders", value: null, sortable: false, serializable: false },
        { property: JsonProperty, name: "dBorders", value: null, sortable: false, serializable: true },
        { property: Property, name: "color", value: null, sortable: true, serializable: true },
        { property: Property, name: "fontFamily", value: null, sortable: true, serializable: true },
        { property: Property, name: "underline", value: null, sortable: true, serializable: true },
        { property: Property, name: "fontSize", value: null, sortable: true, serializable: true },
        { property: Property, name: "italic", value: null, sortable: true, serializable: true },
        { property: Property, name: "bold", value: null, sortable: true, serializable: true },
        { property: Property, name: "textAlign", value: null, sortable: true, serializable: true },
        { property: Property, name: "indent", value: null, sortable: true, serializable: true },
        { property: Property, name: "verticalAlign", value: null, sortable: true, serializable: true },
        { property: Property, name: "wrap", value: null, sortable: true, serializable: true },
        { property: Property, name: "validation", value: null, sortable: false, serializable: true },
        { property: Property, name: "enable", value: null, sortable: false, serializable: true },
        { property: Property, name: "link", value: null, sortable: true, serializable: true },
        { property: Property, name: "editor", value: null, sortable: true, serializable: true },
        { property: Property, name: "comment", value: null, sortable: true, serializable: true },
        { property: Property, name: "html", value: null, sortable: true, serializable: true }
    ];

    class PropertyBag {
        constructor(rowCount, columnCount, defaultValues) {
            defaultValues = defaultValues || {};
            let cellCount = rowCount * columnCount - 1;

            this.specs = propertyBagSpec;
            this.rowCount = rowCount;
            this.columnCount = columnCount;
            this.cellCount = cellCount;
            this.properties = {};
            this.lists = {};

            this.specs.forEach(function(spec) {
                let name = spec.name;
                let value = defaultValues[name];
                if (value === undefined) {
                    value = spec.value;
                }
                this.lists[name] = new SparseRangeList(0, cellCount, value);
                let prop = this.properties[name] = new spec.property(this.lists[name], this.lists[spec.depends]);
                prop.spec = spec;
            }, this);

            // XXX: this is a hack but I have no better ideas at this
            // point.  The getState() method in a SparseRangeList
            // clones the tree (which just copies values over), but
            // formulas are objects maintaining complex state.
            // https://github.com/telerik/kendo-ui-core/issues/2816
            this.lists.formula.tree.clone = cloneFormulaTree;
            this.lists.validation.tree.clone = cloneFormulaTree;
        }

        _resize(new_rows, new_cols) {
            let self = this;
            let old_rows = self.rowCount;
            let cell_count = new_rows * new_cols - 1;
            function scaleIndex(index) {
                let col = index / old_rows | 0;
                let row = index % old_rows;
                return col * new_rows + row;
            }
            function scaleNode(node) {
                // node is a ValueRange from rangelist.js
                // start/end are rowCount * col + row
                node.start = scaleIndex(node.start);
                node.end = scaleIndex(node.end);
            }
            Object.keys(self.lists).forEach(function(name) {
                let list = self.lists[name];
                if (new_rows !== old_rows) {
                    list.forEach(scaleNode);
                }
                list.range.end = cell_count;
            });
            self.rowCount = new_rows;
            self.columnCount = new_cols;
            self.cellCount = cell_count;
        }

        getState() {
            let state = {};

            this.specs.forEach(function(spec) {
                state[spec.name] = this.lists[spec.name].getState();
            }, this);

            return state;
        }

        setState(state) {
            this.specs.forEach(function(spec) {
                this.lists[spec.name].setState(state[spec.name]);
            }, this);
        }

        get(name, index) {
            if (index === undefined) {
                return this.lists[name];
            }

            switch (name) {
            case "borderRight":
                index += this.rowCount;
                /* falls through */
            case "borderLeft":
                name = "vBorders";
                break;

            case "borderBottom":
                index++;
                /* falls through */
            case "borderTop":
                name = "hBorders";
                break;
            }
            return index > this.cellCount ? null : this.properties[name].get(index);
        }

        set(name, start, end, value) {
            switch (name) {
            case "borderRight":
                start += this.rowCount;
                end += this.rowCount;
                /* falls through */
            case "borderLeft":
                name = "vBorders";
                break;

            case "borderBottom":
                start++;
                end++;
                /* falls through */
            case "borderTop":
                name = "hBorders";
                break;
            }
            if (start <= end && end <= this.cellCount) {
                this.properties[name].set(start, end, value);
            }
        }

        fromJSON(index, value) {
            for (let si = 0; si < this.specs.length; si++) {
                let spec = this.specs[si];

                if (spec.serializable) {
                    if (value[spec.name] !== undefined) {
                        this.set(spec.name, index, index, value[spec.name], false);
                    }
                }
            }

            [ "borderLeft", "borderRight", "borderTop", "borderBottom" ].forEach(function(b) {
                if (value[b] !== undefined) {
                    this.set(b, index, index, value[b]);
                }
            }, this);
        }

        copy(sourceStart, sourceEnd, targetStart) {
            this.specs.forEach(function(spec) {
                this.properties[spec.name].copy(sourceStart, sourceEnd, targetStart);
            }, this);
        }

        iterator(name, start, end) {
            let prop = this.properties[name];
            let iter = prop.iterator(start, end), at = iter.at;
            let cellCount = this.cellCount;
            iter.at = function(index) {
                return index > cellCount ? null : prop.parse(at.call(iter, index));
            };
            iter.name = name;
            iter.value = prop.spec.value;
            return iter;
        }

        sortable() {
            return this.specs.filter(function(spec) { return spec.sortable; })
                .map(function(spec) {
                    return this.lists[spec.name];
                }, this);
        }

        iterators(start, end) {
            return this.specs.reduce(function(ret, spec) {
                if (spec.serializable) {
                    ret.push(this.iterator(spec.name, start, end));
                }
                return ret;
            }.bind(this), []);
        }

        forEach(start, end, callback) {
            let iterators = this.iterators(start, end);
            let hBorders = this.iterator("hBorders", start, end + 1);
            let leftBorders = this.iterator("vBorders", start, end);
            let rightBorders = this.iterator("vBorders", start + this.rowCount, end + this.rowCount);
            let values, index;

            function addBorder(name, iterator, index) {
                let val = iterator.at(index);
                if (val !== iterator.value) {
                    values[name] = val;
                }
            }

            for (index = start; index <= end; index++) {
                values = {};

                for (let i = 0; i < iterators.length; i++) {
                    let iterator = iterators[i];
                    let value = iterator.at(index);

                    if (value !== iterator.value) {
                        values[iterator.name] = value;
                    }
                }

                addBorder("borderLeft", leftBorders, index);
                addBorder("borderRight", rightBorders, index + this.rowCount);
                addBorder("borderTop", hBorders, index);
                if ((index + 1) % this.rowCount) {
                    addBorder("borderBottom", hBorders, index + 1);
                }

                callback(values);
            }
        }

        forEachProperty(callback) {
            for (let name in this.properties) {
                callback(this.properties[name]);
            }
        }
    }
    function cloneFormulaValue(x) {
        x = x.clone();
        x.value = x.value.deepClone(); // x.value is Formula or Validation
        return x;
    }
    function cloneFormulaTree() {
        let tree = this.map(cloneFormulaValue);
        tree.clone = cloneFormulaTree; // because it's a new RangeTree now
        return tree;
    }
    const ALL_PROPERTIES = propertyBagSpec.reduce(function(a, spec) {
        if (spec.serializable) {
            a.push(spec.name);
        }
        return a;
    }, [ "borderTop", "borderRight", "borderBottom", "borderLeft" ]);

    /* eslint-disable no-param-reassign */
    /* eslint-disable no-useless-call */
    /* eslint-disable camelcase */
    /* eslint-disable default-case */


    function compileValidation(sheet, row, col, validation) {
        let validationHandler;
        let comparer;
        let parsedFromDate;
        let parsedToDate;
        if (typeof validation === "string") {
            validation = JSON.parse(validation);
        }
        if (validation.from) {
            if (validation.dataType === "list" && !validation.fromIsListValue) {
                // We need to convert the {...} validation.from value to a string, so that it would work when exported to XLSX

                // XXX: this abomination should be removed, and code that converts Excel's
                // comma-separated list to a proper formula better be placed in excel-reader.js. Of
                // course, we'd need to do the reverse transformation too on serialization for OOXML
                // (see how _matrix(...) is unwrapped below in `toJSON`).
                if (validation.from.indexOf("{") > -1) {
                    validation.from = validation.from.replace(/\"/g,"").replace(/^\s*\{\s*/,"\"").replace(/\s*\}\s*$/, "\"");
                }
                validation.from = `_matrix(${validation.from})`;
                validation.fromIsListValue = true;
            }
            if (validation.dataType === "date") {
                parsedFromDate = calc.runtime.parseDate(validation.from);
                if (parsedFromDate) {
                    validation.from = `DATEVALUE("${validation.from}")`;
                    validation.fromIsDateValue = true;
                }
            }
            validation.from = calc.compile(calc.parseFormula(sheet, row, col, validation.from));
        }
        if (validation.to) {
            if (validation.dataType === "date") {
                parsedToDate = calc.runtime.parseDate(validation.to);
                if (parsedToDate) {
                    validation.to = `DATEVALUE("${validation.to}")`;
                    validation.toIsDateValue = true;
                }
            }
            validation.to = calc.compile(calc.parseFormula(sheet, row, col, validation.to));
        }
        if (validation.dataType === "custom") {
            comparer = validationExport.validationComparers.custom;
        } else if (validation.dataType === "list") {
            comparer = validationExport.validationComparers.list;
        } else {
            comparer = validationExport.validationComparers[validation.comparerType];
        }
        if (!comparer) {
            throw intl().format("'{0}' comparer is not implemented.", validation.comparerType);
        }
        validationHandler = function(valueToCompare) { //add 'valueFormat' arg when add isDate comparer
            let toValue = this.to && (this.to_value || this.to_value === 0) ? this.to_value : undefined;
            if (valueToCompare === null || valueToCompare === "") {
                if (this.allowNulls) {
                    this.value = true;
                } else {
                    this.value = false;
                }
            } else if (this.dataType === "custom") {
                this.value = comparer(valueToCompare, this.from_value, toValue);
            } else if (this.dataType === "list") {
                let data = this._getListData();
                this.value = comparer(valueToCompare, data, toValue);
            } else {
                //TODO: TYPE CHECK IS REQUIRED ONLY FOR DATE TYPE WHEN SPECIAL COMPARER (ISDATE) IS USED
                this.value = comparer(valueToCompare, this.from_value, toValue);
            }
            return this.value;
        };
        const resultOptions = Object.assign({}, validation);
        resultOptions.handler = validationHandler;
        resultOptions.sheet = sheet;
        resultOptions.row = row;
        resultOptions.col = col;
        return new Validation(resultOptions);
    }
    class Validation {
        constructor(options) {
            this.handler = options.handler;
            this.from = options.from;
            this.to = options.to;
            this.dataType = options.dataType; //date, time etc
            this.comparerType = options.comparerType; //greaterThan, EqaulTo etc
            this.type = options.type ? options.type : "warning"; //info, warning, reject
            this.allowNulls = options.allowNulls ? true : false;
            this.fromIsDateValue = options.fromIsDateValue ? true : false;
            this.toIsDateValue = options.toIsDateValue ? true : false;
            this.showButton = options.showButton;
            this.fromIsListValue = options.fromIsListValue ? true : false;
            //TODO: address to be range / cell ref, and adjust it based on it
            this.sheet = options.sheet;
            this.row = options.row;
            this.col = options.col;
            if (options.tooltipMessageTemplate) {
                this.tooltipMessageTemplate = options.tooltipMessageTemplate;
            }
            if (options.tooltipTitleTemplate) {
                this.tooltipTitleTemplate = options.tooltipTitleTemplate;
            }
            if (options.messageTemplate) {
                this.messageTemplate = options.messageTemplate;
            }
            if (options.titleTemplate) {
                this.titleTemplate = options.titleTemplate;
            }
        }
        _formatMessages(format) {
            let from = this.from ? this.from_value : "";
            let to = this.to ? this.to_value : "";
            let fromFormula = this.from ? this.from.toString() : "";
            let toFormula = this.to ? this.to.toString() : "";
            let dataType = this.dataType;
            let type = this.type;
            let comparerType = this.comparerType;
            return intl().format(format, from, to, fromFormula, toFormula, dataType, type, comparerType);
        }
        _setMessages() {
            this.title = "";
            this.message = "";
            if (this.tooltipTitleTemplate) {
                this.tooltipTitle = this._formatMessages(this.tooltipTitleTemplate);
            }
            if (this.tooltipMessageTemplate) {
                this.tooltipMessage = this._formatMessages(this.tooltipMessageTemplate);
            }
            if (this.titleTemplate) {
                this.title = this._formatMessages(this.titleTemplate);
            }
            if (this.messageTemplate) {
                this.message = this._formatMessages(this.messageTemplate);
            }
        }
        _getListData() {
            if (!this.from_value || !this.from_value.data) {
                return [];
            }
            let cube = this.from_value.data;
            let i;
            let y;
            let data = [];
            for (i = 0; i < cube.length; i++ ) {
                let array = cube[i];
                if (array) {
                    for (y = 0; y < array.length; y++ ) {
                        data.push(array[y]);
                    }
                }
            }
            return data;
        }
        clone(sheet, row, col) {
            let options = this._getOptions();
            if (options.from) {
                options.from = options.from.clone(sheet, row, col);
            }
            if (options.to) {
                options.to = options.to.clone(sheet, row, col);
            }
            const optionsResult = Object.assign({}, options);
            optionsResult.handler = this.handler;
            optionsResult.sheet = sheet;
            optionsResult.row = row;
            optionsResult.col = col;
            return new Validation(optionsResult);
        }
        deepClone() {
            let v = new Validation(this);
            v.from = v.from.deepClone();
            if (v.to) {
                v.to = v.to.deepClone();
            }
            return v;
        }
        exec(ss, compareValue, compareFormat, callback) {
            let self = this;
            function getValue(val) {
                if (val instanceof Ref) {
                    val = ss.getData(val);
                    if (Array.isArray(val)) {
                        val = val[0];
                    }
                }
                return val;
            }
            let calculateFromCallBack = function(val) {
                self.from_value = getValue(val);
                self.value = self.handler.call(self, compareValue, compareFormat);
                self._setMessages();
                if (callback) {
                    callback(self.value);
                }
            };
            if (self.to) {
                self.to.exec(ss, function(val) {
                    self.to_value = getValue(val);
                    self.from.exec(ss, calculateFromCallBack);
                });
            } else {
                self.from.exec(ss, calculateFromCallBack);
            }
        }
        reset() {
            if (this.from) {
                this.from.reset();
            }
            if (this.to) {
                this.to.reset();
            }
            delete this.value;
        }
        adjust(affectedSheet, operation, start, delta) {
            let prevFrom, prevTo, modified;
            let formulaRow = this.row;
            let formulaCol = this.col;
            if (this.from) {
                prevFrom = this.from.adjust(affectedSheet, operation, start, delta);
            }
            if (this.to) {
                prevTo = this.to.adjust(affectedSheet, operation, start, delta);
            }
            if (this.sheet.toLowerCase() === affectedSheet.toLowerCase()) {
                switch (operation) {
                case "row":
                    if (formulaRow >= start) {
                        modified = true;
                        this.row += delta;
                    }
                    break;
                case "col":
                    if (formulaCol >= start) {
                        modified = true;
                        this.col += delta;
                    }
                    break;
                }
            }
            if (modified || prevFrom || prevTo) {
                let v = new Validation(this);
                v.from = prevFrom;
                v.to = prevTo;
                v.row = formulaRow;
                v.col = formulaCol;
                return v;
            }
        }
        toJSON() {
            let options = this._getOptions();
            if (options.from) {
                options.from = options.from.toString();
                if (options.dataType === "list") {
                    options.from = options.from.replace(/^_matrix\((.*)\)$/i, "$1");
                    delete options.fromIsListValue;
                }
                if (options.dataType === "date") {
                    if (this.fromIsDateValue) {
                        options.from = options.from.replace(/^DATEVALUE\("(.*)"\)$/i, "$1");
                        delete options.fromIsDateValue;
                    }
                }
            }
            if (options.to) {
                options.to = options.to.toString();
                if (options.dataType === "date") {
                    if (this.toIsDateValue) {
                        options.to = options.to.replace(/^DATEVALUE\("(.*)"\)$/i, "$1");
                        delete options.toIsDateValue;
                    }
                }
            }
            return options;
        }
        _getOptions() {
            return {
                from: this.from,
                to: this.to,
                dataType: this.dataType,
                type: this.type,
                comparerType: this.comparerType,
                row: this.row,
                col: this.col,
                sheet: this.sheet,
                allowNulls: this.allowNulls,
                fromIsListValue: this.fromIsListValue,
                fromIsDateValue: this.fromIsDateValue,
                toIsDateValue: this.toIsDateValue,
                tooltipMessageTemplate: this.tooltipMessageTemplate,
                tooltipTitleTemplate: this.tooltipTitleTemplate,
                //TODO: export generated messages instead?
                messageTemplate: this.messageTemplate,
                titleTemplate: this.titleTemplate,
                showButton: this.showButton
            };
        }
    }
    const validationExport = {};
    validationExport.compile = compileValidation;
    validationExport.validationComparers = {
        greaterThan: function(valueToCompare, from) {
            return valueToCompare > from;
        },
        lessThan: function(valueToCompare, from) {
            return valueToCompare < from;
        },
        between: function(valueToCompare, from, to) {
            return valueToCompare >= from && valueToCompare <= to;
        },
        equalTo: function(valueToCompare, from) {
            return valueToCompare === from;
        },
        notEqualTo: function(valueToCompare, from) {
            return valueToCompare !== from;
        },
        greaterThanOrEqualTo: function(valueToCompare, from) {
            return valueToCompare >= from;
        },
        lessThanOrEqualTo: function(valueToCompare, from) {
            return valueToCompare <= from;
        },
        notBetween: function(valueToCompare, from, to) {
            return valueToCompare < from || valueToCompare > to;
        },
        custom: function(valueToCompare, from) {
            return from;
        },
        list: function(valueToCompare, data) {
            return data.indexOf(valueToCompare) > -1;
        }
    };
    validationExport.Validation = Validation;

    /* eslint-disable no-nested-ternary */
    /* eslint-disable curly */
    /* eslint-disable space-infix-ops */
    /* eslint-disable indent */
    /* eslint-disable no-empty */
    /* eslint-disable no-loop-func */
    /* eslint-disable consistent-return */
    /* eslint-disable block-scoped-var */
    /* eslint-disable no-redeclare */
    /* eslint-disable no-var */
    /* eslint-disable eqeqeq */
    /* eslint-disable complexity */
    /* eslint-disable max-params */
    /* eslint-disable no-implicit-coercion */
    /* eslint-disable key-spacing */
    /* eslint-disable default-case */
    /* eslint-disable camelcase */
    /* eslint-disable brace-style */
    /* eslint-disable no-else-return */
    /* eslint-disable no-constant-condition */
    /* eslint-disable no-param-reassign */
    /* eslint-disable space-before-blocks */

    const { measureText } = kendoDrawing.drawing.util;

    let PROPERTIES = [
        "color", "fontFamily", "underline",
        "italic", "bold", "textAlign", "indent",
        "verticalAlign", "background", "format", "link", "editor",
        "borderTop", "borderRight", "borderBottom", "borderLeft",
        "comment", "html"
    ];
    let Range$1 = class Range {
        constructor(ref, sheet) {
            this._sheet = sheet;
            this._ref = ref;
        }

        clone() {
            return new Range(this._ref.clone(), this._sheet);
        }

        skipHiddenCells() {
            let refs = [];
            let self = this, sheet = self._sheet;
            let skipHiddenRows = sheet.isHiddenRow.bind(sheet);
            let skipHiddenCols = sheet.isHiddenColumn.bind(sheet);
            self._ref.forEach(function(ref) {
                ref = self._normalize(ref.toRangeRef());
                let tl = ref.topLeft, br = ref.bottomRight;
                let rows = partition(tl.row, br.row, skipHiddenRows);
                let cols = partition(tl.col, br.col, skipHiddenCols);
                for (let i = 0; i < rows.length; ++i) {
                    for (let j = 0; j < cols.length; ++j) {
                        refs.push(new RangeRef(
                            new CellRef(rows[i].begin, cols[j].begin),
                            new CellRef(rows[i].end, cols[j].end)
                        ));
                    }
                }
            });
            return sheet.range(refs.length > 1 ? new UnionRef(refs) : refs[0]);
        }

        _normalize(ref) {
            return this._sheet._grid.normalize(ref);
        }

        _set(name, value, noTrigger) {
            let self = this;
            let sheet = self._sheet;
            self._ref.forEach(function(ref) {
                let result = ref;
                let valueProp = name === "value" || name === "formula" || name === "link";

                // Set values/formulas/links only to the topLeft cell when merged
                if (valueProp && ref.topLeft) {
                    let topLeftRef = new CellRef(ref.topLeft.row, ref.topLeft.col);

                    sheet.forEachMergedCell(function(f) {
                        if (f.intersects(topLeftRef)) {
                            result = topLeftRef;
                        }
                    });
                }

                sheet._set(result.toRangeRef(), name, value);
            });
            if (!noTrigger) {
                sheet.triggerChange({
                    recalc  : name === "formula" || name === "value" || name === "validation",
                    value   : value,
                    range   : self,
                    ref     : self._ref,
                    isValue : name === "value"
                });
            }
            return self;
        }

        _get(name) {
            return this._sheet._get(this._ref.toRangeRef(), name);
        }

        _property(name, value) {
            if (value === undefined) {
                return this._get(name);
            } else {
                return this._set(name, value);
            }
        }

        value(value) {
            if (value !== undefined) {
                // When value is set through the public API we must clear the
                // formula.  Don't trigger change (third parameter), it'll be
                // done when setting the value below
                this._set("formula", null, true);
            }
            return this._property("value", value);
        }

        html(value) {
            return this._property("html", value);
        }

        resize(direction) {
            let ref = this._resizedRef(direction);
            return new Range(ref, this._sheet);
        }

        _resizedRef(direction) {
            return this._ref.map(function(ref) {
                return ref.toRangeRef().resize(direction);
            });
        }

        input(value, options) {
            options = Object.assign({ arrayFormula: false }, options);
            let existingFormat = this._get("format"), x;
            if (value !== undefined) {
                let tl = this._ref.toRangeRef().topLeft;
                x = calc.parse(this._sheet.name(), tl.row, tl.col, value, existingFormat);
                this._sheet.batch(function() {
                    let formula = null;
                    if (x.type === "exp") {
                        formula = calc.compile(x);
                    } else if (existingFormat !== "@") {
                        let existingFormatType = existingFormat &&
                            formatting.type(x.value, existingFormat);
                        if (x.type === "date" && existingFormatType !== "date") {
                            this.format(x.format || toExcelFormat(culture().calendar.patterns.d));
                        } else if (x.type === "percent" && existingFormatType !== "percent") {
                            this.format(x.value * 100 === (x.value * 100 | 0) ? "0%" : "0.00%");
                        } else if (x.format) {
                            if (!existingFormat || x.currency ||
                                (existingFormatType === "number" && x.type === "number" &&
                                    x.format.length > existingFormat.length)) {
                                this.format(x.format);
                            }
                        }
                    } else if (x.type !== "string") {
                        x.value = value;
                    }
                    this.formula(formula, options.arrayFormula);
                    if (!formula) {
                        // value() will clear the formula.  Lucky for us,
                        // x.value is undefined so it actually won't, but let's
                        // be explicit and only set value if formula is not
                        // present.
                        this.value(x.value);
                    }
                }.bind(this), {
                    recalc       : true,
                    value        : value,
                    ref          : this._ref,
                    editorChange : this._sheet.isInEditMode(),
                    isValue      : true
                });

                return this;
            } else {
                value = this._get("value");
                let formula = this._get("formula");
                let type = existingFormat && !formula && formatting.type(value, existingFormat);

                if (formula) {
                    // it's a Formula object which stringifies to the
                    // formula as text (without the starting `=`).
                    value = "=" + formula;
                } else OUT: {
                    if (existingFormat && type === "date") {
                        // check if we could parse back the displayed value.
                        // https://github.com/telerik/kendo/issues/5335
                        let t1 = formatting.text(value, existingFormat);
                        x = calc.parse(null, null, null, t1, existingFormat); // it's not a formula so we don't need sheet/row/col
                        let t2 = formatting.text(x.value, existingFormat);
                        if (t1 === t2) {
                            value = t1;
                            break OUT;
                        }
                    }
                    if (type === "date") {
                        const intlVal = intl();
                        value = intlVal.toString(calc.runtime.serialToDate(value), culture().calendar.patterns.d, intlVal.locale);
                    } else if (type === "percent") {
                        value = calc.runtime.limitPrecision(value * 100) + "%";
                    } else if (typeof value == "string" &&
                                (/^[=']/.test(value) ||
                                (/^(?:true|false)$/i).test(value) ||
                                looksLikeANumber(value))) {
                        value = "'" + value;
                    } else if (this._sheet._useCultureDecimals() &&
                                typeof value == "number" &&
                                value !== Math.floor(value)) {
                        value = String(value).replace(".", culture().numbers.symbols.decimal);
                    }
                }

                return value;
            }
        }

        enable(value) {
            if (value === undefined) {
                return !withExit(function(exit) {
                    this._sheet.forEach(this._ref, function(_, __, data) {
                        if (data.enable === false) {
                            exit(true);
                        }
                    });
                }, this);
            }

            return this._property("enable", value);
        }

        formula(value, arrayFormula) {
            let self = this;
            if (value === undefined) {
                let f = self._get("formula");
                return f ? "" + f : null; // stringify if present
            }
            if (arrayFormula) {
                // when setting an array formula, we want to set it on
                // the first cell only, as it will fill the whole
                // range.
                let ref = this._ref.toRangeRef();
                value = self._sheet.range(ref.topLeft)
                    ._set("formula", value)
                    ._get("formula"); // make sure we get the compiled Formula, not a string

                if (value) {    // could be null.
                    // this will be used in FormulaContext -- it's the
                    // range that the formula must populate.
                    value.setArrayFormulaRange(ref);
                }
            } else {
                self._set("formula", value);
            }
            return self;
        }

        intersectingArrayFormula() {
            let ref = this._ref.clone().simplify().setSheet(this._sheet.name());
            return withExit(function(exit) {
                this._sheet._forFormulas(function(f) {
                    let r = f.arrayFormulaRange;
                    if (r && (r = ref.intersect(r)) !== NULLREF) {
                        exit({ formula: f, intersection: r });
                    }
                });
            }, this);
        }

        canEditArrayFormula() {
            let x = this.intersectingArrayFormula();
            if (x) {
                // we want to allow editing only when the new range is
                // at least as big as the original range (i.e. no
                // cells removed)
                return x.formula.arrayFormulaRange.eq(x.intersection);
            }
            return true;
        }

        validation(value) {
            //TODO: Accept objects only?

            if (value === undefined) {
                let f = this._get("validation");

                return f ? f.toJSON() : null; // stringify if present
            }
            return this._property("validation", value);
        }

        _getValidationState() {
            let ref = this._ref.toRangeRef();
            let topLeftRow = ref.topLeft.row;
            let topLeftCol = ref.topLeft.col;
            let bottomRightRow = ref.bottomRight.row;
            let bottomRightCol = ref.bottomRight.col;
            let ci, ri;

            for (ci = topLeftCol; ci <= bottomRightCol; ci ++) {
                for (ri = topLeftRow; ri <= bottomRightRow; ri ++) {
                    let validation = this._sheet._validation(ri, ci);

                    if (validation && validation.type === "reject" && validation.value === false) {
                        return validation;
                    }
                }
            }

            return false;
        }

        merge() {
            this._ref = this._sheet._merge(this._ref);
            return this;
        }

        unmerge() {
            let mergedCells = this._sheet._mergedCells;

            this._ref.forEach(function(ref) {
                ref.toRangeRef().intersecting(mergedCells).forEach(function(mergedRef) {
                    mergedCells.splice(mergedCells.indexOf(mergedRef), 1);
                });
            });

            this._sheet.triggerChange({});

            return this;
        }

        select() {
            this._sheet.select(this._ref);

            return this;
        }

        values(values) {
            if (this._ref instanceof UnionRef) {
                throw new Error("Unsupported for multiple ranges.");
            }

            if (this._ref === NULLREF) {
                if (values !== undefined) {
                    throw new Error("Unsupported for NULLREF.");
                } else {
                    return [];
                }
            }

            let ref = this._ref.toRangeRef();
            let topLeftRow = ref.topLeft.row;
            let topLeftCol = ref.topLeft.col;
            let bottomRightRow = ref.bottomRight.row;
            let bottomRightCol = ref.bottomRight.col;
            let ci, ri;

            if (values === undefined) {
                values = new Array(ref.height());

                for (let vi = 0; vi < values.length; vi++) {
                    values[vi] = new Array(ref.width());
                }

                for (ci = topLeftCol; ci <= bottomRightCol; ci ++) {
                    for (ri = topLeftRow; ri <= bottomRightRow; ri ++) {
                        values[ri - topLeftRow][ci - topLeftCol] = this._sheet._value(ri, ci);
                    }
                }

                return values;
            } else {
                this._sheet._set(ref, "formula", null);

                for (ci = topLeftCol; ci <= bottomRightCol; ci ++) {
                    for (ri = topLeftRow; ri <= bottomRightRow; ri ++) {
                        let row = values[ri - topLeftRow];

                        if (row) {
                            let value = row[ci - topLeftCol];

                            if (value !== undefined) {
                                this._sheet._value(ri, ci, value);
                            }
                        }
                    }
                }

                this._sheet.triggerChange({ recalc: true, ref: ref });

                return this;
            }
        }

        _properties(props, isAutofill) {
            if (this._ref instanceof UnionRef) {
                throw new Error("Unsupported for multiple ranges.");
            }

            if (this._ref === NULLREF) {
                if (props !== undefined) {
                    throw new Error("Unsupported for NULLREF.");
                } else {
                    return [];
                }
            }

            let ref = this._ref.toRangeRef();
            let topLeftRow = ref.topLeft.row;
            let topLeftCol = ref.topLeft.col;
            let bottomRightRow = ref.bottomRight.row;
            let bottomRightCol = ref.bottomRight.col;
            let ci, ri;
            let sheet = this._sheet;

            if (props === undefined) {
                props = new Array(ref.height());
                sheet.forEach(ref, function(row, col, data) {
                    row -= topLeftRow;
                    col -= topLeftCol;
                    let line = props[row] || (props[row] = []);
                    line[col] = data;
                });
                return props;
            } else {
                let data;
                ref = ref.clone();
                let setProp = function(propName) {
                    let propValue = data[propName];
                    ref.topLeft.row = ref.bottomRight.row = ri;
                    ref.topLeft.col = ref.bottomRight.col = ci;

                    if (propName === "value") {
                        sheet._set(ref, "formula", null);
                    }

                    sheet._set(ref, propName, propValue);
                };

                let isValue = false;
                for (ci = topLeftCol; ci <= bottomRightCol; ci ++) {
                    if (!isAutofill && sheet.isHiddenColumn(ci)) {
                        continue;
                    }
                    for (ri = topLeftRow; ri <= bottomRightRow; ri ++) {
                        if (!isAutofill && sheet.isHiddenRow(ri)) {
                            continue;
                        }
                        if (isAutofill && sheet.isFilteredRow(ri)) {
                            continue;
                        }
                        let row = props[ri - topLeftRow];
                        if (row) {
                            data = row[ci - topLeftCol];
                            if (data) {
                                const keys = Object.keys(data);
                                keys.forEach(setProp);
                                isValue = isValue || keys.includes("value");
                            }
                        }
                    }
                }
                sheet.triggerChange({ recalc: true, ref: this._ref, isValue: isValue });
                return this;
            }
        }

        clear(options) {
            options = options || {};
            let clearAll = options.clearAll || !Object.keys(options).length;

            let sheet = this._sheet;

            let reason = {
                recalc: clearAll || options.contentsOnly,
                ref: this._ref,
                isValue: true
            };

            sheet.batch(function() {

                if (reason.recalc) {
                    this.formula(null);
                }

                if (clearAll) {
                    this.validation(null);
                }

                if (clearAll || options.formatOnly) {
                    PROPERTIES.forEach(function(x) {
                        if (!(options.keepBorders && /^border/i.test(x))) {
                            this[x](null);
                        }
                    }.bind(this));
                    this.fontSize(null);
                    this.wrap(null);
                    this.unmerge();
                }

            }.bind(this), reason);

            return this;
        }

        clearContent() {
            return this.clear({ contentsOnly: true });
        }

        clearFormat() {
            return this.clear({ formatOnly: true });
        }

        isSortable() {
            return !this.cantSort();
        }

        cantSort() {
            if (this._ref instanceof UnionRef) {
                return { code: "cantSortMultipleSelection",
                            message: "Unsupported for multiple ranges." };
            }
            if (this._ref === NULLREF) {
                return { code: "cantSortNullRef",
                            message: "Unsupported for NULLREF." };
            }
            let mc = this._sheet._getMergedCells(this._ref.toRangeRef());
            let primary = mc.primary;
            let secondary = mc.secondary;
            let width = null, height = null;
            let cant = {};
            try {
                this._sheet.forEach(this, function(row, col) {
                    let id = new CellRef(row, col).print();
                    let merged = primary[id];
                    if (merged) {
                        if (width === null) {
                            width = merged.width();
                            height = merged.height();
                        } else if (!(width === merged.width() && height === merged.height())) {
                            throw cant;
                        }
                    } else if (!secondary[id] && mc.hasMerged) {
                        throw cant;
                    }
                });
            } catch (ex) {
                if (ex !== cant) {
                    throw ex;
                }
                return {
                    code: "cantSortMixedCells",
                    message: "Unsupported for range containing cells of different shapes."
                };
            }
            return false;
        }

        sort(spec) {
            let reason = this.cantSort();
            if (reason) {
                throw new Error(reason.message);
            }

            if (spec === undefined) {
                spec = { column: 0 };
            }

            spec = spec instanceof Array ? spec : [spec];

            this._sheet._sortBy(this._ref.toRangeRef(), spec.map(function(spec, index) {
                if (typeof spec === "number") {
                    spec = { column: spec };
                }

                return {
                    index: spec.column === undefined ? index : spec.column,
                    ascending: spec.ascending === undefined ? true : spec.ascending
                };
            }));

            return this;
        }

        isFilterable() {
            return !(this._ref instanceof UnionRef);
        }

        filter(spec) {
            if (this._ref instanceof UnionRef) {
                throw new Error("Unsupported for multiple ranges.");
            }

            if (spec === false) {
                this.clearFilters();
            } else {
                spec = spec === true ? [] : spec instanceof Array ? spec : [spec];

                this._sheet._filterBy(this._ref.toRangeRef(), spec.map(function(spec, index) {
                    return {
                        index: spec.column === undefined ? spec.index === undefined ? index : spec.index : spec.column,
                        filter: spec.filter
                    };
                }));
            }

            return this;
        }

        clearFilter(spec) {
            this._sheet.clearFilter(spec);
        }

        clearFilters() {
            let filter = this._sheet.filter();
            let spec = [];

            if (filter) {
                for (let i = 0; i < filter.columns.length; i++) {
                    spec.push(filter.columns[i].index);
                }

                this._sheet.batch(function() {
                    this.clearFilter(spec);
                    this._filter = null;
                }, { layout: true, filter: true });
            }
        }

        hasFilter() {
            let filter = this._sheet.filter();
            return Boolean(filter);
        }

        leftColumn() {
            return new Range(this._ref.leftColumn(), this._sheet);
        }

        rightColumn() {
            return new Range(this._ref.rightColumn(), this._sheet);
        }

        topRow() {
            return new Range(this._ref.topRow(), this._sheet);
        }

        bottomRow() {
            return new Range(this._ref.bottomRow(), this._sheet);
        }

        column(column) {
            return new Range(this._ref.toColumn(column), this._sheet);
        }

        row(row) {
            return new Range(this._ref.toRow(row), this._sheet);
        }

        forEachRow(callback) {
            this._ref.forEachRow(function(ref) {
                callback(new Range(ref, this._sheet));
            }.bind(this));
        }

        forEachColumn(callback) {
            this._ref.forEachColumn(function(ref) {
                callback(new Range(ref, this._sheet));
            }.bind(this));
        }

        sheet() {
            return this._sheet;
        }

        topLeft() {
            return this._ref.toRangeRef().topLeft;
        }

        intersectingMerged() {
            let sheet = this._sheet;
            let mergedCells = [];

            sheet._mergedCells.forEach(function(ref) {
                if (ref.intersects(this._ref)) {
                    mergedCells.push(ref.toString());
                }
            }.bind(this));

            return mergedCells;
        }

        getState(propertyName) {
            let topLeft = this._ref.first();
            let state = {
                ref     : topLeft,
                data    : [],
                origRef : this._ref,

                // save row heights
                rows    : this._sheet._rows.getState()
            };
            let properties;
            if (!propertyName) {
                properties = ALL_PROPERTIES;
                state.mergedCells = this.intersectingMerged();
            } else if (propertyName === "input") {
                properties = ["value", "formula"];
            } else if (propertyName === "border") {
                properties = ["borderLeft", "borderTop", "borderRight", "borderBottom"];
            } else {
                properties = [propertyName];
            }

            let data = state.data;
            this.forEachCell(function(row, col, cell) {
                let cellState = {};
                let dr = row - topLeft.row;
                let dc = col - topLeft.col;
                if (!data[dr]) {
                    data[dr] = [];
                }
                data[dr][dc] = cellState;

                properties.forEach(function(property) {
                    let value = typeof cell[property] == "undefined" ? null : cell[property];
                    if (value instanceof calc.runtime.Formula ||
                        value instanceof validationExport.Validation) {
                        value = value.deepClone();
                    }
                    cellState[property] = value;
                });
            });

            return state;
        }

        setState(state, clipboard) {
            let sheet = this._sheet;
            let origin = this._ref.first();
            let rowDelta = state.ref.row - origin.row;
            let colDelta = state.ref.col - origin.col;
            let internalClipboard = clipboard && !clipboard.isExternal();
            let externalClipboard = clipboard && !internalClipboard;

            sheet.batch(function() {
                if (state.mergedCells) {
                    this.unmerge();
                }

                if (!clipboard) {
                    // restore row heights.  they won't be available
                    // when this function is called from the clipboard
                    // code.
                    this._sheet._rows.setState(state.rows);
                }

                let row = origin.row;
                let hasFilter = this.hasFilter();
                state.data.forEach(function(data, dr) {
                    if (hasFilter && internalClipboard && sheet.isHiddenRow(state.ref.row + dr)) {
                        return;
                    }
                    let col = origin.col;
                    data.forEach(function(cellState, dc) {
                        if (hasFilter && internalClipboard && sheet.isHiddenColumn(state.ref.col + dc)) {
                            return;
                        }
                        let range = clipboard ? sheet.range(row, col)
                            : sheet.range(origin.row + dr, origin.col + dc);
                        if (range.enable()) {
                            for (let property in cellState) {
                                if (property !== "value") {
                                    // make sure value comes last (after the loop),
                                    // because if we set value here and get get to
                                    // formula later and cellState.formula is null,
                                    // it'll clear the value.

                                    // when pasting, do not copy "disabled" state
                                    if (!(clipboard && property === "enable")) {
                                        range._set(property, cellState[property]);
                                    }
                                }
                            }
                            if (!cellState.formula) {
                                // only need to set the value if we don't have a
                                // formula.  Go through the lower level setter rather
                                // than range.value(...), because range.value will clear
                                // the formula!  chicken and egg issues.
                                if (externalClipboard) {
                                    // https://github.com/telerik/kendo-ui-core/issues/1688
                                    // if we have a paste from external source, we should parse the
                                    // value as if it were inputted.  This allows to treat numbers
                                    // as numbers, or `=sum(a1:b2)` as formula (Google Sheets does
                                    // the same).  A difference though is that we can't store an
                                    // invalid Formula and display #ERROR, like G.S. does, so in
                                    // case of a parse error we'll just set the value as string.
                                    try {
                                        if (cellState.value == null) {
                                            range._set("value", null);
                                        } else {
                                            range.input(cellState.value);
                                        }
                                    } catch (ex) {
                                        range._set("value", cellState.value);
                                    }
                                } else {
                                    range._set("value", cellState.value);
                                }
                            }
                        }
                        col++;
                    });
                    row++;
                });

                if (state.mergedCells) {
                    state.mergedCells.forEach(function(merged) {
                        merged = sheet._ref(merged).relative(rowDelta, colDelta, 3);
                        sheet.range(merged).merge();
                    }, this);
                }
            }.bind(this), { recalc: true, ref: this._ref });
        }

        _adjustRowHeight() {
            let that = this;
            let sheet = that._sheet;
            let mc = sheet._getMergedCells(that._ref.toRangeRef());
            let primary = mc.primary;
            let secondary = mc.secondary;

            sheet.batch(function() {
                that.forEachRow(function(rowRange) {
                    let row = rowRange._ref.topLeft.row;
                    let height = sheet.rowHeight(row);
                    if (!height) {
                        // do not adjust if hidden.
                        // https://github.com/telerik/kendo-ui-core/issues/6272
                        // (case 2)
                        return;
                    }
                    rowRange.forEachCell(function(row, col, cell) {
                        let id = new CellRef(row, col).print();
                        if (secondary[id]) {
                            return;
                        }
                        let merged = primary[id];
                        let width;
                        if (merged) {
                            width = sheet._columns.sum(merged.topLeft.col,
                                                        merged.bottomRight.col);
                        } else {
                            width = sheet.columnWidth(col);
                        }
                        let data = cell.value;
                        if (cell.format && data != null) {
                            data = formatting.format(data, cell.format);
                        }
                        let textHeight = getTextHeight(
                            data, width, cell.fontFamily, cell.fontSize, cell.wrap);
                        height = Math.max(height, textHeight);
                    });
                    sheet.rowHeight(row, height);
                });
            }, { layout: true });
        }

        forEachCell(callback) {
            this._ref.forEach(function(ref) {
                this._sheet.forEach(ref.toRangeRef(), callback.bind(this));
            }.bind(this));
        }

        hasValue() {
            let defStyle = this._sheet._defaultCellStyle;
            return withExit(function(exit) {
                this.forEachCell(function(row, col, cell) {
                    // we must not consider cells that only have same values
                    // as defaultCellStyle, or otherwise we will forbid
                    // inserting rows/cols in an empty sheet.
                    for (let key in cell) {
                        let val = cell[key];
                        if (val !== undefined && val !== null && val !== defStyle[key]) {
                            exit(true);
                        }
                    }
                });
            }, this);
        }

        wrap(flag) {
            if (flag === undefined) {
                return Boolean(this._property("wrap"));
            }
            this._property("wrap", flag);
            if (flag !== null) {
                this._adjustRowHeight();
            }
            return this;
        }

        fontSize(size) {
            if (size === undefined) {
                return this._property("fontSize");
            }
            this._property("fontSize", size);
            if (size !== null) {
                this._adjustRowHeight();
            }
            return this;
        }

        draw(options, callback) {
            this._sheet.draw(this, options, callback);
        }

        insideBorders(value) {
            return this.insideVerticalBorders(value).insideHorizontalBorders(value);
        }

        insideVerticalBorders(value) {
            this._ref.forEach(function(ref) {
                if (ref instanceof RangeRef && ref.width() > 1) {
                    ref = ref.clone();
                    ref.topLeft.col++;
                    this._sheet.range(ref)._set("vBorders", value);
                }
            }, this);
            return this;
        }

        insideHorizontalBorders(value) {
            this._ref.forEach(function(ref) {
                if (ref instanceof RangeRef && ref.height() > 1) {
                    ref = ref.clone();
                    ref.topLeft.row++;
                    this._sheet.range(ref)._set("hBorders", value);
                }
            }, this);
            return this;
        }
    };
    function partition(begin, end, predicate) {
        while (begin <= end && predicate(begin)) {
            begin++;
        }
        if (begin > end) {
            return [];
        }
        for (let i = begin + 1; i <= end; ++i) {
            if (predicate(i)) {
                return [
                        { begin: begin, end: i - 1 }
                ].concat(partition(i + 1, end, predicate));
            }
        }
        return [{ begin: begin, end: end }];
    }
    PROPERTIES.forEach(function(property) {
        Range$1.prototype[property] = function(value) {
            return this._property(property, value);
        };
    });
    function toExcelFormat(format) {
        return format.replace(/M/g, "m").replace(/'/g, '"').replace(/tt/, "am/pm");
    }
    function looksLikeANumber(str) {
        // XXX: could do with just a regexp instead of calling parse.
        return !(/^=/.test(str)) && (/number|percent/).test(calc.parse(null, 0, 0, str).type);
    }

    function getTextHeight(text, width, fontFamily, fontSize, wrap) {
        const measureBox = document.createElement("div");

        measureBox.style.setProperty('position', 'absolute', 'important');
        measureBox.style.setProperty('top', '-4000px', 'important');
        measureBox.style.setProperty('height', 'auto', 'important');
        measureBox.style.setProperty('padding', '1px 3px', 'important');
        measureBox.style.setProperty('box-sizing', 'border-box', 'important');
        measureBox.style.setProperty('margin', '0', 'important');
        measureBox.style.setProperty('border', '1px solid black', 'important');
        measureBox.style.setProperty('line-height', 'normal', 'important');
        measureBox.style.setProperty('visibility', 'hidden', 'important');
        measureBox.style.setProperty('white-space', 'pre-wrap');

        let styles = {
            "baselineMarkerSize" : 0,
            "width" : (wrap === true) ? width + "px" : "auto",
            "font-size" : (fontSize || 12) + "px",
            "font-family" : fontFamily || "Arial",
            "white-space" : (wrap === true) ? "pre-wrap" : "pre",
            "overflow-wrap" : (wrap === true) ? "break-word" : "normal",
            "word-wrap" : (wrap === true) ? "break-word" : "normal"
        };

        return measureText(text, styles, { box: measureBox, normalizeText: false }).height;
    }

    // --------------------------------------------------------------- autofill.js

    var runtime = calc.runtime;
    var Formula = runtime.Formula;

    var ERR_INCOMPATIBLE = "incompatibleRanges";
    var ERR_NO_DIRECTION = "noFillDirection";

    var FillError = Range$1.FillError = function(msg) {
        this.code = msg;
    };

    // `srcRange`: the range containing data that we wish to fill.  `direction`: 0↓, 1→, 2↑, 3←.  So
    // when bit 0 is set we're doing horizontal filling, and when bit 1 is set we're doing it in
    // reverse order.
    Range$1.prototype._previewFillFrom = function(srcRange, direction) {
        var destRange = this, sheet = destRange._sheet;
        if (typeof srcRange == "string") {
            srcRange = sheet.range(srcRange);
        }
        var src = srcRange._ref.toRangeRef().clone().setSheet(sheet.name());
        var dest = destRange._ref.toRangeRef().clone().setSheet(sheet.name());

        if (src.intersects(dest)) {
            // the UI will send e.g. C2:C8.fillFrom(C7:D8) (intersecting ranges).  this figures out
            // the actual destination range.
            if (src.eq(dest)) {
                return null; // nothing to do
            }
            dest = dest.clone();
            if (src.topLeft.eq(dest.topLeft)) {
                if (src.width() == dest.width()) {
                    dest.topLeft.row += src.height();
                    direction = 0;
                } else if (src.height() == dest.height()) {
                    dest.topLeft.col += src.width();
                    direction = 1;
                } else {
                    throw new FillError(ERR_INCOMPATIBLE);
                }
            } else if (src.bottomRight.eq(dest.bottomRight)) {
                if (src.width() == dest.width()) {
                    dest.bottomRight.row -= src.height();
                    direction = 2;
                } else if (src.height() == dest.height()) {
                    dest.bottomRight.col -= src.width();
                    direction = 3;
                } else {
                    throw new FillError(ERR_INCOMPATIBLE);
                }
            } else {
                throw new FillError(ERR_INCOMPATIBLE);
            }
            return sheet.range(dest)._previewFillFrom(srcRange, direction);
        }

        if (direction == null) {
            // try to determine based on ranges location/geometry
            if (src.topLeft.col == dest.topLeft.col) {
                // assume vertical filling
                direction = src.topLeft.row < dest.topLeft.row ? 0 : 2;
            } else if (src.topLeft.row == dest.topLeft.row) {
                direction = src.topLeft.col < dest.topLeft.col ? 1 : 3;
            } else {
                throw new FillError(ERR_NO_DIRECTION);
            }
        }
        var horizontal = direction & 1;
        var descending = direction & 2;
        if ((horizontal && src.height() != dest.height()) ||
            (!horizontal && src.width() != dest.width())) {
            throw new FillError(ERR_INCOMPATIBLE);
        }
        var data = srcRange._properties(), n;
        if (!horizontal) {
            data = transpose(data);
            n = dest.height();
        } else {
            n = dest.width();
        }
        var fill = new Array(data.length);
        var hint = null;
        for (var i = 0; i < data.length; ++i) {
            var s = data[i];
            var f = findSeries(s);
            var a = fill[i] = new Array(n);
            for (var j = 0; j < n; ++j) {
                var idx = descending ? -j - 1 : s.length + j;
                var srcIdx = descending ? s.length - (j % s.length) - 1 : (j % s.length);
                var cell = a[descending ? n - j - 1 : j] = f(idx, srcIdx);
                if (cell.value != null) {
                    hint = cell.value;
                }
            }
        }
        if (!horizontal) {
            fill = transpose(fill);
        }
        return { props: fill, direction: direction, dest: destRange, hint: hint };
    };

    Range$1.prototype.fillFrom = function(srcRange, direction) {
        var x = this._previewFillFrom(srcRange, direction);
        x.dest._properties(x.props, true);
        return x.dest;
    };

    // This is essentially the FORECAST function, see ./runtime.functions.2.js.
    // It receives an array of values, and returns a function that "predicts"
    // the value in cell N.
    function linearRegression(data) {
        var N = data.length;
        var mx = (N + 1) / 2, my = data.reduce(function(a, b){
            return a + b;
        }, 0) / N;
        var s1 = 0, s2 = 0;
        for (var i = 0; i < N; i++) {
            var t1 = (i + 1) - mx, t2 = data[i] - my;
            s1 += t1 * t2;
            s2 += t1 * t1;
        }
        if (!s2) {
            return function(N){
                return data[N % data.length];
            };
        }
        var b = s1 / s2, a = my - b * mx;
        return function(N) {
            return a + b * (N + 1);
        };
    }

    function findSeries(properties) {
        function findStep(a) {
            var diff = a[1] - a[0];
            for (var i = 2; i < a.length; ++i) {
                if (a[i] - a[i-1] != diff) {
                    return null;
                }
            }
            return diff;
        }
        function getData(a) {
            return a.map(function(v){
                return v.number;
            });
        }
        var series = [];
        var data = properties.map(function(x){
            return x.formula || x.value;
        });
        forEachSeries(data, function(begin, end, type, a){
            var f, values;
            if (type == "number") {
                values = getData(a);

                // This code would increase a date even if a single cell was selected.  Seems it's
                // not desirable so I commented it out.
                // https://github.com/telerik/kendo-ui-core/issues/3565
                //
                // if (values.length == 1 && (begin > 0 || end < data.length ||
                //                            formatType(values[0], properties[begin].format) == "date")) {
                //     values.push(values[0] + 1);
                // }

                f = linearRegression(values);
            } else if (type == "string" || type == "formula" || type == "boolean") {
                // formulas are simply copied over; the sheet will internally clone the objects
                f = function(N, i) {
                    return data[i];
                };
            } else if (Array.isArray(type)) {
                if (a.length == 1) {
                    f = function(N) {
                        return type[(a[0].number + N) % type.length];
                    };
                } else {
                    // figure out the step
                    var diff = findStep(getData(a));
                    if (diff == null) {
                        // seemingly no pattern, just repeat those strings
                        f = function(N) {
                            return a[(N) % a.length].value;
                        };
                    } else {
                        f = function(N) {
                            var idx = a[0].number + diff * N;
                            return type[idx % type.length];
                        };
                    }
                }
            } else if (type != "null") {
                values = getData(a);
                if (values.length == 1) {
                    values.push(values[0] + 1);
                }
                values = linearRegression(values);
                f = function(N, i) {
                    return data[i].replace(/^(.*\D0*)\d+$/, "$1" + values(N, i));
                };
            } else {
                f = function() { return null; };
            }
            var s = { f: f, begin: begin, end: end, len: end - begin };
            for (var i = begin; i < end; ++i) {
                series[i] = s;
            }
        });
        return function(N, i) {
            var s = series[i];
            var q = N / data.length | 0;
            var r = N % data.length;
            var n = q * s.len + r - s.begin;
            var value = s.f(n, i);
            var props = clone$1(properties[i]);
            delete props.enable;
            if (value instanceof Formula) {
                props.formula = value;
            } else {
                props.value = value;
            }
            return props;
        };
    }

    function clone$1(obj) {
        var copy = {};
        Object.keys(obj || {}).forEach(function(key){
            copy[key] = obj[key];
        });
        return copy;
    }

    function forEachSeries(data, f) {
        var prev = null, start = 0, a = [], type;
        for (var i = 0; i < data.length; ++i) {
            type = getType(data[i]);
            a.push(type);
            if (prev != null && type.type !== prev.type) {
                f(start, i, prev.type, a.slice(start, i));
                start = i;
            }
            prev = type;
        }
        f(start, i, prev.type, a.slice(start, i));
    }

    function getType(el) {
        if (typeof el == "number") {
            return { type: "number", number: el };
        }
        if (typeof el == "string") {
            var lst = findStringList(el);
            if (lst) {
                return lst;
            }
            var m = /^(.*\D0*)(\d+)$/.exec(el);
            if (m) {
                el = el.replace(/^(.*\D0*)\d+$/, "$1-######");
                return { type: el, match: m, number: parseFloat(m[2]) };
            }
            return { type: "string" };
        }
        if (typeof el == "boolean") {
            return { type: "boolean" };
        }
        if (el == null) {
            return { type: "null" };
        }
        if (el instanceof Formula) {
            return { type: "formula" };
        }
        window.console.error(el);
        throw new Error("Cannot fill data");
    }

    function stringLists() {
        const calendar = culture().calendar;
        return [
            calendar.days.format.abbreviated,
            calendar.days.format.wide,
            calendar.months.format.abbreviated,
            calendar.months.format.wide
        ];
    }

    function findStringList(str) {
        var strl = str.toLowerCase();
        var lists = stringLists();
        for (var i = 0; i < lists.length; ++i) {
            var a = lists[i];
            for (var j = a.length; --j >= 0;) {
                var el = a[j].toLowerCase();
                if (el == strl) {
                    return { type: a, number: j, value: str };
                }
            }
        }
    }

    function transpose(a) {
        var height = a.length, width = a[0].length;
        var t = [];
        for (var i = 0; i < width; ++i) {
            t[i] = [];
            for (var j = 0; j < height; ++j) {
                t[i][j] = a[j][i];
            }
        }
        return t;
    }

    /* eslint-disable no-loop-func */
    /* eslint-disable no-param-reassign */
    const STRING$1 = 'string';
    const FUNCTION = 'function';

    let preventDefault = function() {
        this._defaultPrevented = true;
    };

    let isDefaultPrevented = function() {
        return this._defaultPrevented === true;
    };

    class Observable {
        constructor() {
            this._events = {};
        }

        bind(eventName, handlers, one) {
            let that = this,
                idx,
                eventNames = typeof eventName === STRING$1 ? [eventName] : eventName,
                length,
                original,
                handler,
                handlersIsFunction = typeof handlers === FUNCTION,
                events;

            if (handlers === undefined) {
                for (idx in eventName) {
                    that.bind(idx, eventName[idx]);
                }
                return that;
            }

            for (idx = 0, length = eventNames.length; idx < length; idx++) {
                eventName = eventNames[idx];

                handler = handlersIsFunction ? handlers : handlers[eventName];

                if (handler) {
                    if (one) {
                        original = handler;
                        handler = function() {
                            that.unbind(eventName, handler);
                            original.apply(that, arguments);
                        };
                        handler.original = original;
                    }
                    events = that._events[eventName] = that._events[eventName] || [];
                    events.push(handler);
                }
            }

            return that;
        }

        one(eventNames, handlers) {
            return this.bind(eventNames, handlers, true);
        }

        first(eventName, handlers) {
            let that = this,
                idx,
                eventNames = typeof eventName === STRING$1 ? [eventName] : eventName,
                length,
                handler,
                handlersIsFunction = typeof handlers === FUNCTION,
                events;

            for (idx = 0, length = eventNames.length; idx < length; idx++) {
                eventName = eventNames[idx];

                handler = handlersIsFunction ? handlers : handlers[eventName];

                if (handler) {
                    events = that._events[eventName] = that._events[eventName] || [];
                    events.unshift(handler);
                }
            }

            return that;
        }

        trigger(eventName, e) {
            let that = this,
                events = that._events[eventName],
                idx,
                length;

            if (events) {
                e = e || {};

                e.sender = that;

                e._defaultPrevented = false;

                e.preventDefault = preventDefault;

                e.isDefaultPrevented = isDefaultPrevented;

                events = events.slice();

                for (idx = 0, length = events.length; idx < length; idx++) {
                    events[idx].call(that, e);
                }

                return e._defaultPrevented === true;
            }

            return false;
        }

        unbind(eventName, handler) {
            let that = this,
                events = that._events[eventName],
                idx;

            if (eventName === undefined) {
                that._events = {};
            } else if (events) {
                if (handler) {
                    for (idx = events.length - 1; idx >= 0; idx--) {
                        if (events[idx] === handler || events[idx].original === handler) {
                            events.splice(idx, 1);
                        }
                    }
                } else {
                    that._events[eventName] = [];
                }
            }

            return that;
        }
    }

    class Widget extends Observable {
        constructor(element, options) {
            super();

            this.element = element;
            this.events = [];
            this.options = options;

            // this.bind(this.events, options);
        }

        setOptions(options) {
            this._setEvents(options);
            deepExtend({}, this.options, options);
        }

        _setEvents(options) {
            let that = this,
                idx = 0,
                length = that.events.length,
                e;

            for (; idx < length; idx ++) {
                e = that.events[idx];
                if (that.options[e] && options[e]) {
                    that.unbind(e, that.options[e]);
                    if (that._events && that._events[e]) {
                        delete that._events[e];
                    }
                }
            }

            that.bind(that.events, options);
        }

        resize(force) {
            const size = this.getSize(),
                currentSize = this._size;

            if (force || (size.width > 0 || size.height > 0) && (!currentSize || size.width !== currentSize.width || size.height !== currentSize.height)) {
                this._size = size;
                this._resize(size, force);
                this.trigger("resize", size);
            }
        }

        getSize() {
            return { width: this.element.offsetWidth, height: this.element.offsetHeight };
        }

        destroy() {
            this.unbind();
        }
    }

    /* eslint-disable no-param-reassign */

    const _activeElement = function() {
        try {
            return document.activeElement;
        } catch (e) {
            return document.documentElement.activeElement;
        }
    };

    class SheetEditor extends Observable {
        constructor(view) {
            super();

            this.events = [
                "activate",
                "deactivate",
                "change",
                "update"
            ];

            this.view = view;
            this.formulaBar = view.formulaBar;
            this._active = false;

            this.barInput = view.formulaBar.formulaInput;
            this.cellInput = view.formulaInput;

            this.barInput.syncWith(this.cellInput);
            this.cellInput.syncWith(this.barInput);

            this.barInput.bind("keyup", this._triggerUpdate.bind(this));
            this.cellInput.bind("keyup", this._triggerUpdate.bind(this));

            this.barInput.bind("blur", this._blur.bind(this));
            this.cellInput.bind("blur", this._blur.bind(this));
        }

        _blur() {
            this.deactivate();
        }

        _triggerUpdate() {
            this.trigger("update", { value: this.value() });
        }

        activeEditor() {
            let editor = null;
            let activeElement = _activeElement();

            if (this.barElement() === activeElement) {
                editor = this.barInput;
            } else if (this.cellElement() === activeElement) {
                editor = this.cellInput;
            }

            return editor;
        }

        activate(options) {
            let viewElement = this.view.element,
                viewWidth, scrollerElement, scrollbarWidth;

            this._active = true;
            this._rect = options.rect;
            this._range = options.range;

            this.cellInput.position(options.rect);
            this.cellInput.resize(options.rect);
            this.cellInput.tooltip(options.tooltip);
            this.cellInput.activeCell = this.barInput.activeCell = this._range.topLeft();
            this.cellInput.activeSheet = this.barInput.activeSheet = this._range._sheet;

            if (viewElement) {
                viewWidth = viewElement.offsetWidth;
                scrollerElement = viewElement.querySelector(".k-spreadsheet-scroller");
                scrollbarWidth = scrollerElement.offsetWidth - scrollerElement.clientWidth;

                this.cellInput.element.style.maxWidth = (viewWidth - scrollbarWidth - parseFloat(this.cellInput.element.style.left)) + "px";
            }

            this.trigger("activate");

            return this;
        }

        deactivate(noChange) {
            let cellInput = this.cellInput;

            if (!this._active) {
                return;
            }

            this._active = false;

            if (!noChange && cellInput.value() !== this._value) {
                this.trigger("change", {
                    value: cellInput.value(),
                    range: this._range
                });
            }

            this._rect = null;
            cellInput.hide();
            this.trigger("deactivate");
        }

        enable(enable) {
            this.barInput.enable(enable);
            this.cellInput.enable(enable);
        }

        barElement() {
            return this.barInput.element;
        }

        cellElement() {
            return this.cellInput.element;
        }

        focus(inputType) {
            inputType = inputType || "cell";

            if (inputType === "cell") {
                this.cellInput.element.focus();
                this.cellInput.end();
            } else {
                this.barInput.focus();
            }
        }

        isActive() {
            return this._active;
        }

        isFiltered() {
            return this.barInput.popup.visible() || this.cellInput.popup.visible();
        }

        canInsertRef(isKeyboardAction) {
            let editor = this.activeEditor();
            return editor && editor.canInsertRef(isKeyboardAction);
        }

        highlightedRefs() {
            let editor = this.activeEditor();
            let refs = [];

            if (editor) {
                refs = editor.highlightedRefs();
            }

            return refs;
        }

        scale() {
            this.cellInput.scale();
        }

        toggleTooltip(rect) {
            this.cellInput.toggleTooltip(notEqual(this._rect, rect));
        }

        value(value, isArrayFormula) {
            if (value === undefined) {
                return this.barInput.value();
            }

            if (value === null) {
                value = "";
            }

            this._value = value;

            this.barInput.value(value);
            this.cellInput.value(value);

            this.barInput.element.classList.toggle("k-spreadsheet-array-formula", Boolean(isArrayFormula));
        }

        insertNewline() {
            this.activeEditor().insertNewline();
            this.scale();
        }

        select() {
            this.activeEditor().select();
        }
    }

    function notEqual(oldRect, newRect) {
        return oldRect && (oldRect.top !== newRect.top || oldRect.left !== newRect.left);
    }

    const ampRegExp = /&/g,
        ltRegExp = /</g,
        quoteRegExp = /"/g,
        aposRegExp = /'/g,
        gtRegExp = />/g;

    const htmlEncode = function(value) {
        return String(value).replace(ampRegExp, "&amp;").replace(ltRegExp, "&lt;").replace(gtRegExp, "&gt;").replace(quoteRegExp, "&quot;").replace(aposRegExp, "&#39;");
    };

    class Axis {
        constructor(count, value) {
            this._value = value;
            this._count = count;
            this.values = new RangeList(0, count - 1, value);
            this._hidden = new RangeList(0, count - 1, 0);
            this.scrollBarSize = scrollbar();
            this._refresh();
        }
        _resize(count) {
            if (count > this._count) {
                this.values.value(this._count, count - 1, this._value);
                this._hidden.value(this._count, count - 1, 0);
            } else if (count < this._count) {
                this.values.value(count, this._count - 1, 0);
                this._hidden.value(count, this._count - 1, 0);
            }
            this._count = count;
            this._refresh();
        }
        adjust(start, delta) {
            // adjust this axis for insert/remove rows/cols operation
            if (delta < 0) {
                // removing -- copy from start+|delta| to start
                this.values.copy(start - delta, this._count - 1, start);
                this._hidden.copy(start - delta, this._count - 1, start);
            } else {
                // adding -- copy from start to start+delta, and set
                // values for inserted things to default.
                this.values.copy(start, this._count, start + delta);
                this._hidden.copy(start, this._count, start + delta);
                this.values.value(start, start + delta - 1, this._value);
                this._hidden.value(start, start + delta - 1, 0);
            }
            this._refresh();
        }
        toJSON(field, positions) {
            let values = [];

            let iterator = this.values.iterator(0, this._count - 1);

            for (let idx = 0; idx < this._count; idx++) {
                let value = iterator.at(idx);
                let hidden = this._hidden.value(idx, idx);

                if (value === this._value && !hidden) {
                    continue;
                }

                let position = positions[idx];

                if (position === undefined) {
                    position = values.length;

                    let item = { index: idx };

                    item[field] = value;
                    if (hidden) {
                        item.hidden = hidden;
                    }

                    values.push(item);

                    positions[idx] = position;
                }
            }

            return values;
        }
        fromJSON(field, values) {
            for (let idx = 0; idx < values.length; idx++) {
                let el = values[idx];

                let index = el.index;
                if (index === undefined) {
                    index = idx;
                }

                // when this particular axis is hidden, the value for
                // the field ("height" or "width") will be zero, and
                // in the "hidden" field we'll have the actual value
                // before it was hidden.
                // https://github.com/telerik/kendo-ui-core/issues/3523
                let value = el[field];

                if (value === 0) {
                    this._hidden.value(index, index, el.hidden || this._value);
                    this.value(index, index, 0);
                } else {
                    this.value(index, index, value);
                }
            }
        }
        hide(index) {
            if (!this.hidden(index)) {
                let value = this.value(index, index);
                this._hidden.value(index, index, value);
                this.value(index, index, 0);
            }
        }
        hidden(index) {
            return this._hidden.value(index, index) !== 0;
        }
        includesHidden(start, end) {
            return this._hidden.intersecting(start, end).length > 1;
        }
        nextVisible(index) {
            let end = this._count - 1, i = index;
            while (++i <= end) {
                if (!this.hidden(i)) {
                    return i;
                }
            }
            return index;
        }
        nextUntil(index, pred) {
            let end = this._count - 1, i = index, advanced = false;
            while (++i <= end) {
                let val = pred(i, advanced, this.hidden(i));
                if (typeof val == 'number') {
                    return val;
                } else if (val) {
                    break;
                }
                advanced = true;
            }
            return i - 1;
        }
        nextPage(index, pageSize) {
            return this.index(this.sum(0, index - 1) + pageSize);
        }
        prevPage(index, pageSize) {
            return this.index(this.sum(0, index) - pageSize);
        }
        firstVisible() {
            let firstHidden = this._hidden.first();
            if (firstHidden.value === 0) {
                return 0;
            }
            return firstHidden.end + 1;
        }
        lastVisible() {
            let lastHidden = this._hidden.last();
            if (lastHidden.value === 0) {
                return this._count - 1;
            }
            return lastHidden.start - 1;
        }
        prevVisible(index) {
            let i = index;
            while (--i >= 0) {
                if (!this.hidden(i)) {
                    return i;
                }
            }
            return index;
        }
        prevUntil(index, pred) {
            let i = index, advanced = false;
            while (--i >= 0) {
                let val = pred(i, advanced, this.hidden(i));
                if (typeof val == 'number') {
                    return val;
                } else if (val) {
                    break;
                }
                advanced = true;
            }
            return i + 1;
        }
        unhide(index) {
            if (this.hidden(index)) {
                let value = this._hidden.value(index, index);
                this._hidden.value(index, index, 0);
                this.value(index, index, value);
            }
        }
        value(start, end, value) {
            if (value !== undefined) {
                this.values.value(start, end, value);
                this._refresh();
            } else {
                return this.values.iterator(start, end).at(0);
            }
        }
        sum(start, end) {
            let values = this.values.iterator(start, end);
            let sum = 0;
            for (let idx = start; idx <= end; idx ++) {
                sum += values.at(idx);
            }
            return sum;
        }
        locate(start, end, predicate) {
            let values = this.values.iterator(start, end);
            let sum = 0;
            for (let idx = start; idx <= end; idx++) {
                sum += values.at(idx);
                let val = predicate(sum);
                if (val) {
                    return idx;
                }
            }
            return null;
        }
        visible(start, end) {
            let startSegment = null;
            let endSegment = null;
            let lastPage = false;
            if (end >= this.total + this.scrollBarSize) {
                lastPage = true;
            }
            let ranges = this._pixelValues.intersecting(start, end);
            startSegment = ranges[0];
            endSegment = ranges[ranges.length - 1];
            if (!startSegment) {
                return { values: this.values.iterator(0, 0), offset: 0 };
            }
            let startOffset = start - startSegment.start;
            // eslint-disable-next-line no-bitwise
            let startIndex = ((startOffset / startSegment.value.value) >> 0) + startSegment.value.start;
            let offset = startOffset - (startIndex - startSegment.value.start) * startSegment.value.value;
            let endOffset = end - endSegment.start;
            // eslint-disable-next-line no-bitwise
            let endIndex = ((endOffset / endSegment.value.value) >> 0) + endSegment.value.start;
            if (endIndex > endSegment.value.end) {
                endIndex = endSegment.value.end;
            }
            if (lastPage) {
                offset += endSegment.value.value - (endOffset - (endIndex - endSegment.value.start) * endSegment.value.value);
            }
            offset = Math.min(-offset, 0);
            return {
                values: this.values.iterator(startIndex, endIndex),
                offset: offset
            };
        }
        index(value) {
            let index = 0;
            let iterator = this.values.iterator(0, this._count - 1);
            let current = iterator.at(0);
            while (current < value && index < this._count - 1) {
                current += iterator.at(++index);
            }
            return index;
        }
        indexVisible(value) {
            let index = this.index(value);
            if (this.hidden(index)) {
                index = this.prevVisible(index);
            }
            return index;
        }
        _refresh() {
            let current = 0;
            this._pixelValues = this.values.map(function(range) {
                let start = current;
                current += (range.end - range.start + 1) * range.value;
                let end = current - 1;
                return new ValueRange(start, end, range);
            });
            this.total = current;
        }
        getState() {
            return {
                values: this.values.getState(),
                hidden: this._hidden.getState(),
                count: this._count
            };
        }
        setState(state) {
            this.values.setState(state.values);
            this._hidden.setState(state.hidden);
            let nowCount = this._count;
            if (nowCount > state.count) {
                this._count = state.count;
                this._resize(nowCount); // calls _refresh too
            } else {
                this._refresh();
            }
        }
    }

    class PaneAxis {
        constructor(axis, start, count, headerSize) {
            this._axis = axis;
            this._start = start;
            this._count = count;
            this.hasHeader = start === 0;
            this.headerSize = headerSize;
            this.defaultValue = axis._value;
            this.frozen = count > 0;
        }
        viewSize(viewSize) {
            this._viewSize = viewSize;
        }
        sum(start, end) {
            return this._axis.sum(start, end - 1);
        }
        start() {
            return this.sum(0, this._start);
        }
        size() {
            return this.sum(this._start, this._start + this._count);
        }
        index(value, offset) {
            return this._axis.index(value + (this.frozen ? 0 : offset) - this.headerSize);
        }
        indexVisible(value, offset) {
            return this._axis.indexVisible(value + (this.frozen ? 0 : offset) - this.headerSize);
        }
        // XXX: rename this method
        paneSegment() {
            let offset = this.start();
            let length;
            if (!this.hasHeader) {
                offset += this.headerSize;
            }
            if (this.frozen) {
                length = this.size();
                if (this.hasHeader) {
                    length += this.headerSize;
                } else {
                    length -= this.headerSize;
                }
            } else {
                length = this._viewSize - offset;
            }
            return {
                offset: offset,
                length: length
            };
        }
        visible(offset) {
            let start = this.start();
            let size;
            if (this.frozen) {
                size = this.size();
                if (!this.hasHeader) {
                    size -= this.headerSize;
                }
            } else {
                size = this._viewSize - start - this.headerSize;
                start += offset;
            }
            let result = this._axis.visible(start, start + size - 1);
            if (this.frozen) {
                result.offset = 0;
            }
            result.start = start;
            if (this.hasHeader) {
                result.offset += this.headerSize;
                result.start -= this.headerSize;
            }
            return result;
        }
        contains(start, end) {
            if (this.frozen) {
                if (start > this._start + this._count) {
                    return false;
                }
                if (end < this._start) {
                    return false;
                }
                return true;
            }
            return end >= this._start;
        }
    }

    /* eslint-disable no-param-reassign */
    /* eslint-disable camelcase */

    class Rectangle {
        constructor(left, top, width, height) {
            this.left = left;
            this.top = top;
            this.width = width;
            this.height = height;
            this.right = this.left + this.width;
            this.bottom = this.top + this.height;
        }

        offset(left, top) {
            return new Rectangle(this.left + left, this.top + top, this.width, this.height);
        }

        resize(width, height) {
            return new Rectangle(this.left, this.top, this.width + width, this.height + height);
        }

        intersects(x, y) {
            if (x instanceof Rectangle) {
                return this.intersectsRect(x);
            }
            return this.left < x && x < this.left + this.width &&
                   this.top < y && y < this.top + this.height;
        }

        intersectsRect(b) {
            let a = this;
            return a.left <= b.right
                && b.left <= a.right
                && a.top <= b.bottom
                && b.top <= a.bottom;
        }

        toDiv(className) {
            return dom.element("div", {
                className: className,
                style: {
                    width: this.width + "px",
                    height: this.height + "px",
                    top: this.top + "px",
                    left: this.left + "px"
                }
            });
        }
    }

    class Grid {
        constructor(rows, columns, rowCount, columnCount, headerHeight, headerWidth) {
            this.rowCount = rowCount;
            this.columnCount = columnCount;
            this._columns = columns;
            this._rows = rows;
            this._headerHeight = headerHeight;
            this._headerWidth = headerWidth;
        }

        _resize(new_rows, new_cols) {
            this.rowCount = new_rows;
            this.columnCount = new_cols;
        }

        isAxis(ref) {
            ref = ref.toRangeRef();
            let topLeft = ref.topLeft;
            let bottomRight = ref.bottomRight;
            return (topLeft.row === 0 && bottomRight.row === this.rowCount - 1) || (topLeft.col === 0 && bottomRight.col === this.columnCount - 1);
        }

        width(start, end) {
            return this._columns.sum(start, end);
        }

        height(start, end) {
            return this._rows.sum(start, end);
        }

        totalHeight() {
            return this._rows.total + this._headerHeight;
        }

        totalWidth() {
            return this._columns.total + this._headerWidth;
        }

        index(row, column) {
            return column * this.rowCount + row;
        }

        cellRef(index) {
            return new CellRef(index % this.rowCount, (index / this.rowCount) >> 0);
        }

        rowRef(row) {
            return new RangeRef(new CellRef(row, 0), new CellRef(row, this.columnCount - 1));
        }

        colRef(col) {
            return new RangeRef(new CellRef(0, col), new CellRef(this.rowCount - 1, col));
        }

        cellRefIndex(ref) {
            return this.index(ref.row, ref.col);
        }

        normalize(ref) {
            if (ref instanceof RangeRef) {
                return new RangeRef(
                    this.normalize(ref.topLeft),
                    this.normalize(ref.bottomRight)
                ).setSheet(ref.sheet, ref.hasSheet());
            }

            if (ref instanceof UnionRef) {
                return ref.map(function(ref) {
                    return this.normalize(ref);
                }, this);
            }

            if (ref instanceof CellRef) {
                ref = ref.clone();
                ref.col = Math.max(0, Math.min(this.columnCount - 1, ref.col));
                ref.row = Math.max(0, Math.min(this.rowCount - 1, ref.row));
            }

            return ref;
        }

        rectangle(ref) {
            let topLeft = this.normalize(ref.topLeft);
            let bottomRight = this.normalize(ref.bottomRight);
            return new Rectangle(
                this.width(0, topLeft.col - 1),
                this.height(0, topLeft.row - 1),
                this.width(topLeft.col, bottomRight.col),
                this.height(topLeft.row, bottomRight.row)
            );
        }

        pane(options) {
            return new PaneGrid(
                new PaneAxis(this._rows, options.row, options.rowCount, this._headerHeight),
                new PaneAxis(this._columns, options.column, options.columnCount, this._headerWidth),
                this
            );
        }

        rangeDimensions(rangeRef) {
            return {
                rows: this._rows.values.iterator(rangeRef.topLeft.row, rangeRef.bottomRight.row),
                columns: this._columns.values.iterator(rangeRef.topLeft.col, rangeRef.bottomRight.col)
            };
        }

        forEach(ref, callback) {
            let topLeft = this.normalize(ref.topLeft);
            let bottomRight = this.normalize(ref.bottomRight);

            for (let ci = topLeft.col; ci <= bottomRight.col; ci ++) {
                for (let ri = topLeft.row; ri <= bottomRight.row; ri ++) {
                    callback(new CellRef(ri, ci));
                }
            }
        }

        trim(ref, property) {
            let topLeft = this.normalize(ref.topLeft);
            let bottomRight = this.normalize(ref.bottomRight);
            let bottomRightRow = topLeft.row;
            let bottomRightCol = topLeft.col;

            for (let ci = topLeft.col; ci <= bottomRight.col; ci ++) {
                let start = this.index(topLeft.row, ci);
                let end = this.index(bottomRight.row, ci);
                let values = property.tree.intersecting(start, end);
                if (values.length) {
                    let cell = this.cellRef(values[values.length - 1].end);
                    bottomRightRow = Math.max(bottomRightRow, cell.row);
                    bottomRightCol = ci;
                }
            }
            return new RangeRef(ref.topLeft, new CellRef(Math.min(bottomRightRow, ref.bottomRight.row), bottomRightCol));
        }
    }

    class PaneGrid {
        constructor(rows, columns, grid) {
            this.rows = rows;
            this.columns = columns;
            this._grid = grid;

            this.headerHeight = rows.headerSize;
            this.headerWidth = columns.headerSize;
            this.hasRowHeader = columns.hasHeader;
            this.hasColumnHeader = rows.hasHeader;
        }

        refresh(width, height) {
            this.columns.viewSize(width);
            this.rows.viewSize(height);

            let x = this.columns.paneSegment();
            let y = this.rows.paneSegment();

            this.left = x.offset;
            this.top = y.offset;
            this.right = x.offset + x.length;
            this.bottom = y.offset + y.length;

            this.style = {
                top: y.offset + "px",
                left: x.offset + "px",
                height: y.length + "px",
                width: x.length + "px"
            };
        }

        view(left, top) {
            let rows = this.rows.visible(top);
            let columns = this.columns.visible(left);

            return {
                rows: rows,
                columns: columns,

                rowOffset: rows.offset,
                columnOffset: columns.offset,

                mergedCellLeft: columns.start,
                mergedCellTop: rows.start,

                ref: new RangeRef(
                    new CellRef(rows.values.start, columns.values.start),
                    new CellRef(rows.values.end, columns.values.end)
                )
            };
        }

        contains(ref) {
            return this.rows.contains(ref.topLeft.row, ref.bottomRight.row) &&
                this.columns.contains(ref.topLeft.col, ref.bottomRight.col);
        }

        index(row, column) {
            return this._grid.index(row, column);
        }

        boundingRectangle(ref) {
            return this._grid.rectangle(ref);
        }

        cellRefIndex(ref) {
            return this._grid.cellRefIndex(ref);
        }

        scrollBoundaries(cell) {
            let position = this.boundingRectangle(cell);

            let boundaries = {
                top: Math.max(0, position.top - this.top + (this.hasColumnHeader ? 0 : this.headerHeight)),
                left: Math.max(0, position.left - this.left + (this.hasRowHeader ? 0 : this.headerWidth)),
                right: position.right - this.columns._viewSize + this.headerWidth,
                bottom: position.bottom - this.rows._viewSize + this.headerHeight
            };

            let widthCompensation = this.columns.defaultValue / 2;
            let heightCompensation = this.rows.defaultValue / 2;

            boundaries.scrollTop = boundaries.top - heightCompensation;
            boundaries.scrollBottom = boundaries.bottom + heightCompensation;

            boundaries.scrollLeft = boundaries.left - widthCompensation;
            boundaries.scrollRight = boundaries.right + widthCompensation;
            return boundaries;
        }
    }

    class Sorter {
        constructor(grid, lists) {
            this._grid = grid;
            this._lists = lists;
        }

        indices(rangeRef, list, ascending, indices) {
            let comparer = Sorter.ascendingComparer;

            if (ascending === false) {
                comparer = Sorter.descendingComparer;
            }

            return list.sortedIndices(this._grid.cellRefIndex(rangeRef.topLeft),
                                      this._grid.cellRefIndex(rangeRef.bottomRight), comparer, indices);
        }

        sortBy(ref, column, list, ascending, indices) {
            let sortedIndices = this.indices(ref.toColumn(column), list, ascending, indices);

            for (let ci = ref.topLeft.col; ci <= ref.bottomRight.col; ci++) {
                let start = this._grid.index(ref.topLeft.row, ci);
                let end = this._grid.index(ref.bottomRight.row, ci);

                for (let li = 0; li < this._lists.length; li++) {
                    if (start < this._lists[li].lastRangeStart()) {
                        this._lists[li].sort(start, end, sortedIndices);
                    }
                }
            }

            return sortedIndices;
        }
    }

    Sorter.ascendingComparer = function(a, b) {
        if (a === null && b === null) {
            return 0;
        }

        if (a === null) {
            return 1;
        }

        if (b === null) {
            return -1;
        }

        let typeA = typeof a;
        let typeB = typeof b;

        if (typeA === 'number') {
            if (typeB === 'number') {
                return a - b;
            }
            return -1;
        }

        if (typeA === 'string') {
            switch (typeB) {
            case 'number':
                return 1;
            case 'string':
                return a.localeCompare(b);
            default:
                return -1;
            }
        }

        if (typeA === 'boolean') {
            switch (typeB) {
            case 'number':
                return 1;
            case 'string':
                return 1;
            case 'boolean':
                return a - b;
            default:
                return -1;
            }
        }

        if (a instanceof CalcError) {
            if (b instanceof CalcError) {
                return 0;
            }
            return 1;
        }

        throw new Error('Cannot compare ' + a + ' and ' + b);
    };

    Sorter.descendingComparer = function(a, b) {
        if (a === null && b === null) {
            return 0;
        }

        if (a === null) {
            return 1;
        }

        if (b === null) {
            return -1;
        }

        return Sorter.ascendingComparer(b, a);
    };

    /* eslint-disable no-constant-condition */
    /* eslint-disable key-spacing */
    /* eslint-disable no-param-reassign */


    class AxisManager {
        constructor(sheet) {
            this._sheet = sheet;
        }

        forEachSelectedColumn(callback) {
            let sheet = this._sheet;

            sheet.batch(function() {
                sheet.select().forEachColumnIndex(function(index, i) {
                    callback(sheet, index, i);
                });
            }, { layout: true, recalc: true });
        }

        forEachSelectedRow(callback) {
            let sheet = this._sheet;

            sheet.batch(function() {
                sheet.select().forEachRowIndex(function(index, i) {
                    callback(sheet, index, i);
                });
            }, { layout: true, recalc: true });
        }

        includesHiddenColumns(ref) {
            return this._sheet._grid._columns.includesHidden(ref.topLeft.col, ref.bottomRight.col);
        }

        includesHiddenRows(ref) {
            return this._sheet._grid._rows.includesHidden(ref.topLeft.row, ref.bottomRight.row);
        }

        selectionIncludesHiddenColumns() {
            return this.includesHiddenColumns(this._sheet.select());
        }

        selectionIncludesHiddenRows() {
            return this.includesHiddenRows(this._sheet.select());
        }

        deleteSelectedColumns() {
            let indexes = [], delta = 0;
            this.forEachSelectedColumn(function(sheet, index) {
                index -= delta;
                if (sheet.isHiddenColumn(index)) {
                    return;
                }
                delta++;
                let formulas = [];
                indexes.unshift({
                    index    : index,
                    formulas : formulas,
                    width    : sheet.columnWidth(index)
                });
                sheet._saveModifiedFormulas(formulas, function() {
                    sheet.deleteColumn(index);
                });
            });
            return indexes;
        }

        deleteSelectedRows() {
            let indexes = [], delta = 0;
            this.forEachSelectedRow(function(sheet, index) {
                index -= delta;
                if (sheet.isHiddenRow(index)) {
                    return;
                }
                delta++;
                let formulas = [];
                indexes.unshift({
                    index    : index,
                    formulas : formulas,
                    height   : sheet.rowHeight(index)
                });
                sheet._saveModifiedFormulas(formulas, function() {
                    sheet.deleteRow(index);
                });
            });
            return indexes;
        }

        hideSelectedColumns() {
            this.forEachSelectedColumn(function(sheet, index) {
                sheet.hideColumn(index);
            });
            let sheet = this._sheet;
            let ref = sheet.select().toRangeRef();
            let left = ref.topLeft.col;
            let right = ref.bottomRight.col;
            let sel = null;
            while (true) {
                let hasRight = right < sheet._columns._count;
                let hasLeft = left >= 0;
                if (!hasLeft && !hasRight) {
                    break;
                }
                if (hasRight && !sheet.isHiddenColumn(right)) {
                    sel = right;
                    break;
                }
                if (hasLeft && !sheet.isHiddenColumn(left)) {
                    sel = left;
                    break;
                }
                left--;
                right++;
            }
            if (sel !== null) {
                ref = new RangeRef(
                    new CellRef(0, sel),
                    new CellRef(sheet._rows._count - 1, sel)
                );
                sheet.range(ref).select();
            }
        }

        hideSelectedRows() {
            this.forEachSelectedRow(function(sheet, index) {
                sheet.hideRow(index);
            });
            let sheet = this._sheet;
            let ref = sheet.select().toRangeRef();
            let top = ref.topLeft.row;
            let bottom = ref.bottomRight.row;
            let sel = null;
            while (true) {
                let hasBottom = bottom < sheet._rows._count;
                let hasTop = top >= 0;
                if (!hasTop && !hasBottom) {
                    break;
                }
                if (hasBottom && !sheet.isHiddenRow(bottom)) {
                    sel = bottom;
                    break;
                }
                if (hasTop && !sheet.isHiddenRow(top)) {
                    sel = top;
                    break;
                }
                top--;
                bottom++;
            }
            if (sel !== null) {
                ref = new RangeRef(
                    new CellRef(sel, 0),
                    new CellRef(sel, sheet._columns._count - 1)
                );
                sheet.range(ref).select();
            }
        }

        unhideSelectedColumns() {
            this.forEachSelectedColumn(function(sheet, index) {
                sheet.unhideColumn(index);
            });
        }

        unhideSelectedRows() {
            this.forEachSelectedRow(function(sheet, index) {
                sheet.unhideRow(index);
            });
        }

        addColumnLeft() {
            let sheet = this._sheet;
            let base, count = 0;
            sheet.batch(function() {
                sheet.select().forEachColumnIndex(function(index) {
                    if (!base) {
                        base = index;
                    }
                    sheet.insertColumn(base);
                    ++count;
                });
            }, { recalc: true, layout: true });
            return { base: base, count: count };
        }

        addColumnRight() {
            let sheet = this._sheet;
            let base, count = 0;
            sheet.batch(function() {
                sheet.select().forEachColumnIndex(function(index) {
                    base = index + 1;
                    ++count;
                });
                for (let i = 0; i < count; ++i) {
                    sheet.insertColumn(base);
                }
            }, { recalc: true, layout: true });
            return { base: base, count: count };
        }

        addRowAbove() {
            let sheet = this._sheet;
            let base, count = 0;
            let selectedRows = sheet.select();

            sheet.batch(function() {
                selectedRows.forEachRowIndex(function(index) {
                    if (!base) {
                        base = index;
                    }
                    sheet.insertRow(base);
                    ++count;
                });
            }, { recalc: true, layout: true });

            return { base: base, count: count };
        }

        addRowBelow() {
            let sheet = this._sheet;
            let base, count = 0;

            sheet.batch(function() {
                sheet.select().forEachRowIndex(function(index) {
                    base = index + 1;
                    ++count;
                });
                for (let i = 0; i < count; ++i) {
                    sheet.insertRow(base);
                }
            }, { recalc: true, layout: true });

            return { base: base, count: count };
        }
    }

    /* eslint-disable no-param-reassign */

    class AutoFillCalculator {
        constructor(grid) {
            this._grid = grid;
        }

        rectIsVertical(start, end, x, y) {
            let startRect = this._grid.rectangle(start.toRangeRef());
            let endRect = this._grid.rectangle(end.toRangeRef());
            return Math.abs(endRect[y] - startRect[y]) > Math.abs(startRect[x] - endRect[x]);
        }

        autoFillDest(selection, cursor) {
            let topLeft = selection.topLeft;
            let bottomRight = selection.bottomRight;

            let quadrant;
            let lower = cursor.row >= topLeft.row;
            let further = cursor.col >= topLeft.col;

            if (lower) {
                quadrant = further ? 4 : 3;
            } else {
                quadrant = further ? 2 : 1;
            }

            let pivot, opposite, cornerResult, expanding;

            if (quadrant === 4) {
                pivot = topLeft;
                opposite = bottomRight;

                expanding = cursor.row > opposite.row || cursor.col > opposite.col;

                if (expanding) {
                    cursor = new CellRef(Math.max(cursor.row, opposite.row), Math.max(cursor.col, opposite.col));
                }

                if (this.rectIsVertical(opposite, cursor, 'right', 'bottom')) { // vertical
                    cornerResult = new CellRef(cursor.row, opposite.col);
                } else {
                    cornerResult = new CellRef(opposite.row, cursor.col);
                }
            } else if (quadrant === 3) {
                let bottomLeft = new CellRef(topLeft.col, bottomRight.row);

                if (cursor.row > bottomRight.row && this.rectIsVertical(bottomLeft, cursor, 'left', 'bottom')) { // vertical
                    pivot = topLeft;
                    cornerResult = new CellRef(cursor.row, bottomRight.col);
                } else {
                    pivot = bottomRight;
                    cornerResult = new CellRef(topLeft.row, cursor.col);
                }
            } else if (quadrant === 2) {
                let topRight = new CellRef(topLeft.row, bottomRight.col);

                if (cursor.col > bottomRight.col && !this.rectIsVertical(topRight, cursor, 'right', 'top')) { // horizontal
                    pivot = topLeft;
                    cornerResult = new CellRef(bottomRight.row, cursor.col);
                } else {
                    pivot = bottomRight;
                    cornerResult = new CellRef(cursor.row, topLeft.col);
                }
            } else {
                pivot = bottomRight;
                if (this.rectIsVertical(topLeft, cursor, 'left', 'top')) { // horizontal
                    cornerResult = new CellRef(cursor.row, topLeft.col);
                } else {
                    cornerResult = new CellRef(topLeft.row, cursor.col);
                }
            }

            return this._grid.normalize(new RangeRef(pivot, cornerResult));
        }
    }

    /* eslint-disable max-params */
    /* eslint-disable no-empty */
    /* eslint-disable no-loop-func */
    /* eslint-disable consistent-return */
    /* eslint-disable block-scoped-var */
    /* eslint-disable no-redeclare */
    /* eslint-disable no-var */
    /* eslint-disable eqeqeq */
    /* eslint-disable complexity */
    /* eslint-disable no-implicit-coercion */
    /* eslint-disable brace-style */
    /* eslint-disable key-spacing */
    /* eslint-disable no-else-return */
    /* eslint-disable default-case */
    /* eslint-disable no-param-reassign */


    class EdgeNavigator {
        constructor(field, axis, rangeGetter, union) {
            this.rangeGetter = rangeGetter;

            this.prevLeft = function(index) {
                var current = union(this.range(index));
                var range = this.range(axis.prevVisible(current.topLeft[field]));
                return union(range).topLeft[field];
            };

            this.nextRight = function(index) {
                var current = union(this.range(index));
                var range = this.range(axis.nextVisible(current.bottomRight[field]));
                return union(range).bottomRight[field];
            };

            // these two don't look like the other ones, as they "shrink"
            this.nextLeft = function(index) {
                var range = union(this.range(index));
                return axis.nextVisible(range.bottomRight[field]);
            };

            this.prevRight = function(index) {
                var range = union(this.range(index));
                return axis.prevVisible(range.topLeft[field]);
            };
        }

        boundary(top, bottom) {
            this.top = top;
            this.bottom = bottom;
        }

        range(index) {
            return this.rangeGetter(index, this.top, this.bottom);
        }
    }

    class SheetNavigator {
        constructor(sheet) {
            this._sheet = sheet;
            this.autoFillCalculator = new AutoFillCalculator(sheet._grid);

            this.colEdge = new EdgeNavigator("col", this._sheet._grid._columns, this.columnRange.bind(this), this.union.bind(this));
            this.rowEdge = new EdgeNavigator("row", this._sheet._grid._rows, this.rowRange.bind(this), this.union.bind(this));
        }

        height(height) {
            this._viewPortHeight = height;
        }

        union(ref) {
            return this._sheet.unionWithMerged(ref);
        }

        columnRange(col, topRow, bottomRow) {
            return this._sheet._ref(topRow, col, bottomRow - topRow, 1);
        }

        rowRange(row, leftCol, rightCol) {
            return this._sheet._ref(row, leftCol, 1, rightCol - leftCol);
        }

        selectionIncludesMergedCells() {
            return this._sheet.select().contains(this._sheet._mergedCells);
        }

        setSelectionValue(value) {
            var selection = this._sheet.selection();

            setTimeout(function() {
                selection.value(value());
            });
        }

        selectAll() {
            this._sheet.select(this._sheet._sheetRef);
        }

        select(ref, mode, addToExisting) {
            ref = this.refForMode(ref, mode);

            if (addToExisting) {
                ref = this._sheet.select().concat(ref);
            }

            this._sheet.select(ref);
        }

        refForMode(ref, mode) {
            var grid = this._sheet._grid;

            switch (mode) {
            case "range":
                ref = grid.normalize(ref);
                break;
            case "row":
                ref = grid.rowRef(ref.row);
                break;
            case "column":
                ref = grid.colRef(ref.col);
                break;
            case "sheet":
                ref = this._sheet._sheetRef;
                break;
            }

            return ref;
        }

        startSelection(ref, mode, addToExisting, shiftKey, view) {
            if (mode === "autofill") {
                this._sheet.startAutoFill();
            } else if (shiftKey && mode === "range") {
                var range = new RangeRef(this._sheet.activeCell().first(), ref);
                this._sheet.select(range, false, false);
                this._sheet.startSelection(view);
            } else {
                this._sheet.startSelection(view);
                this.select(ref, mode, addToExisting);
            }
        }

        completeSelection() {
            this._sheet.completeSelection();
        }

        selectForContextMenu(ref, mode) {
            var sheet = this._sheet;
            sheet._activeDrawing = null;
            if (!sheet.select().contains(this.refForMode(ref, mode))) {
                this.select(ref, mode);
            }
        }

        selectDrawingForContextMenu(drawing) {
            var sheet = this._sheet;
            sheet._activeDrawing = drawing;
            sheet.triggerChange({ selection: true });
        }

        modifySelection(action) {
            var direction = this.determineDirection(action);

            var sheet = this._sheet;
            var viewPortHeight = this._viewPortHeight;
            var rows = sheet._grid._rows;
            var columns = sheet._grid._columns;

            var originalSelection = sheet.currentOriginalSelectionRange();
            var selection = sheet.select().toRangeRef();
            var activeCell = sheet.activeCell();

            var topLeft = originalSelection.topLeft.clone();
            var bottomRight = originalSelection.bottomRight.clone();
            var bottomLeft = new CellRef(bottomRight.row, topLeft.col);

            var scrollInto;

            this.colEdge.boundary(selection.topLeft.row, selection.bottomRight.row);
            this.rowEdge.boundary(selection.topLeft.col, selection.bottomRight.col);

            switch (direction) {
            case "expand-left": // <| |
                topLeft.col = this.colEdge.prevLeft(topLeft.col);
                scrollInto = topLeft;
                break;
            case "shrink-right": // |>|
                topLeft.col = this.colEdge.nextLeft(topLeft.col);
                scrollInto = topLeft;
                break;
            case "expand-right": // | |>
                bottomRight.col = this.colEdge.nextRight(bottomRight.col);
                scrollInto = bottomRight;
                break;
            case "shrink-left": // |<|
                bottomRight.col = this.colEdge.prevRight(bottomRight.col);
                scrollInto = bottomRight;
                break;

                // four actions below mirror the upper ones, on the vertical axis
            case "expand-up":
                topLeft.row = this.rowEdge.prevLeft(topLeft.row);
                scrollInto = topLeft;
                break;
            case "shrink-down":
                topLeft.row = this.rowEdge.nextLeft(topLeft.row);
                scrollInto = topLeft;
                break;
            case "expand-down":
                bottomRight.row = this.rowEdge.nextRight(bottomRight.row);
                scrollInto = bottomRight;
                break;
            case "shrink-up":
                bottomRight.row = this.rowEdge.prevRight(bottomRight.row);
                scrollInto = bottomRight;
                break;

                // pageup/down - may need improvement
            case "expand-page-up":
                topLeft.row = rows.prevPage(topLeft.row, viewPortHeight);
                break;
            case "shrink-page-up":
                bottomRight.row = rows.prevPage(bottomRight.row, viewPortHeight);
                break;
            case "expand-page-down":
                bottomRight.row = rows.nextPage(bottomRight.row, viewPortHeight);
                break;
            case "shrink-page-down":
                topLeft.row = rows.nextPage(topLeft.row, viewPortHeight);
                break;

            case "first-col":
                topLeft.col = columns.firstVisible();
                bottomRight.col = activeCell.bottomRight.col;
                scrollInto = topLeft;
                break;
            case "last-col":
                bottomRight.col = columns.lastVisible();
                topLeft.col = activeCell.topLeft.col;
                scrollInto = bottomRight;
                break;
            case "first-row":
                topLeft.row = rows.firstVisible();
                bottomRight.row = activeCell.bottomRight.row;
                scrollInto = topLeft;
                break;
            case "last-row":
                bottomRight.row = rows.lastVisible();
                topLeft.row = activeCell.topLeft.row;
                scrollInto = bottomRight;
                break;
            case "last":
                bottomRight.row = rows.lastVisible();
                bottomRight.col = columns.lastVisible();
                topLeft = activeCell.topLeft;
                scrollInto = bottomRight;
                break;
            case "first":
                topLeft.row = rows.firstVisible();
                topLeft.col = columns.firstVisible();
                bottomRight = activeCell.bottomRight;
                scrollInto = topLeft;
                break;

            case "expand-word-right":
                bottomRight.col = columns.nextUntil(bottomRight.col, makeWordMovement(sheet, bottomRight, true));
                scrollInto = bottomRight;
                break;
            case "shrink-word-right":
                topLeft.col = columns.nextUntil(bottomLeft.col, makeWordMovement(sheet, bottomLeft, true));
                scrollInto = topLeft;
                break;
            case "expand-word-left":
                topLeft.col = columns.prevUntil(bottomLeft.col, makeWordMovement(sheet, bottomLeft, true));
                scrollInto = topLeft;
                break;
            case "shrink-word-left":
                bottomRight.col = columns.prevUntil(bottomRight.col, makeWordMovement(sheet, bottomRight, true));
                scrollInto = bottomRight;
                break;
            case "expand-word-up":
                topLeft.row = rows.prevUntil(topLeft.row, makeWordMovement(sheet, topLeft, false));
                scrollInto = topLeft;
                break;
            case "shrink-word-up":
                bottomRight.row = rows.prevUntil(bottomRight.row, makeWordMovement(sheet, bottomRight, false));
                scrollInto = bottomRight;
                break;
            case "expand-word-down":
                bottomRight.row = rows.nextUntil(bottomRight.row, makeWordMovement(sheet, bottomRight, false));
                scrollInto = bottomRight;
                break;
            case "shrink-word-down":
                topLeft.row = rows.nextUntil(topLeft.row, makeWordMovement(sheet, topLeft, false));
                scrollInto = topLeft;
                break;
            }

            var newSelection = new RangeRef(topLeft, bottomRight);

            if (!this.union(newSelection).intersects(activeCell)) {
                // throw new Error(newSelection.print() + " does not contain " + activeCell.print());
                this.modifySelection(direction.replace("shrink", "expand"));
                return;
            }

            if (scrollInto) {
                sheet.focus(scrollInto);
            }

            this.updateCurrentSelectionRange(newSelection);
        }

        moveActiveCell(direction) {
            var sheet = this._sheet;
            var activeCell = sheet.activeCell();
            var topLeft = activeCell.topLeft;
            var bottomRight = activeCell.bottomRight;

            var cell = sheet.originalActiveCell();
            var rows = sheet._grid._rows;
            var columns = sheet._grid._columns;

            var row = cell.row;
            var column = cell.col;

            switch (direction) {
            case "left":
                column = columns.prevVisible(topLeft.col);
                break;
            case "up":
                row = rows.prevVisible(topLeft.row);
                break;
            case "right":
                column = columns.nextVisible(bottomRight.col);
                break;
            case "down":
                row = rows.nextVisible(bottomRight.row);
                break;
            case "first-col":
                column = columns.firstVisible();
                break;
            case "last-col":
                column = columns.lastVisible();
                break;
            case "first-row":
                row = rows.firstVisible();
                break;
            case "last-row":
                row = rows.lastVisible();
                break;
            case "last":
                row = rows.lastVisible();
                column = columns.lastVisible();
                break;
            case "first":
                row = rows.firstVisible();
                column = columns.firstVisible();
                break;
            case "next-page":
                row = rows.nextPage(bottomRight.row, this._viewPortHeight);
                break;
            case "prev-page":
                row = rows.prevPage(bottomRight.row, this._viewPortHeight);
                break;

            case "word-right":
                column = columns.nextUntil(column, makeWordMovement(sheet, bottomRight, true));
                break;
            case "word-left":
                column = columns.prevUntil(column, makeWordMovement(sheet, bottomRight, true));
                break;
            case "word-up":
                row = rows.prevUntil(row, makeWordMovement(sheet, bottomRight, false));
                break;
            case "word-down":
                row = rows.nextUntil(row, makeWordMovement(sheet, bottomRight, false));
                break;
            }

            sheet.select(new CellRef(row, column));
        }

        navigateInSelection(direction) {
            var sheet = this._sheet;
            var activeCell = sheet.activeCell();
            var topLeft = activeCell.topLeft;

            var cell = sheet.originalActiveCell();
            var rows = sheet._grid._rows;
            var columns = sheet._grid._columns;

            var row = cell.row;
            var column = cell.col;

            var isFirstCell = false;
            var isLastCell = false;

            var selTopLeft, selBottomRight;

            var topLeftCol = topLeft.col;
            var topLeftRow = topLeft.row;
            var tmp;

            function setSelection(sel) {
                selTopLeft = sel.topLeft;
                selBottomRight = sel.bottomRight;
            }

            setSelection(sheet.currentNavigationRange());

            var done = false;
            var navigatedAway = false;

            while (!done && !navigatedAway) {
                var current = new CellRef(row, column);
                var isSingleCellSelected = sheet.singleCellSelection();

                if (isSingleCellSelected) {
                    isFirstCell = selTopLeft.eq(current) && sheet._sheetRef.topLeft.eq(current);
                    isLastCell = selBottomRight.eq(current) && sheet._sheetRef.bottomRight.eq(current);

                    if (!isFirstCell) {
                        isFirstCell = columns.firstVisible() === column && rows.firstVisible() === row;
                    }

                    if (!isLastCell) {
                        isLastCell = columns.lastVisible() === column && rows.lastVisible() === row;
                    }
                }

                switch (direction) {
                case "next":
                    if (isLastCell) {
                        navigatedAway = true;
                    } else if (selBottomRight.eq(current)) {
                        setSelection(sheet.nextNavigationRange());
                        row = selTopLeft.row;
                        column = selTopLeft.col;
                    } else {
                        column = columns.nextVisible(topLeftCol);
                        if (column === topLeftCol || column > selBottomRight.col) {
                            column = selTopLeft.col;
                            tmp = rows.nextVisible(row);
                            if (tmp === row || tmp > selBottomRight.row) {
                                row = selTopLeft.row;
                            } else {
                                row = tmp;
                            }
                        }
                    }
                    break;
                case "previous":
                    if (isFirstCell) {
                        navigatedAway = true;
                        this._sheet._workbook._view.element.querySelector('.k-spreadsheet-name-editor .k-input-inner').focus();
                    } else if (selTopLeft.eq(current)) {
                        setSelection(sheet.previousNavigationRange());
                        row = selBottomRight.row;
                        column = selBottomRight.col;
                    } else {
                        column = columns.prevVisible(topLeftCol);
                        if (column === topLeftCol || column < selTopLeft.col) {
                            column = selBottomRight.col;
                            tmp = rows.prevVisible(row);
                            if (tmp === row || tmp < selTopLeft.row) {
                                row = selBottomRight.row;
                            } else {
                                row = tmp;
                            }
                        }
                    }
                    break;
                case "lower":
                    if (selBottomRight.eq(current)) {
                        setSelection(sheet.nextNavigationRange());
                        row = selTopLeft.row;
                        column = selTopLeft.col;
                    } else {
                        row = rows.nextVisible(topLeftRow);
                        if (row === topLeftRow || row > selBottomRight.row) {
                            row = selTopLeft.row;
                            tmp = columns.nextVisible(column);
                            if (tmp === column || tmp > selBottomRight.col) {
                                column = selTopLeft.col;
                            } else {
                                column = tmp;
                            }
                        }
                    }
                    break;
                case "upper":
                    if (selTopLeft.eq(current)) {
                        setSelection(sheet.previousNavigationRange());
                        row = selBottomRight.row;
                        column = selBottomRight.col;
                    } else {
                        row = rows.prevVisible(topLeftRow);
                        if (row === topLeftRow || row < selTopLeft.row) {
                            row = selBottomRight.row;
                            tmp = columns.prevVisible(column);
                            if (tmp === column || tmp < selTopLeft.col) {
                                column = selBottomRight.col;
                            } else {
                                column = tmp;
                            }
                        }
                    }
                    break;
                default:
                    throw new Error("Unknown entry navigation: " + direction);
                }

                done = !this.shouldSkip(row, column);
                // if (!done) { console.log("skipping", row, column); }
                topLeftCol = column;
                topLeftRow = row;
            }

            if (done) {
                if (sheet.singleCellSelection()) {
                    sheet.select(new CellRef(row, column));
                } else {
                    sheet.activeCell(new CellRef(row, column));
                }
            }
        }

        extendSelection(ref, mode) {
            var sheet = this._sheet;
            var grid = sheet._grid;

            if (mode === "autofill") {
                this.resizeAutoFill(ref);
                return;
            }
            if (mode === "range") {
                ref = grid.normalize(ref);
            }
            else if (mode === "row") {
                ref = grid.rowRef(ref.row).bottomRight;
            } else if (mode === "column") {
                ref = grid.colRef(ref.col).bottomRight;
            }

            var activeCell = sheet.originalActiveCell().toRangeRef();

            this.updateCurrentSelectionRange(new RangeRef(activeCell.topLeft, ref));
        }

        shouldSkip(row, col) {
            if (this._sheet.isHiddenRow(row) || this._sheet.isHiddenColumn(col)) {
                return true;
            }
            var ref = new CellRef(row, col);
            var isMerged = false;
            this._sheet.forEachMergedCell(function(merged) {
                if (merged.intersects(ref) && !merged.collapse().eq(ref)) {
                    isMerged = true;
                }
            });

            return isMerged;
        }

        resizeAutoFill(ref) {
            var sheet = this._sheet;
            var selection = sheet.select();
            var origin = sheet._autoFillOrigin;
            var dest = this.autoFillCalculator.autoFillDest(selection, ref);

            var punch = this.punch(selection, dest);
            var hint, direction;

            if (!punch) {
                var preview = sheet.range(dest)._previewFillFrom(sheet.range(origin));
                if (preview) {
                    direction = preview.direction;
                    hint = preview.hint;
                }
            }

            sheet.updateAutoFill(dest, punch, hint, direction);
        }

        determineDirection(action) {
            var selection = this._sheet.currentSelectionRange();
            var activeCell = this._sheet.activeCell();

            // There may be a third, indeterminate state, caused by a merged cell.
            // In this state, all key movements are treated as shrinks.
            // The navigator will reverse them if it detects this it will cause the selection to exclude the active cell.
            var leftMode = activeCell.topLeft.col === selection.topLeft.col;
            var rightMode = activeCell.bottomRight.col === selection.bottomRight.col;
            var topMode = activeCell.topLeft.row === selection.topLeft.row;
            var bottomMode = activeCell.bottomRight.row === selection.bottomRight.row;

            switch (action) {
            case "left":
                action = rightMode ? "expand-left" : "shrink-left";
                break;
            case "right":
                action = leftMode ? "expand-right" : "shrink-right";
                break;
            case "up":
                action = bottomMode ? "expand-up" : "shrink-up";
                break;
            case "down":
                action = topMode ? "expand-down" : "shrink-down";
                break;
            case "prev-page":
                action = bottomMode ? "expand-page-up" : "shrink-page-up";
                break;
            case "next-page":
                action = topMode ? "expand-page-down" : "shrink-page-down";
                break;
            case "word-left":
                action = rightMode ? "expand-word-left" : "shrink-word-left";
                break;
            case "word-right":
                action = leftMode ? "expand-word-right" : "shrink-word-right";
                break;
            case "word-up":
                action = bottomMode ? "expand-word-up" : "shrink-word-up";
                break;
            case "word-down":
                action = topMode ? "expand-word-down" : "shrink-word-down";
                break;
            }

            return action;
        }

        updateCurrentSelectionRange(ref) {
            var sheet = this._sheet;
            sheet.select(sheet.originalSelect().replaceAt(sheet.selectionRangeIndex(), ref), false);
        }

        punch(selection, subset) {
            var punch;
            if (subset.topLeft.eq(selection.topLeft)) {
                if (subset.bottomRight.row < selection.bottomRight.row) {
                    var bottomRow = this.rowEdge.nextRight(subset.bottomRight.row);

                    punch = new RangeRef(
                        new CellRef(bottomRow, selection.topLeft.col),
                        selection.bottomRight
                    );
                } else if (subset.bottomRight.col < selection.bottomRight.col) {
                    var bottomCol = this.colEdge.nextRight(subset.bottomRight.col);

                    punch = new RangeRef(
                        new CellRef(selection.topLeft.row, bottomCol),
                        selection.bottomRight
                    );
                }
            }

            return punch;
        }
    }

    function makeWordMovement(sheet, pivot, isCol) {
        // the general idea is:
        //
        // - if we start on a non-empty cell, we should select the
        //   range of non-empty cells that follow it.  If, however,
        //   the second cell is empty, then we don't stop there; we
        //   should skip all the empty cells and stop at the first
        //   non-empty cell (and select it).
        //
        // - if we start on an empty cell, then skip all empty cells
        //   and select the first non-empty one.

        var firstVal = sheet.range(pivot).value();
        return function(pos, advanced, hidden) {
            if (hidden) { return true; }   // skip hidden cells
            var val = ( isCol ?
                        sheet.range(pivot.row, pos) :
                        sheet.range(pos, pivot.col) ).value();
            if (firstVal === null) {
                return val === null ? false : pos;
            } else if (!advanced && val === null) {
                firstVal = null; // switch to the other mode
                return false;
            } else {
                return val === null;
            }
        };
    }

    /* eslint-disable max-params */
    /* eslint-disable no-empty */
    /* eslint-disable no-loop-func */
    /* eslint-disable consistent-return */
    /* eslint-disable block-scoped-var */
    /* eslint-disable no-redeclare */
    /* eslint-disable no-var */
    /* eslint-disable eqeqeq */
    /* eslint-disable complexity */
    /* eslint-disable no-implicit-coercion */
    /* eslint-disable brace-style */
    /* eslint-disable key-spacing */
    /* eslint-disable no-else-return */
    /* eslint-disable default-case */
    /* eslint-disable no-param-reassign */


    function numberToDate(val) {
        return val == null ? null : calc.runtime.serialToDate(val);
    }

    function dateToNumber(val) {
        return val == null ? null : calc.runtime.dateToSerial(val);
    }

    var identity = function (o) { return o; };

    class SheetDataSourceBinder {
        constructor(options) {
            this.options = Object.assign({ columns: [] }, this.options,
                // skip undefined properties in options
                Object.keys(options).reduce((acc, key) => {
                    if (options[key] !== undefined) acc[key] = options[key];
                    return acc;
                }, {})
            );

            this.columns = this._normalizeColumns(this.options.columns);

            this._sheet();
            this._dataSource();

            this._header();

            this._boundRowsCount = 0;

            this.dataSource.fetch();
        }

        _sheet() {
            this.sheet = this.options.sheet;

            this._sheetChangeHandler = this._sheetChange.bind(this);
            this._sheetDeleteRowHandler = this._sheetDeleteRow.bind(this);
            this._sheetInsertRowHandler = this._sheetInsertRow.bind(this);

            this.sheet.bind("change", this._sheetChangeHandler)
                .bind("afterDeleteRow", this._sheetDeleteRowHandler)
                .bind("afterInsertRow", this._sheetInsertRowHandler);
        }

        _sheetInsertRow(e) {
            if (e.index !== undefined) {
                this.dataSource.insert(Math.max(e.index - 1, 0), {});
            }
        }

        _sheetDeleteRow(e) {
            if (e.index !== undefined) {
                var dataSource = this.dataSource;
                var model = dataSource.view()[e.index - 1];

                if (model) {
                    dataSource.remove(model);
                }
            }
        }

        _header() {
            this.sheet.batch(function () {
                this.columns.forEach(function (column, index) {
                    this.sheet.range(0, index).value(column.title);
                }.bind(this));
            }.bind(this));
        }

        _sheetChange(e) {
            if (e.insertRow || e.deleteRow) {
                // these actions are handled via custom events
                return;
            }

            if (e.recalc && e.ref && e.isValue) {
                var dataSource = this.dataSource;
                var data = dataSource.view();
                var columns = this.columns;
                var values = [];
                var sheet = this.sheet;
                var fields, getters, normalizedRef, i, rangeRef, normalizedRefs;
                var setValues = function (ref) {
                    ref = ref.toRangeRef();
                    var record;
                    var valueIndex = 0;
                    for (var ri = ref.topLeft.row; ri <= ref.bottomRight.row; ri++) {
                        record = data[ri - 1]; // skip header row

                        if (!record) {
                            record = dataSource.insert(ri - 1, {});
                            data = dataSource.view();
                        }

                        var colValueIndex = 0;
                        for (var ci = ref.topLeft.col; ci <= ref.bottomRight.col && ci < columns.length; ci++) {
                            var currentValue = values[i][valueIndex][colValueIndex++];
                            record.set(columns[ci].field, getters[ci](currentValue));
                        }
                        valueIndex++;
                    }
                };

                if (dataSource.reader.model) {
                    fields = dataSource.reader.model.fields;
                }

                if (!columns.length && data.length) {
                    columns = Object.keys(data[0].toJSON());
                }

                getters = columns.map(function (column) {
                    var field = column.field;
                    if (field && fields && fields[field] && fields[field].type === "date") {
                        return numberToDate;
                    }
                    return identity;
                });

                this._skipRebind = true;
                normalizedRef = sheet._grid.normalize(e.ref);

                if (!(normalizedRef instanceof UnionRef)) {
                    normalizedRef = new UnionRef([normalizedRef]);
                }

                normalizedRefs = normalizedRef.refs;

                normalizedRefs.forEach(function (ref) {
                    values.push(sheet.range(ref).values());
                });

                for (i = 0; i < normalizedRefs.length; i++) {
                    rangeRef = normalizedRefs[i];
                    rangeRef.forEach(setValues);
                }

                this._boundRowsCount = dataSource.view().length;

                this._skipRebind = false;
            }
        }

        _normalizeColumns(columns) {
            return columns.map(function (column) {
                var field = column.field || column;
                return {
                    field: field,
                    title: column.title || field
                };
            });
        }

        _dataSource() {
            var options = this.options;
            var dataSource = options.dataSource;

            dataSource = Array.isArray(dataSource) ? { data: dataSource } : dataSource;

            if (this.dataSource && this._changeHandler) {
                this.dataSource.unbind("change", this._changeHandler)
                    .unbind("progress", this._progressHandler)
                    .unbind("error", this._errorHandler);
            } else {
                this._changeHandler = this._change.bind(this);
                this._progressHandler = this._requestStart.bind(this);
                this._errorHandler = this._error.bind(this);
            }

            this.dataSource = this.options.sheet.createSheetDataSource?.(dataSource)
                .bind("change", this._changeHandler)
                .bind("progress", this._progressHandler)
                .bind("error", this._errorHandler);
        }

        _error() {
            this._progress(false);
        }

        _requestStart() {
            this._progress(true);
        }

        _progress(toggle) {
            this.sheet.trigger("progress", {
                toggle: toggle
            });
        }

        _change() {
            if (this._skipRebind) {
                return;
            }

            if (this.sheet.trigger("dataBinding")) {
                return;
            }

            var data = this.dataSource.view();
            var columns = this.columns;

            if (!columns.length && data.length) {
                this.columns = columns = this._normalizeColumns(Object.keys(data[0].toJSON()));
                this._header();
            }

            var getters = columns.map(function (column) {
                return getter(column.field);
            });

            this.sheet.batch(function () {
                var length = Math.max(data.length, this._boundRowsCount, this.sheet._grid.rowCount - 1);

                for (var idx = 0; idx < length; idx++) {
                    for (var getterIdx = 0; getterIdx < getters.length; getterIdx++) {
                        var value = data[idx] ? getters[getterIdx](data[idx]) : null;

                        //skip header row
                        this.sheet.range(idx + 1, getterIdx).value(value);
                    }
                }
            }.bind(this));

            this._boundRowsCount = data.length;

            this._progress(false);
            this.sheet.trigger("dataBound");
        }

        destroy() {
            this.dataSource.unbind("change", this._changeHandler)
                .unbind("progress", this._progressHandler)
                .unbind("error", this._errorHandler);

            this.sheet.unbind("change", this._sheetChangeHandler)
                .unbind("deleteRow", this._sheetDeleteRowHandler)
                .unbind("insertRow", this._sheetInsertRowHandler);
        }
    }

    const kendoDate = (function() {
        function today() {
            return kendoDateMath.getDate(new Date());
        }

        function isToday(date) {
            return kendoDateMath.getDate(date).getTime() === today().getTime();
        }

        return {
            dayOfWeek: kendoDateMath.dayOfWeek,
            getDate: kendoDateMath.getDate,
            isToday: isToday,
            addDays: kendoDateMath.addDays,
            today: today,
            firstDayOfMonth: kendoDateMath.firstDayOfMonth
        };
    })();

    /* eslint-disable no-var */
    /* eslint-disable no-implicit-coercion */
    /* eslint-disable no-param-reassign */
    /* eslint-disable no-loop-func */


    const logic = {
        or: {
            concat: (acc, fn) => (a) => acc(a) || fn(a),
            identity: () => false,
        },
        and: {
            concat: (acc, fn) => (a) => acc(a) && fn(a),
            identity: () => true,
        },
    };

    const operatorsMap = {
        contains: (a, b) => (a || "").indexOf(b) >= 0,
        doesnotcontain: (a, b) => (a || "").indexOf(b) === -1,
        doesnotendwith: (a, b) =>
            (a || "").indexOf(b, (a || "").length - (b || "").length) < 0,
        doesnotstartwith: (a, b) => (a || "").lastIndexOf(b, 0) === -1,
        endswith: (a, b) =>
            (a || "").indexOf(b, (a || "").length - (b || "").length) >= 0,
        eq: (a, b) => a === b,
        gt: (a, b) => a > b,
        gte: (a, b) => a >= b,
        isempty: (a) => a === "",
        isnotempty: (a) => a !== "",
        isnotnull: (a) => isPresent(a),
        isnull: (a) => isBlank(a),
        lt: (a, b) => a < b,
        lte: (a, b) => a <= b,
        neq: (a, b) => a != b, // tslint:disable-line:triple-equals
        startswith: (a, b) => (a || "").lastIndexOf(b, 0) === 0,
    };

    const dateRegExp = /^\/Date\((.*?)\)\/$/;

    const convertValue = (value, ignoreCase, accentFoldingFiltering) => {
        if (value != null && isString(value)) {
            const date = dateRegExp.exec(value);
            if (date) {
                return new Date(+date[1]).getTime();
            } else if (ignoreCase) {
                return accentFoldingFiltering
                    ? value.toLocaleLowerCase(accentFoldingFiltering)
                    : value.toLowerCase();
            }
        } else if (value != null && isDate(value)) {
            return value.getTime();
        }
        return value;
    };

    const transformFilter = ({
        field,
        ignoreCase,
        value,
        operator,
        accentFoldingFiltering,
    }) => {
        field = !isPresent(field) ? (a) => a : field;

        ignoreCase = isPresent(ignoreCase) ? ignoreCase : true;

        const itemProp = typedGetter(
            isFunction(field) ? field : getter(field, true),
            value,
            ignoreCase,
            accentFoldingFiltering
        );

        value = convertValue(value, ignoreCase, accentFoldingFiltering);

        const op = isFunction(operator) ? operator : operatorsMap[operator];

        return (a) => op(itemProp(a), value, ignoreCase);
    };

    const typedGetter = (prop, value, ignoreCase, accentFoldingFiltering) => {
        if (!isPresent(value)) {
            return prop;
        }

        let acc = prop;

        if (isString(value)) {
            const date = dateRegExp.exec(value);
            if (date) {
                value = new Date(+date[1]);
            } else {
                acc = (a) => {
                    const x = prop(a);
                    if (typeof x === "string" && ignoreCase) {
                        return accentFoldingFiltering
                            ? x.toLocaleLowerCase(accentFoldingFiltering)
                            : x.toLowerCase();
                    } else {
                        return isNumeric(x) ? x + "" : x;
                    }
                };
            }
        }

        if (isDate(value)) {
            return (a) => {
                const x = acc(a);
                return isDate(x) ? x.getTime() : x;
            };
        }
        return acc;
    };

    const transformCompositeFilter = function (filter) {
        const accentFoldingFiltering = filter.accentFoldingFiltering;
        const combiner = logic[filter.logic || "and"];

        return filter.filters
            .filter(isPresent)
            .map((x) => {
                const extendedFilter = isPresent(accentFoldingFiltering)
                    ? deepExtend({}, x, { accentFoldingFiltering })
                    : x;

                return isPresent(x.filters)
                    ? transformCompositeFilter(extendedFilter)
                    : transformFilter(extendedFilter);
            })
            .reduce(combiner.concat, combiner.identity);
    };

    /* eslint-disable max-params */
    /* eslint-disable no-empty */
    /* eslint-disable no-loop-func */
    /* eslint-disable consistent-return */
    /* eslint-disable block-scoped-var */
    /* eslint-disable no-redeclare */
    /* eslint-disable no-var */
    /* eslint-disable eqeqeq */
    /* eslint-disable complexity */
    /* eslint-disable no-implicit-coercion */
    /* eslint-disable brace-style */
    /* eslint-disable key-spacing */
    /* eslint-disable no-else-return */
    /* eslint-disable default-case */
    /* eslint-disable no-param-reassign */


    let filtersObj = {};
    const dateToSerial$1 = calc.runtime.dateToSerial;
    const serialToDate$1 = calc.runtime.serialToDate;

    class Filter {
        prepare() {
        }
        value(cell) {
            return cell.value;
        }
        matches() {
            throw new Error("The 'matches' method is not implemented.");
        }
        toJSON() {
            throw new Error("The 'toJSON' method is not implemented.");
        }
    }

    Filter.create = function(options) {
        var filter = options.filter;

        if (!filter) {
            throw new Error("Filter type not specified.");
        }

        var constructor = filtersObj[filter.charAt(0).toUpperCase() + filter.substring(1) + "Filter"];

        if (!constructor) {
            throw new Error("Filter type not recognized.");
        }

        return new constructor(options);
    };

    class ValueFilter extends Filter {
        constructor(options) {
            super(options);

            this._values = [];
            this._dates = [];
            this._blanks = false;

            if (options.values !== undefined) {
                this._values = options.values;
            }

            if (options.blanks !== undefined) {
                this._blanks = options.blanks;
            }

            if (options.dates !== undefined) {
                this._dates = options.dates;
            }
        }

        value(cell) {
            var value = cell.value;

            if (this._dates.length > 0 && cell.format && typeof value === "number") {
                var type = formatting.type(value, cell.format);

                if (type === "date") {
                    value = serialToDate$1(value);
                }
            }

            return value;
        }

        matches(value) {
            if (value === null || value === undefined) {
                return this._blanks;
            }

            if (value instanceof Date) {
                return this._dates.some(function(date) {
                    return date.year === value.getFullYear() &&
                        (date.month === undefined || date.month === value.getMonth()) &&
                        (date.day === undefined || date.day === value.getDate()) &&
                        (date.hours === undefined || date.hours === value.getHours()) &&
                        (date.minutes === undefined || date.minutes === value.getMinutes()) &&
                        (date.seconds === undefined || date.seconds === value.getSeconds());
                });
            }

            return this._values.indexOf(value) >= 0;
        }
        toJSON() {
            return {
                filter: "value",
                blanks: this._blanks,
                values: this._values.slice(0)
            };
        }
    }

    class CustomFilter extends Filter {
        constructor(options) {
            super(options);
            this._logic = "and";
            if (options.logic !== undefined) {
                this._logic = options.logic;
            }

            if (options.criteria === undefined) {
                throw new Error("Must specify criteria.");
            }

            this._criteria = options.criteria;

            this._matches = transformCompositeFilter({
                logic: this._logic,
                filters: this._criteria,
                accentFoldingFiltering: culture().name,
            });
        }
        matches(value) {
            if (value === null) {
                return false;
            }

            return this._matches(value);
        }
        value(cell) {
            var value = cell.value;
            var criterionValue = this._criteria[0].value;
            var criterionType = criterionValue instanceof Date ? "date" : typeof criterionValue;
            var valueType = typeof value;

            if (cell.format) {
                valueType = formatting.type(value, cell.format);
            }

            if (valueType != criterionType) {
                if (criterionType == "string") {
                    if (cell.format) {
                        value = formatting.text(value, cell.format);
                    }
                    value = value + "";
                }
            } else if (valueType == "date") {
                value = serialToDate$1(value);
            }

            return value;
        }
        toJSON() {
            return {
                filter: "custom",
                logic: this._logic,
                criteria: this._criteria
            };
        }
    }

    class TopFilter extends Filter {
        constructor(options) {
            super(options);
            this._type = options.type;
            this._value = options.value;
            this._values = [];
        }

        prepare(cells) {
            var values = cells.map(this.value)
            .sort()
            .filter(function(value, index, array) {
                return index === 0 || value !== array[index - 1];
            });

            if (this._type === "topNumber" || this._type == "topPercent") {
                values.sort(function(x, y) {
                    return y - x;
                });
            } else {
                values.sort(function(x, y) {
                    return x - y;
                });
            }

            var count = this._value;

            if (this._type === "topPercent" || this._type === "bottomPercent") {
                count = (values.length * count / 100) >> 0;
            }

            this._values = values.slice(0, count);
        }
        matches(value) {
            return this._values.indexOf(value) >= 0;
        }
        toJSON() {
            return {
                filter: "top",
                type: this._type,
                value: this._value
            };
        }
    }

    class DynamicFilter extends Filter {
        constructor(options) {
            super(options);
            this._type = options.type;

            this._predicate = this[options.type];

            if (typeof this._predicate !== "function") {
                throw new Error("DynamicFilter type '" + options.type + "' not recognized.");
            }
        }
        value(cell) {
            var value = cell.value;

            if (cell.format) {
                var type = formatting.type(value, cell.format);

                if (type === "date") {
                    value = serialToDate$1(value);
                }
            }

            return value;
        }
        prepare(cells) {
            var sum = 0;
            var count = 0;

            for (var ci = 0; ci < cells.length; ci++) {
                var value = this.value(cells[ci]);

                if (typeof value === "number") {
                    sum += value;
                    count ++;
                }
            }

            if (count > 0) {
                this._average = sum / count;
            } else {
                this._average = 0;
            }
        }
        matches(value) {
            return this._predicate(value);
        }
        aboveAverage(value) {
            if (value instanceof Date) {
                value = dateToSerial$1(value);
            }

            if (typeof value !== "number") {
                return false;
            }

            return value > this._average;
        }
        belowAverage(value) {
            if (value instanceof Date) {
                value = dateToSerial$1(value);
            }

            if (typeof value !== "number") {
                return false;
            }

            return value < this._average;
        }
        tomorrow(value) {
            if (value instanceof Date) {
                var tomorrow = kendoDate.addDays(kendoDate.today(), 1);

                return kendoDate.getDate(value).getTime() === tomorrow.getTime();
            }

            return false;
        }
        today(value) {
            if (value instanceof Date) {
                return kendoDate.isToday(value);
            }

            return false;
        }
        yesterday(value) {
            if (value instanceof Date) {
                var yesterday = kendoDate.addDays(kendoDate.today(), -1);

                return kendoDate.getDate(value).getTime() === yesterday.getTime();
            }

            return false;
        }
        nextWeek(value) {
            return sameWeek(kendoDate.addDays(kendoDate.today(), 7), value);
        }
        thisWeek(value) {
            return sameWeek(kendoDate.today(), value);
        }
        lastWeek(value) {
            return sameWeek(kendoDate.addDays(kendoDate.today(), -7), value);
        }
        nextMonth(value) {
            return sameMonth(value, 1);
        }
        thisMonth(value) {
            return sameMonth(value, 0);
        }
        lastMonth(value) {
            return sameMonth(value, -1);
        }
        nextQuarter(value) {
            if (value instanceof Date) {
                var today = kendoDate.today();

                var diff = quarter(value) - quarter(today);

                return (diff === 1 && today.getFullYear() === value.getFullYear()) ||
                        (diff == -3 && today.getFullYear() + 1 === value.getFullYear());
            }

            return false;
        }
        thisQuarter(value) {
            if (value instanceof Date) {
                var today = kendoDate.today();

                var diff = quarter(value) - quarter(today);

                return diff === 0 && today.getFullYear() === value.getFullYear();
            }

            return false;
        }
        lastQuarter(value) {
            if (value instanceof Date) {
                var today = kendoDate.today();

                var diff = quarter(today) - quarter(value);

                return (diff === 1 && today.getFullYear() === value.getFullYear()) ||
                        (diff == -3 && today.getFullYear() - 1 === value.getFullYear());
            }

            return false;
        }
        nextYear(value) {
            return sameYear(value, 1);
        }
        thisYear(value) {
            return sameYear(value, 0);
        }
        lastYear(value) {
            return sameYear(value, -1);
        }
        yearToDate(value) {
            if (value instanceof Date) {
                var today = kendoDate.today();

                return value.getFullYear() === today.getFullYear() && value <= today;
            }

            return false;
        }
        toJSON() {
            return {
                filter: "dynamic",
                type: this._type
            };
        }
    }

    filtersObj = {
        Filter, ValueFilter, CustomFilter, TopFilter
    };

    [1, 2, 3, 4].forEach(function(target) {
        DynamicFilter.prototype["quarter" + target] = function(value) {
            if (value instanceof Date) {
                return quarter(value) === target;
            }

            return false;
        };
    });

    const initDynamicFilter = () => {
        culture().calendar.months.format.wide.forEach(function(month, index) {
            DynamicFilter.prototype[month.toLowerCase()] = function(value) {
                if (value instanceof Date) {
                    return value.getMonth() === index;
                }

                return false;
            };
        });
    };

    function quarter(value) {
        var month = value.getMonth() + 1;

        if (month >= 1 && month <= 3) {
            return 1;
        } else if (month >= 4 && month <= 6) {
            return 2;
        } else if (month >= 7 && month <= 9) {
            return 3;
        } else {
            return 4;
        }
    }

    function sameYear(value, offset) {
        if (value instanceof Date) {
            var today = kendoDate.today();

            today.setFullYear(today.getFullYear() + offset);

            return today.getFullYear() === value.getFullYear();
        }

        return false;
    }

    function sameMonth(value, offset) {
        if (value instanceof Date) {
            var today = kendoDate.firstDayOfMonth(kendoDate.today());

            today.setMonth(today.getMonth() + offset, 1);

            return today.getTime() === kendoDate.firstDayOfMonth(value).getTime();
        }

        return false;
    }

    function sameWeek(a, b) {
        if (b instanceof Date) {
            var firstWeek = kendoDate.dayOfWeek(kendoDate.getDate(a), 1);

            var secondWeek = kendoDate.dayOfWeek(kendoDate.getDate(b), 1);

            return firstWeek.getTime() === secondWeek.getTime();
        }

        return false;
    }

    /* eslint-disable max-params */
    /* eslint-disable no-empty */
    /* eslint-disable no-loop-func */
    /* eslint-disable consistent-return */
    /* eslint-disable block-scoped-var */
    /* eslint-disable no-redeclare */
    /* eslint-disable no-var */
    /* eslint-disable eqeqeq */
    /* eslint-disable complexity */
    /* eslint-disable no-implicit-coercion */
    /* eslint-disable brace-style */
    /* eslint-disable key-spacing */
    /* eslint-disable no-else-return */
    /* eslint-disable default-case */
    /* eslint-disable no-param-reassign */


    // This is a “dynamic variable” (see Greenspun's 10th rule).  It's
    // bound to an array via sheet._saveModifiedFormulas (which see)
    // while the callback runs.  The goal is to enable external code
    // to get a list of formulas or validations that have been
    // adjusted as an effect of an insert/delete row/column operation,
    // to be able to undo it.
    //
    // The reason why simply saving the state via sheet.getState() or
    // range.getState() won't suffice is that an insert or delete
    // operation can have far-reaching effects, like adjusting
    // formulas from another sheet.
    var MODIFIED_FORMULAS;

    const DEFAULT_SHEET_STATE = 'visible';

    class Selection {
        constructor(sheet) {
            this._sheet = sheet;
            this.selection = FIRSTREF.toRangeRef();
            this.originalSelection = FIRSTREF.toRangeRef();
            this._activeCell = FIRSTREF.toRangeRef();
            this.originalActiveCell = FIRSTREF;
        }

        currentSelectionRange() {
            return this.selection.rangeAt(this.selectionRangeIndex).toRangeRef();
        }

        currentOriginalNavigationRange() {
            return this.originalSelection.rangeAt(this.selectionRangeIndex).toRangeRef();
        }

        currentNavigationRange() {
            if (this.singleCellSelection()) {
                return this._sheet._sheetRef;
            } else {
                return this.selection.rangeAt(this.selectionRangeIndex).toRangeRef();
            }
        }

        nextNavigationRange() {
            if (!this.singleCellSelection()) {
                this.selectionRangeIndex = this.selection.nextRangeIndex(this.selectionRangeIndex);
            }

            return this.currentNavigationRange();
        }

        previousNavigationRange() {
            if (!this.singleCellSelection()) {
                this.selectionRangeIndex = this.selection.previousRangeIndex(this.selectionRangeIndex);
            }

            return this.currentNavigationRange();
        }

        activeCell(ref) {
            if (ref) {
                this.originalActiveCell = ref.first();
                this._activeCell = this._sheet.unionWithMerged(ref.toRangeRef());
                this._sheet.focus(ref);
                this._sheet.triggerChange({ activeCell: true, selection: true });
            }

            return this._activeCell;
        }

        select(ref, expanded, changeActiveCell, view) {
            if (ref) {
                if (ref.eq(this.originalSelection)) {
                    return;
                }

                this._sheet.triggerSelect(new Range$1(ref, this._sheet));

                this.originalSelection = ref;

                this.selection = expanded;

                if (changeActiveCell !== false) {
                    if (ref.isCell()) {
                        // when selecting part of a merged cell, i.e. A1:B2 is merged and select(B2)
                        // is requested, mark A1 as the actually active cell.
                        // https://github.com/telerik/kendo/issues/7698
                        this._sheet.forEachMergedCell(ref, function(merged) {
                            ref = merged.topLeft;
                        });
                        this.activeCell(ref);
                    } else {
                        ref = this.selection.lastRange();
                        if (view && view._sheet === this._sheet && view.panes[0]) {
                            // we should intersect this ref with the range that's currently on
                            // screen, so that the view doesn't scroll (that is, keep the activeCell
                            // visible) - https://github.com/telerik/kendo-ui-core/issues/5182 —
                            // XXX: fiddling with View internals here is probably bad practice, but
                            // this whole thing is a mess already, so it can be forgiven. :-/
                            var panes = view.panes;
                            var i, pane, rows, cols, visible, newRef;

                            for (i = 0; i < panes.length; i++) {
                                pane = panes[i];
                                if (!pane._currentView) {
                                    continue;
                                }
                                rows = pane._currentView.rows.values;
                                cols = pane._currentView.columns.values;

                                visible = new RangeRef(
                                    new CellRef(rows.start, cols.start),
                                    new CellRef(rows.end, cols.end)
                                );

                                newRef = ref.intersect(visible);

                                if (newRef !== NULLREF) {
                                    break;
                                }
                            }

                            if (newRef && newRef !== NULLREF) {
                                ref = newRef;
                            }
                        }
                        this.activeCell(ref.first());
                    }

                    this.selectionRangeIndex = this.selection.size() - 1;
                } else {
                    this._sheet.triggerChange({ selection: true });
                }
            }

            return this.selection;
        }

        singleCellSelection() {
            return this._activeCell.eq(this.selection);
        }
    }

    let EDITORS = {};

    function registerEditor(name, editor) {
        EDITORS[name] = editor;
    }

    class Sheet extends Observable {
        constructor() {
            super();
            this.events = [
                "changing",
                "commandRequest",
                "afterInsertRow",
                "afterDeleteRow",
                "insertRow",
                "insertColumn",
                "deleteRow",
                "deleteColumn",
                "hideRow",
                "hideColumn",
                "unhideRow",
                "unhideColumn",
                "select",
                "dataBinding",
                "dataBound",
                "progress"
            ];

            this.createSheetDataSource = Array.from(arguments).pop();

            this._reinit.apply(this, arguments);
        }

        activeCellCustomEditor() {
            let cell = this.activeCell().first();

            if (this.range(cell).enable()) {
                let val = this.validation(cell);
                let key = this._properties.get("editor", this._grid.cellRefIndex(cell));
                let editor;

                if (key != null) {
                    editor = EDITORS[key];
                }
                else if (val && val.showButton) {
                    key = "_validation_" + val.dataType;
                    editor = EDITORS[key];
                }

                if (typeof editor == "function") {
                    editor = EDITORS[key] = editor();
                }

                return editor;
            }
        }

        _reinit(rowCount, columnCount, rowHeight, columnWidth, headerHeight, headerWidth, defaultCellStyle) {
            defaultCellStyle = defaultCellStyle || {};

            this._defaultCellStyle = {
                background: defaultCellStyle.background,
                color: defaultCellStyle.color,
                fontFamily: defaultCellStyle.fontFamily,
                fontSize: defaultCellStyle.fontSize,
                italic: defaultCellStyle.italic,
                bold: defaultCellStyle.bold,
                underline: defaultCellStyle.underline,
                wrap: defaultCellStyle.wrap,
                verticalAlign: defaultCellStyle.verticalAlign,
                textAlign: defaultCellStyle.textAlign
            };

            this._rows = new Axis(rowCount, rowHeight);
            this._columns = new Axis(columnCount, columnWidth);
            this._filteredRows = new RangeList(0, rowCount - 1, false);
            this._mergedCells = [];
            this._frozenRows = 0;
            this._frozenColumns = 0;
            this._suspendChanges = false;
            this._filter = null;
            this._showGridLines = true;
            this._gridLinesColor = null;
            this._grid = new Grid(this._rows, this._columns, rowCount, columnCount, headerHeight, headerWidth);
            this._sheetRef = this._grid.normalize(SHEETREF);
            this._properties = new PropertyBag(rowCount, columnCount, this._defaultCellStyle);
            this._sorter = new Sorter(this._grid, this._properties.sortable());

            this._viewSelection = new Selection(this);

            this._editSelection = new Selection(this);

            this._formulaSelections = [];
            this._drawings = [];
        }

        resize(newRows, newCols) {
            newRows = Math.max(newRows, 1);
            newCols = Math.max(newCols, 1);
            var oldRows = this._rows._count;
            var oldCols = this._columns._count;
            if (newRows < oldRows) {
                this.range(newRows, 0, oldRows - newRows, oldCols).clear();
            }
            if (newCols < oldCols) {
                this.range(0, newCols, oldRows, oldCols - newCols).clear();
            }
            this._rows._resize(newRows);
            this._columns._resize(newCols);
            this._grid._resize(newRows, newCols);
            this._properties._resize(newRows, newCols);
            this._sheetRef = this._grid.normalize(SHEETREF);
            if (newRows > oldRows) {
                this.range(oldRows, 0, newRows - oldRows, newCols).clear();
                this._filteredRows.value(oldRows, newRows - 1, false);
            }
            if (newCols > oldCols) {
                this.range(0, oldCols, newRows, newCols - oldCols).clear();
            }
            this.triggerChange({ layout: true });
        }

        _resizeAddRow(count) {
            this.resize(this._rows._count + (count || 1), this._columns._count);
        }

        _resizeAddColumn(count) {
            this.resize(this._rows._count, this._columns._count + (count || 1));
        }

        _resizeDeleteRow(count) {
            this._resizeAddRow(-(count || 1));
        }

        _resizeDeleteColumn(count) {
            this._resizeAddColumn(-(count || 1));
        }

        _resizeForJSON(rows) {
            var rowCount = rows.length, colCount = 0;
            for (var ri = 0; ri < rows.length; ++ri) {
                var row = rows[ri];
                if (row.index != null) {
                    rowCount = Math.max(rowCount, row.index + 1);
                }
                if (row.cells) {
                    colCount = Math.max(colCount, row.cells.length);
                    for (var ci = 0; ci < row.cells.length; ++ci) {
                        var cell = row.cells[ci];
                        if (cell.index != null) {
                            colCount = Math.max(colCount, cell.index + 1);
                        }
                    }
                }
            }
            this.resize(Math.max(rowCount, this._rows._count),
                        Math.max(colCount, this._columns._count));
        }

        _selectionState() {
            return this._inEdit ? this._editSelection : this._viewSelection;
        }

        navigator() {
            if (!this._navigator) {
                this._navigator = new SheetNavigator(this);
            }
            return this._navigator;
        }

        axisManager() {
            if (!this._axisManager) {
                this._axisManager = new AxisManager(this);
            }

            return this._axisManager;
        }

        _name(value) {
            if (!value) {
                return this._sheetName;
            }

            this._sheetName = value;

            return this;
        }

        name() {
            return this._name();
        }

        _state(value) {
            if (!value) {
                return this._sheetState || DEFAULT_SHEET_STATE;
            }

            this._sheetState = value;

            return this;
        }

        state() {
            return this._state();
        }

        _property(accessor, value, reason) {
            if (value === undefined) {
                return accessor();
            } else {
                accessor(value);

                return this.triggerChange(reason);
            }
        }

        _field(name, value, reason) {
            if (value === undefined) {
                return this[name];
            } else {
                this[name] = value;

                return this.triggerChange(reason);
            }
        }

        suspendChanges(value) {
            if (value === undefined) {
                return this._suspendChanges;
            }

            this._suspendChanges = value;

            return this;
        }

        triggerChange(reason) {
            if (!this._suspendChanges) {
                this.trigger("change", reason);
            } else if (reason && reason.isValue) {
                this._valueChanged = true;
            }
            return this;
        }

        triggerSelect(range) {
            this.trigger("select", { range: range });
        }

        setDataSource(dataSource, columns) {
            if (this.dataSourceBinder) {
                this.dataSourceBinder.destroy();
            }

            this.dataSourceBinder = new SheetDataSourceBinder({
                dataSource: dataSource,
                sheet: this,
                columns: columns,
                createSheetDataSource: this.createSheetDataSource
            });

            this.dataSource = this.dataSourceBinder.dataSource;
        }

        hideColumn(columnIndex) {
            if (this.trigger("hideColumn", { index: columnIndex })) {
                return;
            }

            return this._property(this._columns.hide.bind(this._columns), columnIndex, { layout: true });
        }

        unhideColumn(columnIndex) {
            if (this.trigger("unhideColumn", { index: columnIndex })) {
                return;
            }

            return this._property(this._columns.unhide.bind(this._columns), columnIndex, { layout: true });
        }

        isHiddenColumn(columnIndex) {
            return this._grid._columns.hidden(columnIndex);
        }

        _copyRange(sourceRangeRef, targetRef) {
            var grid = this._grid;
            var rowCount = grid.rowCount;

            var nextRefTopLeft = grid.normalize(sourceRangeRef.topLeft);
            var nextRefBottomRight = grid.normalize(sourceRangeRef.bottomRight);

            var nextIndex = nextRefTopLeft.col * rowCount + nextRefTopLeft.row;
            var nextBottomIndex = nextRefBottomRight.col * rowCount + nextRefBottomRight.row;

            var targetIndex = targetRef.col * rowCount + targetRef.row;

            this._properties.copy(nextIndex, nextBottomIndex, targetIndex);
        }

        _saveModifiedFormulas(array, callback) {
            var save = MODIFIED_FORMULAS;
            MODIFIED_FORMULAS = array;
            var ret = callback();
            MODIFIED_FORMULAS = save;
            return ret;
        }

        _restoreModifiedFormulas(array) {
            var wb = this._workbook;
            array.forEach(function(f) {
                var sheet = wb.sheetByName(f.sheet), index;
                if (f instanceof calc.runtime.Formula) {
                    index = sheet._grid.cellRefIndex(f); // f has row, col
                    sheet._properties.set("formula", index, index, f);
                }
                if (f instanceof validationExport.Validation) {
                    index = sheet._grid.cellRefIndex(f); // f has row, col
                    sheet._properties.set("validation", index, index, f);
                }
            });
        }

        _adjustReferences(operation, start, delta, mergedCells) {
            this._mergedCells = mergedCells.reduce(function(a, ref) {
                ref = ref.adjust(null, null, null, null, operation === "row", start, delta);
                if (ref instanceof RangeRef) {
                    a.push(ref);
                }
                return a;
            }, []);
            if (this._workbook) {
                var affectedSheet = this._name();
                this._workbook._sheets.forEach(function(sheet) {
                    sheet._forFormulas(function(formula) {
                        var prev = formula.adjust(affectedSheet, operation, start, delta);
                        if (prev && MODIFIED_FORMULAS) {
                            // if formula.adjust returns non-null,
                            // that means the formula was indeed
                            // modified and the returned value is a
                            // copy of the previous Formula, which we
                            // can use for undoing the operation.
                            MODIFIED_FORMULAS.push(prev);
                        }
                    });

                    sheet._forValidations(function(validation) {
                        var prev = validation.adjust(affectedSheet, operation, start, delta);
                        if (prev && MODIFIED_FORMULAS) {
                            MODIFIED_FORMULAS.push(prev);
                        }
                    });
                });
                this._workbook.adjustNames(affectedSheet, operation === "row", start, delta);
            }
            var selection = this.select();
            selection = selection.adjust(null, null, null, null, operation === "row", start, delta);
            if (selection !== NULLREF) {
                this.select(selection);
            }
            // adjust column widths or row heights and hidden attribute
            var axis = operation === "col" ? this._columns : this._rows;
            axis.adjust(start, delta);

            if (operation === "row") {
                if (delta < 0) {
                    this._filteredRows.copy(start - delta, this._rows._count - 1, start);
                } else {
                    this._filteredRows.copy(start, this._rows._count, start + delta);
                    this._filteredRows.value(start, start + delta - 1, false);
                }
            }

            // adjust drawing anchor cells
            this._drawings.forEach(function(drawing) {
                if (drawing.topLeftCell) {
                    drawing.topLeftCell = drawing.topLeftCell.adjust(null, null, null, null,
                                                                        operation === "row", start, delta);
                }
            });
        }

        _forFormulas(callback) {
            var props = this._properties;
            var formulas = props.get("formula").values();
            var n = formulas.length;
            formulas.forEach(function(f, i) {
                callback.call(this, f.value, i, n);
            }, this);
        }

        _forValidations(callback) {
            var props = this._properties;
            props.get("validation").values().forEach(function(v) {
                callback.call(this, v.value);
            }, this);
        }

        insertRow(rowIndex, skipDataSourceInsert) {
            if (this.trigger("insertRow", { index: rowIndex })) {
                return;
            }

            this.batch(function() {
                this._resizeAddRow();

                var grid = this._grid;
                var columnCount = grid.columnCount;
                var rowCount = grid.rowCount;

                if (rowIndex + 1 === rowCount) {
                    // we just inserted after the last one, no need to shift data
                    return;
                }

                var frozenRows = this.frozenRows();

                if (rowIndex < frozenRows) {
                    this.frozenRows(frozenRows + 1);
                }

                var mergedCells = this._mergedCells.slice();

                for (var ci = 0; ci < columnCount; ci++) {
                    var ref = new RangeRef(new CellRef(rowIndex, ci), new CellRef(rowIndex, ci));

                    var topLeft = grid.normalize(ref.topLeft);
                    var bottomRight = grid.normalize(ref.bottomRight);

                    var nextRef = new RangeRef(
                        new CellRef(topLeft.row, topLeft.col),
                        new CellRef(rowCount - 2, bottomRight.col)
                    );

                    this._copyRange(nextRef, new CellRef(topLeft.row + 1, topLeft.col));

                    new Range$1(ref, this).clear({ clearAll: true, keepBorders: true });
                }

                this._adjustReferences("row", rowIndex, 1, mergedCells);
            }, {
                recalc: true,
                layout: true,
                insertRow: { index: rowIndex },
                ref: new RangeRef(new CellRef(rowIndex, 0), new CellRef(Infinity, Infinity))
            });

            if (!skipDataSourceInsert) {
                this.trigger("afterInsertRow", { index: rowIndex });
            }

            return this;
        }

        isEnabledRow(rowIndex) {
            var ref = new RangeRef(new CellRef(rowIndex, 0), new CellRef(rowIndex, this._grid.columnCount));
            return new Range$1(ref, this).enable();
        }

        deleteRow(rowIndex, skipDataSourceDelete) {
            if (!this.isEnabledRow(rowIndex)) {
                return this;
            }

            if (this.trigger("deleteRow", { index: rowIndex })) {
                return;
            }

            this.batch(function() {
                var grid = this._grid;
                var columnCount = grid.columnCount;

                var frozenRows = this.frozenRows();
                if (rowIndex < frozenRows) {
                    this.frozenRows(frozenRows - 1);
                }

                var mergedCells = this._mergedCells.slice();

                for (var ci = 0; ci < columnCount; ci++) {
                    var ref = new RangeRef(new CellRef(rowIndex, ci), new CellRef(rowIndex, ci));

                    new Range$1(ref, this).clear({ clearAll: true, keepBorders: true });

                    var topLeft = grid.normalize(ref.topLeft);
                    var bottomRight = grid.normalize(ref.bottomRight);

                    var nextRef = new RangeRef(
                        new CellRef(topLeft.row + 1, topLeft.col),
                        new CellRef(Infinity, bottomRight.col)
                    );

                    this._copyRange(nextRef, topLeft);

                    var nextRefBottomRight = grid.normalize(nextRef.bottomRight);

                    new Range$1(new RangeRef(nextRefBottomRight, nextRefBottomRight), this).clear();
                }

                this._adjustReferences("row", rowIndex, -1, mergedCells);

                this._resizeDeleteRow();
            }, {
                recalc: true,
                layout: true,
                deleteRow: { index: rowIndex },
                ref: new RangeRef(new CellRef(rowIndex, 0), new CellRef(Infinity, Infinity))
            });

            if (!skipDataSourceDelete) {
                this.trigger("afterDeleteRow", { index: rowIndex });
            }

            return this;
        }

        insertColumn(columnIndex) {
            if (this.trigger("insertColumn", { index: columnIndex })) {
                return;
            }

            this.batch(function() {
                this._resizeAddColumn();

                var grid = this._grid;
                var columnCount = grid.columnCount;

                if (columnIndex + 1 === columnCount) {
                    // we just inserted after the last one, no need to shift data
                    return;
                }

                var frozenColumns = this.frozenColumns();

                if (columnIndex < frozenColumns) {
                    this.frozenColumns(frozenColumns + 1);
                }

                var mergedCells = this._mergedCells.slice();

                for (var ci = columnCount; ci >= columnIndex; ci--) {
                    var ref = new RangeRef(new CellRef(0, ci), new CellRef(Infinity, ci));

                    new Range$1(ref, this).clear({ clearAll: true, keepBorders: true });

                    if (ci === columnIndex) {
                        break;
                    }

                    var topLeft = grid.normalize(ref.topLeft);
                    var bottomRight = grid.normalize(ref.bottomRight);

                    var nextRef = new RangeRef(
                        new CellRef(topLeft.row, topLeft.col - 1),
                        new CellRef(bottomRight.row, bottomRight.col - 1)
                    );

                    this._copyRange(nextRef, topLeft);
                }

                this._adjustReferences("col", columnIndex, 1, mergedCells);
            }, {
                recalc: true,
                layout: true,
                insertColumn: { index: columnIndex },
                ref: new RangeRef(new CellRef(0, columnIndex), new CellRef(Infinity, Infinity))
            });

            return this;
        }

        isEnabledColumn(columnIndex) {
            var ref = new RangeRef(new CellRef(0, columnIndex), new CellRef(Infinity, columnIndex));
            return new Range$1(ref, this).enable();
        }

        deleteColumn(columnIndex) {
            if (!this.isEnabledColumn(columnIndex)) {
                return this;
            }

            if (this.trigger("deleteColumn", { index: columnIndex })) {
                return;
            }

            this.batch(function() {
                var grid = this._grid;
                var columnCount = grid.columnCount;

                var frozenColumns = this.frozenColumns();

                if (columnIndex < frozenColumns) {
                    this.frozenColumns(frozenColumns - 1);
                }

                var mergedCells = this._mergedCells.slice();

                for (var ci = columnIndex; ci < columnCount; ci++) {
                    var ref = new RangeRef(new CellRef(0, ci), new CellRef(Infinity, ci));

                    new Range$1(ref, this).clear({ clearAll: true, keepBorders: true });

                    if (ci === columnCount - 1) {
                        break;
                    }

                    var topLeft = grid.normalize(ref.topLeft);
                    var bottomRight = grid.normalize(ref.bottomRight);

                    var nextRef = new RangeRef(
                        new CellRef(topLeft.row, topLeft.col + 1),
                        new CellRef(bottomRight.row, bottomRight.col + 1)
                    );

                    this._copyRange(nextRef, topLeft);
                }

                this._adjustReferences("col", columnIndex, -1, mergedCells);

                this._resizeDeleteColumn();
            }, {
                recalc: true,
                layout: true,
                deleteColumn: { index: columnIndex },
                ref: new RangeRef(new CellRef(0, columnIndex), new CellRef(Infinity, Infinity))
            });

            return this;
        }

        _filterRow(rowIndex) {
            this._rows.hide(rowIndex);
            this._filteredRows.value(rowIndex, rowIndex, true);
            this.triggerChange({ layout: true });
        }

        hideRow(rowIndex) {
            if (this.trigger("hideRow", { index: rowIndex })) {
                return;
            }
            return this._property(this._rows.hide.bind(this._rows), rowIndex, { layout: true });
        }

        unhideRow(rowIndex) {
            if (this.trigger("unhideRow", { index: rowIndex })) {
                return;
            }
            return this._property(this._rows.unhide.bind(this._rows), rowIndex, { layout: true });
        }

        isHiddenRow(rowIndex) {
            return this._grid._rows.hidden(rowIndex);
        }

        isFilteredRow(rowIndex) {
            return this._filteredRows.value(rowIndex);
        }

        columnWidth(columnIndex, width) {
            return this._property(this._columns.value.bind(this._columns, columnIndex, columnIndex), width, { layout: true });
        }

        rowHeight(rowIndex, height) {
            return this._property(this._rows.value.bind(this._rows, rowIndex, rowIndex), height, { layout: true });
        }

        frozenRows(value) {
            return this._field("_frozenRows", value, { layout: true });
        }

        frozenColumns(value) {
            return this._field("_frozenColumns", value, { layout: true });
        }

        showGridLines(value) {
            return this._field("_showGridLines", value, { layout: true });
        }

        gridLinesColor(value) {
            return this._field("_gridLinesColor", value, { layout: true });
        }

        _ref(row, column, numRows, numColumns) {
            var ref = null;

            if (row instanceof Ref) {
                return row;
            }

            if (row instanceof Range$1) {
                return row._ref.toRangeRef();
            }

            if (typeof row === "string") {
                ref = calc.parseReference(row);
            } else {
                if (!numRows) {
                    numRows = 1;
                }

                if (!numColumns) {
                    numColumns = 1;
                }
                ref = new RangeRef(new CellRef(row, column), new CellRef(row + numRows - 1, column + numColumns - 1));
            }

            return ref;
        }

        range(row, column, numRows, numColumns) {
            return new Range$1(this._ref(row, column, numRows, numColumns), this);
        }

        _getMergedCells(range) {
            var grid = this._grid;
            var primary = {};
            var secondary = {};
            var hasMerged = false;

            this.forEachMergedCell(range, function(ref) {
                var topLeft = ref.topLeft;
                grid.forEach(ref, function(cellRef) {
                    if (topLeft.eq(cellRef)) {
                        primary[cellRef.print()] = ref;
                        hasMerged = true;
                    } else if (range.contains(cellRef)) {
                        secondary[cellRef.print()] = topLeft;
                        hasMerged = true;
                    }
                });
            });

            return { primary: primary, secondary: secondary, hasMerged: hasMerged };
        }

        forEachMergedCell(ref, callback) {
            var selectAll = false;

            if (typeof callback === "undefined") {
                callback = ref;
                selectAll = true;
            }

            this._mergedCells.forEach(function(merged) {
                if (selectAll || merged.intersects(ref)) {
                    callback(merged);
                }
            });
        }

        forEachFilterHeader(ref, callback) {
            var selectAll = false;

            if (typeof callback === "undefined") {
                callback = ref;
                selectAll = true;
            }

            if (this._filter) {
                var refs = [];

                // get refs of all columns
                this._filter.ref.forEachColumn(function(columnRef) {
                    if (selectAll || columnRef.intersects(ref)) {
                        refs.push(columnRef.topLeft);
                    }
                });

                // filter out merged references
                this._mergedCells.forEach(function(merged) {
                    refs = refs.map(function(ref) {
                        if (merged.intersects(ref)) {
                            return merged;
                        }

                        return ref;
                    });
                });

                // use only unique refs
                refs.reduce(function unique(result, element) {
                    if (result.indexOf(element) < 0) {
                        result.push(element);
                    }

                    return result;
                }, []).forEach(callback);
            }
        }

        forEach(ref, callback) {
            var self = this;
            function forEachRange(ref) {
                if (!(ref instanceof RangeRef)) {
                    ref = ref.toRangeRef();
                }
                var topLeft = self._grid.normalize(ref.topLeft);
                var bottomRight = self._grid.normalize(ref.bottomRight);
                var ci, ri;

                function doIt(value) {
                    callback(ri++, ci, value);
                }

                for (ci = topLeft.col; ci <= bottomRight.col; ci++) {
                    ri = topLeft.row;
                    var startCellIndex = self._grid.index(ri, ci);
                    var endCellIndex = self._grid.index(bottomRight.row, ci);
                    self._properties.forEach(startCellIndex, endCellIndex, doIt);
                }
            }

            if (!(ref instanceof RangeRef)) {
                ref = self._ref(ref);
            }

            if (ref instanceof UnionRef) {
                // _ref() might still return a UnionRef, for instance, if
                // `ref` happens to be one.  Probably an oversight, but it
                // turns out to be useful.
                ref.forEach(forEachRange);
            } else {
                forEachRange(ref);
            }
        }

        startResizing(initialPosition) {
            this._initialPosition = initialPosition;
            this._resizeInProgress = true;
        }

        startAutoFill() {
            this._autoFillInProgress = true;
            var selection = this.select();
            this._autoFillOrigin = selection;
            this._autoFillDest = selection;
            this.triggerChange({ selection: true });
        }

        updateAutoFill(dest, punch, hint, direction) {
            this._autoFillDest = dest;
            this._autoFillPunch = punch;
            this._autoFillHint = hint;
            this._autoFillDirection = direction;
            this.triggerChange({ selection: true });
        }

        autoFillRef() {
            return this._autoFillDest;
        }

        autoFillPunch() {
            return this._autoFillPunch;
        }

        autoFillInProgress() {
            return this._autoFillInProgress;
        }

        resizingInProgress() {
            return this._resizeInProgress;
        }

        draggingInProgress() {
            return this._draggingInProgress;
        }

        completeResizing() {
            if (this._resizeInProgress) {
                this._resizeInProgress = false;
                var hintPosition = this.resizeHintPosition();

                if (this._initialPosition && hintPosition) {
                    var handlePosition = this.resizeHandlePosition();
                    if (handlePosition.col !== -Infinity) {
                        this.trigger("commandRequest", {
                            command: "ColumnWidthCommand",
                            options: {
                                target: handlePosition.col,
                                value: this.columnWidth(handlePosition.col) - (this._initialPosition.x - hintPosition.x)
                            }
                        });
                    } else {
                        this.trigger("commandRequest", {
                            command: "RowHeightCommand",
                            options: {
                                target: handlePosition.row,
                                value: this.rowHeight(handlePosition.row) - (this._initialPosition.y - hintPosition.y)
                            }
                        });
                    }
                } else {
                    this.trigger("change", { resize: true });
                }
            }
        }

        _visualRange(ref) {
            var merged = this._mergedCells;
            for (var i = merged.length; --i >= 0;) {
                if (merged[i].intersects(ref)) {
                    return this.range(merged[i]);
                }
            }
            return this.range(ref);
        }

        _renderComment(ref) {
            var comment = null;
            if (ref) {
                var range = this._visualRange(ref);
                comment = range.comment();
                ref = range._ref.toRangeRef().topLeft;
            }
            if (comment) {
                if (!this._commentRef || !ref.eq(this._commentRef)) {
                    this._commentRef = ref;
                    this.trigger("change", { comment: true });
                }
            } else {
                if (this._commentRef) {
                    this._commentRef = null;
                    this.trigger("change", { comment: true });
                }
            }
        }

        resizeHandlePosition() {
            return this._resizeHandlePosition;
        }

        resizeHintPosition(location) {
            if (location !== undefined) {
                this._resizeHintPosition = location;
                this.trigger("change", { resize: true });
            }
            return this._resizeHintPosition;
        }

        removeResizeHandle() {
            if (this._resizeHandlePosition) {
                this._resizeHintPosition = undefined;
                this._resizeHandlePosition = undefined;
                this._initialPosition = undefined;
                this.trigger("change", { resize: true });
            }
        }

        positionResizeHandle(ref) {
            this._resizeHandlePosition = ref;
            this.trigger("change", { resize: true });
        }

        startDragging(data) {
            this._draggingInProgress = data;
        }

        completeDragging() {
            var drag = this._draggingInProgress;
            if (drag) {
                this._draggingInProgress = null;
                var drawing = drag.drawing;
                if (drawing.eq(drag.copy)) {
                    return;
                }
                if (drawing.topLeftCell) {
                    // adjust reference - in case the top-left corner
                    // was moving, select the cell beneath it.
                    var box = this.drawingBoundingBox(drawing);
                    var row = this._rows.indexVisible(box.top);
                    var col = this._columns.indexVisible(box.left);
                    var ref = new CellRef(row, col);
                    var refBox = this.refBoundingBox(ref);
                    drawing.offsetX = box.left - refBox.left;
                    drawing.offsetY = box.top - refBox.top;
                    drawing.topLeftCell = ref;
                    this.triggerChange({ dragging: true });
                }
                this.trigger("commandRequest", {
                    command: "DrawingUpdateCommand",
                    options: {
                        sheet    : this,
                        drawing  : drawing,
                        previous : drag.copy
                    }
                });
            }
        }

        startSelection(view) {
            if (this.frozenRows() || this.frozenColumns()) {
                this._currentView = null;
            } else if (view && view._sheet === this) {
                this._currentView = view;
            }
            this._selectionInProgress = true;
        }

        completeSelection() {
            if (this._selectionInProgress) {
                this._selectionInProgress = false;
                this._resizeHintPosition = undefined;
                this.trigger("change", { selection: true });
            }
            if (this._autoFillInProgress) {
                this._autoFillInProgress = false;
                var dest = this._autoFillDest;
                var origin = this._autoFillOrigin;

                if (this._autoFillPunch) { // we just clear data here
                    this.trigger("commandRequest", {
                        command: "ClearContentCommand", options: { operatingRange: this.range(this._autoFillPunch) }
                    });
                } else {
                    if (!dest.eq(origin)) {
                        this.trigger("commandRequest", {
                            command: "AutoFillCommand", options: { operatingRange: this.range(dest), origin: this.range(origin) }
                        });
                    } else {
                        this.triggerChange({ selection: true });
                    }
                }

                this._autoFillDest = null;
                this._autoFillPunch = null;
                this._autoFillOrigin = null;

                this.select(dest);
            }
        }

        selectionInProgress() {
            return this._selectionInProgress;
        }

        select(ref, changeActiveCell) {
            var selectionState = this._selectionState();

            var expandedRef;

            if (ref) {
                ref = this._ref(ref);
                ref = this._grid.normalize(ref);
                expandedRef = this._grid.isAxis(ref) ? ref : this.unionWithMerged(ref);
            }

            return selectionState.select(ref, expandedRef, changeActiveCell, this._currentView);
        }

        originalSelect() {
            return this._selectionState().originalSelection;
        }

        currentSelectionRange() {
            return this._selectionState().currentSelectionRange();
        }

        currentOriginalSelectionRange() {
            return this._selectionState().currentOriginalNavigationRange();
        }

        currentNavigationRange() {
            return this._selectionState().currentNavigationRange();
        }

        nextNavigationRange() {
            return this._selectionState().nextNavigationRange();
        }

        previousNavigationRange() {
            return this._selectionState().previousNavigationRange();
        }

        selectionRangeIndex() {
            return this._selectionState().selectionRangeIndex;
        }

        activeCell(ref) {
            return this._selectionState().activeCell(ref);
        }

        originalActiveCell() {
            return this._selectionState().originalActiveCell;
        }

        singleCellSelection() {
            return this._selectionState().singleCellSelection();
        }

        unionWithMerged(ref) {
            var mergedCells = this._mergedCells;

            return ref.map(function(ref) {
                return ref.toRangeRef().union(mergedCells);
            });
        }

        trim(ref) {
            var trims = [];
            var grid = this._grid;
            this._properties.forEachProperty(function(property) {
                trims.push(grid.trim(ref, property.list));
            });
            return this.unionWithMerged(ref.topLeft.toRangeRef().union(trims));
        }

        focus(ref) {
            if (ref) {
                this._focus = ref.toRangeRef();
            } else {
                var focus = this._focus;
                this._focus = null;
                return focus;
            }
        }

        activeCellSelection() {
            return new Range$1(this._grid.normalize(this.activeCell()), this);
        }

        selection() {
            return new Range$1(this._grid.normalize(this._selectionState().selection), this);
        }

        selectedHeaders() {
            var selection = this.select();

            var rows = {};
            var cols = {};
            var allCols = false;
            var allRows = false;
            var maxRow = this._grid.rowCount - 1;
            var maxCol = this._grid.columnCount - 1;

            selection.forEach(function(ref) {
                var i;
                var rowState = "partial";
                var colState = "partial";
                ref = ref.toRangeRef();

                var bottomRight = ref.bottomRight;
                var topLeft = ref.topLeft;

                var rowSelection = topLeft.col <= 0 && bottomRight.col >= maxCol;
                var colSelection = topLeft.row <= 0 && bottomRight.row >= maxRow;

                if (colSelection) { //column selection
                    allRows = true;
                    colState = "full";
                }

                if (rowSelection) { //row selection
                    allCols = true;
                    rowState = "full";
                }

                if (!colSelection) { //column selection
                    for (i = topLeft.row; i <= bottomRight.row; i++) {
                        if (rows[i] !== "full") {
                            rows[i] = rowState;
                        }
                    }
                }

                if (!rowSelection) {
                    for (i = topLeft.col; i <= bottomRight.col; i++) {
                        if (cols[i] !== "full") {
                            cols[i] = colState;
                        }
                    }
                }
            });

            return {
                rows: rows,
                cols: cols,
                allRows: allRows,
                allCols: allCols,
                all: allRows && allCols
            };
        }

        isInEditMode(isInEdit) {
            if (isInEdit === undefined) {
                return this._inEdit;
            }

            this._inEdit = isInEdit;

            if (isInEdit) {
                this._editSelection.selection = this._viewSelection.selection.clone();
                this._editSelection.originalSelection = this._viewSelection.originalSelection.clone();
                this._editSelection._activeCell = this._viewSelection._activeCell.clone();
                this._editSelection.originalActiveCell = this._viewSelection.originalActiveCell.clone();
            }
        }

        _setFormulaSelections(selection) {
            this._formulaSelections = (selection || []).slice();
            this.triggerChange({ selection: true });
        }

        _viewActiveCell() {
            return this._viewSelection._activeCell.toRangeRef();
        }

        toJSON() {
            var positions = {};

            var rows = this._rows.toJSON("height", positions);
            var columns = this._columns.toJSON("width", {});
            var viewSelection = this._viewSelection;
            var hyperlinks = [];
            var defaultCellStyle = this._defaultCellStyle || {};

            function clearDefaultStyle(cell) {
                Object.keys(defaultCellStyle).forEach(function(key) {
                    if (cell[key] === defaultCellStyle[key]) {
                        delete cell[key];
                    }
                });
            }

            this.forEach(SHEETREF, function(row, col, cell) {
                clearDefaultStyle(cell);

                if (Object.keys(cell).length === 0) {
                    return;
                }

                if (cell.link) {
                    hyperlinks.push({
                        ref    : Ref.display(null, row, col),
                        target : cell.link
                    });
                }

                var position = positions[row];

                if (position === undefined) {
                    position = rows.length;
                    rows.push({ index: row });
                    positions[row] = position;
                }

                row = rows[position];

                cell.index = col;

                if (row.cells === undefined) {
                    row.cells = [];
                }

                if (cell.formula) {
                    // stringify Formula object.
                    if (cell.formula.arrayFormulaRange) {
                        cell.formula = {
                            src: cell.formula.toString(),
                            ref: cell.formula.arrayFormulaRange.toString()
                        };
                    } else {
                        cell.formula = cell.formula.toString();
                    }
                }

                if (cell.validation) {
                    cell.validation = cell.validation.toJSON();
                }

                if (cell.color) {
                    cell.color = kendoDrawing.parseColor(cell.color).toCss();
                }

                if (cell.background) {
                    cell.background = kendoDrawing.parseColor(cell.background).toCss();
                }

                if (cell.borderTop && cell.borderTop.color) {
                    cell.borderTop.color = kendoDrawing.parseColor(cell.borderTop.color).toCss();
                }

                if (cell.borderBottom && cell.borderBottom.color) {
                    cell.borderBottom.color = kendoDrawing.parseColor(cell.borderBottom.color).toCss();
                }

                if (cell.borderRight && cell.borderRight.color) {
                    cell.borderRight.color = kendoDrawing.parseColor(cell.borderRight.color).toCss();
                }

                if (cell.borderLeft && cell.borderLeft.color) {
                    cell.borderLeft.color = kendoDrawing.parseColor(cell.borderLeft.color).toCss();
                }

                row.cells.push(cell);
            });

            var json = {
                name: this._name(),
                state: this._state(),
                rows: rows,
                columns: columns,
                selection: viewSelection.selection.toString(),
                activeCell: viewSelection.activeCell().toString(),
                frozenRows: this.frozenRows(),
                frozenColumns: this.frozenColumns(),
                showGridLines: this.showGridLines(),
                gridLinesColor: this.gridLinesColor(),
                mergedCells: this._mergedCells.map(function(ref) {
                    return ref.toString();
                }),
                hyperlinks: hyperlinks,
                defaultCellStyle: defaultCellStyle,
                drawings: this._drawings.map(function(dr) {
                    return dr.toJSON();
                })
            };

            if (this._sort) {
                json.sort = {
                    ref: this._sort.ref.toString(),
                    columns: this._sort.columns.map(function(column) {
                        return {
                            index: column.index,
                            ascending: column.ascending
                        };
                    })
                };
            }

            if (this._filter) {
                json.filter = {
                    ref: this._filter.ref.toString(),
                    columns: this._filter.columns.map(function(column) {
                        var filter = column.filter.toJSON();
                        filter.index = column.index;
                        return filter;
                    })
                };
            }

            return json;
        }

        fromJSON(json) {
            this.batch(function() {
                if (json.name !== undefined) {
                    this._name(json.name);
                }

                if (json.frozenColumns !== undefined) {
                    this.frozenColumns(json.frozenColumns);
                }

                if (json.frozenRows !== undefined) {
                    this.frozenRows(json.frozenRows);
                }

                if (json.columns !== undefined) {
                    this._columns.fromJSON("width", json.columns);
                }

                if (json.rows !== undefined) {
                    this._resizeForJSON(json.rows);
                    this._rows.fromJSON("height", json.rows);

                    for (var ri = 0; ri < json.rows.length; ri++) {
                        var row = json.rows[ri];
                        var rowIndex = row.index;

                        if (rowIndex === undefined) {
                            rowIndex = ri;
                        }

                        if (row.cells) {
                            for (var ci = 0; ci < row.cells.length; ci++) {
                                var cell = row.cells[ci];
                                var columnIndex = cell.index;

                                if (columnIndex === undefined) {
                                    columnIndex = ci;
                                }

                                if (cell.formula) {
                                    var isArray = typeof cell.formula != "string";
                                    var src = isArray ? cell.formula.src : cell.formula;
                                    var formula = this._compileFormula(rowIndex, columnIndex, src);
                                    if (isArray) {
                                        formula.setArrayFormulaRange(
                                            calc.parseReference(cell.formula.ref));
                                    }
                                    cell.formula = formula;
                                }

                                if (cell.validation) {
                                    cell.validation = this._compileValidation(rowIndex, columnIndex, cell.validation);
                                }

                                this._properties.fromJSON(this._grid.index(rowIndex, columnIndex), cell);
                            }
                        }
                    }
                }

                if (json.drawings) {
                    this._drawings = json.drawings.map(Drawing.fromJSON);
                }

                if (json.selection) {
                    this._viewSelection.selection =
                        this._viewSelection.originalSelection = this._ref(json.selection);
                }

                if (json.activeCell) {
                    var activeCellRef = this._ref(json.activeCell);

                    this._viewSelection._activeCell = activeCellRef.toRangeRef();
                    this._viewSelection.originalActiveCell = activeCellRef.first();
                }


                if (json.mergedCells) {
                    json.mergedCells.forEach(function(ref) {
                        this.range(ref).merge();
                    }, this);
                }

                if (json.filter) {
                    var ref = json.filter.ref;
                    var columns = json.filter.columns === undefined ? [] : json.filter.columns;

                    if (!ref) ; else {
                        this._filter = {
                            ref: this._ref(ref),
                            columns: columns.map(function(column) {
                                return {
                                    index: column.index,
                                    filter: Filter.create(column)
                                };
                            })
                        };

                        this._refreshFilter();
                    }
                }

                if (json.showGridLines !== undefined) {
                    this._showGridLines = json.showGridLines;
                }

                this._gridLinesColor = json.gridLinesColor;

                if (json.sort) {
                    this._sortBy(this._ref(json.sort.ref), json.sort.columns.slice(0));
                }
            });

            this._rows._refresh();
            this._columns._refresh();
        }

        formula(ref) {
            return this._properties.get("formula", this._grid.cellRefIndex(ref));
        }

        validation(ref) {
            return this._properties.get("validation", this._grid.cellRefIndex(ref));
        }

        // NOTE: resetFormulas should be called first.  We don't do it in this
        // function because it should be done from the Workbook object for all
        // sheets.
        resetFormulas() {
            this._forFormulas(function(formula) {
                formula.reset();
            });
        }

        resetValidations() {
            this._forValidations(function(validation) {
                validation.reset();
            });
        }

        recalc(context, callback) {
            var formulas = this._properties.get("formula").values();
            var count = formulas.length, pending = 0, i = 0;
            if (!count && callback) {
                return callback();
            }
            function next() {
                pending--;
                if (i === count && !pending) {
                    callback();
                }
            }
            while (i < count) {
                pending++;
                formulas[i++].value.exec(context, callback ? next : null);
            }
        }

        revalidate(context) {
            var self = this;
            this._forValidations(function(validation) {
                var cellRef = new CellRef(validation.row, validation.col);
                var ref = new RangeRef(cellRef, cellRef);
                validation.exec(context, self._get(ref, "value"), self._get(ref, "format"));
            });
        }

        _value(row, col, value) {
            var index = this._grid.index(row, col);

            if (value !== undefined) {
                this._properties.set("value", index, index, value);
            } else {
                return this._properties.get("value", index);
            }
        }

        _validation(row, col) {
            var index = this._grid.index(row, col);

            return this._properties.get("validation", index);
        }

        _compileValidation(row, col, curValidation) {
            if (curValidation instanceof validationExport.Validation) {
                // do not alter an existing object.
                return curValidation.clone(this._name(), row, col);
            }

            if (curValidation.from != null) {
                curValidation.from = (curValidation.from + "").replace(/^=/, "");
            }

            if (curValidation.to != null) {
                curValidation.to = (curValidation.to + "").replace(/^=/, "");
            }

            return validationExport.compile(this._name(), row, col, curValidation);
        }

        _compileFormula(row, col, f) {
            f = f.replace(/^=/, "");
            f = calc.parseFormula(this._name(), row, col, f);
            return calc.compile(f);
        }

        _copyValuesInRange(topLeft, bottomRight, value, property) {
            var ci, start, end;

            for (ci = topLeft.col; ci <= bottomRight.col; ci++) {
                start = this._grid.index(topLeft.row, ci);
                end = this._grid.index(bottomRight.row, ci);
                for (var index = start, row = topLeft.row; index <= end; ++index, ++row) {
                    // Even if it's the same formula in multiple cells, we
                    // need to have different Formula objects, hence cloning
                    // it.  Don't worry, clone() is fast.
                    value = value.clone(this._name(), row, ci);
                    this._properties.set(property, index, index, value);
                }
            }
            return value;
        }

        _set(ref, name, value) {
            var topLeft = this._grid.normalize(ref.topLeft);
            var bottomRight = this._grid.normalize(ref.bottomRight);
            var ci, start, end;

            if (typeof value == "number") {
                // Apparently, Excel (and LibreOffice and Google
                // Sheets) will limit precision to 14 digits; type:
                // -4.2524999999999995 and you get -4.2525.  The
                // formula engine already does something similar for
                // intermediate formula results, but we must do it
                // here as well for original input values.
                value = calc.runtime.limitPrecision(value);
            }

            if (value && name === "formula") {
                if (typeof value == "string") {
                    // get Formula object.  we don't care about handling errors
                    // here since it won't be called interactively.
                    value = this._compileFormula(topLeft.row, topLeft.col, value);
                }

                value = this._copyValuesInRange(topLeft, bottomRight, value, "formula");

            } else if (value && name === "validation") {
                value = this._compileValidation(topLeft.row, topLeft.col, value);
                value = this._copyValuesInRange(topLeft, bottomRight, value, "validation");

            } else {
                for (ci = topLeft.col; ci <= bottomRight.col; ci++) {
                    start = this._grid.index(topLeft.row, ci);
                    end = this._grid.index(bottomRight.row, ci);
                    this._properties.set(name, start, end, value);
                    if (name === "formula") {
                        // removing a formula, must clear value.
                        this._properties.set("value", start, end, null);
                    }
                }
            }
        }

        _get(ref, name) {
            var topLeft = this._grid.normalize(ref.topLeft);

            var index = this._grid.index(topLeft.row, topLeft.col);

            return this._properties.get(name, index);
        }

        batch(callback, reason) {
            var suspended = this.suspendChanges();

            this.suspendChanges(true);
            this._valueChanged = false;

            callback.call(this);

            if (!reason) {
                reason = { recalc: true };
            }
            if (this._valueChanged) {
                reason.isValue = true;
            }

            return this.suspendChanges(suspended).triggerChange(reason);
        }

        _sortBy(ref, columns) {
            var indices = null;

            columns.forEach(function(column) {
                indices = this._sorter.sortBy(ref, column.index, this._properties.get("value"), column.ascending, indices);
            }, this);

            this._sort = {
                ref: ref,
                columns: columns
            };

            this._refreshFilter();

            this.forEach(ref, function(row, col, props) {
                var formula = props.formula;
                if (formula) {
                    var diff = row - formula.row;
                    if (diff !== 0) {
                        var start = diff > 0 ? formula.row : formula.row + diff;
                        formula.adjust(this.name(), "row", start, diff);
                    }
                }
            }.bind(this));

            this.triggerChange({ recalc: true });
        }

        _refreshFilter() {
            if (this._filter) {
                this._filterBy(this._filter.ref, this._filter.columns);
            }
        }

        _filterBy(ref, columns) {
            this.batch(function() {
                for (var ri = ref.topLeft.row; ri <= ref.bottomRight.row; ri++) {
                    if (this.isFilteredRow(ri)) {
                        this._filteredRows.value(ri, ri, false);
                        this._rows.unhide(ri);
                    }
                }

                columns.forEach(function(column) {
                    // do not filter header row
                    var columnRef = ref.resize({ top: 1 }).toColumn(column.index);

                    var cells = [];

                    if (columnRef === NULLREF) {
                        return;
                    }

                    this.forEach(columnRef, function(row, col, cell) {
                        cell.row = row;
                        cells.push(cell);
                    });

                    column.filter.prepare(cells);

                    for (var ci = 0; ci < cells.length; ci++) {
                        var cell = cells[ci];
                        var value = column.filter.value(cell);

                        if (column.filter.matches(value) === false) {
                            this._filterRow(cell.row);
                        }
                    }
                }, this);

                this._filter = {
                    ref: ref,
                    columns: columns
                };
            }, { recalc: true, layout: true, filter: true });
        }

        filterColumn(ref) {
            var filterRef = this.filter().ref;
            return ref.toRangeRef().topLeft.col - filterRef.topLeft.col;
        }

        filter() {
            return this._filter;
        }

        clearFilter(spec) {
            this._clearFilter(spec instanceof Array ? spec : [spec]);
        }

        _clearFilter(indices) {
            if (this._filter) {
                this.batch(function() {
                    this._filter.columns = this._filter.columns.filter(function(column) {
                        return indices.indexOf(column.index) < 0;
                    });

                    this._refreshFilter();
                }, { recalc: true, layout: true, filter: true });
            }
        }

        getAxisState() {
            return {
                rows: this._rows.getState(),
                columns: this._columns.getState()
            };
        }

        setAxisState(state) {
            this._rows.setState(state.rows);
            this._columns.setState(state.columns);
            this.triggerChange({ layout: true });
        }

        getState() {
            return {
                rows: this._rows.getState(),
                columns: this._columns.getState(),
                mergedCells: this._mergedCells.map(function(cell) { return cell.clone(); }),
                properties: this._properties.getState()
            };
        }

        setState(state) {
            this._rows.setState(state.rows);
            this._columns.setState(state.columns);
            this._mergedCells = state.mergedCells;
            this._properties.setState(state.properties);
            this.triggerChange(ALL_REASONS);
        }

        _merge(ref) {
            var mergedCells = this._mergedCells;

            var sheet = this;
            var mergedRef;
            this.batch(function() {
                mergedRef = ref.map(function(ref) {
                    if (ref instanceof CellRef) {
                        return ref;
                    }

                    var currentRef = ref.toRangeRef().union(mergedCells, function(ref) {
                        mergedCells.splice(mergedCells.indexOf(ref), 1);
                    });

                    var range = new Range$1(currentRef, sheet);
                    var formula = range._get("formula");
                    var value = range.value();
                    var format = range.format();
                    var background = range.background();

                    range.value(null);
                    range.format(null);
                    range.background(null);

                    var topLeft = new Range$1(currentRef.collapse(), sheet);

                    if (formula) {
                        topLeft._set("formula", formula);
                    } else {
                        topLeft.value(value);
                    }
                    topLeft.format(format);
                    topLeft.background(background);

                    mergedCells.push(currentRef);
                    return currentRef;
                });

                var viewSelection = sheet._viewSelection;

                viewSelection.selection = sheet.unionWithMerged(viewSelection.originalSelection);
                viewSelection._activeCell = sheet.unionWithMerged(viewSelection.originalActiveCell);
            }, { activeCell: true, selection: true });

            return mergedRef;
        }

        _useCultureDecimals() {
            return this._workbook && this._workbook.options.useCultureDecimals;
        }

        withCultureDecimals(f) {
            var dot = ".";
            if (this._useCultureDecimals()) {
                dot = culture().numbers.symbols.decimal;
            }
            return calc.withDecimalSeparator(dot, f);
        }

        drawingBoundingBox(drawing) {
            var left = drawing.offsetX;
            var top = drawing.offsetY;
            if (drawing.topLeftCell) {
                // offsets are relative to cell
                left += this._columns.sum(0, drawing.topLeftCell.col - 1);
                top += this._rows.sum(0, drawing.topLeftCell.row - 1);
            }
            return new Rectangle(left, top, drawing.width, drawing.height);
        }

        refBoundingBox(ref) {
            return this._grid.rectangle(ref.toRangeRef());
        }

        addDrawing(drw, activate) {
            if (!(drw instanceof Drawing)) {
                drw = new Drawing(drw);
            }
            this._drawings.push(drw);
            if (activate) {
                this._activeDrawing = drw;
            }
            this.triggerChange({ layout: true });
            return drw;
        }

        removeDrawing(drawing) {
            var pos = this._drawings.indexOf(drawing);
            if (pos >= 0) {
                this._drawings.splice(pos, 1);
                this.triggerChange({ layout: true });
            }
        }

        usesImage(img) {
            for (var i = this._drawings.length; --i >= 0;) {
                if (this._drawings[i].image === img) {
                    return true;
                }
            }
            return false;
        }

        isMerged(ref) {
            var merged = this._mergedCells;
            for (var i = merged.length; --i >= 0;) {
                if (merged[i].eq(ref)) {
                    return true;
                }
            }
            return false;
        }
    }

    class Drawing {
        constructor(args) {
            this.reset(args);
        }

        toJSON() {
            return {
                topLeftCell: this.topLeftCell.toString(),
                offsetX: this.offsetX,
                offsetY: this.offsetY,
                width: this.width,
                height: this.height,
                image: this.image,
                opacity: this.opacity
            };
        }

        clone() {
            return new Drawing(this);
        }

        reset(dr) {
            var anchor = dr.topLeftCell;
            if (typeof anchor == "string") {
                anchor = calc.parseReference(anchor);
            }
            this.topLeftCell = anchor;
            this.offsetX = dr.offsetX || 0;
            this.offsetY = dr.offsetY || 0;
            this.width = dr.width;
            this.height = dr.height;
            this.image = dr.image;
            this.opacity = dr.opacity != null ? dr.opacity : 1;
        }

        eq(dr) {
            return ((!this.topLeftCell && !dr.topLeftCell)
                    || (this.topLeftCell && dr.topLeftCell
                        && this.topLeftCell.eq(dr.topLeftCell)))
                && this.offsetX === dr.offsetX
                && this.offsetY === dr.offsetY
                && this.width === dr.width
                && this.height === dr.height
                && this.image === dr.image
                && this.opacity === dr.opacity;
        }
    }

    Drawing.fromJSON = function(args) {
        return new Drawing(args);
    };

    /* eslint-disable no-param-reassign */
    /* eslint-disable key-spacing */
    let PAPER_SIZE = {
        a0        : [ 2383.94 , 3370.39 ],
        a1        : [ 1683.78 , 2383.94 ],
        a2        : [ 1190.55 , 1683.78 ],
        a3        : [ 841.89 , 1190.55 ],
        a4        : [ 595.28 , 841.89 ],
        a5        : [ 419.53 , 595.28 ],
        a6        : [ 297.64 , 419.53 ],
        a7        : [ 209.76 , 297.64 ],
        a8        : [ 147.40 , 209.76 ],
        a9        : [ 104.88 , 147.40 ],
        a10       : [ 73.70 , 104.88 ],
        b0        : [ 2834.65 , 4008.19 ],
        b1        : [ 2004.09 , 2834.65 ],
        b2        : [ 1417.32 , 2004.09 ],
        b3        : [ 1000.63 , 1417.32 ],
        b4        : [ 708.66 , 1000.63 ],
        b5        : [ 498.90 , 708.66 ],
        b6        : [ 354.33 , 498.90 ],
        b7        : [ 249.45 , 354.33 ],
        b8        : [ 175.75 , 249.45 ],
        b9        : [ 124.72 , 175.75 ],
        b10       : [ 87.87 , 124.72 ],
        c0        : [ 2599.37 , 3676.54 ],
        c1        : [ 1836.85 , 2599.37 ],
        c2        : [ 1298.27 , 1836.85 ],
        c3        : [ 918.43 , 1298.27 ],
        c4        : [ 649.13 , 918.43 ],
        c5        : [ 459.21 , 649.13 ],
        c6        : [ 323.15 , 459.21 ],
        c7        : [ 229.61 , 323.15 ],
        c8        : [ 161.57 , 229.61 ],
        c9        : [ 113.39 , 161.57 ],
        c10       : [ 79.37 , 113.39 ],
        executive : [ 521.86 , 756.00 ],
        folio     : [ 612.00 , 936.00 ],
        legal     : [ 612.00 , 1008.00 ],
        letter    : [ 612.00 , 792.00 ],
        tabloid   : [ 792.00 , 1224.00 ]
    };

    function mm2pt(mm) {
        return mm * (72 / 25.4);
    }

    function cm2pt(cm) {
        return mm2pt(cm * 10);
    }

    function in2pt(inch) {
        return inch * 72;
    }

    function unitsToPoints(x, def) {
        if (typeof x == "number") {
            return x;
        }
        if (typeof x == "string") {
            let m;
            m = /^\s*([0-9.]+)\s*(mm|cm|in|pt)\s*$/.exec(x);
            if (m) {
                let num = parseFloat(m[1]);
                if (!isNaN(num)) {
                    if (m[2] === "pt") {
                        return num;
                    }
                    return {
                        "mm": mm2pt,
                        "cm": cm2pt,
                        "in": in2pt
                    }[m[2]](num);
                }
            }
        }
        if (def != null) {
            return def;
        }
        throw new Error("Can't parse unit: " + x);
    }

    function getPaperOptions(getOption) {
        if (typeof getOption != "function") {
            let options = getOption;
            getOption = function(key, def) {
                return key in options ? options[key] : def;
            };
        }
        let paperSize = getOption("paperSize", PAPER_SIZE.a4);
        if (!paperSize) {
            return {};
        }
        if (typeof paperSize == "string") {
            paperSize = PAPER_SIZE[paperSize.toLowerCase()];
            if (paperSize == null) {
                throw new Error("Unknown paper size");
            }
        }

        paperSize[0] = unitsToPoints(paperSize[0]);
        paperSize[1] = unitsToPoints(paperSize[1]);

        if (getOption("landscape", false)) {
            paperSize = [
                Math.max(paperSize[0], paperSize[1]),
                Math.min(paperSize[0], paperSize[1])
            ];
        }

        let margin = getOption("margin");
        if (margin) {
            if (typeof margin == "string" || typeof margin == "number") {
                margin = unitsToPoints(margin, 0);
                margin = { left: margin, top: margin, right: margin, bottom: margin };
            } else {
                margin = {
                    left   : unitsToPoints(margin.left, 0),
                    top    : unitsToPoints(margin.top, 0),
                    right  : unitsToPoints(margin.right, 0),
                    bottom : unitsToPoints(margin.bottom, 0)
                };
            }
            if (getOption("addMargin")) {
                paperSize[0] += margin.left + margin.right;
                paperSize[1] += margin.top + margin.bottom;
            }
        }
        return { paperSize: paperSize, margin: margin };
    }

    /* eslint-disable no-nested-ternary */
    /* eslint-disable default-case */
    /* eslint-disable no-implicit-coercion */
    /* eslint-disable no-else-return */
    /* eslint-disable key-spacing */
    /* eslint-disable eqeqeq */
    /* eslint-disable no-param-reassign */


    let GUIDELINE_WIDTH = 0.8;

    // This takes a list of row heights and the page height, and
    // produces a list of Y coordinates for each row, such that rows
    // are not truncated across pages.  However, the algorithm will
    // decide to truncate a row in the event that more than
    // `maxEmpty` (default 0.2) of the available space would
    // otherwise be left blank.
    //
    // It will be used for horizontal splitting too (will receive
    // column widths and page width, and produce a list of X coords).
    //
    // If the third argument (headerRows) is not null, it specifies a
    // number of rows to repeat on each page.  On pages other than the
    // first, the necessary space will be skipped at the top.  Header
    // coordinates (except for the first page) are pushed in
    // headerCoords.
    function distributeCoords(heights, pageHeight, maxEmpty, headerRows, headerCoords) {
        let curr = 0;
        let out = [];
        let bottom = pageHeight;
        let header = 0;
        if (pageHeight && maxEmpty) {
            maxEmpty *= pageHeight;
        }
        heights.forEach(function(h, i) {
            if (headerRows != null && i < headerRows) {
                header += h;
            }
            if (pageHeight && curr + h > bottom) {
                if (bottom - curr < maxEmpty) {
                    // align to next page
                    curr = pageHeight * Math.ceil(curr / pageHeight) + header;
                    if (header > 0) {
                        headerCoords.push(curr - header);
                    }
                }
                // update bottom anyway; don't just add pageHeight, as
                // we might need multiple pages for the pathological
                // case of one row higher than the page.
                bottom += pageHeight * Math.ceil(h / pageHeight);
            }
            out.push(curr);
            curr += h;
        });
        out.push(curr);
        return out;
    }

    function doLayout(sheet, range, options) {
        // normalize reference so we don't have to deal with Infinity here.
        let grid = sheet._grid;
        range = grid.normalize(range);

        let wholeRect = grid.rectangle(range);
        let drawings = [];
        sheet._drawings.forEach(function(d) {
            let box = sheet.drawingBoundingBox(d);
            if (box.intersects(wholeRect)) {
                drawings.push({
                    drawing: d,
                    box: box.offset(-wholeRect.left, -wholeRect.top)
                });
            }
        });

        // 1. obtain the list of cells that need to be printed, the
        //    row heights and column widths.  Place in each cell row,
        //    col (relative to range, i.e. first is 0,0), rowspan,
        //    colspan and merged.  also place a list of drawings
        //    anchored to that cell.
        let cells = [];
        let rowHeights = [];
        let colWidths = [];
        let mergedCells = sheet._getMergedCells(range);

        let maxRow = -1, maxCol = -1;
        sheet.forEach(range, function(row, col, cell) {
            let relrow = row - range.topLeft.row;
            let relcol = col - range.topLeft.col;
            let rh = sheet.rowHeight(row);
            let cw = sheet.columnWidth(col);
            if (!options.forScreen) {
                // for printing we'll need the list of anchored
                // drawings so that we can adjust them after page
                // splitting.
                cell.drawings = drawings.filter(function(d) {
                    let tl = d.drawing.topLeftCell;
                    if (tl && tl.row == row && tl.col == col) {
                        maxRow = Math.max(maxRow, sheet._rows.index(d.box.bottom));
                        maxCol = Math.max(maxCol, sheet._columns.index(d.box.right));
                        return true;
                    }
                });
            }
            if (!relcol) {
                rowHeights.push(rh);
            }
            if (!relrow) {
                colWidths.push(cw);
            }
            let id = new CellRef(row, col).print();
            if (mergedCells.secondary[id]) {
                return;
            }
            cell.row = relrow;
            cell.col = relcol;
            let m = mergedCells.primary[id];
            if (m) {
                delete mergedCells.primary[id];
                cell.merged = true;
                cell.rowspan = m.height();
                cell.colspan = m.width();
                if (options.forScreen) {
                    cell.width = sheet._columns.sum(m.topLeft.col, m.bottomRight.col);
                    cell.height = sheet._rows.sum(m.topLeft.row, m.bottomRight.row);
                }
            } else {
                cell.rowspan = 1;
                cell.colspan = 1;
            }
            if (!sheet._grid._columns.sum(col, col + cell.colspan - 1) ||
                !sheet._grid._rows.sum(row, row + cell.rowspan - 1)) {
                return;
            }
            let nonEmpty = options.forScreen || shouldDrawCell(cell);
            if (!(options.emptyCells || nonEmpty)) {
                return;
            }
            if (nonEmpty) {
                maxRow = Math.max(maxRow, relrow + cell.rowspan - 1);
                maxCol = Math.max(maxCol, relcol + cell.colspan - 1);
            } else {
                cell.empty = true;
            }
            cells.push(cell);
        });

        if (!options.forScreen) {
            // keep only the drawable area
            rowHeights = rowHeights.slice(0, maxRow + 1);
            colWidths = colWidths.slice(0, maxCol + 1);
        }

        let pageWidth = options.pageWidth;
        let pageHeight = options.pageHeight;
        let scaleFactor = options.scale || 1;

        // when fitWidth is requested, we must update the page size
        // with the corresponding scale factor; the algorithm below
        // (2) will continue to work, just drawing on a bigger page.
        if (options.fitWidth) {
            let width = colWidths.reduce(sum, 0);
            if (width > pageWidth) {
                scaleFactor = pageWidth / width;
            }
        }
        pageWidth = Math.ceil(pageWidth / scaleFactor);
        pageHeight = Math.ceil(pageHeight / scaleFactor);

        // 2. calculate top, left, bottom, right, width and height for
        //    printable cells.  Merged cells will be split across
        //    pages, unless the first row/col is shifted to next page.
        //    boxWidth and boxHeight get the complete drawing size.
        //    Note that cell coordinates keep increasing, i.e. they
        //    are not reset to zero for a new page.  The print
        //    function translates the view to current page.
        let hyCoords = []; // will receive header Y coordinates, if needed
        let yCoords = distributeCoords(rowHeights, pageHeight || 0, options.maxEmpty,
                                        options.headerRows, hyCoords);
        let xCoords = distributeCoords(colWidths, pageWidth || 0, options.maxEmpty);
        let boxWidth = 0;
        let boxHeight = 0;
        let headerCells = [];
        cells = cells.filter(function(cell) {
            if (cell.empty && (cell.row > maxRow || cell.col > maxCol)) {
                return false;
            }
            if (options.headerRows && cell.row < options.headerRows) {
                headerCells.push(cell);
            }
            cell.left = xCoords[cell.col];
            cell.top = yCoords[cell.row];
            if (cell.merged) {
                if (!options.forScreen) {
                    cell.right = orlast(xCoords, cell.col + cell.colspan);
                    cell.bottom = orlast(yCoords, cell.row + cell.rowspan);
                    cell.width = cell.right - cell.left;
                    cell.height = cell.bottom - cell.top;
                } else {
                    cell.right = cell.left + cell.width;
                    cell.bottom = cell.top + cell.height;
                }
            } else {
                cell.width = colWidths[cell.col];
                cell.height = rowHeights[cell.row];
                cell.bottom = cell.top + cell.height;
                cell.right = cell.left + cell.width;
            }
            if (!options.forScreen) {
                // page breaking will shift cell coordinates.  adjust
                // anchored drawings.
                cell.drawings.forEach(function(d) {
                    let box = d.box;
                    box.left = cell.left + d.drawing.offsetX;
                    box.top = cell.top + d.drawing.offsetY;
                    box.right = box.left + box.width;
                    box.bottom = box.top + box.height;
                });
            }
            boxWidth = Math.max(boxWidth, cell.right);
            boxHeight = Math.max(boxHeight, cell.bottom);
            return true;
        });

        // 3. if any merged cells remain in "primary", they start
        //    outside the printed range and we should still display
        //    them partially.
        Object.keys(mergedCells.primary).forEach(function(id) {
            let ref = mergedCells.primary[id];
            sheet.forEach(ref.topLeft.toRangeRef(), function(row, col, cell) {
                let relrow = row - range.topLeft.row;
                let relcol = col - range.topLeft.col;
                cell.merged = true;
                cell.colspan = ref.width();
                cell.rowspan = ref.height();
                if (relrow < 0) {
                    cell.top = -sheet._rows.sum(row, row - relrow - 1);
                } else {
                    cell.top = yCoords[relrow];
                }
                if (relcol < 0) {
                    cell.left = -sheet._columns.sum(col, col - relcol - 1);
                } else {
                    cell.left = xCoords[relcol];
                }
                cell.height = sheet._rows.sum(ref.topLeft.row, ref.bottomRight.row);
                cell.width = sheet._columns.sum(ref.topLeft.col, ref.bottomRight.col);
                if (cell.height > 0 && cell.width > 0) {
                    // zero means a fully hidden merged cell (all rows/columns are hidden)
                    // https://github.com/telerik/kendo-ui-core/issues/1794
                    cell.right = cell.left + cell.width;
                    cell.bottom = cell.top + cell.height;
                    cell.row = relrow;
                    cell.col = relcol;
                    cells.push(cell);
                }
            });
        });

        // 4. replicate header rows on all pages
        if (options.headerRows) {
            hyCoords.forEach(function(y) {
                headerCells.forEach(function(cell) {
                    cell = clone(cell);
                    cell.top += y;
                    cell.bottom = cell.top + cell.height;
                    cells.push(cell);
                });
                yCoords.push(y);
            });
            yCoords.sort(orderCoords);
        }

        return {
            width    : boxWidth,
            height   : boxHeight,
            cells    : cells.sort(orderCells),
            scale    : scaleFactor,
            xCoords  : xCoords,
            yCoords  : yCoords,
            drawings : drawings
        };
    }

    function clone(hash, target) {
        if (!target) {
            target = {};
        }
        if (Object.assign) {
            return Object.assign(target, hash);
        }
        return Object.keys(hash).reduce(function(copy, key) {
            copy[key] = hash[key];
            return copy;
        }, target);
    }

    function sameBorder(a, b) {
        return a.size === b.size && a.color === b.color;
    }

    function sum(a, b) {
        return a + b;
    }

    function orlast(a, i) {
        return i < a.length ? a[i] : a[a.length - 1];
    }

    function shouldDrawCell(cell) {
        return cell.value != null
            || cell.merged
            || cell.background != null
            || cell.borderRight != null
            || cell.borderBottom != null
            || cell.dBorders != null
            || (cell.validation != null && !cell.validation.value)
            || (cell.drawings && cell.drawings.length);
    }

    function orderCells(a, b) {
        if (a.top < b.top) {
            return -1;
        } else if (a.top == b.top) {
            if (a.left < b.left) {
                return -1;
            } else if (a.left == b.left) {
                return 0;
            } else {
                return 1;
            }
        } else {
            return 1;
        }
    }

    function orderCoords(a, b) {
        return a < b ? -1 : a > b ? 1 : 0;
    }

    function drawLayout(sheet, layout, group, options) {
        // options:
        // - pageWidth
        // - pageHeight
        // - fitWidth
        // - hCenter
        // - vCenter
        let ncols = Math.ceil(layout.width / options.pageWidth);
        let nrows = Math.ceil(layout.height / options.pageHeight);
        let pageWidth = Math.ceil(options.pageWidth / layout.scale);
        let pageHeight = Math.ceil(options.pageHeight / layout.scale);

        for (let j = 0; j < nrows; ++j) {
            for (let i = 0; i < ncols; ++i) {
                addPage(j, i);
            }
        }

        function addPage(row, col) {
            let left = col * pageWidth;
            let right = left + pageWidth;
            let top = row * pageHeight;
            let bottom = top + pageHeight;
            let endbottom = 0, endright = 0;

            function isInside(box) {
                if (box.right <= left || box.left >= right ||
                    box.bottom <= top || box.top >= bottom) {
                    return false;
                }
                endbottom = Math.max(box.bottom, endbottom);
                endright = Math.max(box.right, endright);
                return true;
            }

            // XXX: this can be optimized - discard cells that won't
            // be used again, and don't walk cells that stand no
            // chance to fit.
            let cells = layout.cells.filter(isInside);

            let drawings = layout.drawings.filter(function(d) {
                return isInside(d.box);
            });

            // merged cells might stretch beyond page; limit to that
            endbottom = Math.min(endbottom, bottom);
            endright = Math.min(endright, right);

            if (cells.length || drawings.length) {
                let page = new kendoDrawing.drawing.Group();
                group.append(page);
                // page.clip(drawing.Path.fromRect(
                //     new geometry.Rect([ 0, 0 ],
                //                  [ options.pageWidth, options.pageHeight ])));

                let content = new kendoDrawing.drawing.Group();
                page.append(content);

                content.clip(kendoDrawing.drawing.Path.fromRect(
                    new kendoDrawing.geometry.Rect([ left - 1, top - 1 ], [ endright + 1, endbottom + 1 ])
                ));

                let matrix = kendoDrawing.geometry.Matrix.scale(layout.scale, layout.scale)
                    .multiplyCopy(kendoDrawing.geometry.Matrix.translate(-left, -top));

                if (options.hCenter || options.vCenter) {
                    matrix = matrix.multiplyCopy(
                        kendoDrawing.geometry.Matrix.translate(
                            options.hCenter ? (right - endright) / 2 : 0,
                            options.vCenter ? (bottom - endbottom) / 2 : 0)
                    );
                }

                content.transform(matrix);

                if (options.guidelines) {
                    let prev = null;
                    layout.xCoords.forEach(function(x) {
                        x = Math.min(x, endright);
                        if (x !== prev && x >= left && x <= right) {
                            prev = x;
                            content.append(
                                new kendoDrawing.drawing.Path()
                                    .moveTo(x, top)
                                    .lineTo(x, endbottom)
                                    .close()
                                    .stroke(options.guideColor, GUIDELINE_WIDTH)
                            );
                        }
                    });
                    prev = null;
                    layout.yCoords.forEach(function(y) {
                        y = Math.min(y, endbottom);
                        if (y !== prev && y >= top && y <= bottom) {
                            prev = y;
                            content.append(
                                new kendoDrawing.drawing.Path()
                                    .moveTo(left, y)
                                    .lineTo(endright, y)
                                    .close()
                                    .stroke(options.guideColor, GUIDELINE_WIDTH)
                            );
                        }
                    });
                }

                let borders = Borders();
                cells.forEach(function(cell) {
                    drawCell$1(cell, content, options);
                    borders.add(cell, sheet);
                });

                let bordersGroup = new kendoDrawing.drawing.Group();
                borders.vert.forEach(function(a) {
                    a.forEach(function(b) {
                        if (!b.rendered) {
                            b.rendered = true;
                            bordersGroup.append(
                                new kendoDrawing.drawing.Path()
                                    .moveTo(b.x, b.top)
                                    .lineTo(b.x, b.bottom)
                                    .close()
                                    .stroke(b.color, b.size)
                            );
                        }
                    });
                });
                borders.horiz.forEach(function(a) {
                    a.forEach(function(b) {
                        if (!b.rendered) {
                            b.rendered = true;
                            bordersGroup.append(
                                new kendoDrawing.drawing.Path()
                                    .moveTo(b.left, b.y)
                                    .lineTo(b.right, b.y)
                                    .close()
                                    .stroke(b.color, b.size)
                            );
                        }
                    });
                });
                content.append(bordersGroup);

                drawings.forEach(function(d) {
                    let drawing = d.drawing;
                    let image = drawing.image;
                    if (image != null) {
                        let box = d.box;
                        let url = sheet._workbook.imageUrl(image);
                        content.append(
                            new drawing.Image(url, new kendoDrawing.geometry.Rect(
                                [ box.left, box.top ],
                                [ box.width, box.height ]
                            )).opacity(drawing.opacity)
                        );
                    }
                });
            }
        }
    }

    function drawCell$1(cell, content, options) {
        let g = new kendoDrawing.drawing.Group();
        content.append(g);
        let rect = new kendoDrawing.geometry.Rect([ cell.left, cell.top ],
                                [ cell.width, cell.height ]);
        if (cell.background || cell.merged) {
            let r2d2 = rect;
            if (options.guidelines) {
                r2d2 = rect.clone();
                r2d2.origin.x += GUIDELINE_WIDTH / 2 + 0.1;
                r2d2.origin.y += GUIDELINE_WIDTH / 2 + 0.1;
                r2d2.size.width -= GUIDELINE_WIDTH + 0.2;
                r2d2.size.height -= GUIDELINE_WIDTH + 0.2;
            }
            g.append(
                new kendoDrawing.drawing.Rect(r2d2)
                    .fill(cell.background || "#fff")
                    .stroke(null)
            );
        }
        if (cell.dBorders) {
            if (cell.dBorders.type & 2) {
                g.append(
                    new kendoDrawing.drawing.Path()
                        .moveTo(cell.left, cell.bottom)
                        .lineTo(cell.right, cell.top)
                        .stroke(cell.dBorders.color, cell.dBorders.size)
                );
            }
            if (cell.dBorders.type & 1) {
                g.append(
                    new kendoDrawing.drawing.Path()
                        .moveTo(cell.left, cell.top)
                        .lineTo(cell.right, cell.bottom)
                        .stroke(cell.dBorders.color, cell.dBorders.size)
                );
            }
        }
        let val = cell.value;
        if (val != null) {
            let type = typeof val == "number" ? "number" : null;
            let clip = new kendoDrawing.drawing.Group();
            clip.clip(kendoDrawing.drawing.Path.fromRect(rect));
            g.append(clip);
            let f, format = cell.format;
            if (!format && type == "number" && val != Math.floor(val)) {
                format = "0.##############";
            }
            if (format) {
                f = formatting.textAndColor(val, format);
                val = f.text;
                if (f.type) {
                    type = f.type;
                }
            } else {
                val += "";
            }
            if (!cell.textAlign) {
                switch (type) {
                case "number":
                case "date":
                case "percent":
                case "currency":
                    cell.textAlign = "right";
                    break;
                case "boolean":
                    cell.textAlign = "center";
                    break;
                }
            }
            drawText(val, (f && f.color) || cell.color || "#000", cell, clip);
        }
    }

    function applyIndent(cell, style) {
        if (cell.indent) {
            // OOXML spec states the indent is "An integer value,
            // where an increment of 1 represents 3 spaces".  This, of
            // course, bears no resemblance to what Excel actually
            // does, so we need magic numbers here.
            let indent = 1.4 * cell.indent;
            switch (style.textAlign) {
            case null:
            case "left":
                style.paddingLeft = indent + "ch";
                break;
            case "right":
                style.paddingRight = indent + "ch";
                break;
            case "center":
                style.paddingLeft = indent / 2 + "ch";
                style.paddingRight = indent / 2 + "ch";
                break;
            }
        }
    }

    let CONT;
    function drawText(text, color, cell, group) {
        if (!CONT) {
            CONT = document.createElement("div");
            CONT.style.position = "fixed";
            CONT.style.left = "0px";
            CONT.style.top = "0px";
            CONT.style.visibility = "hidden";
            CONT.style.overflow = "hidden";
            CONT.style.boxSizing = "border-box";
            CONT.style.lineHeight = "normal";
            document.body.appendChild(CONT);
        }

        if (CONT.firstChild) {
            CONT.removeChild(CONT.firstChild);
        }

        CONT.style.padding = "2px 4px";
        CONT.style.color = color;
        CONT.style.font = makeFontDef(cell);
        CONT.style.width = cell.width + "px";
        CONT.style.textAlign = cell.textAlign || "left";
        CONT.style.textDecoration = cell.underline ? "underline" : "none";

        applyIndent(cell, CONT.style);

        if (cell.wrap) {
            CONT.style.whiteSpace = "pre-wrap";
            CONT.style.overflowWrap = CONT.style.wordWrap = "break-word";
        } else {
            CONT.style.whiteSpace = "pre";
            CONT.style.overflowWrap = CONT.style.wordWrap = "normal";
        }

        CONT.appendChild(document.createTextNode(text));

        let vtrans = 0;
        switch (cell.verticalAlign) {
        case "center":
            vtrans = (cell.height - CONT.offsetHeight) >> 1;
            break;

        case undefined:
        case null:
        case "bottom":
            vtrans = (cell.height - CONT.offsetHeight);
            break;
        }
        if (vtrans < 0) { vtrans = 0; }

        let textGroup = kendoDrawing.drawText(CONT);
        textGroup.transform(kendoDrawing.geometry.Matrix.translate(cell.left, cell.top + vtrans));
        group.append(textGroup);
    }

    function makeFontDef(cell) {
        let font = [];
        if (cell.italic) {
            font.push("italic");
        }
        if (cell.bold) {
            font.push("bold");
        }
        font.push((cell.fontSize || 12) + "px");
        font.push((cell.fontFamily || "Arial"));
        return font.join(" ");
    }

    function drawFn(sheet, range, options, callback) {
        if (options == null && callback == null) {
            callback = range;
            options = {};
            range = SHEETREF;
        }
        if (callback == null) {
            callback = options;
            if (range instanceof Range
                || range instanceof Ref
                || typeof range == "string") {
                options = {};
            } else {
                options = range;
                range = SHEETREF;
            }
        }
        options = Object.assign({ }, {
            paperSize  : "A4",
            landscape  : true,
            margin     : "1cm",
            guidelines : true,
            guideColor : "#aaa",
            emptyCells : true,
            fitWidth   : false,
            center     : false,
            headerRows : null,
            maxEmpty   : 0.2,
            scale      : 1
        }, options);
        let group = new kendoDrawing.drawing.Group();
        let paper = getPaperOptions(options);
        group.options.set("pdf", {
            author    : options.author,
            creator   : options.creator,
            date      : options.date,
            keywords  : options.keywords,
            margin    : paper.margin,
            multiPage : true,
            paperSize : paper.paperSize,
            subject   : options.subject,
            title     : options.title,
            autoPrint : options.autoPrint
        });
        let pageWidth = paper.paperSize[0];
        let pageHeight = paper.paperSize[1];
        if (paper.margin) {
            pageWidth -= paper.margin.left + paper.margin.right + 1;
            pageHeight -= paper.margin.top + paper.margin.bottom + 1;
        }
        options.pageWidth = pageWidth;
        options.pageHeight = pageHeight;
        let layout = doLayout(sheet, sheet._ref(range), options);
        drawLayout(sheet, layout, group, options);
        callback(group);
    }

    Sheet.prototype.draw = function(range, options, callback) {
        let sheet = this;
        if (sheet._workbook) {
            sheet.recalc(sheet._workbook._context, function() {
                drawFn(sheet, range, options, callback);
            });
        } else {
            drawFn(sheet, range, options, callback);
        }
    };

    // Hack: since we index the border arrays by relative row/col we
    // could end up with negative indexes, i.e. horiz[-2] = border.
    // Array forEach will ignore these, so we provide a simple
    // container here (outside code only needs forEach at this time).
    function Container() {}
    Container.prototype = {
        forEach: function(f) {
            Object.keys(this).forEach(function(key) {
                f(this[key], key, this);
            }, this);
        }
    };

    function Borders() {
        let horiz = new Container();
        let vert = new Container();
        function add(cell, sheet) {
            if (sheet) {
                // reset borders here; the propertybag doesn't keep track of merged cells :-/ this
                // is ugly, but the inner details of data storage have leaked everywhere anyway.
                let pb = sheet._properties;
                let grid = sheet._grid;
                cell.borderLeft = pb.get("vBorders", grid.index(cell.row, cell.col));
                cell.borderRight = pb.get("vBorders", grid.index(cell.row, cell.col + cell.colspan));
                cell.borderTop = pb.get("hBorders", grid.index(cell.row, cell.col));
                cell.borderBottom = pb.get("hBorders", grid.index(cell.row + cell.rowspan, cell.col));
            }
            if (cell.borderLeft) {
                addVert(cell.row, cell.col, cell.borderLeft,
                        cell.left, cell.top, cell.bottom);
            }
            if (cell.borderRight) {
                addVert(cell.row, cell.col + cell.colspan, cell.borderRight,
                        cell.right, cell.top, cell.bottom);
            }
            if (cell.borderTop) {
                addHoriz(cell.row, cell.col, cell.borderTop,
                            cell.top, cell.left, cell.right);
            }
            if (cell.borderBottom) {
                addHoriz(cell.row + cell.rowspan, cell.col, cell.borderBottom,
                            cell.bottom, cell.left, cell.right);
            }
        }

        function isUnwantedProp(propName){
            return propName === '__proto__' || propName === 'constructor' || propName === 'prototype' 
        }

        function addVert(row, col, border, x, top, bottom) {
            if (isUnwantedProp(row) || isUnwantedProp(col)) {
                return;
            }
            let a = vert[col] || (vert[col] = new Container());
            let prev = row > 0 && a[row - 1];
            if (prev && sameBorder(prev, border)) {
                a[row] = prev;
                prev.bottom = bottom;
            } else {
                a[row] = {
                    size: border.size,
                    color: border.color || "#000",
                    x: x,
                    top: top,
                    bottom: bottom
                };
            }
        }
        function addHoriz(row, col, border, y, left, right) {
            if (isUnwantedProp(row) || isUnwantedProp(col)) {
                return;
            }
            let a = horiz[row] || (horiz[row] = new Container());
            let prev = col > 0 && a[col - 1];
            if (prev && sameBorder(prev, border)) {
                a[col] = prev;
                prev.right = right;
            } else {
                a[col] = {
                    size: border.size,
                    color: border.color || "#000",
                    y: y,
                    left: left,
                    right: right
                };
            }
        }
        return { add: add, horiz: horiz, vert: vert };
    }

    // export function drawTabularData(options) {
        // let progress = new $.Deferred();
        // let promise = progress.promise();

        // options = clone(options, {
        //     dataSource       : null,
        //     guidelines       : true,
        //     guideColor       : "#000",
        //     columns          : null,
        //     headerBackground : "#999",
        //     headerColor      : "#000",
        //     oddBackground    : null,
        //     evenBackground   : null,
        //     fontFamily       : "Arial",
        //     fontSize         : 12,
        //     paperSize        : "A4",
        //     margin           : "1cm",
        //     landscape        : true,
        //     fitWidth         : false,
        //     scale            : 1,
        //     rowHeight        : 20,
        //     maxEmpty         : 1,
        //     useGridFormat    : true
        // });

        // // retrieve fonts; custom fonts should be already loaded
        // pdf.defineFont(
        //     getFontFaces(document)
        // );

        // let charWidth = charWidthFunction(options.fontFamily, options.fontSize);

        // function textWidth(value) {
        //     if (value != null) {
        //         let width = 12;         // magic numbers :-/
        //         for (let i = value.length; --i >= 0;) {
        //             width += charWidth(value.charAt(i));
        //         }
        //         return width;
        //     }
        //     return 0;
        // }

        // let border = options.guidelines ? { size: 1, color: options.guideColor } : null;

        // function mkCell(data) {
        //     if (!border) {
        //         return data;
        //     }
        //     return clone(data, {
        //         borderLeft: border,
        //         borderTop: border,
        //         borderRight: border,
        //         borderBottom: border
        //     });
        // }

        // options.dataSource.fetch(function() {
        //     let data = options.dataSource.data();
        //     if (!data.length) {
        //         return progress.reject("Empty dataset");
        //     }

        //     // this really must be present
        //     let columns = options.columns.map(function(col) {
        //         if (typeof col == "string") {
        //             return { title: col, field: col };
        //         } else {
        //             return col;
        //         }
        //     });
        //     let columnTitles = columns.map(function(col) {
        //         return col.title || col.field;
        //     });
        //     let columnWidths = columnTitles.map(textWidth);

        //     // prepare data for a Sheet object's fromJSON method
        //     let rows = data.map(function(row, rowIndex) {
        //         return {
        //             cells: columns.map(function(col, colIndex) {
        //                 let value = row[col.field];

        //                 // NOTE: value might not be string.  I added option useGridFormat (default
        //                 // true), which will use a column's format, if present, to convert the value
        //                 // to a string, so that we can measure the width right now.
        //                 if (options.useGridFormat) {
        //                     if (value != null) {
        //                         if (col.format) {
        //                             value = intl().format(col.format, value);
        //                         } else {
        //                             value += "";
        //                         }
        //                     }
        //                     // adjust the column widths while we're at it
        //                     columnWidths[colIndex] = Math.max(
        //                         textWidth(value),
        //                         columnWidths[colIndex]
        //                     );
        //                 }

        //                 // if options.useGridFormat is false and col.format is present, pass it over
        //                 // to the spreadsheet.  In that case we should calculate the widths after
        //                 // the spreadsheet is created (XXX to be implemented when someone needs it).
        //                 return mkCell({
        //                     value: value,
        //                     format: options.useGridFormat ? null : col.format,
        //                     background: rowIndex % 2 ? options.evenBackground : options.oddBackground
        //                 });
        //             })
        //         };
        //     });

        //     // insert header line
        //     rows.unshift({
        //         cells: columnTitles.map(function(label) {
        //             return mkCell({
        //                 value: label,
        //                 background: options.headerBackground,
        //                 color: options.headerColor
        //             });
        //         })
        //     });

        //     // init a Sheet object.  Note that we have to add one
        //     // extra-row and column, because the very last ones can't
        //     // have right/bottom borders (known limitation).
        //     let sheet = new Sheet(
        //         rows.length + 1,        // rows
        //         columns.length + 1,     // columns
        //         options.rowHeight,      // row height
        //         50,                     // column width
        //         20,                     // header height
        //         20,                     // header width,
        //         {                       // default cell style
        //             fontFamily: options.fontFamily,
        //             fontSize: options.fontSize,
        //             verticalAlign: "center"
        //         }
        //     );

        //     // load data
        //     sheet.fromJSON({
        //         name: "Sheet1",
        //         rows: rows,
        //         columns: columnWidths.map(function(w, i) {
        //             return { index: i, width: w };
        //         })
        //     });

        //     sheet.draw({
        //         paperSize  : options.paperSize,
        //         landscape  : options.landscape,
        //         margin     : options.margin,
        //         guidelines : false, // using borders instead (better contrast)
        //         scale      : options.scale,
        //         fitWidth   : options.fitWidth,
        //         maxEmpty   : options.maxEmpty,
        //         headerRows : 1
        //     }, progress.resolve.bind(progress));
        // });

        // return promise;
    // }

    // let CACHE_CHAR_WIDTH = {};

    // let charWidthFunction = function(fontFamily, fontSize) {
    //     let id = fontSize + ":" + fontFamily;
    //     let func = CACHE_CHAR_WIDTH[id];
    //     if (!func) {
    //         let span, div = document.createElement("div");
    //         div.style.position = "fixed";
    //         div.style.left = "-10000px";
    //         div.style.top = "-10000px";
    //         div.style.fontFamily = fontFamily;
    //         div.style.fontSize = fontSize + "px";
    //         div.style.whiteSpace = "pre";
    //         for (let i = 32; i < 128; ++i) {
    //             span = document.createElement("span");
    //             span.appendChild(document.createTextNode(String.fromCharCode(i)));
    //             div.appendChild(span);
    //         }
    //         document.body.appendChild(div);
    //         let widths = {};
    //         for (let i = 32, span = div.firstChild; i < 128 && span; ++i, span = span.nextSibling) {
    //             widths[i] = span.offsetWidth;
    //         }
    //         while ((span = div.firstChild)) {
    //             div.removeChild(span);
    //         }
    //         func = CACHE_CHAR_WIDTH[id] = function(ch) {
    //             let code = ch.charCodeAt(0);
    //             let width = widths[code];
    //             if (width == null) {
    //                 // probably not an ASCII character, let's cache its width as well
    //                 span = document.createElement("span");
    //                 span.appendChild(document.createTextNode(String.fromCharCode(code)));
    //                 div.appendChild(span);
    //                 width = widths[code] = span.offsetWidth;
    //                 div.removeChild(span);
    //             }
    //             return width;
    //         };
    //     }
    //     return func;
    // };

    // spreadsheet.draw = {
    //     Borders         : Borders,
    //     doLayout        : doLayout,
    //     applyIndent     : applyIndent
    // };

    const draw = { Borders, doLayout, applyIndent };

    // spreadsheet.drawTabularData = drawTabularData;

    const RESIZE_HANDLE_WIDTH = 7;
    const EDIT_BUTTON_WIDTH = 20;
    const DOT = ".";

    const viewClassNames = {
        view: "k-spreadsheet-view",
        fixedContainer: "k-spreadsheet-fixed-container",
        editContainer: "k-spreadsheet-edit-container",
        scroller: "k-spreadsheet-scroller",
        viewSize: "k-spreadsheet-view-size",
        clipboard: "k-spreadsheet-clipboard",
        cellEditor: "k-spreadsheet-cell-editor",
        barEditor: "k-spreadsheet-editor",
        topCorner: "k-spreadsheet-top-corner",
        filterHeadersWrapper: "k-filter-wrapper",
        filterRange: "k-filter-range",
        filterButton: "k-spreadsheet-filter",
        filterButtonSelected: "k-selected",
        horizontalResize: "k-horizontal-resize",
        verticalResize: "k-vertical-resize",
        icon: "k-icon",
        iconFilterDefault: "k-i-caret-alt-down",
        sheetsBar: "k-spreadsheet-sheets-bar",
        sheetsBarActive: "k-spreadsheet-sheets-bar-active",
        sheetsBarInactive: "k-spreadsheet-sheets-bar-inactive",
        cellContextMenu: "k-spreadsheet-cell-context-menu",
        rowHeaderContextMenu: "k-spreadsheet-row-header-context-menu",
        colHeaderContextMenu: "k-spreadsheet-col-header-context-menu",
        drawingContextMenu: "k-spreadsheet-drawing-context-menu"
    };

    const paneClassNames = {
        cell: "k-spreadsheet-cell",
        vaxis: "k-spreadsheet-vaxis",
        haxis: "k-spreadsheet-haxis",
        vborder: "k-spreadsheet-vborder",
        hborder: "k-spreadsheet-hborder",
        rowHeader: "k-spreadsheet-row-header",
        columnHeader: "k-spreadsheet-column-header",
        pane: "k-spreadsheet-pane",
        data: "k-spreadsheet-data",
        mergedCell: "k-spreadsheet-merged-cell",
        mergedCellsWrapper: "k-merged-cells-wrapper",
        activeCell: "k-spreadsheet-active-cell",
        selection: "k-spreadsheet-selection",
        selectionWrapper: "k-selection-wrapper",
        autoFillWrapper: "k-auto-fill-wrapper",
        single: "k-single",
        top: "k-top",
        right: "k-right",
        bottom: "k-bottom",
        left: "k-left",
        resizeHandle: "k-resize-handle",
        columnResizeHandle: "k-column-resize-handle",
        rowResizeHandle: "k-row-resize-handle",
        resizeHint: "k-resize-hint",
        resizeHintHandle: "k-resize-hint-handle",
        resizeHintMarker: "k-resize-hint-marker",
        resizeHintVertical: "k-resize-hint-vertical",
        selectionHighlight: "k-spreadsheet-selection-highlight",
        series: [
            "k-series-a",
            "k-series-b",
            "k-series-c",
            "k-series-d",
            "k-series-e",
            "k-series-f"
        ]
    };

    /* eslint-disable complexity */


    function cellBorder(value) {
        return (value.size || 1) + "px solid " + (value.color || "#000");
    }

    function asURL(link) {
        if (!/:\/\//.test(link)) {
            link = "http://" + link;
        }
        return link;
    }

    function drawCell(collection, cell, cls, showGrid) {
        function maybeLink(el) {
            let link = cell.link;
            if (!link) {
                if (typeof cell.value == "object") {
                    link = cell.value.link;
                }
            }
            if (link) {
                let style = {
                    textDecoration: "none"
                };
                if (cell.color) {
                    style.color = cell.color;
                }
                if (cell.underline) {
                    style.textDecoration = "underline";
                }
                return dom.element("a", {
                    href   : asURL(link),
                    style  : style,
                    target : "_blank" // XXX: customizable?
                }, el ? [ el ] : []);
            }
            return el;
        }

        let shouldDraw = (cell.value != null || (cell.validation != null && !cell.validation.value) || // jshint ignore:line
                            cell.background || cell.merged || cell.comment || cell.dBorders);
        if (!cls && !shouldDraw) {
            return;
        }

        let style = { background: [] };
        let background = cell.background;
        if (background) {
            let defaultBorder = background;
            if (showGrid) {
                // darken
                defaultBorder = kendoDrawing.parseColor(defaultBorder).toHSV();
                defaultBorder.v *= 0.9;
                defaultBorder = defaultBorder.toCssRgba();
            }
            defaultBorder = cellBorder({ color: defaultBorder });
            style.outline = defaultBorder;
        }

        if (cell.dBorders) {
            if (cell.dBorders.type & 2) {
                style.background.push("linear-gradient(to top left, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 0) calc(50% - " +
                                        cell.dBorders.size + "px), " + cell.dBorders.color + " 50%, rgba(0, 0, 0, 0) calc(50% + " +
                                        cell.dBorders.size + "px), rgba(0, 0, 0, 0) 100%)");
            }
            if (cell.dBorders.type & 1) {
                style.background.push("linear-gradient(to top right, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 0) calc(50% - " +
                                        cell.dBorders.size + "px), " + cell.dBorders.color + " 50%, rgba(0, 0, 0, 0) calc(50% + " +
                                        cell.dBorders.size + "px), rgba(0, 0, 0, 0) 100%)");
            }
        }

        if (background) {
            style.background.push(background);
        }

        if (cell.color) {
            style.color = cell.color;
        }

        if (cell.fontFamily) {
            style.fontFamily = cell.fontFamily;
        }

        if (cell.underline) {
            style.textDecoration = "underline";
        }

        if (cell.italic) {
            style.fontStyle = "italic";
        }

        if (cell.textAlign) {
            style.textAlign = cell.textAlign;
        }

        if (cell.bold) {
            style.fontWeight = "bold";
        }

        if (cell.fontSize) {
            style.fontSize = cell.fontSize + "px";
        }

        if (cell.wrap === true) {
            style.whiteSpace = "pre-wrap";
            style.overflowWrap = "break-word";
            style.wordWrap = "break-word";
        } else {
            style.whiteSpace = "pre";
            style.overflowWrap = "normal";
            style.wordWrap = "normal";
        }

        style.left = (cell.left + 1) + "px";
        style.top = (cell.top + 1) + "px";
        style.width = (cell.width - 1) + "px";
        style.height = (cell.height - 1) + "px";

        let data = cell.value, type = typeof data, format = cell.format;
        if (!format && type === "number" && data !== Math.floor(data)) {
            format = "0.##############";
        }
        if (format && data != null) {
            data = formatting.format(data, format);
            if (data.__dataType) {
                type = data.__dataType;
            }
        } else if (data != null) {
            if (cell.html) {
                data = dom.html(data);
            } else {
                data = dom.text(data);
            }
        }

        if (!style.textAlign) {
            switch (type) {
            case "number":
            case "date":
            case "percent":
            case "currency":
                style.textAlign = "right";
                break;
            case "boolean":
                style.textAlign = "center";
                break;
            }
        }

        // defined in print.js
        draw.applyIndent(cell, style);

        let classNames = [ paneClassNames.cell ];

        if (cls) {
            classNames.push(cls);
        }
        if (cell.enable === false) {
            classNames.push("k-disabled");
        }
        if (cell.merged) {
            classNames.push("k-spreadsheet-merged-cell");
            if (!cell.enable) {
                collection.push(dom.element("div", {
                    className: "k-spreadsheet-disabled-mask",
                    style: {
                        left: (cell.left + 1) + "px",
                        top: (cell.top + 1) + "px",
                        width: (cell.width - 1) + "px",
                        height: (cell.height - 1) + "px"
                    }
                }));
            }
        }
        if (cell.comment) {
            classNames.push("k-spreadsheet-has-comment");
        }

        let verticalAlign = cell.verticalAlign || "bottom";

        if (verticalAlign && data) {
            data = dom.element("div", { className: "k-vertical-align-" + verticalAlign }, [ maybeLink(data) ]);
        } else {
            data = maybeLink(data);
        }

        if (style.background.length) {
            style.background = style.background.join(",");
        } else {
            delete style.background;
        }

        let children = data ? [ data ] : [];
        let properties = {
            style: style
        };
        let validation = cell.validation;
        if (validation && !validation.value) {
            children.push(dom.element("span", { className: "k-dirty" }));
            classNames.push("k-dirty-cell");

            properties.title = validation.message;
        }
        properties.className = classNames.join(" ");

        let div = dom.element("div", properties, children);
        collection.push(div);
        return div;
    }

    class Pane {
        constructor(sheet, grid, getIconHTMLString) {
            this._sheet = sheet;
            this._grid = grid;
            this.getIconHTMLString = getIconHTMLString;
        }

        refresh(width, height) {
            this._grid.refresh(width, height);
        }

        isVisible(scrollLeft, scrollTop, ref) {
            return this._grid.view(scrollLeft, scrollTop).ref.intersects(ref);
        }

        render(args) {
            let scroller = args.scroller;
            let scrollLeft = scroller.scrollLeft;
            let scrollTop = scroller.scrollTop;

            if (scrollTop < 0) {
                scrollTop = 0;
            }

            if (scrollLeft < 0) {
                scrollLeft = 0;
            }

            let classNames = Pane.classNames;
            let sheet = this._sheet;
            let grid = this._grid;
            let view = grid.view(scrollLeft, scrollTop);
            this._currentView = view;
            this._currentRect = this._rectangle(view.ref);
            this._selectedHeaders = sheet.selectedHeaders();

            let children = [];

            children.push(this.renderData(args));

            if (!sheet._activeDrawing) {
                children.push(this.renderSelection(scroller));
            }

            children.push(this.renderAutoFill());

            children.push(this.renderEditorSelection());

            children.push(this.renderFilterHeaders());

            if (grid.hasRowHeader) {
                let rowHeader = dom.element("div", {
                    className: classNames.rowHeader,
                    style: {
                        width: grid.headerWidth + "px",
                        top: view.rowOffset + "px"
                    }
                });
                children.push(rowHeader);
                sheet.forEach(view.ref.leftColumn(), function(row) {
                    if (!sheet.isHiddenRow(row)) {
                        let text = row + 1, height = sheet.rowHeight(row);
                        rowHeader.children.push(dom.element("div", {
                            className: this.headerClassName(row, "row"),
                            style: {
                                width: grid.headerWidth + "px",
                                height: height + "px"
                            }
                        }, [ dom.element("div", {
                            className: "k-vertical-align-center"
                        }, [ dom.text(text + "") ])]));
                    }
                }.bind(this));
            }

            if (grid.hasColumnHeader) {
                let columnHeader = dom.element("div", {
                    className: classNames.columnHeader,
                    style: {
                        top: "0px",
                        left: view.columnOffset + "px",
                        width: this._currentRect.width + "px",
                        height: grid.headerHeight + "px"
                    }
                });
                children.push(columnHeader);
                let left = 0;
                sheet.forEach(view.ref.topRow(), function(row, col) {
                    if (!sheet.isHiddenColumn(col)) {
                        let text = Ref.display(null, Infinity, col),
                            width = sheet.columnWidth(col);
                        columnHeader.children.push(dom.element("div", {
                            className: this.headerClassName(col, "col"),
                            style: {
                                position: "absolute",
                                left: left + "px",
                                width: width + "px",
                                height: grid.headerHeight + "px"
                            }
                        }, [ dom.element("div", {
                            className: "k-vertical-align-center"
                        }, [ dom.text(text + "") ])]));
                        left += width;
                    }
                }.bind(this));
            }

            if (sheet.resizeHandlePosition() && (grid.hasColumnHeader || grid.hasRowHeader)) {
                if (!sheet.resizeHintPosition()) {
                    this.renderResizeHandle(children);
                }
            }

            let paneClasses = [classNames.pane];

            if (grid.hasColumnHeader) {
                paneClasses.push(classNames.top);
            }

            if (grid.hasRowHeader) {
                paneClasses.push(classNames.left);
            }

            return dom.element("div", {
                style: grid.style,
                className: paneClasses.join(" ")
            }, children);
        }

        headerClassName(index, type) {
            let selectedHeaders = this._selectedHeaders;

            let itemSelection;
            let allHeaders;

            if (type === "row") {
                itemSelection = selectedHeaders.rows[index];
                allHeaders = selectedHeaders.allRows;
            } else {
                itemSelection = selectedHeaders.cols[index];
                allHeaders = selectedHeaders.allCols;
            }

            let className = itemSelection || (selectedHeaders.all ? "full" : (allHeaders ? "partial" : "none"));

            if (className) {
                className = "k-selection-" + className;
            }

            return className;
        }

        renderData(args) {
            let sheet = this._sheet;
            let view = this._currentView;
            let cont = dom.element("div", {
                className: Pane.classNames.data,
                style: {
                    position: "relative",
                    left: view.columnOffset + "px",
                    top: view.rowOffset + "px"
                }
            });
            let rect = this._currentRect;
            let layout = draw.doLayout(sheet, view.ref, { forScreen: true }), prev;
            let grid = this._grid;
            let showGridLines = sheet._showGridLines;
            if (showGridLines) {
                // draw axis first
                prev = null;
                layout.xCoords.forEach(function(x) {
                    if (x !== prev) {
                        prev = x;
                        cont.children.push(dom.element("div", {
                            className: paneClassNames.vaxis,
                            style: {
                                left: x + "px",
                                height: rect.height + "px",
                                borderColor: sheet.gridLinesColor()
                            }
                        }));
                    }
                });
                prev = null;
                layout.yCoords.forEach(function(y) {
                    if (y !== prev) {
                        prev = y;
                        cont.children.push(dom.element("div", {
                            className: paneClassNames.haxis,
                            style: {
                                top: y + "px",
                                width: rect.width + "px",
                                borderColor: sheet.gridLinesColor()
                            }
                        }));
                    }
                });
            }
            let borders = draw.Borders();
            let activeCellRange = sheet.activeCell().toRangeRef();
            let activeCell = activeCellRange.topLeft;

            layout.cells.forEach(function(cell) {
                let cls = null;
                let absRow = cell.row + view.ref.topLeft.row;
                let absCol = cell.col + view.ref.topLeft.col;
                if (sheet._activeDrawing) {
                    let ref = sheet._activeDrawing.topLeftCell;
                    if (ref && ref.row === absRow && ref.col === absCol) {
                        cls = "k-spreadsheet-drawing-anchor-cell";
                    }
                } else if (absRow === activeCell.row && absCol === activeCell.col) {
                    // active cell.  normally we enter here only once.
                    cls = [
                        Pane.classNames.activeCell
                    ].concat(this._activeFormulaColor(),
                                this._directionClasses(activeCellRange));
                    if (sheet.singleCellSelection()) {
                        cls.push(Pane.classNames.single);
                    }
                    cls = cls.join(" ");
                }
                borders.add(cell);
                drawCell(cont.children, cell, cls, showGridLines);
                if (cell.comment && sheet._commentRef &&
                    absRow === sheet._commentRef.row && absCol === sheet._commentRef.col) {
                    let ttOffset = 4;
                    let left = cell.right + grid.left + view.columnOffset + ttOffset;
                    let style = { top: (cell.top + grid.top + view.rowOffset) + "px" };
                    if (left + 200 > args.contentWidth) {
                        style.right = (args.contentWidth - grid.left - cell.left - view.columnOffset + ttOffset) + "px";
                    } else {
                        style.left = left + "px";
                    }
                    let div = dom.element("div", {
                        className: "k-tooltip k-spreadsheet-cell-comment",
                        style: style
                    }, [ dom.text(cell.comment) ]);
                    args.toplevelElements.push(div);
                }
            }, this);
            borders.vert.forEach(function(a) {
                a.forEach(function(b) {
                    if (!b.rendered) {
                        b.rendered = true;
                        let style = {
                            left        : b.x + "px",
                            top         : b.top + "px",
                            height      : (b.bottom - b.top + 1) + "px",
                            borderWidth : b.size + "px",
                            borderColor : b.color
                        };
                        if (b.size !== 1) {
                            style.transform = "translateX(-" + (b.size - 1) / 2 + "px)";
                        }
                        cont.children.push(dom.element("div", {
                            className: paneClassNames.vborder,
                            style: style
                        }));
                    }
                });
            });
            borders.horiz.forEach(function(a) {
                a.forEach(function(b) {
                    if (!b.rendered) {
                        b.rendered = true;
                        let style = {
                            top         : b.y + "px",
                            left        : b.left + "px",
                            width       : (b.right - b.left) + "px",
                            borderWidth : b.size + "px",
                            borderColor : b.color
                        };
                        if (b.size !== 1) {
                            style.transform = "translateY(-" + (b.size - 1) / 2 + "px)";
                        }
                        cont.children.push(dom.element("div", {
                            className: paneClassNames.hborder,
                            style: style
                        }));
                    }
                });
            });
            this.renderDrawings(layout, cont.children);
            return cont;
        }

        renderDrawings(layout, container) {
            let sheet = this._sheet;
            let workbook = sheet._workbook;
            layout.drawings.forEach(function(d) {
                let drawing = d.drawing;
                let box = d.box;
                let div = box.toDiv("k-spreadsheet-drawing");
                if (drawing.image) {
                    div.children.push(dom.element("div", {
                        className: "k-spreadsheet-drawing-image",
                        style: {
                            backgroundImage: "url('" + workbook.imageUrl(drawing.image) + "')",
                            opacity: drawing.opacity
                        }
                    }));
                }
                if (drawing === sheet._activeDrawing) {
                    div.attr.className += " k-spreadsheet-active-drawing";
                    drawingResizeHandles(div.children);
                }
                container.push(div);
            });
        }

        renderResizeHandle(container) {
            let sheet = this._sheet;
            let ref = sheet.resizeHandlePosition();
            let rectangle = this._rectangle(ref);
            let classNames = [ Pane.classNames.resizeHandle ];

            let style;
            if (ref.col !== -Infinity) {
                if (this._grid.rows._start > 0) {
                    return;
                }
                style = {
                    height: this._grid.headerHeight + "px",
                    width: RESIZE_HANDLE_WIDTH + "px",
                    left: rectangle.right - RESIZE_HANDLE_WIDTH / 2 + "px",
                    top: "0px"
                };
                classNames.push(viewClassNames.horizontalResize);
            } else {
                if (this._grid.columns._start > 0) {
                    return;
                }
                style = {
                    height: RESIZE_HANDLE_WIDTH + "px",
                    width: this._grid.headerWidth + "px",
                    top: rectangle.bottom - RESIZE_HANDLE_WIDTH / 2 + "px",
                    left: "0px"
                };
                classNames.push(viewClassNames.verticalResize);
            }

            container.push(dom.element("div", {
                className: classNames.join(" "),
                style: style
            }));
        }

        filterIconRect(rect) {
            let BUTTON_SIZE = 16;
            let BUTTON_OFFSET = 3;

            return new Rectangle(
                rect.right - BUTTON_SIZE - BUTTON_OFFSET,
                rect.top + BUTTON_OFFSET,
                BUTTON_SIZE,
                BUTTON_SIZE
            );
        }

        icon(className) {
            if (typeof this.getIconHTMLString === "function") {
                return dom.element(this.getIconHTMLString(className));
            }

            return dom.element("span", {
                className: viewClassNames.icon + " " + className
            });
        }

        renderFilterHeaders() {
            let pane = this;
            let sheet = this._sheet;
            let children = [];
            let classNames = viewClassNames;
            let filter = sheet.filter();

            function filterButton(classNames, position, index) {
                let style = {
                    left: position.left + "px",
                    top: position.top + "px"
                };
                let filtered = filter && filter.columns.some(function(c) {
                    return c.index === index;
                });
                let classes = classNames.filterButton;

                if (filtered) {
                    classes += " " + classNames.filterButtonSelected;
                }

                let button = dom.element(
                    "span",
                    { className: classes, style: style },
                    [ pane.icon(classNames.iconFilterDefault) ]
                );

                return button;
            }

            if (filter) {
                this._addDiv(children, filter.ref, classNames.filterRange);
            }

            sheet.forEachFilterHeader(this._currentView.ref, function(ref) {
                let rect = this._rectangle(ref);
                let position = this.filterIconRect(rect);
                let column = this._sheet.filterColumn(ref);
                let button = filterButton(classNames, position, column);

                children.push(button);
            }.bind(this));

            return dom.element("div", {
                className: classNames.filterHeadersWrapper
            }, children);

        }

        renderEditorSelection() {
            let classNames = Pane.classNames;
            let sheet = this._sheet;
            let selections = [];

            sheet._formulaSelections.forEach(function(range) {
                let ref = range.ref;

                if (ref === NULLREF) {
                    return;
                }

                this._addDiv(selections, ref, classNames.selectionHighlight + " " + range.colorClass);
            }.bind(this));

            return dom.element("div", { className: classNames.selectionWrapper }, selections);

        }

        renderSelection(scroller) {
            let classNames = Pane.classNames;
            let selections = [];
            let selectionClasses = [classNames.selection];
            let sheet = this._sheet;
            let activeCell = sheet.activeCell().toRangeRef();
            let selection = sheet.select();

            selectionClasses = selectionClasses.concat(this._activeFormulaColor());

            if (selection.size() === 1) {
                selectionClasses.push("k-single-selection");
            }

            if (this._sheet.autoFillPunch()) {
                selectionClasses.push("k-dim-auto-fill-handle");
            }

            selection.forEach(function(ref) {
                if (ref !== NULLREF) {
                    this._addDiv(selections, ref, selectionClasses.join(" "));
                }
            }.bind(this));

            this._renderCustomEditorButton(selections, activeCell, scroller);

            return dom.element("div", { className: classNames.selectionWrapper }, selections);
        }

        renderAutoFill() {
            let autoFillRectangle = [];

            if (this._sheet.autoFillInProgress()) {
                let autoFillRef = this._sheet.autoFillRef();
                let punch = this._sheet.autoFillPunch();
                let direction = this._sheet._autoFillDirection;

                this._addDiv(autoFillRectangle, autoFillRef, "k-auto-fill");

                if (punch) { // collapsing, add overlay
                    this._addDiv(autoFillRectangle, punch, "k-auto-fill-punch");
                } else if (direction !== undefined) { // expanding - add hint
                    let ref, cssClass;

                    switch (direction) {
                    case 0:
                        ref = autoFillRef.bottomRight;
                        cssClass = "k-auto-fill-br-hint";
                        break;
                    case 1:
                        ref = autoFillRef.bottomRight;
                        cssClass = "k-auto-fill-br-hint";
                        break;
                    case 2:
                        ref = new CellRef(autoFillRef.topLeft.row, autoFillRef.bottomRight.col);
                        cssClass = "k-auto-fill-tr-hint";
                        break;
                    case 3:
                        ref = new CellRef(autoFillRef.bottomRight.row, autoFillRef.topLeft.col);
                        cssClass = "k-auto-fill-bl-hint";
                        break;
                    }

                    let rectangle = this._addDiv(autoFillRectangle, ref, cssClass);
                    if (rectangle) {
                        let hint = dom.element("span", { className: "k-tooltip" }, [ dom.text(this._sheet._autoFillHint) ]);
                        rectangle.children.push(hint);
                    }
                }
            }

            return dom.element("div", { className: Pane.classNames.autoFillWrapper }, autoFillRectangle);
        }

        _addDiv(collection, ref, className) {
            let view = this._currentView, div;

            if (view.ref.intersects(ref)) {
                div = this._rectangle(ref).resize(1, 1).toDiv(className);
                collection.push(div);
            }
            return div;
        }

        _renderCustomEditorButton(collection, ref, scroller) {
            let self = this;
            let sheet = self._sheet;
            let view = self._currentView;
            let columnCount = self._grid.columns._axis._count;
            let ed = sheet.activeCellCustomEditor();

            if (ed && view.ref.intersects(ref)) {
                let rectangle = self._rectangle(ref);
                sheet.forEach(ref.collapse(), function(row, col, cell) {
                    cell.left = rectangle.left;
                    cell.top = rectangle.top;
                    cell.width = rectangle.width;
                    cell.height = rectangle.height;

                    let btnClass = "k-button k-button-md k-rounded-md k-button-solid k-button-solid-base k-spreadsheet-editor-button";
                    let isLastColumn = col === columnCount - 1 || self._buttonOutOfVisiblePane(row, col, scroller);
                    if (isLastColumn) {
                        btnClass += " k-spreadsheet-last-column";
                    }
                    self._editorInLastColumn = isLastColumn;
                    let btn = dom.element("div", {
                        className: btnClass,
                        style: {
                            left   : (cell.left + (isLastColumn ? 0 : cell.width)) + "px",
                            top    : cell.top + "px",
                            height : cell.height + "px"
                        }
                    });

                    if (ed.icon) {
                        btn.children.push(self.icon(ed.icon));
                    }

                    collection.push(btn);
                });
            }
        }

        _activeFormulaColor() {
            let activeFormulaSelection;
            let colorClasses = [];

            if (this._sheet.isInEditMode()) {
                activeFormulaSelection = this._sheet._formulaSelections.filter(function(sel) { return sel.active && sel.type === "ref"; })[0];

                if (activeFormulaSelection) {
                    colorClasses.push(activeFormulaSelection.colorClass);
                }
            }

            return colorClasses;
        }

        _directionClasses(cell) {
            let cellClasses = [];
            let classNames = Pane.classNames;
            let view = this._currentView.ref;

            if (!cell.move(0, -1).intersects(view)) {
                cellClasses.push(classNames.left);
            }

            if (!cell.move(-1, 0).intersects(view)) {
                cellClasses.push(classNames.top);
            }

            if (!cell.move(0, 1).intersects(view)) {
                cellClasses.push(classNames.right);
            }

            if (!cell.move(1, 0).intersects(view)) {
                cellClasses.push(classNames.bottom);
            }

            return cellClasses;
        }

        _rectangle(ref) {
            return this._grid.boundingRectangle(ref.toRangeRef()).offset(-this._currentView.mergedCellLeft, -this._currentView.mergedCellTop);
        }

        _buttonOutOfVisiblePane(row, col, scroller) {
            let self = this;
            let theGrid = self._grid;
            let sheet = self._sheet;
            let ref = sheet.range(row, col)._ref;
            let boundaries = theGrid.scrollBoundaries(ref);
            let scrollLeft = theGrid.columns.frozen ? 0 : scroller.scrollLeft;

            if (boundaries.right + EDIT_BUTTON_WIDTH > scrollLeft || col + 1 === sheet.frozenColumns()) {
                return true;
            }
        }
    }

    Pane.classNames = paneClassNames;

    function drawingResizeHandles(container) {
        [ "N", "NE", "E", "SE", "S", "SW", "W", "NW" ].forEach(function(direction) {
            container.push(dom.element("div", {
                "className": "k-spreadsheet-drawing-handle " + direction,
                "data-direction": direction
            }));
        });
    }

    /* eslint-disable no-unused-vars */
    /* eslint-disable no-param-reassign */
    /* eslint-disable no-else-return */
    /* eslint-disable no-multi-spaces */
    /* eslint-disable no-nested-ternary */


    let styles = [
        "font-family",
        "font-size",
        "font-stretch",
        "font-style",
        "font-weight",
        "letter-spacing",
        "text-transform",
        "line-height"
    ];

    //move to core
    let KEY_NAMES = {
        27: 'esc',
        37: 'left',
        39: 'right',
        35: 'end',
        36: 'home',
        32: 'spacebar'
    };

    let PRIVATE_FORMULA_CHECK = /(^_|[^a-z0-9]$)/i;

    class FormulaInput extends Widget {
        constructor(element, opt) {
            const defaultOptions = {
                name: "FormulaInput",
                autoScale: false,
                filterOperator: "startswith",
                scalePadding: 30,
                minLength: 1,
                formulaBarWidth: null
            };

            const options = Object.assign({}, defaultOptions, opt);
            super(element, options);

            this.events = [
                "keyup",
                "focus"
            ];

            this.input = opt.input;

            if (!element) {
                return;
            }

            this.bind(this.events, this.options);

            element.classList.add(FormulaInput.classNames.wrapper);

            if (options && options.formulaBarWidth) ;

            this._highlightedRefs = [];

            this._formulaSource();

            this._formulaList();

            this._tooltip();

            this._sync = this._sync.bind(this);
            this.scale = this.scale.bind(this);
            this._keydown = this._keydown.bind(this);
            this._keyup = this._keyup.bind(this);
            this._blur = this._blur.bind(this);
            this._input = this._input.bind(this);
            this._focus = this._focus.bind(this);
            this._paste = this._paste.bind(this);

            if (this.options.autoScale) {
                element.addEventListener("input", this.scale);
            }

            element.addEventListener("keydown", this._keydown);
            element.addEventListener("keyup", this._keyup);
            element.addEventListener("blur", this._blur);
            element.addEventListener("input", this._input);
            element.addEventListener("click", this._input);
            element.addEventListener("focus", this._focus);
            element.addEventListener("paste", this._paste);
        }

        enable(enable) {
            if (enable === undefined) {
                return this.element.getAttribute("contenteditable") === "true";
            }

            if (enable) {
                this.element.setAttribute("contenteditable", enable);
            } else {
                this.element.removeAttribute("contenteditable");
            }

            this.element.classList.toggle("k-disabled", !enable);
        }

        getPos() {
            let div = this.element;
            let sel = window.getSelection();
            let a = lookup(sel.focusNode, sel.focusOffset);
            let b = lookup(sel.anchorNode, sel.anchorOffset);
            if (a != null && b != null) {
                if (a > b) {
                    let tmp = a;
                    a = b;
                    b = tmp;
                }
                return { begin: a, end: b, collapsed: a === b };
            }
            function lookup(lookupNode, pos) {
                try {
                    (function loop(node) {
                        if (node === lookupNode) {
                            throw pos;
                        } else if (node.nodeType === 1 /* Element */) {
                            for (let i = node.firstChild; i; i = i.nextSibling) {
                                loop(i);
                            }
                        } else if (node.nodeType === 3 /* Text */) {
                            pos += node.nodeValue.length;
                        }
                    })(div);
                } catch (index) {
                    return index;
                }
            }
        }

        setPos(begin, end) {
            let eiv = this.element;
            begin = lookup(eiv, begin);
            if (end != null) {
                end = lookup(eiv, end);
            } else {
                end = begin;
            }
            if (begin && end) {
                this._setRange(begin, end);
            }

            function lookup(node, pos) {
                try {
                    (function loop(node) {
                        if (node.nodeType === 3 /* Text */) {
                            let len = node.nodeValue.length;
                            if (len >= pos) {
                                throw node;
                            }
                            pos -= len;
                        } else if (node.nodeType === 1 /* Element */) {
                            for (let i = node.firstChild; i; i = i.nextSibling) {
                                loop(i);
                            }
                        }
                    })(node);
                } catch (el) {
                    return { node: el, pos: pos };
                }
            }
        }

        end() {
            this.setPos(this.length());
        }

        home() {
            this.setPos(0);
        }

        select() {
            this.setPos(0, this.length());
        }

        length() {
            return this.value().length;
        }

        _setRange(begin, end) {
            let range = document.createRange();
            range.setStart(begin.node, begin.pos);
            range.setEnd(end.node, end.pos);
            let sel = window.getSelection();
            let currentRange = sel.getRangeAt(0);
            if (differ(range, currentRange))  {
                sel.removeAllRanges();
                sel.addRange(range);
            }

            function differ(a, b) {
                return (
                    a.startOffset !== b.startOffset ||
                    a.endOffset !== b.endOffset ||
                    a.startContainer !== b.endContainer ||
                    a.endContainer !== b.endContainer
                );
            }
        }

        _formulaSource() {
            let result = [];
            let value;

            for (let key in calc.runtime.FUNCS) {
                if (!PRIVATE_FORMULA_CHECK.test(key)) {
                    value = key.toUpperCase();
                    result.push({ value: value, text: value });
                }
            }

            this.formulaSource = result;
        }

        get list() { return  this.input.current.list; }
        get popup() { return  this.input.current.popup; }

        _formulaList() {
            this.list.data(this.formulaSource);
            this.list.itemClick((value) => {
                this._formulaListChange(value);
            });
        }

        _formulaListChange(value) {
            let tokenCtx = this._tokenContext();

            if (!tokenCtx || this._mute) {
                return;
            }

            let activeToken = tokenCtx.token;
            let completion = value;
            let ctx = {
                replace: true,
                token: activeToken,
                end: activeToken.end
            };

            if (!tokenCtx.nextToken || tokenCtx.nextToken.value !== "(") {
                completion += "(";
            }

            this._replaceAt(ctx, completion);
            this.popup.close();
        }

        _blur() {
            this.popup.close();
            clearTimeout(this._focusId);
            this.trigger("blur");
        }

        _isFormula() {
            return /^=/.test(this.value());
        }

        _keydown(e) {
            let key = e.keyCode;
            let that = this;

            if (KEY_NAMES[key]) {
                that.popup.close();
                that._navigated = true;
            } else if (that._move(key)) {
                that._navigated = true;
                e.preventDefault();
            }

            that._keyDownTimeout = setTimeout(that._syntaxHighlight.bind(that));
        }

        _keyup() {
            let popup = this.popup;
            let value;

            if (this._isFormula() && !this._navigated) {
                value = ((this._tokenContext() || {}).token || {}).value;

                const data = this.filter(value);

                if (!value || !data.length) {
                    popup.close();
                } else {
                    popup[popup.visible() ? "position" : "open"]();
                    setTimeout(() => { this.list.focusFirst(); }, 0);
                }
            }

            this._navigated = false;
            this._syntaxHighlight();

            this.trigger("keyup");
        }

        _input() {
            this._syntaxHighlight();
        }

        _focus() {
            setTimeout(this._sync.bind(this));
            this._focusTimeout = setTimeout(this._syntaxHighlight.bind(this));
            this.trigger("focus");
        }

        _paste(ev) {
            ev.preventDefault();
            let pos = this.getPos();
            let text;
            text = ev.clipboardData.getData("text/plain");
            let val = this.value();
            val = val.substr(0, pos.begin) + text + val.substr(pos.end);
            this.value(val);
            this.setPos(pos.begin + text.length);
            this.scale();
        }

        _move(key) {
            let list = this.list;
            let popup = this.popup;
            if (popup.visible()) {
                if (key === keys.DOWN) {
                    list.focusNext();
                    return true;
                }
                if (key === keys.UP) {
                    list.focusPrev();
                    return true;
                }
                if (key === keys.ENTER || key === keys.TAB) {
                    let focusIndex = typeof list.focusIndex === "function" ? list.focusIndex() : list.focus();
                    if (list.data()[focusIndex]) {
                        this._formulaListChange(list.data()[focusIndex].value);
                    }

                    popup.close();
                    return true;
                }
                if (key === keys.PAGEUP) {
                    list.focusFirst();
                    return true;
                }
                if (key === keys.PAGEDOWN) {
                    list.focusLast();
                    return true;
                }
            }
            return false; // key === keys.ENTER || key === keys.TAB;
        }

        _tokenContext() {
            let point = this.getPos();
            let value = this.value();

            if (!value || !point || !point.collapsed) {
                return null;
            }

            let tokens = calc.tokenize(value, this.row(), this.col());
            let tok;

            for (let i = 0; i < tokens.length; ++i) {
                tok = tokens[i];
                if (touches(tok, point) && /^(?:str|sym|func)$/.test(tok.type)) {
                    return { token: tok, nextToken: tokens[i + 1] };
                }
            }

            return null;
        }

        _sync() {
            if (this._editorToSync && this.isActive()) {
                this._editorToSync.value(this.value());
            }
        }

        _textContainer() {
            let computedStyles = kendoGetComputedStyles(this.element, styles);

            computedStyles.position = "absolute";
            computedStyles.visibility = "hidden";
            computedStyles.whiteSpace = "pre";
            computedStyles.top = -3333;
            computedStyles.left = -3333;

            this._span = document.createElement('span');
            this._span.style.whiteSpace = 'pre';
            for (const style in computedStyles) {
                if (Object.hasOwnProperty.call(computedStyles, style)) {
                    this._span.style[style] = computedStyles[style];
                }
            }
            insertAfter(this._span, this.element);
            // this._span = $("<span style='white-space: pre'/>").css(computedStyles).insertAfter(this.element);
        }

        _tooltip() {
            this._cellTooltip = document.createElement('div');
            this._cellTooltip.className = 'k-widget k-tooltip';
            this._cellTooltip.style.position = 'absolute';
            this._cellTooltip.style.display = 'none';
            this._cellTooltip.appendChild(document.createTextNode('A1'));
            insertAfter(this._cellTooltip, this.element);
            // this._cellTooltip = $('<div class="k-widget k-tooltip" style="position:absolute; display:none">A1</div>').insertAfter(this.element);
        }

        tooltip(value) {
            while (this._cellTooltip.firstChild) {
                this._cellTooltip.removeChild(this._cellTooltip.firstChild);
            }
            this._cellTooltip.appendChild(document.createTextNode(value));
            // this._cellTooltip.text(value);
        }

        toggleTooltip(show) {
            this._cellTooltip.style.display = (show ? '' : 'none');
            // this._cellTooltip.toggle(show);
        }

        isActive() {
            return this.element === _activeElement$1();
        }

        filter(value) {
            if (!value || value.length < this.options.minLength) {
                return;
            }

            const data = this.formulaSource.filter((item) => String(item.value).toLowerCase().startsWith(value.toLowerCase()));

            this.list.data(data);

            return data;
        }

        hide() {
            this.enable(false);
            this.element.style.display = 'none';
            this._cellTooltip.style.display = 'none';
        }

        show() {
            this.enable(true);
            this.element.style.display = 'block';
        }

        row() {
            if (this.activeCell) {
                return this.activeCell.row;
            }
        }

        col() {
            if (this.activeCell) {
                return this.activeCell.col;
            }
        }

        position(rectangle) {
            if (!rectangle) {
                return;
            }

            this.show();

            this.element.style.top = (rectangle.top + 1) + "px";
            this.element.style.left = (rectangle.left + 1) + "px";

            this._cellTooltip.style.top =  (rectangle.top - this._cellTooltip.offsetHeight - 10) + "px";
            this._cellTooltip.style.left = rectangle.left + "px";
        }

        resize(rectangle) {
            if (!rectangle) {
                return;
            }

            this.element.style.width = (rectangle.width - 1) + "px";
            this.element.style.height = (rectangle.height - 1) + "px";
        }

        canInsertRef(isKeyboardAction) {
            return this._canInsertRef(isKeyboardAction);
        }

        _canInsertRef(isKeyboardAction) {
            if (this.popup.visible()) {
                return null;
            }
            let strictMode = isKeyboardAction;
            let point = this.getPos();
            let tokens, tok, i;

            if (point && this._isFormula()) {
                if (point.begin === 0) {
                    return null;
                }

                tokens = calc.tokenize(this.value(), this.row(), this.col());

                for (i = 0; i < tokens.length; ++i) {
                    tok = tokens[i];
                    if (touches(tok, point)) {
                        return canReplace(tok);
                    }
                    if (afterPoint(tok)) {
                        return canInsertBetween(tokens[i - 1], tok);
                    }
                }
                return canInsertBetween(tok, null);
            }

            return null;

            function afterPoint(tok) {
                return tok.begin > point.begin;
            }
            function canReplace(tok) {
                if (tok) {
                    if (/^(?:num|str|bool|sym|ref)$/.test(tok.type)) {
                        return { replace: true, token: tok, end: tok.end };
                    }
                    if (/^(?:op|punc|startexp)$/.test(tok.type)) {
                        if (tok.end === point.end) {
                            return canInsertBetween(tok, tokens[i + 1]);
                        }
                        return canInsertBetween(tokens[i - 1], tok);
                    }
                }
            }
            function canInsertBetween(left, right) {
                if (left == null) {
                    return null;
                }
                if (right == null) {
                    if (/^(?:op|startexp)$/.test(left.type) || isOpenParen(left.value)) {
                        return { token: left, end: point.end };
                    }
                    return null;
                }
                if (strictMode) {
                    if (left.type === "op" && /^(?:punc|op)$/.test(right.type)) {
                        return { token: left, end: point.end };
                    }
                } else {
                    if (left.type === "startexp") {
                        return { token: left, end: point.end };
                    }
                    if (/^(?:op|punc)$/.test(left.type) && /^[,;({]$/.test(left.value)) {
                        return { token: left, end: point.end };
                    }
                    if (/^(?:ref|sym)/.test(left.type)) {
                        return { token: left, replace: true, end: left.end };
                    }
                    if (/^(?:ref|sym)/.test(right.type)) {
                        return { token: right, replace: true, end: right.end };
                    }
                }
                return false;
            }
        }

        refAtPoint(sheet) {
            let x = this._canInsertRef();
            if (x) {
                let ref = sheet.selection()._ref.simplify().clone().relative(0, 0, 3);
                if (sheet.isMerged(ref)) {
                    ref = ref.topLeft;
                }
                if (sheet !== this.activeSheet) {
                    ref = ref.setSheet(sheet.name(), true);
                }
                this._replaceAt(x, ref.print(0, 0));
            }
        }

        _replaceAt(ctx, newValue) {
            let value = this.value();
            let tok = ctx.token;
            let rest = value.substr(ctx.end);
            value = value.substr(0, ctx.replace ? tok.begin : ctx.end) + newValue;
            let point = value.length;
            value += rest;
            this._value(value);
            this.setPos(point);
            this.scale();
            this._syntaxHighlight();
        }

        syncWith(formulaInput) {
            this._editorToSync = formulaInput;
            if (this.element) {
                this.element.removeEventListener("input", this._sync);
                this.element.addEventListener("input", this._sync);
            }
        }

        scale() {
            let element = this.element;
            let width, height;

            if (!this._span) {
                this._textContainer();
            }

            this._span.innerHTML = element.innerHTML;

            width = this._span.offsetWidth + this.options.scalePadding;
            height = this._span.offsetHeight;

            if (width > element.offsetWidth) {
                element.style.width = width + 'px';
            }

            const activeCellOutlineWidth = 1;
            if (height - activeCellOutlineWidth > element.offsetHeight) {
                element.style.height = (height - activeCellOutlineWidth) + 'px';
            }

            this._sync();
        }

        _value(value) {
            let txt = (this.element.innerText || this.element.textContent).replace(/\n$/, "");
            if (txt !== value) {
                while (this.element.firstChild) {
                    this.element.removeChild(this.element.firstChild);
                }
                this.element.appendChild(document.createTextNode(value));
            }
        }

        value(value) {
            let txt = (this.element.innerText || this.element.textContent).replace(/\n$/, "");
            if (value === undefined) {
                return txt;
            }

            if (txt !== value) {
                this._value(value);
                this._syntaxHighlight();
            }
        }

        highlightedRefs() {
            return this._highlightedRefs.slice();
        }

        _syntaxHighlight() {
            let pos = this.getPos();
            let value = this.value();
            let refClasses = Pane.classNames.series;
            let highlightedRefs = [];
            let refIndex = 0;
            let parens = [];
            let tokens = [];
            // let activeToken;

            if (pos && !pos.collapsed) {
                // Backward selection (hold shift, move right to left)
                // will not work properly if we continuously re-set
                // the HTML.  If the selection is on, presumably the
                // text has already been highlighted, so stop here.
                return;
            }

            if (!(/^=/.test(value))) {
                // if an user deleted the initial =, reset the text to
                // discard any highlighting.  Only do that once.
                if (this._highlightedRefs.length) {
                    this._highlightedRefs = [];
                    this._value(value);
                }

                // also make sure the completion popup goes away
                // if (this.popup) {
                    // this.popup.close();
                // }

                return; // avoid messing with the cursor position below
            } else {
                tokens = calc.tokenize(value, this.row(), this.col());
                tokens.forEach(function(tok) {
                    tok.active = false;
                    tok.cls = [ "k-syntax-" + tok.type ];

                    if (tok.type === "ref") {
                        tok.colorClass = refClasses[(refIndex++) % refClasses.length];
                        tok.cls.push(tok.colorClass);
                        highlightedRefs.push(tok);
                    }
                    if (pos && tok.type === "punc") {
                        if (isOpenParen(tok.value)) {
                            parens.unshift(tok);
                        } else if (isCloseParen(tok.value)) {
                            let open = parens.shift();
                            if (open) {
                                if (isMatchingParen(tok.value, open.value)) {
                                    if (touches(tok, pos) || touches(open, pos)) {
                                        tok.cls.push("k-syntax-paren-match");
                                        open.cls.push("k-syntax-paren-match");
                                    }
                                } else {
                                    tok.cls.push("k-syntax-error");
                                    open.cls.push("k-syntax-error");
                                }
                            } else {
                                tok.cls.push("k-syntax-error");
                            }
                        }
                    }
                    if (pos && touches(tok, pos)) {
                        tok.cls.push("k-syntax-at-point");
                        tok.active = true;
                        // activeToken = tok;
                    }
                    if (tok.type === "func" && !knownFunction(tok.value) && (!pos || !touches(tok, pos))) {
                        tok.cls.push("k-syntax-error");
                    }
                });
                tokens.reverse().forEach(function(tok) {
                    let begin = tok.begin, end = tok.end;
                    let text = htmlEncode(value.substring(begin, end));
                    value = value.substr(0, begin) +
                        "<span class='" + tok.cls.join(" ") + "'>" + text + "</span>" +
                        value.substr(end);
                });
                this.element.innerHTML = value;
            }
            if (pos) {
                this.setPos(pos.begin, pos.end);
            }

            this._highlightedRefs = highlightedRefs;
        }

        destroy() {
            this._editorToSync = null;

            this.element.removeEventListener("input", this.scale);
            this.element.removeEventListener("keydown", this._keydown);
            this.element.removeEventListener("keyup", this._keyup);
            this.element.removeEventListener("blur", this._blur);
            this.element.removeEventListener("input", this._input);
            this.element.removeEventListener("click", this._input);
            this.element.removeEventListener("focus", this._focus);
            this.element.removeEventListener("paste", this._paste);

            clearTimeout(this._focusTimeout);
            clearTimeout(this._keyDownTimeout);

            this._cellTooltip = null;
            this._span = null;

            super.destroy();
        }

        insertNewline() {
            let val = this.value();
            let pos = this.getPos();
            let eof = pos.end === val.length;
            val = val.substr(0, pos.begin) + (eof ? "\n\n" : "\n" + val.substr(pos.end));
            this.value(val);
            this.setPos(pos.begin + 1);
        }
    }

    FormulaInput.classNames = {
        wrapper: "k-spreadsheet-formula-input",
        listWrapper: "k-spreadsheet-formula-list"
    };

    function isOpenParen(ch) {
        return ch === "(" || ch === "[" || ch === "{";
    }

    function isCloseParen(ch) {
        return ch === ")" || ch === "]" || ch === "}";
    }

    function isMatchingParen(close, open) {
        return open === "(" ? close === ")"
            :  open === "[" ? close === "]"
            :  open === "{" ? close === "}"
            :  false;
    }

    function touches(pos, target) {
        return pos.begin <= target.begin && pos.end >= target.end;
    }

    function knownFunction(name) {
        return calc.runtime.FUNCS[name.toLowerCase()];
    }

    class FormulaBar extends Widget {
        constructor(element, options) {
            super(element, options);

            const formulaInputDiv = element && element.querySelector(".k-spreadsheet-formula-input:not(.k-spreadsheet-cell-editor)");
            this.formulaInput = new FormulaInput(formulaInputDiv, this.options);
        }

        destroy() {
            if (this.formulaInput) {
                this.formulaInput.destroy();
            }
            this.formulaInput = null;
        }
    }

    class NameEditor extends Widget {
        readData() {
            const data = [];
            this._workbook.forEachName(function(def) {
                if (!def.hidden && def.value instanceof Ref) {
                    data.push({ name: def.name });
                }
            });
            return data;
        }
        value(val) {
            if (this.options.combobox.current) {
                return this.options.combobox.current.value(val);
            }
        }
    }

    class SheetsBar extends Widget {
        constructor(element, options) {
            super(element, Object.assign({}, { name: "SheetsBar" }, options));
            this.events = [
                "select",
                "reorder",
                "rename"
            ];
        }

        onSheetReorderEnd(e) {
            this.trigger("reorder", { oldIndex: e.oldIndex, newIndex: e.newIndex });
        }
        onSheetRemove(removedSheetName) {
            this.trigger("remove", { name: removedSheetName, confirmation: true });
        }
        onSheetSelect(selectedSheetText) {
            this.trigger("select", { name: selectedSheetText, isAddButton: false });
        }
        onSheetRename(newSheetName, sheetIndex) {
            this.trigger("rename", { name: newSheetName, sheetIndex: sheetIndex });
        }
        onAddSelect() {
            this.trigger("select", { isAddButton: true });
        }
        destroy() {
            super.destroy();
        }
    }

    /* eslint-disable complexity */
    /* eslint-disable consistent-return */
    /* eslint-disable default-case */
    /* eslint-disable no-implicit-coercion */
    /* eslint-disable no-nested-ternary */
    /* eslint-disable key-spacing */
    /* eslint-disable no-param-reassign */


    function selectElementContents(el) {
        let sel = window.getSelection();
        sel.removeAllRanges();

        let range = document.createRange();
        range.selectNodeContents(el);

        sel.addRange(range);
    }

    function cellBefore(table, row) {
        let cells = table.trs[row].children;
        return cells[cells.length - 2];
    }

    function cellAbove(table, row) {
        let prevRow = table.trs[row - 1];
        let index = table.trs[row].children.length - 1;

        if (prevRow && index >= 0) {
            return prevRow.children[index];
        }
    }

    function addCell(table, row, cell) {
        let style = {};

        if (cell.background) {
            style.backgroundColor = cell.background;
        }

        if (cell.color) {
            style.color = cell.color;
        }

        if (cell.fontFamily) {
            style.fontFamily = cell.fontFamily;
        }

        if (cell.underline) {
            style.textDecoration = "underline";
        }

        if (cell.italic) {
            style.fontStyle = "italic";
        }

        if (cell.textAlign) {
            style.textAlign = cell.textAlign;
        }

        if (cell.verticalAlign) {
            style.verticalAlign = (cell.verticalAlign === "center") ? "middle" : cell.verticalAlign;
        }

        if (cell.bold) {
            style.fontWeight = "bold";
        }

        if (cell.fontSize) {
            style.fontSize = cell.fontSize + "px";
        }

        if (cell.wrap === true) {
            style.whiteSpace = "pre-wrap";
        }

        if (cell.borderRight) {
            style.borderRight = cellBorder(cell.borderRight);
        } else if (cell.background) {
            style.borderRightColor = cell.background;
        }

        if (cell.borderBottom) {
            style.borderBottom = cellBorder(cell.borderBottom);
        } else if (cell.background) {
            style.borderBottomColor = cell.background;
        }

        let data = cell.value, type = typeof data, format = cell.format;
        if (!format && type === "number" && data !== Math.floor(data)) {
            format = "0.##############";
        }
        if (format && data != null) {
            data = formatting.format(data, format);
            if (data.__dataType) {
                type = data.__dataType;
            }
        }

        let attrs = { style: style };

        if (!style.textAlign) {
            switch (type) {
                case "number":
                case "date":
                case "percent":
                case "currency":
                    style.textAlign = "right";
                    break;
                case "boolean":
                    style.textAlign = "center";
                    break;
            }
        }

        if (!/^(?:string|undefined)$/.test(type)) {
            // provide original value and number format for better
            // interoperability with google sheets and libre office.
            attrs.sdval = cell.value;
            attrs["data-sheets-value"] = JSON.stringify({ 1: 3, 3: cell.value });
            if (format) {
                attrs.sdnum = format;
                attrs["data-sheets-numberformat"] = JSON.stringify({ 1: 2, 2: format, 3: 1 });
            }
        }
        if (cell.formula) {
            attrs["data-sheets-formula"] = "=" + cell.formula.print();
        }

        let className = null;

        if (cell.enable === false) {
            className = "k-disabled";
        }

        let td = table.addCell(row, data, attrs, className, cell.validation);

        let border, sibling;

        if (cell.borderLeft) {
            sibling = cellBefore(table, row);
            border = cellBorder(cell.borderLeft);
            if (sibling && border) {
                sibling.attr.style.borderRight = border;
            }
        } else if (cell.background) {
            style.borderLeftColor = cell.background;
        }

        if (cell.borderTop) {
            sibling = cellAbove(table, row);
            border = cellBorder(cell.borderTop);
            if (sibling && border) {
                sibling.attr.style.borderBottom = border;
            }
        } else if (cell.background) {
            style.borderTopColor = cell.background;
        }

        return td;
    }

    class HtmlTable {
        constructor() {
            this.cols = [];
            this.trs = [];
            this._height = 0;
            this._width = 0;
        }

        addColumn(width) {
            this._width += width;

            let col = dom.element("col", { style: { width: width + "px" } });

            col.visible = width > 0;

            this.cols.push(col);
        }

        addRow(height) {
            let attr = null;

            attr = { style: { height: height + "px" } };

            this._height += height;

            let tr = dom.element("tr", attr);

            tr.visible = height > 0;

            this.trs.push(tr);
        }

        addCell(rowIndex, text, attrs, className, validation) {
            if (text === null || text === undefined) {
                text = "";
            }
            if (!(text instanceof dom.Node)) {
                text = dom.text(text);
            }

            let children = [text];

            if (validation && !validation.value) {
                children.push(dom.element("span", { className: "k-dirty" }));

                className = (className || "") + (className ? " " : "") + "k-dirty-cell";
                attrs.title = validation.message;
            }

            if (className) {
                attrs.className = className;
            }
            let td = dom.element("td", attrs, children);

            this.trs[rowIndex].children.push(td);
            return td;
        }

        toDomTree(x, y, className) {
            this.trs = this.trs.filter(function (tr) {
                return tr.visible;
            });

            let offset = 0;
            this.cols = this.cols.filter(function (col, ci) {
                if (!col.visible) {
                    this.trs.forEach(function (tr) {
                        tr.children.splice(ci - offset, 1);
                    });
                    offset++;
                }

                return col.visible;
            }, this);

            return dom.element("table", {
                style: { left: x + "px", top: y + "px", height: this._height + "px", width: this._width + "px" },
                className: className,
                role: "presentation"
            }, [
                dom.element("colgroup", null, this.cols),
                dom.element("tbody", null, this.trs)
            ]);
        }
    }

    function within(value, min, max) {
        return value >= min && value <= max;
    }

    class View extends Observable {
        constructor(element, options) {
            super();
            let classNames = View.classNames;

            this.element = element;

            this.options = deepExtend({}, {
                messages: messages.view
            }, this.options, options);

            this.events = ['update', 'message'];

            this._chrome();

            this._dialogs = [];

            this._formulaInput();

            this.wrapper = element.querySelector(DOT + classNames.view);
            this.container = element.querySelector(DOT + classNames.fixedContainer);
            this.scroller = element.querySelector(DOT + classNames.scroller);
            this.clipboard = element.querySelector(DOT + classNames.clipboard);

            this.viewSize = this.scroller ?
                this.scroller.querySelector(".k-spreadsheet-view-size") || this.scroller.firstElementChild :
                null;

            if (!this.viewSize) {
                throw new Error("The scroller element does not contain a view size element.");
            }

            this.tree = new dom.Tree(this.container);
            this.clipboardContents = new dom.Tree(this.clipboard);

            this.editor = new SheetEditor(this);

            this._sheetsbar();

            this.options.createContextMenus?.();
        }

        enableClipboard(enable) {
            this.isClipboardDeactivated = !enable;

            if (enable) {
                this.clipboard.setAttribute("contenteditable", enable);
            } else {
                this.clipboard.removeAttribute("contenteditable");
            }
        }

        _resize() {
            // let actionBar = $(this.formulaBar.element).parents(".k-spreadsheet-action-bar");
            // let outerHeight = kendo._outerHeight;
            // let tabstripHeight = this.tabstrip ? outerHeight(this.tabstrip.element) : 0;
            // let formulaBarHeight = actionBar ? outerHeight(actionBar) : 0;
            // let sheetsBarHeight = this.sheetsbar ? outerHeight(this.sheetsbar.element) : 0;

            // this.wrapper.height(
            //     this.element.height() -
            //         (tabstripHeight + formulaBarHeight + sheetsBarHeight)
            // );

            // if (this.tabstrip) {
            //     this.tabstrip.quickAccessAdjust();
            // }
        }

        _chrome() {
            // let wrapper = document.createElement('div');
            // wrapper.className = 'k-spreadsheet-action-bar';
            // this.element.appendChild(wrapper);

            let nameEditor = this.element.querySelector('.k-spreadsheet-name-editor');
            this.nameEditor = new NameEditor(nameEditor, { combobox: this.options.nameBoxRef });

            // let formulaBar = document.createElement('div');
            // wrapper.appendChild(formulaBar);
            let formulaBar = this.element.querySelector('.k-spreadsheet-formula-bar');
            this.formulaBar = new FormulaBar(formulaBar, { input: this.options.formulaBarInputRef });

            // if (this.options.toolbar) {
            this._tabstrip();
            // }
        }

        _formulaInput() {
            let editor = this.element.querySelector(DOT + View.classNames.cellEditor);

            this.formulaInput = new FormulaInput(editor, {
                autoScale: true,
                input: this.options.formulaCellInputRef
            });
        }

        _sheetsbar() {
            if (this.options.sheetsbar) {
                this.sheetsbar = new SheetsBar(this.element.querySelector(DOT + View.classNames.sheetsBar), this.options.sheetsbar);
                this.options.createSheetBar?.(this.options.openDialogCallback);
            }
        }

        _tabstrip() {
            this.tabstrip = this.options.createTabStrip?.();
            // let messages = this.options.messages.tabs;
            // let options = $.extend(true, { home: true, insert: true, data: true }, this.options.toolbar);
            // let tabs = [];

            // if (this.tabstrip) {
            //     this.tabstrip.destroy();
            //     this.element.children(".k-tabstrip").remove();
            // }

            // for (let name in options) {
            //     if (options[name] === true || options[name] instanceof Array) {
            //         tabs.push({ id: name, text: messages[name], content: "" });
            //     }
            // }

            // this.tabstrip = new kendo.spreadsheet.TabStrip($("<div />").prependTo(this.element), {
            //     animation: false,
            //     dataTextField: "text",
            //     dataContentField: "content",
            //     dataSource: tabs,
            //     toolbarOptions: options,
            //     view: this
            // });

            // this.tabstrip.select(0);
        }

        _executeCommand(e) {
            this._sheet.trigger("commandRequest", e);
        }

        workbook(workbook) {
            this._workbook = workbook;
            workbook._view = this;
            this.nameEditor._workbook = workbook;
        }

        sheet(sheet) {
            this._sheet = sheet;
        }

        activeCellRectangle() {
            return this.cellRectangle(this._sheet._viewActiveCell());
        }

        _rectangle(pane, ref) {
            return pane._grid.boundingRectangle(ref.toRangeRef());
        }

        isColumnResizer(x, pane, col) {
            // relative to content
            x -= this._sheet._grid._headerWidth;

            // add scroll if pane is not frozen
            if (!pane._grid.columns.frozen) {
                x += this.scroller.scrollLeft;
            }

            col = this._sheet._grid._columns.locate(0, col, function (w) {
                return Math.abs(x - w) <= RESIZE_HANDLE_WIDTH / 2;
            });

            return col !== null && !this._sheet.isHiddenColumn(col) ? col : null;
        }

        isRowResizer(y, pane, row) {
            // relative to content
            y -= this._sheet._grid._headerHeight;

            // add scroll if pane is not frozen
            if (!pane._grid.rows.frozen) {
                y += this.scroller.scrollTop;
            }

            row = this._sheet._grid._rows.locate(0, row, function (h) {
                return Math.abs(y - h) <= RESIZE_HANDLE_WIDTH / 2;
            });

            return row !== null && !this._sheet.isHiddenRow(row) ? row : null;
        }

        isFilterIcon(x, y, pane, ref) {
            let self = this;
            let theGrid = pane._grid;
            let scrollTop = theGrid.rows.frozen ? 0 : self.scroller.scrollTop;
            let scrollLeft = theGrid.columns.frozen ? 0 : self.scroller.scrollLeft;

            x -= self._sheet._grid._headerWidth - scrollLeft;
            y -= self._sheet._grid._headerHeight - scrollTop;

            return withExit(function (exit) {
                self._sheet.forEachFilterHeader(ref, function (ref) {
                    let rect = self._rectangle(pane, ref);
                    if (pane.filterIconRect(rect).intersects(x, y)) {
                        exit(true);
                    }
                });
            });
        }

        isAutoFill(x, y, pane) {
            let selection = this._sheet.select();

            if (selection.size > 1) {
                return false;
            }

            x -= this._sheet._grid._headerWidth;
            y -= this._sheet._grid._headerHeight;

            if (!pane._grid.columns.frozen) {
                x += this.scroller.scrollLeft;
            }

            if (!pane._grid.rows.frozen) {
                y += this.scroller.scrollTop;
            }

            let rectangle = this._rectangle(pane, selection);

            return Math.abs(rectangle.right - x) < 8 && Math.abs(rectangle.bottom - y) < 8;
        }

        isEditButton(x, y, pane) {
            let ed = this._sheet.activeCellCustomEditor();
            if (ed) {
                let r = this.activeCellRectangle();
                // XXX: hard-coded button width (20)

                if (y >= r.top && y <= r.bottom) {
                    return pane._editorInLastColumn ? x < r.left && x >= r.left - EDIT_BUTTON_WIDTH
                        : x > r.right && x <= r.right + EDIT_BUTTON_WIDTH;
                }
            }
        }

        drawingAt(x, y, pane) {
            x -= this._sheet._grid._headerWidth;
            y -= this._sheet._grid._headerHeight;

            if (!pane._grid.columns.frozen) {
                x += this.scroller.scrollLeft;
            }

            if (!pane._grid.rows.frozen) {
                y += this.scroller.scrollTop;
            }

            let sheet = this._sheet;
            let drawings = this._sheet._drawings;
            for (let i = drawings.length; --i >= 0;) {
                let d = drawings[i];
                let box = sheet.drawingBoundingBox(d);
                if (box.intersects(x, y)) {
                    return {
                        drawing: d,

                        // also include how far is the drawing's
                        // top-left from the mouse position, as it's
                        // not easy to compute some place else.
                        drx: box.left - x,
                        dry: box.top - y
                    };
                }
            }
        }

        objectAt(x, y, noDrawing) {
            let grid = this._sheet._grid;
            let object, pane;

            if (x < 0 || y < 0 || x > this.scroller.clientWidth || y > this.scroller.clientHeight) {
                object = { type: "outside" };
            } else if (x < grid._headerWidth && y < grid._headerHeight) {
                object = { type: "topcorner" };
            } else {
                pane = this.paneAt(x, y);

                if (!pane) {
                    object = { type: "outside" };
                } else {
                    if (!noDrawing) {
                        let drawing = this.drawingAt(x, y, pane);
                        if (drawing) {
                            return {
                                type: "drawing",
                                drawing: drawing.drawing,
                                drx: drawing.drx,
                                dry: drawing.dry,
                                pane: pane,
                                startX: x,
                                startY: y
                            };
                        }
                    }

                    let row = pane._grid.rows.indexVisible(y, this.scroller.scrollTop);
                    let column = pane._grid.columns.indexVisible(x, this.scroller.scrollLeft);

                    let type = "cell";
                    let ref = new CellRef(row, column);
                    let selecting = this._sheet.selectionInProgress();

                    if (this.isAutoFill(x, y, pane)) {
                        type = "autofill";
                    } else if (this.isFilterIcon(x, y, pane, ref)) {
                        type = "filtericon";
                    } else if (!selecting && x < grid._headerWidth) {
                        type = "rowheader";
                        if ((row = this.isRowResizer(y, pane, row)) !== null) {
                            ref = new CellRef(row, -Infinity);
                            type = "rowresizehandle";
                        }
                    } else if (!selecting && y < grid._headerHeight) {
                        type = "columnheader";
                        if ((column = this.isColumnResizer(x, pane, column)) !== null) {
                            ref = new CellRef(-Infinity, column);
                            type = "columnresizehandle";
                        }
                    } else if (this.isEditButton(x, y, pane)) {
                        type = "editor";
                    }

                    object = { type: type, ref: ref };
                }
            }

            object.pane = pane;
            object.x = x;
            object.y = y;
            return object;
        }

        paneAt(x, y) {
            return this.panes.filter(function paneLocationWithin(pane) {
                let grid = pane._grid;
                return within(y, grid.top, grid.bottom) && within(x, grid.left, grid.right);
            })[0];
        }

        containingPane(cell) {
            return this.panes.filter(function (pane) {
                if (pane._grid.contains(cell)) {
                    return true;
                }
                return false;
            })[0];
        }

        cellRectangle(cell) {
            let theGrid = this.containingPane(cell)._grid;
            let rectangle = this._sheet._grid.rectangle(cell);

            return rectangle.offset(
                theGrid.headerWidth - (theGrid.columns.frozen ? 0 : this.scroller.scrollLeft),
                theGrid.headerHeight - (theGrid.rows.frozen ? 0 : this.scroller.scrollTop)
            );
        }

        refresh(reason) {
            let sheet = this._sheet;

            // if (this.tabstrip) {
            //     this.tabstrip.refreshTools(sheet.range(sheet.activeCell()));
            // }

            this.trigger('update', { reason, range: sheet.range(sheet.activeCell()), sheet });

            // if (reason.sheetSelection && this.sheetsbar) {
            //    this.sheetsbar.renderSheets(this._workbook.sheets(), this._workbook.sheetIndex(this._sheet));
            // }

            this._resize();

            //TODO: refresh sheets list on sheetSelection
            this.viewSize.style.height = sheet._grid.totalHeight() + "px";
            this.viewSize.style.width = sheet._grid.totalWidth() + "px";

            if (reason.layout) {
                let frozenColumns = sheet.frozenColumns();
                let frozenRows = sheet.frozenRows();

                // main or bottom or right pane
                this.panes = [this._pane(frozenRows, frozenColumns)];

                // left pane
                if (frozenColumns > 0) {
                    this.panes.push(this._pane(frozenRows, 0, null, frozenColumns));
                }

                // top pane
                if (frozenRows > 0) {
                    this.panes.push(this._pane(0, frozenColumns, frozenRows, null));
                }

                // left-top "fixed" pane
                if (frozenRows > 0 && frozenColumns > 0) {
                    this.panes.push(this._pane(0, 0, frozenRows, frozenColumns));
                }
            }

            if (reason.filter) {
                this._destroyFilterMenu();
            }

            if (reason.activeCell) {
                this._focus = sheet.activeCell().toRangeRef();
            }
        }

        createFilterMenu(column) {
            this._destroyFilterMenu();

            let sheet = this._sheet;
            let ref = sheet.filter().ref;
            let range = new Range$1(ref, sheet);

            let options = { column: column, range: range };

            this._filterMenu = this.options.createFilterMenu(options);

            return this._filterMenu;
        }

        selectClipboardContents() {
            if (!this.isClipboardDeactivated) {
                this.clipboard.focus({ preventScroll: true });
                selectElementContents(this.clipboard);
            }
        }

        scrollIntoView(cell) {
            let willScroll = false;
            let theGrid = this.containingPane(cell)._grid;

            let boundaries = theGrid.scrollBoundaries(cell);

            let scroller = this.scroller;
            let scrollTop = theGrid.rows.frozen ? 0 : scroller.scrollTop;
            let scrollLeft = theGrid.columns.frozen ? 0 : scroller.scrollLeft;

            if (boundaries.top < scrollTop) {
                willScroll = true;
                scroller.scrollTop = boundaries.scrollTop;
            }

            if (boundaries.bottom > scrollTop) {
                willScroll = true;
                scroller.scrollTop = boundaries.scrollBottom;
            }

            if (boundaries.left < scrollLeft) {
                willScroll = true;
                scroller.scrollLeft = boundaries.scrollLeft;
            }

            if (boundaries.right > scrollLeft) {
                willScroll = true;
                scroller.scrollLeft = boundaries.scrollRight;
            }

            return willScroll;
        }

        _destroyDialog() {
            this._dialogs.pop();
        }

        openCustomEditor() {
            let self = this;
            let cell = self._sheet.activeCell().first();
            let editor = self._sheet.activeCellCustomEditor();
            let range = self._sheet.range(cell);
            editor.edit({
                range: range,
                rect: self.activeCellRectangle(),
                view: this,
                validation: this._sheet.validation(cell),
                callback: function (value, parse) {
                    self._executeCommand({
                        command: "EditCommand",
                        options: {
                            operatingRange: range,
                            editRange: range,
                            property: parse ? "input" : "value",
                            value: value
                        }
                    });
                }
            });
        }

        openDialog(name, options) {
            let sheet = this._sheet;
            return sheet.withCultureDecimals(function () {
                let ref = sheet.activeCell();
                let range = new Range$1(ref, sheet);
                let args = { ...options, name, ref, range };
                this.trigger('message', args);
                return args.dialog;
            }.bind(this));
        }

        showError(options, reopenEditor) {
            let currentDialogs = this._dialogs;
            let errorMessages = this.options.messages.errors;

            if (currentDialogs.length > 0) {
                return;
            }

            let onClose = function () {
                currentDialogs.pop();
                // let dlg = e.sender;
                this.selectClipboardContents();
                if (reopenEditor) { // dlg._retry &&
                    reopenEditor();
                }
            }.bind(this);

            const dialogOptions = {
                title: options.title || "Error",
                text: options.body ? options.body : errorMessages[options.type],
                close: onClose
            };

            currentDialogs.push(dialogOptions);

            this.openDialog(options.type || "message", dialogOptions);
        }

        destroy() {
            this.unbind();

            [this.tree, this.clipboardContents].forEach(el => {
                while (el && el.root && el.root.lastChild) {
                    el.root.removeChild(el.root.lastChild);
                }
            });
            this.tree = this.clipboardContents = null;

            // this._dialogs.forEach(function(dialog) {
            //     dialog.destroy();
            // });

            // if (this.cellContextMenu) {
            //     this.cellContextMenu.destroy();
            // }

            // this.rowHeaderContextMenu.destroy();
            // this.colHeaderContextMenu.destroy();
            // this.drawingContextMenu.destroy();

            // this.cellContextMenu = this.rowHeaderContextMenu =
            //                         this.colHeaderContextMenu =
            //                         this.drawingContextMenu = null;

            if (this.tabstrip) {
                this.tabstrip.destroy();
                this.tabstrip = null;
            }

            this._destroyFilterMenu();
        }

        _destroyFilterMenu() {
            if (this._filterMenu) {
                this._filterMenu.destroy();
                this._filterMenu = undefined;
            }
        }

        render(reason) {
            // if (!this.element.is(":visible")) {
            //     return;
            // }
            let sheet = this._sheet;
            let focus = sheet.focus();
            let scrollbarSize = scrollbar();
            let contentWidth = this.wrapper.clientWidth - scrollbarSize;
            let contentHeight = this.wrapper.clientHeight - scrollbarSize;

            if (focus && this.scrollIntoView(focus)) {
                return;
            }

            let resizeDirection =
                !sheet.resizingInProgress() ? "none" :
                sheet.resizeHandlePosition().col === -Infinity ? "column" :
                "row";

            this.wrapper.classList.toggle(viewClassNames.editContainer, this.editor.isActive());
            this.wrapper.classList.toggle(viewClassNames.horizontalResize, resizeDirection === "row");
            this.wrapper.classList.toggle(viewClassNames.verticalResize, resizeDirection === "column");

            let grid = sheet._grid;
            let content = [];
            let args = {
                scroller: this.scroller,
                toplevelElements: content,
                contentWidth: contentWidth,
                contentHeight: contentHeight
            };
            this.panes.forEach(function (pane) {
                content.push(pane.render(args));
            });

            let topCorner = dom.element("div", {
                style: { width: grid._headerWidth + "px", height: grid._headerHeight + "px" },
                className: View.classNames.topCorner
            });

            content.push(topCorner);

            if (sheet.resizeHandlePosition() && sheet.resizeHintPosition()) {
                content.push(this.renderResizeHint());
            }

            this.tree.render(content);

            this.container.style.width = contentWidth + 'px';
            this.container.style.height = contentHeight + 'px';
            // $(this.container).css({
            //     width: contentWidth,
            //     height: contentHeight
            // });

            if (this.editor.isActive()) {
                this.editor.toggleTooltip(this.activeCellRectangle());
            } else if (!(reason.resize ||
                         reason.comment ||
                         sheet.selectionInProgress() ||
                         sheet.resizingInProgress() ||
                         sheet.draggingInProgress() ||
                         sheet.isInEditMode())) {
                this.renderClipboardContents();
            }
        }

        // this renders the big blue line during resizing
        renderResizeHint() {
            let sheet = this._sheet;
            let ref = sheet.resizeHandlePosition();

            let horizontal = ref.col !== -Infinity;

            let style;
            if (horizontal) {
                style = {
                    height: this.scroller.clientHeight + "px",
                    width: RESIZE_HANDLE_WIDTH + "px",
                    left: sheet.resizeHintPosition().x + "px",
                    top: "0px"
                };
            } else {
                style = {
                    height: RESIZE_HANDLE_WIDTH + "px",
                    width: this.scroller.clientWidth + "px",
                    top: sheet.resizeHintPosition().y + "px",
                    left: "0px"
                };
            }

            let classNames = Pane.classNames;

            return dom.element("div", {
                className: classNames.resizeHint + (!horizontal ? " " + classNames.resizeHintVertical : ""),
                style: style
            }, [
                dom.element("div", { className: classNames.resizeHintHandle }),
                dom.element("div", { className: classNames.resizeHintMarker })
            ]);
        }

        renderClipboardContents() {
            let sheet = this._sheet;
            let grid = sheet._grid;

            // if (sheet._activeDrawing && sheet._activeDrawing.image) {
            //     let url = this._workbook.imageUrl(sheet._activeDrawing.image);
            //     let img = dom.element("img", {
            //         src: url,
            //         style: {
            //             width: sheet._activeDrawing.width + "px",
            //             height: sheet._activeDrawing.height + "px"
            //         }
            //     });
            //     this.clipboardContents.render([ img ]);
            //     this.selectClipboardContents();
            //     return;
            // }

            let selection = grid.normalize(sheet.select().toRangeRef());
            let status = this._workbook.clipboard().canCopy();
            if (status.canCopy === false && status.multiSelection) {
                this.clipboardContents.render([]);
                this.selectClipboardContents();
                return;
            }

            selection = sheet.trim(selection);

            let table = new HtmlTable();

            let selectionView = grid.rangeDimensions(selection);

            selectionView.rows.forEach(function (height) {
                table.addRow(height);
            });

            selectionView.columns.forEach(function (width) {
                table.addColumn(width);
            });

            let tmp = sheet._getMergedCells(selection);
            let primaryMergedCells = tmp.primary;
            let secondaryMergedCells = tmp.secondary;

            sheet.forEach(selection, function (row, col, cell) {
                let location = new CellRef(row, col).print();

                if (!secondaryMergedCells[location]) {
                    let td = addCell(table, row - selection.topLeft.row, cell);

                    let mergedCell = primaryMergedCells[location];

                    if (mergedCell) {
                        td.attr.colspan = mergedCell.width();
                        td.attr.rowspan = mergedCell.height();
                    }
                }
            });

            this.clipboardContents.render([table.toDomTree(0, 0, "kendo-clipboard-" + this._workbook.clipboard()._uid)]);

            this.selectClipboardContents();
        }

        _pane(row, column, rowCount, columnCount) {
            let pane = new Pane(this._sheet, this._sheet._grid.pane({ row: row, column: column, rowCount: rowCount, columnCount: columnCount }), this.options.getIconHTMLString);
            pane.refresh(this.scroller.clientWidth, this.scroller.clientHeight);
            return pane;
        }
    }

    View.classNames = viewClassNames;

    const reTable = /<table[^>]+>/gmi;
    const tables = contentStr => ((contentStr || '').match(reTable) || []);

    class Clipboard {
        constructor(workbook) {
            this._content = {};
            this._externalContent = {};
            this._internalContent = {};
            this.workbook = workbook;
            this.origin = NULLREF;
            this.iframe = document.createElement("iframe");
            this.iframe.className = "k-spreadsheet-clipboard-paste";
            this.iframe.setAttribute("title", "Spreadsheet clipboard iframe");
            this.menuInvoked = false;
            this._uid = guid();
            document.body.appendChild(this.iframe);
        }

        destroy() {
            if (this.iframe && this.iframe.parentNode) {
                this.iframe.parentNode.removeChild(this.iframe);
            }
        }

        canCopy() {
            let status = { canCopy: true };
            let selection = this.workbook.activeSheet().select();
            if (selection === NULLREF) {
                status.canCopy = false;
            }
            if (selection instanceof UnionRef) {
                status.canCopy = false;
                status.multiSelection = true;
            }
            if (this.menuInvoked) {
                status.canCopy = false;
                status.menuInvoked = true;
            }
            return status;
        }

        canPaste() {
            let sheet = this.workbook.activeSheet();
            let ref = this.pasteRef();
            let range = sheet.range(ref);
            let status = { canPaste: true, pasteOnMerged: false, pasteOnDisabled: false };

            if (!range.enable()) {
                status.canPaste = false;
                status.pasteOnDisabled = true;
            }
            if (!ref.eq(sheet.unionWithMerged(ref))) {
                status.canPaste = false;
                status.pasteOnMerged = true;
            }
            if (this.menuInvoked) {
                status.canPaste = false;
                status.menuInvoked = true;
            }
            return status;
        }

        intersectsMerged() {
            let sheet = this.workbook.activeSheet();
            this.parse();
            this.origin = this._content.origRef;
            let ref = this.pasteRef();
            return !ref.eq(sheet.unionWithMerged(ref));
        }

        copy() {
            let sheet = this.workbook.activeSheet();
            this.origin = sheet.select();
            this._internalContent = sheet.selection().getState();
            delete this._externalContent.html;
            delete this._externalContent.plain;
        }

        cut() {
            let sheet = this.workbook.activeSheet();
            this.copy();
            sheet.range(sheet.select()).clear();
        }

        pasteRef() {
            let sheet = this.workbook.activeSheet();

            // When pasting from an external source, origin will be
            // NULLREF.  Just return the destination range.
            // https://github.com/telerik/kendo-ui-core/issues/3486
            if (this.origin === NULLREF) {
                return sheet.select();
            }

            let destination = sheet.activeCell().first();
            let originActiveCell = this.origin.first();
            let rowDelta = originActiveCell.row - destination.row;
            let colDelta = originActiveCell.col - destination.col;

            return this.origin.relative(rowDelta, colDelta, 3);
        }

        paste() {
            let sheet = this.workbook.activeSheet();
            let pasteRef = this.pasteRef();
            if (pasteRef.bottomRight.row >= sheet._rows._count || pasteRef.bottomRight.col >= sheet._columns._count) {
                sheet.resize(
                    Math.max(pasteRef.bottomRight.row + 1, sheet._rows._count),
                    Math.max(pasteRef.bottomRight.col + 1, sheet._columns._count)
                );
            }
            sheet.range(pasteRef).setState(this._content, this);
            sheet.triggerChange({ recalc: true, ref: pasteRef });
        }

        external(data) {
            if (data && (data.html || data.plain)) {
                this._externalContent = data;
            } else {
                return this._externalContent;
            }
        }

        isExternal() {
            return !this._isInternal();
        }

        parse() {
            let state;

            if (this._isInternal()) {
                state = this._internalContent;
            } else {
                let data = this._externalContent;
                state = data.plain ? parseTSV(data.plain) : newState();
                if (data.html) {
                    let doc = this.iframe.contentWindow.document;
                    doc.open();
                    doc.write(data.html);
                    doc.close();
                    let table = doc.querySelector("table"),
                        program = doc.head.querySelector("meta[name=ProgId]")?.getAttribute("content");
                    if (table) {
                        let richState = parseHTML(table, program);

                        // fixup #### values that are sent by Excel when the column is too
                        // narrow. It turns out that the plain text clipboard data contains the
                        // actual values. https://github.com/telerik/kendo-ui-core/issues/5277
                        richState.data.forEach(function(rowData, rowIndex) {
                            rowData.forEach(function(colData, colIndex) {
                                if (/^\s*#+\s*$/.test(colData.value)) {
                                    colData.value = state.data[rowIndex][colIndex].value;
                                }
                            });
                        });
                        state = richState;
                    }
                }
                this.origin = state.origRef;
            }

            this._content = state;
        }

        _isInternal() {
            if (this._externalContent.html === undefined) {
                return true;
            }

            const uid = "kendo-clipboard-" + this._uid;
            const includeUid = tablesArr => tablesArr.some(table => table.includes(uid));

            return includeUid(tables(this._externalContent.html)) || includeUid(tables(this._externalContent.plain));
        }
    }

    function newState() {
        let ref = new CellRef(0, 0, 0);
        return {
            ref: ref,
            mergedCells: [],
            data: [],
            foreign: true,
            origRef: ref.toRangeRef()
        };
    }

    function setStateData(state, row, col, value) {
        let data = state.data || (state.data = []);
        if (!data[row]) {
            data[row] = [];
        }
        data[row][col] = value;
        let br = state.origRef.bottomRight;
        br.row = Math.max(br.row, row);
        br.col = Math.max(br.col, col);
    }

    function stripStyle(style) {
        return style.replace(/^-(?:ms|moz|webkit)-/, "");
    }

    function borderObject(element, styles) {
        // MS Office uses class name and writes borders in the <style> section, so for it we need to
        // use the computed styles.  For Google Sheets / LibreOffice, however, the inline styles are
        // more accurate.
        if (!element.className) {
            styles = element.style;
        }
        let obj = {};
        [
            "borderBottom",
            "borderRight",
            "borderLeft",
            "borderTop"
        ].forEach(function(key) {
            let width = styles[key + "Width"];
            if (width) {
                width = parseInt(width, 10);
            }
            if (width) {
                obj[key] = {
                    size: width,
                    color: styles[key + "Color"] || "#000"
                };
            }
        });
        return obj;
    }

    function cellState(row, col, element, hBorders, vBorders, program) {
        let styles = window.getComputedStyle(element),
            isExcel = typeof program === "string" && program.indexOf("Excel") > -1;
        let value, format, formula;

        // google sheets
        if (!isExcel && (value = element.getAttribute("data-sheets-value"))) {
            value = JSON.parse(value);
            value = value[value[1]];
        }
        if (!isExcel && (format = element.getAttribute("data-sheets-numberformat"))) {
            format = JSON.parse(format);
            format = format[format[1]];
        }
        formula = element.getAttribute("data-sheets-formula");

        // libre office
        if (!isExcel && value == null && format == null && formula == null) {
            value = element.getAttribute("sdval");
            format = element.getAttribute("sdnum");
            if (format) {
                // for ungoogable reasons, libreoffice prepends format strings with
                // "1033;" and sometimes with "1033;0;". discard it below.
                format = format.replace(/^1033;(?:0;)?/, "");
            }
        }

        // note: Chrome 70 appends a \t to a cell's text, which is actually mandated by the standard
        // ([1] item 6).  We remove it below.  In [2] it's suggested they might switch back to
        // previous behavior, but removing an eventual last TAB won't hurt anyway.
        //
        // [1] https://www.w3.org/TR/html53/dom.html#dom-htmlelement-innertext
        // [2] https://bugs.chromium.org/p/chromium/issues/detail?id=897373
        if (value == null) {
            value = (element.innerText || element.textContent).replace(/\t$/, "");
        }

        let borders = borderObject(element, styles);
        let state = {
            value: value === "" ? null : value,
            formula: formula,

            borderTop: borders.borderTop || hBorders.get(row, col) || null,
            borderBottom: borders.borderBottom || hBorders.get(row + 1, col) || null,
            borderLeft: borders.borderLeft || vBorders.get(row, col) || null,
            borderRight: borders.borderRight || vBorders.get(row, col + 1) || null,

            fontSize: parseInt(styles["fontSize"], 10)
        };

        if (format != null) {
            state.format = format;
        }

        hBorders.set(row, col, state.borderTop);
        hBorders.set(row + 1, col, state.borderBottom);
        vBorders.set(row, col, state.borderLeft);
        vBorders.set(row, col + 1, state.borderRight);

        if (styles["backgroundColor"] !== "rgb(0, 0, 0)" && styles["backgroundColor"] !== "rgba(0, 0, 0, 0)") {
            state.background = styles["backgroundColor"];
        }
        if (stripStyle(styles["textAlign"]) !== "right") {
            state.textAlign = stripStyle(styles["textAlign"]);
        }
        if (styles["verticalAlign"] !== "middle") {
            state.verticalAlign = styles["verticalAlign"];
        }
        if (styles["wordWrap"] !== "normal" ) {
            state.wrap = true;
        }

        const txtElem = element.querySelector("font"); // libre office
        if (txtElem) {
            styles = window.getComputedStyle(txtElem);
        }

        if (styles.color !== "rgb(0, 0, 0)" && styles.color !== "rgba(0, 0, 0, 0)") {
            state.color = styles.color;
        }
        if (/^underline/.test(styles["textDecoration"])) {
            state.underline = true;
        }
        if (styles["fontStyle"] == "italic") {
            state.italic = true;
        }
        if (/^(?:bold|[67]00)$/i.test(styles["fontWeight"])) {
            state.bold = true;
        }

        return state;
    }

    function parseHTML(table, program) {
        let state = newState();

        let done = [], row = 0, col = 0;
        for (let i = 0; i < table.rows.length; ++i) {
            done.push([]);
        }
        let hBorders = new calc.runtime.Matrix();
        let vBorders = new calc.runtime.Matrix();

        for (let ri = 0; ri < table.rows.length; ++ri, ++row) {
            let tr = table.rows[ri];
            col = 0;
            for (let ci = 0; ci < tr.cells.length; ++ci) {
                let td = tr.cells[ci];
                let rowSpan = td.rowSpan;
                let colSpan = td.colSpan;
                while (done[row][col]) {
                    col++;
                }

                // A cell containing a long text overflowing the next (empty) cell will weirdly be
                // reported as merged by Excel (has colspan=2).  Then, Excel informatively suggests
                // us to ignore the colSpan by passing mso-ignore:colspan in the style.  Much thanks!
                // https://github.com/telerik/kendo-ui-core/issues/3760
                let style = td.getAttribute("style");
                let ignoreColspan = /mso-ignore:colspan/.test(style);

                setStateData(state, row, col, cellState(row, col, td, hBorders, vBorders, program));
                if (rowSpan > 1 || (colSpan > 1 && !ignoreColspan)) {
                    state.mergedCells.push(
                        new RangeRef(
                            new CellRef(row, col),
                            new CellRef(row + rowSpan - 1, col + colSpan - 1)
                        ).toString());
                }
                for (let dr = row + rowSpan; --dr >= row;) {
                    for (let dc = col + colSpan; --dc >= col;) {
                        if (dr < done.length) {
                            done[dr][dc] = true;
                            if (!(dr === row && dc === col)) {
                                setStateData(state, dr, dc, {});
                            }
                        }
                    }
                }
            }
        }

        return state;
    }

    function parseTSV(data) {
        let state = newState();
        if (data.indexOf("\t") === -1 && data.indexOf("\n") === -1) {
            setStateData(state, 0, 0, { value: data });
        } else {
            let rows = data.split("\n");
            for (let ri = 0; ri < rows.length; ri++) {
                let cols = rows[ri].split("\t");
                for (let ci = 0; ci < cols.length; ci++) {
                    setStateData(state, ri, ci, { value: cols[ci] });
                }
            }
        }
        return state;
    }

    /* eslint-disable no-else-return */
    /* eslint-disable consistent-return */
    /* eslint-disable space-before-blocks */
    /* eslint-disable no-implicit-coercion */


    let COMMAND_TYPES = {
        AUTO_FILL: "autoFill",
        CLEAR: "clear",
        CUT: "cut",
        EDIT: "edit",
        PASTE: "paste",
        VALIDATION: "validation"
    };

    const noop = () => { /* */ };

    class Command {
        constructor(options) {
            this.options = options;
            this._workbook = options.workbook;
            this._property = options && options.property;
            this._state = {};
        }
        range(range) {
            if (range !== undefined) {
                this._setRange(range);
            }

            return this._range;
        }
        _setRange(range) {
            this._range = range;
        }
        redo() {
            this.range().select();
            this.exec();
        }
        undo() {
            this.setState(this._state);
        }
        getState() {
            this._state = this.range().getState(this._property);
        }
        setState(state) {
            this.range().setState(state);
        }
        rejectState(validationState) {
            this.undo();
            return {
                title: validationState.title,
                body: validationState.message,
                reason: "error",
                type: "validationError"
            };
        }
        _forEachCell(callback) {
            let range = this.range();
            let ref = range._ref;

            ref.forEach(function(ref) {
                range.sheet().forEach(ref.toRangeRef(), callback.bind(this));
            }.bind(this));
        }
        usesImage(/* image id from workbook._images */) {
            return false;
        }
    }

    class DrawingUpdateCommand extends Command {
        constructor(options) {
            super(options);
            this._sheet = options.sheet;
            this._drawing = options.drawing;
            this._orig = this._drawing.clone();
            this._previous = options.previous;
        }
        exec() {}
        undo() {
            this._drawing.reset(this._previous);
            this._sheet._activeDrawing = this._drawing;
            this._sheet.triggerChange({ layout: true });
        }
        redo() {
            this._drawing.reset(this._orig);
            this._sheet._activeDrawing = this._drawing;
            this._sheet.triggerChange({ layout: true });
        }
        usesImage(img) {
            return this._drawing.image === img
                || this._orig.image === img
                || this._previous.image === img;
        }
    }

    class DrawingCommand extends Command {
        constructor(options) {
            super(options);
            this._drawing = options.drawing;
        }
        usesImage(img) {
            return this._drawing.image === img;
        }
    }

    class InsertImageCommand extends DrawingCommand {
        constructor(options) {
            super(options);
            this._blob = options.blob;
            this._width = options.width;
            this._height = options.height;
        }
        exec() {
            let range = this.range();
            let sheet = range.sheet();
            let width = this._width;
            let height = this._height;
            let aspect = width / height;
            if (width > height) {
                width = Math.min(width, 300);
                height = width / aspect;
            } else {
                height = Math.min(height, 300);
                width = height * aspect;
            }
            this._drawing = sheet.addDrawing({
                topLeftCell: range.topLeft(),
                offsetX: 5,
                offsetY: 5,
                width: width,
                height: height,
                opacity: 1,
                image: this._workbook.addImage(this._blob)
            }, true);
            this._blob = null;
        }
        undo() {
            let sheet = this.range().sheet();
            sheet._activeDrawing = null;
            sheet.removeDrawing(this._drawing);
        }
        redo() {
            let sheet = this.range().sheet();
            sheet._activeDrawing = this._drawing;
            sheet.addDrawing(this._drawing);
        }
    }

    class DeleteDrawingCommand extends DrawingCommand {
        exec() {
            let sheet = this.range().sheet();
            sheet._activeDrawing = null;
            sheet.removeDrawing(this._drawing);
        }
        undo() {
            let sheet = this.range().sheet();
            sheet._activeDrawing = this._drawing;
            sheet.addDrawing(this._drawing);
        }
        redo() {
            this.exec();
        }
    }

    class ReorderDrawingsCommand extends DrawingCommand {
        exec() {
            let sheet = this.range().sheet();
            this._origIndex = sheet._drawings.indexOf(this._drawing);
            sheet._drawings.splice(this._origIndex, 1);
            this._newIndex = this._reorder();
            sheet._drawings.splice(this._newIndex, 0, this._drawing);
            sheet.triggerChange({ drawings: true });
        }
        undo() {
            let sheet = this.range().sheet();
            sheet._drawings.splice(this._newIndex, 1);
            sheet._drawings.splice(this._origIndex, 0, this._drawing);
            sheet.triggerChange({ drawings: true });
        }
    }

    class BringToFrontCommand extends ReorderDrawingsCommand {
        _reorder() {
            return this.range().sheet()._drawings.length;
        }
    }

    class SendToBackCommand extends ReorderDrawingsCommand {
        _reorder() {
            return 0;
        }
    }

    class TargetValueCommand extends Command {
        constructor(options) {
            super(options);
            this._target = options.target;
            this._value = options.value;
        }
        exec() {
            this.getState();
            this.setState(this._value);
        }
    }

    class ColumnWidthCommand extends TargetValueCommand {
        getState() {
            this._state = this.range().sheet().columnWidth(this._target);
        }
        setState(state) {
            this.range().sheet().columnWidth(this._target, state);
        }
    }

    class RowHeightCommand extends TargetValueCommand {
        getState() {
            this._state = this.range().sheet().rowHeight(this._target);
        }
        setState(state) {
            this.range().sheet().rowHeight(this._target, state);
        }
    }

    class HyperlinkCommand extends Command {
        constructor(options) {
            super(options);
            this._link = options.link;
        }
        exec() {
            let range = this.range();
            this._prevLink = range.link();
            this._prevUnderline = range.underline();
            range.link(this._link);
            range.underline(true);
            if (range.value() == null) {
                this._hasSetValue = true;
                range.value(this._link);
            }
        }
        undo() {
            let range = this.range();
            range.link(this._prevLink);
            range.underline(this._prevUnderline);
            if (this._hasSetValue) {
                range.value(null);
            }
        }
    }

    class GridLinesChangeCommand extends TargetValueCommand {
        getState() {
            this._state = this._range.sheet().showGridLines();
        }
        setState(v) {
            this._range.sheet().showGridLines(v);
        }
    }

    class PropertyChangeCommand extends Command {
        _setRange(range) {
            Command.prototype._setRange.call(this, range.skipHiddenCells());
        }
        constructor(options) {
            super(options);
            this._value = options.value;
        }
        exec() {
            let range = this.range();
            if (range.enable()) {
                this.getState();

                if (this.options.property === "format") {
                    this._workbook.trigger("changeFormat", { range: range });
                }

                range[this._property](this._value);
            }
        }
    }

    class PropertyCleanCommand extends PropertyChangeCommand {
        exec() {
            let range = this.range();
            if (range.enable()) {
                this.getState();
                range.clearFormat();
            }
        }
    }

    class ClearContentCommand extends Command {
        exec() {
            let values = [], range, rowValues, nullValues, validationState, currentRange;
            if (!this.range().enable()) {
                return { reason: "error", type: "cannotModifyDisabled" };
            }
            if (!this.range().canEditArrayFormula()) {
                return { reason: "error", type: "intersectsArray" };
            }
            this.getState();
            range = this.range().skipHiddenCells();

            if (range._ref.refs && range._ref.refs.length > 1) {
                range._ref.refs.forEach(function(ref) {
                    currentRange = range.sheet().range(ref);
                    values = values.concat(currentRange.values());
                });
            } else {
                values = range.values();
            }
            nullValues = [];
            values.forEach(function(row) {
                rowValues = [];
                row.forEach(function() {
                    rowValues.push(null);
                });
                nullValues.push(rowValues);
            });
            if (range.sheet().trigger("changing", { data: nullValues, range: range, changeType: COMMAND_TYPES.CLEAR })) {
                return;
            }
            range.clearContent();
            validationState = range._getValidationState();
            if (validationState) {
                return this.rejectState(validationState);
            }
        }
        undo() {
            let range = this.range().skipHiddenCells();
            let sheet = range.sheet();
            let data = this._state.data;
            let values = [];
            let rowValues;
            data.forEach(function(row) {
                rowValues = [];
                row.forEach(function(cell) {
                    rowValues.push(cell.value);
                });
                values.push(rowValues);
            });
            if (sheet.trigger("changing", { data: values, range: range, changeType: COMMAND_TYPES.CLEAR })) {
                return;
            }
            this.setState(this._state);
        }
    }

    class EditCommand extends PropertyChangeCommand {
        constructor(options) {
            options.property = options.property || "input";
            super(options);
        }
        _setRange(range) {
            PropertyChangeCommand.prototype._setRange.apply(this, arguments);
            this._editRange = this.options.arrayFormula ? range : range.sheet().activeCellSelection();
        }
        getState() {
            this._state = this.range().getState();
        }
        exec() {
            return this.range().sheet().withCultureDecimals(this._exec.bind(this));
        }
        undo() {
            let editRange = this._editRange;
            let state = this._state;
            if (editRange.sheet().trigger("changing", { data: state.data[0][0].value, range: editRange, changeType: COMMAND_TYPES.EDIT })) {
                return;
            }
            this.setState(this._state);
        }
        _exec() {
            let arrayFormula = this.options.arrayFormula;
            let editRange = this._editRange;

            if (!editRange.enable()) {
                return { reason: "error", type: "rangeDisabled" };
            }

            if (!editRange.canEditArrayFormula()) {
                return { reason: "error", type: "intersectsArray" };
            }

            let value = this._value;
            this.getState();
            if (this.range().sheet().trigger("changing", { data: value, range: this._editRange, changeType: COMMAND_TYPES.EDIT })) {
                return;
            }

            if (this._property === "value") {
                editRange.value(value);
                return;
            }

            try {
                editRange.link(null);
                if (value === "") {
                    editRange.value(null);
                } else {
                    editRange.input(value, { arrayFormula: arrayFormula });
                    if (/\n/.test(editRange.value())) {
                        editRange.wrap(true);
                    }
                }
                editRange._adjustRowHeight();

                let validationState = editRange._getValidationState();
                if (validationState) {
                    return this.rejectState(validationState);
                }
            } catch (ex) {
                if (ex instanceof calc.runtime.ParseError) {
                    return {
                        title: "Error in formula",
                        body: ex + "",
                        reason: "error"
                    };
                } else {
                    throw ex;
                }
            }
        }
    }

    class InsertCommentCommand extends PropertyChangeCommand {
        constructor(options) {
            options.property = "comment";
            super(options);
        }
    }

    class TextWrapCommand extends PropertyChangeCommand {
        constructor(options) {
            options.property = "wrap";
            super(options);

            this._value = options.value;
        }
        getState() {
            let rowHeight = {};
            this.range().forEachRow(function(range) {
                let index = range.topLeft().row;

                rowHeight[index] = range.sheet().rowHeight(index);
            });

            this._state = this.range().getState(this._property);
            this._rowHeight = rowHeight;
        }
        undo() {
            let sheet = this.range().sheet();
            let rowHeight = this._rowHeight;

            this.range().setState(this._state);

            for (let row in rowHeight) {
                sheet.rowHeight(row, rowHeight[row]);
            }
        }
    }

    class AdjustDecimalsCommand extends Command {
        constructor(options) {
            options.property = "format";
            super(options);
            this._delta = options.value;
        }
        exec() {
            let sheet = this.range().sheet();
            let delta = this._delta;

            this.getState();

            sheet.batch(function() {
                this.range().forEachCell(function(row, col, cell) {
                    let format = cell.format;

                    if (!format) {
                        let value = cell.value;
                        if (typeof value == "number" && /\./.test(value)) {
                            format = "0." + String(value).split(".")[1].replace(/\d/g, "0");
                        }
                    }

                    if (format || delta > 0) {
                        format = formatting.adjustDecimals(format || "0", delta);
                        sheet.range(row, col).format(format);
                    }
                });
            }.bind(this));
        }
    }

    class BorderChangeCommand extends Command {
        constructor(options) {
            options.property = "border";
            super(options);
            this._type = options.border;
            this._style = options.style;
        }
        _batch(f) {
            return this.range().sheet().batch(f, {});
        }
        exec() {
            let self = this;

            if (!self._type) {
                return;
            }

            self.getState();
            self._batch(function(){
                self[self._type](self._style);
            });
        }
        noBorders() {
            this.range().insideBorders(null);
            this.outsideBorders(null);
        }
        allBorders(style) {
            this.range().insideBorders(style);
            this.outsideBorders(style);
        }
        leftBorder(style) {
            this.range().leftColumn().borderLeft(style);
        }
        rightBorder(style) {
            this.range().rightColumn().borderRight(style);
        }
        topBorder(style) {
            this.range().topRow().borderTop(style);
        }
        bottomBorder(style) {
            this.range().bottomRow().borderBottom(style);
        }
        outsideBorders(style) {
            let range = this.range();
            range.leftColumn().borderLeft(style);
            range.topRow().borderTop(style);
            range.rightColumn().borderRight(style);
            range.bottomRow().borderBottom(style);
        }
        insideBorders(style) {
            this.range().insideBorders(style);
            this.outsideBorders(null);
        }
        insideHorizontalBorders(style) {
            this.range().insideHorizontalBorders(style);
        }
        insideVerticalBorders(style) {
            this.range().insideVerticalBorders(style);
        }
    }

    class MergeCellCommand extends Command {
        constructor(options) {
            super(options);
            this._type = options.value;
        }
        exec() {
            this.getState();
            this[this._type]();
            this.range().sheet().triggerChange({ recalc: true });
        }
        activate(ref) {
            this.range().sheet().activeCell(ref);
        }
        getState() {
            this._state = this.range().getState();
        }
        undo() {
            if (this._type !== "unmerge") {
                this.range().unmerge();
                this.activate(this.range().topLeft());
            }
            this.range().setState(this._state);
        }
        cells() {
            let range = this.range();
            let ref = range._ref;

            range.merge();
            this.activate(ref);
        }
        horizontally() {
            let ref = this.range().topRow()._ref;

            this.range().forEachRow(function(range) {
                range.merge();
            });

            this.activate(ref);
        }
        vertically() {
            let ref = this.range().leftColumn()._ref;

            this.range().forEachColumn(function(range) {
                range.merge();
            });

            this.activate(ref);
        }
        unmerge() {
            let range = this.range();
            let ref = range._ref.topLeft;

            range.unmerge();
            this.activate(ref);
        }
    }

    class FreezePanesCommand extends Command {
        constructor(options) {
            super(options);
            this._type = options.value;
        }
        exec() {
            this.getState();
            this._topLeft = this.range().topLeft();
            this[this._type]();
        }
        getState() {
            this._state = this.range().sheet().getState();
        }
        undo() {
            this.range().sheet().setState(this._state);
        }
        panes() {
            let topLeft = this._topLeft;
            let sheet = this.range().sheet();

            sheet.frozenColumns(topLeft.col).frozenRows(topLeft.row);
        }
        rows() {
            let topLeft = this._topLeft;
            let sheet = this.range().sheet();

            sheet.frozenRows(topLeft.row);
        }
        columns() {
            let topLeft = this._topLeft;
            let sheet = this.range().sheet();

            sheet.frozenColumns(topLeft.col);
        }
        unfreeze() {
            let sheet = this.range().sheet();
            sheet.frozenRows(0).frozenColumns(0);
        }
    }

    class PasteCommand extends Command {
        constructor(options) {
            super(options);
            this._clipboard = options.workbook.clipboard();
            this._clipboard.parse();
            this._event = options.event;
            this._clipboardContent = this._clipboard._content;
            this._sheet = this._workbook.activeSheet();
            this._range = this._sheet.selection ? this._sheet.selection() : this._sheet.range(this._clipboard.pasteRef());
            this._state = this._range.getState();
            this._targetRangeRefs = (this._range._ref instanceof UnionRef ? this._range._ref.refs : [this._range._ref]).map(function(ref){
                return ref.toRangeRef();
            });
        }
        exec() {
            return this.range().sheet().withCultureDecimals(this._exec.bind(this));
        }
        undo() {
            let sheet = this._sheet;
            let range = this._range;

            if (sheet.trigger("changing", { data: this._state.data, range: range, changeType: COMMAND_TYPES.PASTE })) {
                return;
            }

            this.setState(this._state);
        }
        _exec() {
            let status = this._clipboard.canPaste();

            if (!status.canPaste) {
                if (status.menuInvoked) {
                    return { reason: "error", type: "useKeyboard" };
                }
                if (status.pasteOnMerged) {
                    return { reason: "error", type: "modifyMerged" };
                }
                if (status.pasteOnDisabled) {
                    this._event.preventDefault();
                    return { reason: "error", type: "cannotModifyDisabled" };
                }
                return { reason: "error" };
            }

            let sheet = this._sheet;
            let range = this._range;

            if (this._workbook.trigger("paste", { range: range, clipboardContent: this._clipboardContent }) ||
                sheet.trigger("changing", { data: this._clipboardContent.data, range: range, changeType: COMMAND_TYPES.PASTE })) {
                this._event.preventDefault();
                return;
            } else {
                this._processPaste();
            }
        }
        _adjustPasteTarget(multipliers, sourceRows, sourceCols) {
            let that = this;
            let targetRangeRefs = that._targetRangeRefs;
            let sheet = that._sheet;
            let refs = [];
            let compare = function(a, b) {
                let result = 0;
                let topLeftA = a.topLeft;
                let topLeftB = b.topLeft;

                if (topLeftA.row > topLeftB.row) {
                    result = 1;
                } else if (topLeftA.row < topLeftB.row) {
                    result = -1;
                } else if (topLeftA.col > topLeftB.col) {
                    result = 1;
                } else if (topLeftA.col < topLeftB.col) {
                    result = -1;
                }

                return result;
            };

            let refToSelect, rangeToSelect, ref, topLeft, multiplier, i, bottomRight;

            for (i = 0; i < targetRangeRefs.length; i += 1) {
                ref = targetRangeRefs[i];
                multiplier = multipliers[i];
                topLeft = ref.topLeft;
                bottomRight = {
                    row: multiplier.rows * sourceRows + topLeft.row - 1,
                    col: multiplier.cols * sourceCols + topLeft.col - 1
                };

                refToSelect = new RangeRef(topLeft, bottomRight);
                refs.push(refToSelect);
            }

            if (refs.length === 1) {
                rangeToSelect = sheet.range(refToSelect);
            } else {
                refs.sort(compare);
                rangeToSelect = sheet.range(new UnionRef(refs));
            }

            rangeToSelect.select();
            that._range = rangeToSelect;
            that._state = that._range.getState();
        }
        _processPaste() {
            let that = this;
            let sheet = that._sheet;
            let clipboardContent = that._clipboardContent;
            let range = that._range;
            let sourceData = clipboardContent.data;
            let sourceRows = sourceData.length;
            let sourceCols = sourceData[0].length;
            let targetRangeRefs = that._targetRangeRefs;
            let multipliers = that._targetRanges(sourceRows, sourceCols);
            let i;

            let pasteRef = this._clipboard.pasteRef();
            if (pasteRef.bottomRight.row >= sheet._rows._count || pasteRef.bottomRight.col >= sheet._columns._count) {
                sheet.resize(
                    Math.max(pasteRef.bottomRight.row + 1, sheet._rows._count),
                    Math.max(pasteRef.bottomRight.col + 1, sheet._columns._count)
                );
            }

            that._adjustPasteTarget(multipliers, sourceRows, sourceCols);

            sheet.batch(function() {
                for (i = 0; i < targetRangeRefs.length; i++) {
                    that._populateTargetRange(targetRangeRefs[i], sourceRows, sourceCols, multipliers[i]);
                }
            }, {
                recalc: true,
                ref: that._range._ref
            });

            range._adjustRowHeight();
        }
        _populateTargetRange(ref, sourceRows, sourceCols, multipliers) {
            let topLeft = ref.topLeft;
            let range, i, j;

            for (i = 0; i < multipliers.rows; i++) {
                for (j = 0; j < multipliers.cols; j++) {
                    range = this._sheet.range(topLeft.row + sourceRows * i, topLeft.col + sourceCols * j);
                    range.setState(this._clipboardContent, this._clipboard);
                }
            }
        }
        _targetRangeDimensions(ref, sourceRows, sourceCols) {
            let topLeft = ref.topLeft;
            let bottomRight = ref.bottomRight;
            let targetRangeRows = bottomRight.row - topLeft.row + 1;
            let targetRangeCols = bottomRight.col - topLeft.col + 1;
            let rowsMultiplier = 1;
            let colsMultiplier = 1;

            if ((targetRangeRows % sourceRows === 0 && targetRangeCols % sourceCols === 0)) {
                rowsMultiplier = targetRangeRows / sourceRows;
                colsMultiplier = targetRangeCols / sourceCols;
            }

            return {
                rows: rowsMultiplier,
                cols: colsMultiplier
            };
        }
        _targetRanges(sourceRows, sourceCols) {
            let targetRangeRefs = this._targetRangeRefs;
            let multipliers = [];
            let i;

            for (i = 0; i < targetRangeRefs.length; i++) {
                multipliers.push(this._targetRangeDimensions(targetRangeRefs[i], sourceRows, sourceCols));
            }

            return multipliers;
        }
    }

    class AdjustRowHeightCommand extends Command {
        exec() {
            let options = this.options;
            let sheet = this._workbook.activeSheet();
            let range = options.range || sheet.range(options.rowIndex);

            range._adjustRowHeight();
        }
    }

    class ToolbarPasteCommand extends Command {
        exec() {
            if (detectClipboardAccess().paste) {
                this._workbook._view.clipboard.focus({ preventScroll: true });
                // explore programmatic pasting further
                document.execCommand('paste');
            } else {
                return { reason: "error", type: "useKeyboard" };
            }
        }
    }

    class CutCommand extends Command {
        constructor(options) {
            super(options);
            this._eventType = "cut";
            this._clipboard = options.workbook.clipboard();
            this._event = options.event;
        }
        exec() {
            let status = this._clipboard.canCopy();
            let data = [], rangeValues, currentRow;
            if (!status.canCopy) {
                if (status.menuInvoked) {
                    return { reason: "error", type: "useKeyboard" };
                } else if (status.multiSelection) {
                    return { reason: "error", type: "unsupportedSelection" };
                }
                return;
            }
            let range = this._workbook.activeSheet().selection();
            if (this._eventType === "cut") {
                if (!range.enable()) {
                    this._event.preventDefault();
                    return { reason: "error", type: "cannotModifyDisabled" };
                }
                this.getState();
            }
            if (this._workbook.trigger(this._eventType, { range: range })) {
                this._event.preventDefault();
            } else if (this._eventType === "cut") {
                rangeValues = range.values();
                rangeValues.forEach(function(row){
                    currentRow = [];
                    row.forEach(function(){
                        currentRow.push({});
                    });
                    data.push(currentRow);
                });
                if (range.sheet().trigger("changing", { data: data, range: range, changeType: COMMAND_TYPES.CUT })) {
                    return;
                }
                this._clipboard.cut();
            } else {
                this._clipboard.copy();
            }
        }
        undo() {
            let range = this.range();
            if (range.sheet().trigger("changing", { data: this._state.data, range: range, changeType: COMMAND_TYPES.CUT })) {
                return;
            }
            this.setState(this._state);
        }
    }

    class CopyCommand extends CutCommand {
        constructor(options) {
            super(options);
            this._eventType = "copy";
            this.undo = noop;
        }
    }

    // function copyToClipboard(html) {
    //     let textarea = document.createElement('textarea');
    //     $(textarea).addClass("k-spreadsheet-clipboard")
    //         .val(html)
    //         .appendTo(document.body)
    //         .trigger("focus")
    //         .select();

    //     document.execCommand('copy');

    //     $(textarea).remove();
    // }

    function detectClipboardAccess() {
        const commands = {
            copy: document.queryCommandSupported ? document.queryCommandSupported("copy") : false,
            cut: document.queryCommandSupported ? document.queryCommandSupported("cut") : false,
            paste: document.queryCommandSupported ? document.queryCommandSupported("paste") : false
        };

        return commands;
    }

    class ToolbarCopyCommand extends Command {
        constructor(options) {
            super(options);
            this._clipboard = options.workbook.clipboard();
            this.cannotUndo = true;
        }
        exec() {
            if (detectClipboardAccess().copy) {
                document.execCommand('copy');
            } else {
                return { reason: "error", type: "useKeyboard" };
            }
        }
    }

    class AutoFillCommand extends Command {
        constructor(options) {
            super(options);
        }
        origin(origin) {
            this._origin = origin;
        }
        exec() {
            let range = this.range(), autoFillData;
            if (!range.enable()) {
                return { reason: "error", type: "rangeDisabled" };
            }
            if (range.intersectingArrayFormula()) {
                return { reason: "error", type: "intersectsArray" };
            }
            this.getState();
            try {
                autoFillData = range._previewFillFrom(this._origin);
                if (range.sheet().trigger("changing", { data: autoFillData.props, range: autoFillData.dest, changeType: COMMAND_TYPES.AUTO_FILL })) {
                    return;
                }
                autoFillData.dest._properties(autoFillData.props, true);
            } catch (ex) {
                if (ex instanceof Range$1.FillError) {
                    return { reason: "error", type: ex.code };
                }
                throw ex;
            }
        }
        undo() {
            let range = this.range();
            let state = this._state;
            if (range.sheet().trigger("changing", { data: state.data, range: range, changeType: COMMAND_TYPES.AUTO_FILL })) {
                return;
            }
            this.setState(this._state);
        }
    }

    class ToolbarCutCommand extends Command {
        constructor(options) {
            super(options);
            this._clipboard = options.workbook.clipboard();
            this.cannotUndo = true;
        }
        exec() {
            if (detectClipboardAccess().copy) {
                document.execCommand('cut');
            } else {
                return { reason: "error", type: "useKeyboard" };
            }
        }
    }

    class FilterCommand extends Command {
        undo() {
            this.range().filter(this._state);
        }
        exec() {
            let range = this.range();
            this._state = range.hasFilter();
            range.filter(!this._state);
        }
    }

    class SortCommand extends Command {
        undo() {
            let sheet = this.range().sheet();
            sheet.setState(this._state);
        }
        exec() {
            let range = this.range();
            let sheet = range.sheet();
            let activeCell = sheet.activeCell();
            let col = this.options.sheet ? activeCell.topLeft.col : (this.options.column || 0);
            let ascending = this.options.value === "asc" ? true : false;

            this._state = sheet.getState();

            if (this.options.sheet) {
                range = this.expandRange();
            }

            let reason = range.cantSort();
            if (reason) {
                return { reason: "error", type: reason.code };
            }

            range.sort({ column: col, ascending: ascending });
        }
        expandRange() {
            let sheet = this.range().sheet();
            return new Range$1(sheet._sheetRef, sheet);
        }
    }

    class ApplyFilterCommand extends Command {
        column() {
            return this.options.column || 0;
        }
        undo() {
            let sheet = this.range().sheet();

            sheet.clearFilter(this.column());

            if (this._state.length) {
                this.range().filter(this._state);
            }
        }
        getState() {
            let sheet = this.range().sheet();
            let current = sheet.filter();

            if (current) {
                this._state = current.columns.filter(function(c) {
                    return c.index === this.column();
                }.bind(this));
            }
        }
        exec() {
            let range = this.range();
            let column = this.column();
            let current = range.sheet().filter();
            let options;
            let filterRule;
            let exists = false;

            if (this.options.valueFilter) {
                filterRule = { column: column, filter: new ValueFilter(this.options.valueFilter) };
            } else if (this.options.customFilter) {
                filterRule = { column: column, filter: new CustomFilter(this.options.customFilter) };
            }

            this.getState();

            if (current && current.ref.eq(range._ref) && current.columns.length) {
                current.columns.forEach(function(element) {
                    if (element.index === column) {
                        exists = true;
                    }
                });

                options = current.columns.map(function(element) {
                    return element.index === column ? filterRule : { column: element.index, filter: element.filter };
                });

                if (!exists) {
                    options.push(filterRule);
                }
            } else {
                options = filterRule;
            }

            range.filter(options);
        }
    }

    class ClearFilterCommand extends ApplyFilterCommand {
        exec() {
            let range = this.range();
            let column = this.column();

            this.getState();
            range.clearFilter(column);
        }
    }

    class HideLineCommand extends Command {
        constructor(options) {
            super(options);
            this.axis = options.axis;
        }

        undo() {
            let sheet = this.range().sheet();
            sheet.setAxisState(this._state);
        }

        exec() {
            let sheet = this.range().sheet();
            this._state = sheet.getAxisState();

            if (this.axis === "row") {
                sheet.axisManager().hideSelectedRows();
            } else {
                sheet.axisManager().hideSelectedColumns();
            }
        }
    }

    class UnHideLineCommand extends HideLineCommand {
        exec() {
            let sheet = this.range().sheet();
            this._state = sheet.getAxisState();

            if (this.axis === "row") {
                sheet.axisManager().unhideSelectedRows();
            } else {
                sheet.axisManager().unhideSelectedColumns();
            }
        }
    }

    class DeleteCommand extends Command {
        exec() {
            this._expandedRange = this._expand(this.range());
            this._state = this._expandedRange.getState();
            this._indexes = this._exec(this._expandedRange.sheet());
        }
        undo() {
            let self = this;
            let range = self._expandedRange;
            let sheet = range.sheet();
            sheet.batch(function(){
                self._indexes.forEach(function(x){
                    self._undoOne(sheet, x);
                    sheet._restoreModifiedFormulas(x.formulas);
                });
                range.setState(self._state);
            }, { layout: true, recalc: true, ref: range._ref, isValue: true });
        }
    }

    class DeleteRowCommand extends DeleteCommand {
        _expand(range) {
            return range.resize({ left: -Infinity, right: +Infinity });
        }
        _exec(sheet) {
            return sheet.axisManager().deleteSelectedRows();
        }
        _undoOne(sheet, x) {
            sheet.insertRow(x.index);
            sheet.rowHeight(x.index, x.height);
        }
    }

    class DeleteColumnCommand extends DeleteCommand {
        _expand(range) {
            return range.resize({ top: -Infinity, bottom: +Infinity });
        }
        _exec(sheet) {
            return sheet.axisManager().deleteSelectedColumns();
        }
        _undoOne(sheet, x) {
            sheet.insertColumn(x.index);
            sheet.columnWidth(x.index, x.width);
        }
    }

    class AddCommand extends Command {
        constructor(options) {
            super(options);
            this._value = options.value;
        }
        undo() {
            let self = this;
            let sheet = self.range().sheet();
            sheet.batch(function(){
                for (let i = self._pos.count; --i >= 0;) {
                    self._undoOne(sheet, self._pos.base);
                }
            }, { layout: true, recalc: true });
        }
    }

    class AddColumnCommand extends AddCommand {
        exec() {
            let value = this._value;
            let sheet = this.range().sheet();

            if (value === "left") {
                this._pos = sheet.axisManager().addColumnLeft();
            } else {
                this._pos = sheet.axisManager().addColumnRight();
            }
        }
        _undoOne(sheet, index) {
            sheet.deleteColumn(index);
        }
    }

    class AddRowCommand extends AddCommand {
        exec() {
            let value = this._value;
            let sheet = this.range().sheet();

            if (value === "above") {
                this._pos = sheet.axisManager().addRowAbove();
            } else {
                this._pos = sheet.axisManager().addRowBelow();
            }
        }
        _undoOne(sheet, index) {
            sheet.deleteRow(index);
        }
    }

    class EditValidationCommand extends Command {
        constructor(options) {
            super(options);
            this._value = options.value;
        }
        exec() {
            let self = this, sheet = self.range().sheet();
            this.getState();
            if (sheet.trigger("changing", { data: self._value, range: self.range(), changeType: COMMAND_TYPES.VALIDATION })) {
                return;
            }
            try {
                sheet.withCultureDecimals(function(){
                    self.range().validation(self._value);
                });
            } catch (ex) {
                if (ex instanceof calc.runtime.ParseError) {
                    return {
                        title: "Error in formula",
                        body: ex + "",
                        reason: "error"
                    };
                } else {
                    throw ex;
                }
            }
        }
        undo() {
            let editRange = this.range();
            let state = this._state;
            if (editRange.sheet().trigger("changing", { data: state.data[0][0].validation, range: editRange, changeType: COMMAND_TYPES.VALIDATION })) {
                return;
            }
            this.setState(this._state);
        }
    }

    class OpenCommand extends Command {
        constructor(options) {
            super(options);
            this.cannotUndo = true;
        }
        exec() {
            let file = this.options.file;
            if (file.name.match(/.xlsx$/i) === null) {
                return { reason: "error", type: "openUnsupported" };
            }

            let workbook = this.options.workbook;
            workbook.fromFile(this.options.file);

            let errors = workbook.excelImportErrors;
            if (errors && errors.length) {
                workbook._view.openDialog("importError", {
                    errors: errors
                });
            }
        }
    }

    class SaveAsCommand extends Command {
        constructor(options) {
            super(options);
            this.cannotUndo = true;
        }
        exec() {
            let fileName = this.options.name + this.options.extension;
            if (this.options.extension === ".xlsx") {
                return this.options.workbook.saveAsExcel({
                    fileName: fileName
                });
            } else if (this.options.extension === ".pdf") {
                this.options.workbook.saveAsPDF(deepExtend(this.options.pdf, { workbook: this.options.workbook, fileName: fileName }));
            }
        }
    }

    class NameCommand extends Command {
        constructor(options) {
            super(options);
            this._name = options.name;
            this._value = options.value;
        }
        getState() {
            this._state = this._workbook.nameDefinition(this._name);
        }
        setState() {
            this._workbook.nameDefinition(this._name, this._state);
            this._workbook.trigger("change", { recalc: true });
        }
    }

    class DefineNameCommand extends NameCommand {
        exec() {
            this.getState();
            try {
                this._workbook.defineName(this._name, this._value);
                this._workbook.trigger("change", { recalc: true });
            } catch (ex) {
                return {
                    title: "Error",
                    body: ex + "",
                    reason: "error"
                };
            }
        }
    }

    class DeleteNameCommand extends NameCommand {
        exec() {
            this.getState();
            this._workbook.undefineName(this._name);
            this._workbook.trigger("change", { recalc: true });
        }
    }

    var commands = /*#__PURE__*/Object.freeze({
        __proto__: null,
        AddColumnCommand: AddColumnCommand,
        AddCommand: AddCommand,
        AddRowCommand: AddRowCommand,
        AdjustDecimalsCommand: AdjustDecimalsCommand,
        AdjustRowHeightCommand: AdjustRowHeightCommand,
        ApplyFilterCommand: ApplyFilterCommand,
        AutoFillCommand: AutoFillCommand,
        BorderChangeCommand: BorderChangeCommand,
        BringToFrontCommand: BringToFrontCommand,
        ClearContentCommand: ClearContentCommand,
        ClearFilterCommand: ClearFilterCommand,
        ColumnWidthCommand: ColumnWidthCommand,
        Command: Command,
        CopyCommand: CopyCommand,
        CutCommand: CutCommand,
        DefineNameCommand: DefineNameCommand,
        DeleteColumnCommand: DeleteColumnCommand,
        DeleteCommand: DeleteCommand,
        DeleteDrawingCommand: DeleteDrawingCommand,
        DeleteNameCommand: DeleteNameCommand,
        DeleteRowCommand: DeleteRowCommand,
        DrawingCommand: DrawingCommand,
        DrawingUpdateCommand: DrawingUpdateCommand,
        EditCommand: EditCommand,
        EditValidationCommand: EditValidationCommand,
        FilterCommand: FilterCommand,
        FreezePanesCommand: FreezePanesCommand,
        GridLinesChangeCommand: GridLinesChangeCommand,
        HideLineCommand: HideLineCommand,
        HyperlinkCommand: HyperlinkCommand,
        InsertCommentCommand: InsertCommentCommand,
        InsertImageCommand: InsertImageCommand,
        MergeCellCommand: MergeCellCommand,
        NameCommand: NameCommand,
        OpenCommand: OpenCommand,
        PasteCommand: PasteCommand,
        PropertyChangeCommand: PropertyChangeCommand,
        PropertyCleanCommand: PropertyCleanCommand,
        ReorderDrawingsCommand: ReorderDrawingsCommand,
        RowHeightCommand: RowHeightCommand,
        SaveAsCommand: SaveAsCommand,
        SendToBackCommand: SendToBackCommand,
        SortCommand: SortCommand,
        TargetValueCommand: TargetValueCommand,
        TextWrapCommand: TextWrapCommand,
        ToolbarCopyCommand: ToolbarCopyCommand,
        ToolbarCutCommand: ToolbarCutCommand,
        ToolbarPasteCommand: ToolbarPasteCommand,
        UnHideLineCommand: UnHideLineCommand
    });

    class UndoRedoStack extends Observable {
        constructor(options) {
            super();
            this.options = options;
            this.events = [ "undo", "redo" ];
            this.clear();
        }

        push(command) {
            this.stack = this.stack.slice(0, this.currentCommandIndex + 1);
            this.currentCommandIndex = this.stack.push(command) - 1;
        }
        undo() {
            if (this.canUndo()) {
                let command = this.stack[this.currentCommandIndex--];
                command.undo();
                this.trigger("undo", { command: command });
            }
        }
        redo() {
            if (this.canRedo()) {
                let command = this.stack[++this.currentCommandIndex];
                command.redo();
                this.trigger("redo", { command: command });
            }
        }
        clear() {
            this.stack = [];
            this.currentCommandIndex = -1;
        }
        canUndo() {
            return this.currentCommandIndex >= 0;
        }
        canRedo() {
            return this.currentCommandIndex !== this.stack.length - 1;
        }
    }

    /* eslint-disable no-param-reassign */
    // SAX-style XML parser ====================================================
    let STRING = String.fromCharCode;

    // XXX: add more here?
    let ENTITIES = {
        "amp": 38,
        "lt": 60,
        "gt": 62,
        "quot": 34,
        "apos": 39,
        "nbsp": 160
    };

    function CODE(str) {
        let out = [];
        for (let i = 0; i < str.length; ++i) {
            out.push(str.charCodeAt(i));
        }
        return out;
    }

    function UCS2(out, code) {
        if (code > 0xFFFF) {
            code -= 0x10000;
            out.push(code >>> 10 & 0x3FF | 0xD800,
                        0xDC00 | code & 0x3FF);
        } else {
            out.push(code);
        }
    }

    let START_CDATA = CODE("<![CDATA[");
    let END_CDATA = CODE("]]>");
    let END_COMMENT = CODE("-->");
    let START_COMMENT = CODE("!--");
    let END_SHORT_TAG = CODE("/>");
    let END_TAG = CODE("</");
    let END_DECLARATION = CODE("?>");
    let QUESTION_MARK = CODE("?");
    let LESS_THAN = CODE("<");
    let GREATER_THAN = CODE(">");
    let SEMICOLON = CODE(";");
    let EQUAL = CODE("=");
    let AMPERSAND = CODE("&");
    let QUOTE = CODE('"');
    let APOSTROPHE = CODE("'");
    let SHARP = CODE("#");
    let LOWERCASE_X = CODE("x");
    let UPPERCASE_X = CODE("X");

    let EXIT = {};

    function parse$1(data, callbacks) {
        let index = 0;
        let stack = [];
        let object = {
            is: function(selector) {
                let i = stack.length, j = selector.length;
                while (--i >= 0 && --j >= 0) {
                    if (stack[i].$tag !== selector[j] && selector[j] !== "*") {
                        return false;
                    }
                }
                return j < 0 ? stack[stack.length - 1] : null;
            },
            exit: function() {
                throw EXIT;
            },
            stack: stack
        };

        function readChar(body) {
            let code = data[index++];
            if (!(code & 0xF0 ^ 0xF0)) {// 4 bytes
                UCS2(body,
                        ((code & 0x03) << 18) |
                        ((data[index++] & 0x3F) << 12) |
                        ((data[index++] & 0x3F) << 6) |
                        (data[index++] & 0x3F));
            } else if (!(code & 0xE0 ^ 0xE0)) {// 3 bytes
                UCS2(body,
                        ((code & 0x0F) << 12) |
                        ((data[index++] & 0x3F) << 6) |
                        (data[index++] & 0x3F));
            } else if (!(code & 0xC0 ^ 0xC0)) {// 2 bytes
                UCS2(body,
                        ((code & 0x1F) << 6) |
                        (data[index++] & 0x3F));
            } else {
                body.push(code);
            }
        }

        function croak(msg) {
            throw new Error(msg + ", at " + index);
        }

        function readWhile(pred) {
            let a = [];
            while (index < data.length && pred(data[index])) {
                a.push(data[index++]);
            }
            return a;
        }

        function readAsciiWhile(pred) {
            return STRING.apply(0, readWhile(pred));
        }

        function skipWhitespace() {
            readWhile(isWhitespace);
        }

        function eat(a) {
            let save = index;
            for (let i = 0; i < a.length; ++i) {
                if (data[index++] !== a[i]) {
                    index = save;
                    return false;
                }
            }
            return a;
        }

        function skip(code) {
            if (!eat(code)) {
                croak("Expecting " + code.join(", "));
            }
        }

        function isWhitespace(code) {
            return code === 9 || code === 10 || code === 13 || code === 32;
        }

        function isDigit(code) {
            return code >= 48 && code <= 57;
        }

        function isHexDigit(code) {
            return (code >= 48 && code <= 57) ||
                    ((code |= 32) >= 97 && code <= 102); // a..f or A..F
        }

        function isNameStart(code) {
            return code === 58 ||                      // :
                    code === 95 ||                      // _
                    ((code |= 32) >= 97 && code <= 122); // a..z or A..Z
        }

        function isName(code) {
            return code === 45 ||                      // -
                    isDigit(code) ||
                    isNameStart(code);
        }

        function xmlComment() {
            let body = [];
            while (index < data.length) {
                if (eat(END_COMMENT)) {
                    return call("comment", STRING.apply(0, body));
                }
                readChar(body);
            }
        }

        function xmlTag() {
            let name, attrs;
            if (eat(QUESTION_MARK)) {
                xmlDecl();
            } else if (eat(START_COMMENT)) {
                xmlComment();
            } else {
                name = xmlName();
                attrs = xmlAttrs(name);
                stack.push(attrs);
                if (eat(END_SHORT_TAG)) {
                    call("enter", name, attrs, true);
                } else {
                    skip(GREATER_THAN);
                    call("enter", name, attrs);
                    xmlContent(name);
                    if (name !== xmlName()) {
                        croak("Bad closing tag");
                    }
                    call("leave", name, attrs);
                    skipWhitespace();
                    skip(GREATER_THAN);
                }
                stack.pop();
            }
        }

        function xmlContent(name) {
            let body = [];
            while (index < data.length) {
                if (eat(END_TAG)) {
                    return body.length && call("text", STRING.apply(0, body));
                } else if (eat(START_CDATA)) {
                    while (index < data.length && !eat(END_CDATA)) {
                        readChar(body);
                    }
                } else if (eat(LESS_THAN)) {
                    if (body.length) {
                        call("text", STRING.apply(0, body));
                    }
                    xmlTag();
                    body = [];
                } else if (eat(AMPERSAND)) {
                    xmlEntity(body);
                } else {
                    readChar(body);
                }
            }
            croak("Unclosed tag " + name);
        }

        function xmlName() {
            if (!isNameStart(data[index])) {
                croak("Expecting XML name");
            }
            return readAsciiWhile(isName);
        }

        function xmlString() {
            let quote = eat(QUOTE) || eat(APOSTROPHE);
            if (!quote) {
                croak("Expecting string");
            }
            let body = [];
            while (index < data.length) {
                if (eat(quote)) {
                    return STRING.apply(0, body);
                } else if (eat(AMPERSAND)) {
                    xmlEntity(body);
                } else {
                    readChar(body);
                }
            }
            croak("Unfinished string");
        }

        function xmlEntity(body) {
            let code;
            if (eat(SHARP)) {
                if (eat(LOWERCASE_X) || eat(UPPERCASE_X)) {
                    code = parseInt(readAsciiWhile(isHexDigit), 16);
                } else {
                    code = parseInt(readAsciiWhile(isDigit), 10);
                }
                if (isNaN(code)) {
                    croak("Bad numeric entity");
                }
            } else {
                let name = xmlName();
                code = ENTITIES[name];
                if (code === undefined) {
                    croak("Unknown entity " + name);
                }
            }
            UCS2(body, code);
            skip(SEMICOLON);
        }

        function xmlDecl() {
            call("decl", xmlName(), xmlAttrs());
            skip(END_DECLARATION);
        }

        function xmlAttrs(name) {
            let map = { $tag: name };
            while (index < data.length) {
                skipWhitespace();
                let code = data[index];
                if (code === 63 || code === 62 || code === 47) { // ?, > or /
                    break;
                }
                map[xmlName()] = ( skip(EQUAL), xmlString() );
            }
            return map;
        }

        function call(what, thing, arg1, arg2) {
            let f = callbacks && callbacks[what];
            if (f) {
                f.call(object, thing, arg1, arg2);
            }
        }

        // skip BOM
        let tmp = [];
        readChar(tmp);
        if (tmp[0] !== 65279) {
            index = 0;
        }

        while (index < data.length) {
            skipWhitespace();
            skip(LESS_THAN);
            xmlTag();
            skipWhitespace();
        }
    }

    // Exports ================================================================
    const parseXML = function parseXML() {
        try {
            return parse$1.apply(this, arguments);
        } catch (ex) {
            if (ex !== EXIT) {
                throw ex;
            }
        }
    };

    class Deferred {
        constructor() {
            this._progressHandlers = [];
            this._resolved = false;
            this._rejected = false;
            this.promise = new window.Promise((resolve, reject) => {
                this._resolve = (value) => {
                    if (!this._resolved && !this._rejected) {
                        this._resolved = true;
                        resolve(value);
                    }
                };
                this._reject = (reason) => {
                    if (!this._resolved && !this._rejected) {
                        this._rejected = true;
                        reject(reason);
                    }
                };
            });
        }

        resolve(value) {
            this._resolve(value);
            return this;
        }

        reject(reason) {
            this._reject(reason);
            return this;
        }

        notify(value) {
            if (!this._resolved && !this._rejected) {
                this._progressHandlers.forEach(handler => handler(value));
            }
        }

        progress(callback) {
            this._progressHandlers.push(callback);
            return this;
        }

        then(onFulfilled, onRejected, onProgress) {
            if (onProgress) {
                this.progress(onProgress);
            }
            return this.promise.then(onFulfilled, onRejected);
        }

        promise() {
            return this.promise;
        }
    }

    /* eslint-disable complexity */
    /* eslint-disable camelcase */
    /* eslint-disable key-spacing */
    /* eslint-disable no-nested-ternary */
    /* eslint-disable brace-style */
    /* eslint-disable no-implicit-coercion */
    /* eslint-disable no-loop-func */
    /* eslint-disable no-param-reassign */

    // WARNING: removing the following jshint declaration and turning
    // == into === to make JSHint happy will break functionality.

    let MAP_EXCEL_OPERATOR = {
        // includes only what differs; key is Excel's operator, value
        // is our operator.
        greaterThanOrEqual: "greaterThanOrEqualTo",
        lessThanOrEqual: "lessThanOrEqualTo"
    };

    let ERROR_LOG = null;

    function readExcel(file, workbook, deferred) {
        let reader = new FileReader();
        reader.onload = async function(e) {
            JSZip.loadAsync(e.target.result)
                .then(async zip => await readWorkbook(zip, workbook, deferred));
        };

        reader.readAsArrayBuffer(file);
    }

    let SEL_CELL = ["sheetData", "row", "c"];
    let SEL_COL = ["cols", "col"];
    let SEL_DEFINED_NAME = ["definedNames", "definedName"];
    let SEL_FORMULA = ["sheetData", "row", "c", "f"];
    let SEL_MERGE = ["mergeCells", "mergeCell"];
    let SEL_PANE = ["sheetViews", "sheetView", "pane"];
    let SEL_ROW = ["sheetData", "row"];
    let SEL_SELECTION = ["sheetViews", "sheetView", "selection"];
    let SEL_SHEET = ["sheets", "sheet"];
    let SEL_STRING = ["sheetData", "row", "c", "is"];
    let SEL_TEXT = ["t"];
    let SEL_SHARED_STRING = ["si"];
    let SEL_VALUE = ["sheetData", "row", "c", "v"];
    let SEL_VIEW = ["bookViews", "workbookView"];
    let SEL_SHEET_VIEW = ["sheetViews", "sheetView"];
    let SEL_HYPERLINK = ["hyperlinks", "hyperlink"];
    let SEL_PROTECTION = ["sheetProtection"];

    /* A validation section looks like this:
        *
        * <dataValidations count="1">
        *   <dataValidation type="list" allowBlank="1" showInputMessage="1" showErrorMessage="1" sqref="B2">
        *     <formula1>$E$2:$E$5</formula1>
        *   </dataValidation>
        * </dataValidations>
        */
    let SEL_VALIDATION = ["dataValidations", "dataValidation"];
    let SEL_VALIDATION_FORMULA1 = ["dataValidations", "dataValidation", "formula1"];
    let SEL_VALIDATION_FORMULA2 = ["dataValidations", "dataValidation", "formula2"];

    /* However, when a validation formula in one sheet references
        * cells from another sheet, Excel produces this version instead:
        *
        * <extLst>
        *   <ext xmlns:x14="http://schemas.microsoft.com/office/spreadsheetml/2009/9/main" uri="{CCE6A557-97BC-4b89-ADB6-D9C93CAAB3DF}">
        *     <x14:dataValidations xmlns:xm="http://schemas.microsoft.com/office/excel/2006/main" count="1">
        *       <x14:dataValidation type="list" allowBlank="1" showInputMessage="1" showErrorMessage="1">
        *         <x14:formula1>
        *           <xm:f>Sheet2!$B$3:$B$6</xm:f>
        *         </x14:formula1>
        *         <xm:sqref>B1</xm:sqref>
        *       </x14:dataValidation>
        *     </x14:dataValidations>
        *   </ext>
        * </extLst>
        *
        * I call it the "insane version", because that's what it is.
        * Barring the case that the engineers who produced this horror
        * were on LSD, the only plausible reason for it is that Microsoft
        * does not want third party software to be compatible with Excel
        * (sentiment I've had over and over while working on the
        * Spreadsheet widget).
        */
    // XXX: technically, the aliases `x14` and `xm` below could be
    // different, but Excel seems to be hard-coded on these; our
    // parser does not support proper namespaces for now anyway, so
    // hard-coded they are.
    let SEL_VALIDATION_INSANE = ["x14:dataValidations", "x14:dataValidation"];
    let SEL_VALIDATION_SQREF_INSANE = ["x14:dataValidations", "x14:dataValidation", "xm:sqref"];
    let SEL_VALIDATION_FORMULA1_INSANE = ["x14:dataValidations", "x14:dataValidation", "x14:formula1", "xm:f"];
    let SEL_VALIDATION_FORMULA2_INSANE = ["x14:dataValidations", "x14:dataValidation", "x14:formula2", "xm:f"];

    // comment selectors (in files like comments1.xml)
    let SEL_COMMENT = ["commentList", "comment"];
    let SEL_AUTHOR = ["authors", "author"];
    let SEL_COMMENT_TEXT = ["t"];

    function xl(file) {
        if (!/^\//.test(file)) {
            if (!/^xl\//.test(file)) {
                file = "xl/" + file;
            }
        } else {
            file = file.substr(1);
        }
        return file;
    }

    async function readWorkbook(zip, workbook, progress) {
        ERROR_LOG = workbook.excelImportErrors = [];

        let strings = await readStrings(zip);
        let relationships = await readRelationships(zip, "_rels/workbook.xml");
        let theme = await readTheme(zip, relationships.byType.theme[0]);
        let styles = await readStyles(zip, theme);
        let items = [];
        let activeSheet = 0;

        await parse(zip, "xl/workbook.xml", {
            enter: function(tag, attrs) {
                if (this.is(SEL_SHEET)) {
                    let relId = attrs["r:id"];
                    let file = relationships.byId[relId];
                    let name = attrs.name;
                    let state = attrs.state;
                    let dim = sheetDimensions(relationships.bytes[file]);

                    workbook.options.columnWidth = dim.columnWidth || workbook.options.columnWidth;
                    workbook.options.rowHeight = dim.rowHeight || workbook.options.rowHeight;

                    items.push({
                        workbook: workbook,
                        zip: zip,
                        strings: strings,
                        styles: styles,
                        file: file,
                        options: {
                            state: state,
                            name: name,
                            rows: Math.max(workbook.options.rows || 0, dim.rows),
                            columns: Math.max(workbook.options.columns || 0, dim.cols),
                            columnWidth: dim.columnWidth,
                            rowHeight: dim.rowHeight
                        }
                    });
                } else if (this.is(SEL_VIEW)) {
                    if (attrs.activeTab) {
                        activeSheet = integer(attrs.activeTab);
                    }
                }
            },
            text: function(text) {
                let attrs = this.is(SEL_DEFINED_NAME);
                if (attrs && !(bool(attrs["function"]) || bool(attrs.vbProcedure))) {
                    let localSheetId = attrs.localSheetId;
                    let sheet = null;
                    if (localSheetId != null) {
                        sheet = items[localSheetId].options.name;
                    }
                    let name = attrs.name;
                    if (name !== "_xlnm._FilterDatabase") {
                        if (sheet) {
                            name = "'" + sheet.replace(/\'/g, "\\'") + "'!" + name;
                        }
                        withErrorLog(sheet, null, function() {
                            workbook.defineName(name, text, bool(attrs.hidden));
                        }, "reading user-defined name: " + name);
                    }
                }
            }
        });

        let loading = new Deferred();
        loading.progress(function(args) {
            if (progress) {
                progress.notify(args);
            }
        })
        .then(function() {
            let sheets = workbook.sheets();
            recalcSheets(sheets);

            workbook.activeSheet(sheets[activeSheet]);

            if (progress) {
                progress.resolve();
            }
        });

        loadSheets(items, workbook, loading);
    }

    function loadSheets(items, workbook, progress) {
        let ready = window.Promise.resolve();
        for (let i = 0; i < items.length; i++) {
            (function(entry, i) {
                ready = ready.then(function() {
                    let sheet = workbook.insertSheet(entry.options);
                    sheet.suspendChanges(true);

                    let promise = queueSheet(sheet, entry);
                    let args = {
                        sheet: sheet,
                        progress: i === 1 ? 1 : (i / (items.length - 1))
                    };

                    promise.then(function() {
                        progress.notify(args);
                    });

                    return promise;
                });
            })(items[i], i);
        }

        ready.then(function() {
            progress.resolve();
        });
    }

    function queueSheet(sheet, ctx) {
        let deferred = new Deferred();

        setTimeout(async function() {
            await readSheet(ctx.zip, ctx.file, sheet, ctx.strings, ctx.styles);
            deferred.resolve();
        }, 0);

        return deferred;
    }

    function recalcSheets(sheets) {
        for (let i = 0; i < sheets.length; i++) {
            sheets[i]
                .suspendChanges(false)
                .triggerChange({ recalc: true });
        }
    }

    function sheetDimensions(bytes) {
        let ref, dim = {
                rows: 0,
                cols: 0
            };

        parseXML(bytes, {
            enter: function(tag, attrs) {
                if (tag === "dimension") {
                    ref = calc.parseReference(attrs.ref);
                    if (ref.bottomRight) {
                        dim.cols = ref.bottomRight.col + 1;
                        dim.rows = ref.bottomRight.row + 1;
                    }
                } else if (tag === "sheetFormatPr") {
                    if (attrs.defaultColWidth) {
                        dim.columnWidth = toColWidth(parseFloat(attrs.defaultColWidth));
                    }

                    if (attrs.defaultRowHeight) {
                        dim.rowHeight = toRowHeight(parseFloat(attrs.defaultRowHeight));
                    }
                } else if (this.is(SEL_ROW) && attrs.r) {
                    dim.rows = Math.max(dim.rows, +attrs.r);
                } else if (this.is(SEL_CELL) && attrs.r) {
                    ref = calc.parseReference(attrs.r);
                    dim.rows = Math.max(dim.rows, ref.row + 1);
                    dim.cols = Math.max(dim.cols, ref.col + 1);
                }
            }
        });

        return dim;
    }

    function toColWidth(size) {
        // No font to compute agains, hence the magic number
        let maximumDigitWidth = 7;

        // The formula below is taken from the OOXML spec
        let fraction = (256 * size + Math.floor(128 / maximumDigitWidth)) / 256;
        return fraction * maximumDigitWidth;
    }

    function toRowHeight(pts) {
        return pts * (4 / 3);
    }

    async function readSheet(zip, file, sheet, strings, styles) {
        let sharedFormulas = {};
        let ref, type, value, formula, formulaRange, isArrayFormula;
        let nCols = sheet._columns._count;
        let prevCellRef = null;
        let relsFile = file.replace(/worksheets\//, "worksheets/_rels/");
        let relationships = await readRelationships(zip, relsFile);
        let formula1, formula2;

        let filterRef;
        let filterColumn;
        let customFilterLogic;
        let customFilterCriteria;
        let valueFilterBlanks;
        let valueFilterValues;
        let filters = [];
        let deferredStyles = [];

        ERROR_LOG = sheet._workbook.excelImportErrors;

        file = xl(file);

        await parse(zip, file, {
            enter: function(tag, attrs, closed) {
                let tmp;
                if (this.is(SEL_FORMULA)) {
                    if (closed) {
                        if (attrs.t === "shared" && attrs.si != null) {
                            formula = sheet.range(sharedFormulas[attrs.si])._get("formula");
                        }
                    }
                } else if (this.is(SEL_CELL)) {
                    value = null;
                    formula = null;
                    ref = attrs.r;
                    formulaRange = null;

                    if (ref == null) {
                        // apparently some tools omit the `r` for
                        // consecutive cells in a row, so we'll figure
                        // it out from the previous cell's reference.
                        // XXX: this could be slightly optimized by
                        // keeping it parsed instead of stringifying
                        // it to parse it again later.
                        ref = calc.parseReference(prevCellRef);
                        ref.col++;
                        ref = ref.toString();
                    }
                    prevCellRef = ref;

                    // XXX: can't find no type actually, so everything is
                    // interpreted as string.  Additionally, cells having
                    // a formula will contain both <f> and <v> nodes,
                    // which makes the value take precedence because it's
                    // the second node; hence, the hack is to keep note of
                    // them in the `text` handler, and apply the
                    // appropriate one in the `leave` handler below.
                    type = attrs.t;

                    let styleIndex = attrs.s;
                    if (styleIndex != null) {
                        deferredStyles.push({ ref: ref,  sty: +styleIndex });
                    }
                } else if (this.is(SEL_MERGE)) {
                    sheet.range(attrs.ref).merge();
                } else if (this.is(SEL_COL)) {
                    let start = integer(attrs.min) - 1;
                    let stop = Math.min(nCols, integer(attrs.max)) - 1;
                    let width;
                    if (attrs.width) {
                        width = toColWidth(parseFloat(attrs.width));
                        if (width !== 0) {
                            sheet._columns.values.value(start, stop, width);
                        }
                    }
                    if (attrs.hidden === "1" || width === 0) {
                        for (let ci = start; ci <= stop; ci++) {
                            sheet.hideColumn(ci);
                        }
                    }
                    if (attrs.style != null) {
                        // apply style on a whole range of columns
                        deferredStyles.unshift({
                            ref: new RangeRef(
                                new CellRef(-Infinity, start),
                                new CellRef(+Infinity, stop)
                            ),
                            sty: +attrs.style
                        });
                    }
                } else if (this.is(SEL_ROW)) {
                    let row = integer(attrs.r) - 1;
                    let height;
                    if (attrs.ht) {
                        height = toRowHeight(parseFloat(attrs.ht));
                        if (height !== 0) {
                            sheet._rows.values.value(row, row, height);
                        }
                    }
                    if (attrs.hidden === "1" || height === 0) {
                        sheet.hideRow(row);
                    }
                } else if (this.is(SEL_SELECTION)) {
                    if (attrs.activeCell) {
                        let acRef = calc.parseReference(attrs.activeCell);
                        sheet.select(acRef, true);
                    }
                } else if (this.is(SEL_PANE)) {
                    if (attrs.state && attrs.state.indexOf("frozen") > -1) {
                        if (attrs.xSplit) {
                            sheet.frozenColumns(integer(attrs.xSplit));
                        }

                        if (attrs.ySplit) {
                            sheet.frozenRows(integer(attrs.ySplit));
                        }
                    }
                } else if (this.is(SEL_SHEET_VIEW)) {
                    sheet.showGridLines(bool(attrs.showGridLines, true));
                } else if (this.is(SEL_HYPERLINK)) {
                    let relId = attrs["r:id"];
                    let target = relationships.byId[relId];
                    if (target) {
                        sheet.range(attrs.ref).link(target);
                    }
                } else if (this.is(SEL_PROTECTION)) {
                    if (attrs.sheet) {
                        sheet.range(SHEETREF).enable(false);
                    }
                } else if (this.is(["autoFilter"])) {
                    filterRef = attrs.ref;
                    if (closed) {
                        addAutoFilter();
                    }
                } else if (filterRef) {
                    if (this.is(["filterColumn"])) {
                        filterColumn = parseInt(attrs.colId, 10);
                    } else if (this.is(["customFilters"])) {
                        customFilterLogic = bool(attrs.and) ? "and" : "or";
                        customFilterCriteria = [];
                    } else if (this.is(["customFilter"])) {
                        tmp = getCustomFilter(attrs.operator, attrs.val);
                        if (tmp) {
                            customFilterCriteria.push({
                                operator: tmp.operator,
                                value: tmp.value
                            });
                        }
                    } else if (this.is(["dynamicFilter"])) {
                        filters.push({
                            column: filterColumn,
                            filter: new DynamicFilter({
                                type: dynamicFilterType(attrs.type)
                            })
                        });
                    }
                    else if (this.is(["top10"])) {
                        filters.push({
                            column: filterColumn,
                            filter: new TopFilter({
                                value: getFilterVal(attrs.val),
                                type: (function(percent, top) {
                                    return percent && top ? "topPercent"
                                        : top ? "topNumber"
                                        : percent ? "bottomPercent"
                                        : "bottomNumber";
                                })(bool(attrs.percent), bool(attrs.top))
                            })
                        });
                    }
                    else if (this.is(["filters"])) {
                        valueFilterBlanks = bool(attrs.blank);
                        valueFilterValues = [];
                    }
                    else if (this.is(["filter"])) {
                        valueFilterValues.push(getFilterVal(attrs.val));
                    }
                }
            },
            leave: function(tag, attrs) {
                if (this.is(SEL_FORMULA)) {
                    if (!formula && attrs.t === "shared" && attrs.si != null) {
                        formula = sheet.range(sharedFormulas[attrs.si])._get("formula");
                    }
                }
                else if (this.is(SEL_CELL)) {
                    if (formula != null) {
                        let failed = withErrorLog(sheet, formulaRange || ref, function() {
                            sheet.range(formulaRange || ref).formula(formula, isArrayFormula);
                        }, "parsing formula");
                        if (failed) {
                            sheet.range(formulaRange || ref).value(formula)
                                .background("#ffaaaa");
                        }
                    } else if (value != null) {
                        let range = sheet.range(ref);

                        if (!range._get("formula")) {
                            // Check for "shared" formulas before applying a value.
                            if (!type || type === "n") {
                                value = parseFloat(value);
                            } else if (type === "s") {
                                value = strings[integer(value)];
                            } else if (type === "b") {
                                value = value === "1";
                            } else if (type === "d") {
                                value = intl().parseDate(value);
                            }

                            if (value != null) {
                                range.value(value);
                            }
                        }
                    }
                } else if (this.is(SEL_VALIDATION) ||
                            this.is(SEL_VALIDATION_INSANE)) {
                    (function() {
                        let refs = calc.parseSqref(attrs.sqref);
                        let type = attrs.type.toLowerCase();
                        let operator = attrs.operator;
                        if (/^(?:whole|decimal)$/.test(type)) {
                            // we only support "number"
                            type = "number";
                        } else if (type === "list") {
                            // there'll be no operator from Excel for lists
                            operator = "list";
                        }
                        if (!operator && /^(?:number|date)$/.test(type)) {
                            // Excel skips setting the operator for
                            // "between", because why not.
                            operator = "between";
                        }
                        refs.forEach(function(ref) {
                            withErrorLog(sheet, ref, function() {
                                sheet.range(ref).validation({
                                    type             : bool(attrs.showErrorMessage, true) ? "reject" : "warning",
                                    from             : formula1,
                                    to               : formula2,
                                    dataType         : type,
                                    comparerType     : MAP_EXCEL_OPERATOR[operator] || operator,
                                    allowNulls       : bool(attrs.allowBlank),
                                    showButton       : bool(attrs.showDropDown) || type === "date" || type === "list",
                                    messageTemplate  : attrs.error,
                                    titleTemplate    : attrs.errorTitle
                                });
                            }, "parsing validation");
                        });
                    })();
                } else if (tag === "cols") {
                    sheet._columns._refresh();
                } else if (tag === "sheetData") {
                    sheet._rows._refresh();
                } else if (tag === "autoFilter") {
                    addAutoFilter();
                } else if (filterRef) {
                    if (tag === "customFilters") {
                        filters.push({
                            column: filterColumn,
                            filter: new CustomFilter({
                                logic: customFilterLogic,
                                criteria: customFilterCriteria
                            })
                        });
                    } else if (tag === "filters") {
                        filters.push({
                            column: filterColumn,
                            filter: new ValueFilter({
                                values: valueFilterValues,
                                blanks: valueFilterBlanks
                            })
                        });
                    }
                }
            },
            text: function(text) {
                let attrs;
                if (this.is(SEL_VALUE) || this.is(SEL_STRING)) {
                    value = text;
                } else if ((attrs = this.is(SEL_FORMULA))) {
                    formula = text;
                    isArrayFormula = attrs.t === "array";
                    if (isArrayFormula) {
                        formulaRange = attrs.ref;
                    } else if (attrs.t === "shared") {
                        sharedFormulas[attrs.si] = ref;
                    }
                } else if (this.is(SEL_VALIDATION_FORMULA1) ||
                            this.is(SEL_VALIDATION_FORMULA1_INSANE)) {
                    formula1 = text;
                } else if (this.is(SEL_VALIDATION_FORMULA2) ||
                            this.is(SEL_VALIDATION_FORMULA2_INSANE)) {
                    formula2 = text;
                } else if (this.is(SEL_VALIDATION_SQREF_INSANE)) {
                    // put it in <dataValidation>'s attributes where it should be
                    this.stack[this.stack.length - 2].sqref = text;
                }
            }
        });

        deferredStyles.forEach(({ ref, sty }) => applyStyle(sheet, ref, styles, sty));

        if (relationships.byType.comments) {
            let commentFile = relative_file(file, relationships.byType.comments[0]);
            await readComments(zip, commentFile, sheet);
        }

        if (relationships.byType.drawing) {
            let drawingFile = relative_file(file, relationships.byType.drawing[0]);
            await readDrawings(zip, drawingFile, sheet);
        }

        function addAutoFilter() {
            sheet.range(filterRef).filter(filters);
            filterRef = null;
        }
    }

    function getContentType(filename) {
        let m = /\.([^.]+)$/.exec(filename);
        if (m && m[1]) {
            return {
                jpg  : "image/jpeg",
                jpeg : "image/jpeg",
                png  : "image/png",
                gif  : "image/gif",
                wmf  : "image/wmf"
            }[m[1].toLowerCase()];
        }
    }

    function getFileName(filename) {
        let m = /[^/]+$/.exec(filename);
        return m && m[0];
    }

    async function readDrawings(zip, file, sheet) {
        let sel_two_cell_anchor = [ "xdr:twoCellAnchor" ];
        let sel_ext = [ "xdr:ext" ];
        let sel_one_cell_anchor = [ "xdr:oneCellAnchor" ];
        let sel_from = [ "xdr:from" ];
        let sel_to = [ "xdr:to" ];
        let sel_row = [ "xdr:row" ];
        let sel_col = [ "xdr:col" ];
        let sel_row_offset = [ "xdr:rowOff" ];
        let sel_col_offset = [ "xdr:colOff" ];
        let sel_blip = [ "xdr:blipFill", "a:blip" ];

        let relsFile = file.replace(/drawings\//, "drawings/_rels/");
        let relationships = await readRelationships(zip, relsFile);

        if (relationships.byType.image) {
            let relkeys = Object.keys(relationships.byId);
            for (let i = 0; i < relkeys.length; ++i) {
                let id = relkeys[i];
                let img = relative_file(file, relationships.byId[id]);
                let type = getContentType(img);

                if (type) {
                    let data = await zip.file(img).async("arraybuffer");
                    let name = getFileName(img);
                    let blob = name && !(kendoCommon.browser.edge)
                        ? new window.File([ data ], name, { type: type })
                        : new window.Blob([ data ], { type: type });
                    relationships.byId[id] = sheet._workbook.addImage(blob);
                }
            }
        }

        let cdr, ref, width, height;
        await parse(zip, file, {
            enter: function(tag, attrs) {
                if (this.is(sel_two_cell_anchor) || this.is(sel_one_cell_anchor)) {
                    cdr = {};
                }
                else if (this.is(sel_from) || this.is(sel_to)) {
                    ref = {};
                }
                else if (this.is(sel_blip)) {
                    let id = attrs["r:embed"];
                    cdr.image = relationships.byId[id];
                }
                else if (this.is(sel_ext)) {
                    width = excelToPixels(parseFloat(attrs.cx));
                    height = excelToPixels(parseFloat(attrs.cy));
                }
            },
            leave: function() {
                if (this.is(sel_from)) {
                    cdr.topLeftCell = new CellRef(ref.row, ref.col);
                    cdr.offsetX = excelToPixels(ref.colOffset);
                    cdr.offsetY = excelToPixels(ref.rowOffset);
                }
                else if (this.is(sel_to)) {
                    cdr.brCell = new CellRef(ref.row, ref.col);
                    cdr.brX = excelToPixels(ref.colOffset);
                    cdr.brY = excelToPixels(ref.rowOffset);
                }
                // Add drawing only when it is image
                else if (this.is(sel_two_cell_anchor) && cdr.image) {
                    let left = sheet._columns.sum(0, cdr.topLeftCell.col - 1) + cdr.offsetX;
                    let top = sheet._rows.sum(0, cdr.topLeftCell.row - 1) + cdr.offsetY;
                    let right = sheet._columns.sum(0, cdr.brCell.col - 1) + cdr.brX;
                    let bottom = sheet._rows.sum(0, cdr.brCell.row - 1) + cdr.brY;

                    sheet.addDrawing({
                        topLeftCell : cdr.topLeftCell,
                        offsetX     : cdr.offsetX,
                        offsetY     : cdr.offsetY,
                        width       : width != null ? width : right - left,
                        height      : height != null ? height : bottom - top,
                        image       : cdr.image,
                        opacity     : 1
                    });
                }
                // Add drawing only when it is image
                else if (this.is(sel_one_cell_anchor) && cdr.image) {
                    sheet.addDrawing({
                        topLeftCell : cdr.topLeftCell,
                        offsetX     : cdr.offsetX,
                        offsetY     : cdr.offsetY,
                        width       : width,
                        height      : height,
                        image       : cdr.image,
                        opacity     : 1
                    });
                }
            },
            text: function(text) {
                if (this.is(sel_row)) {
                    ref.row = parseFloat(text);
                }
                else if (this.is(sel_col)) {
                    ref.col = parseFloat(text);
                }
                else if (this.is(sel_row_offset)) {
                    ref.rowOffset = parseFloat(text);
                }
                else if (this.is(sel_col_offset)) {
                    ref.colOffset = parseFloat(text);
                }
            }
        });
    }

    async function readComments(zip, file, sheet) {
        let authors = [];
        let author;
        let comment;
        await parse(zip, file, {
            enter: function(tag, attrs) {
                if (this.is(SEL_COMMENT)) {
                    comment = {
                        author: authors[attrs.authorId],
                        ref: attrs.ref,
                        text: ""
                    };
                } else if (this.is(SEL_AUTHOR)) {
                    author = "";
                }
            },
            leave: function() {
                if (this.is(SEL_COMMENT)) {
                    sheet.range(comment.ref).comment(comment.text);
                } else if (this.is(SEL_AUTHOR)) {
                    authors.push(author);
                }
            },
            text: function(text) {
                if (this.is(SEL_COMMENT_TEXT)) {
                    comment.text += text;
                } else if (this.is(SEL_AUTHOR)) {
                    author += text;
                }
            }
        });
    }

    function getCustomFilter(op, value) {
        let ourOp = {
            equal               : "eq",
            notEqual            : "ne",
            greaterThan         : "gt",
            greaterThanOrEqual  : "gte",
            lessThan            : "lt",
            lessThanOrEqual     : "lte"
        }[op];

        value = getFilterVal(value);

        if (ourOp && typeof value == "number") {
            return { operator: ourOp, value: value };
        }

        if ((op === "notEqual" || !op) && typeof value == "string") {
            // Excel text operators support * and ? wildcards.  Since
            // our startswith/endswith/contains filters do not, we
            // can't really use them here, so we'll apply the more
            // generic "matches" and "doesnotmatch" filters.
            return {
                operator: op ? "doesnotmatch" : "matches",
                value: value
            };
        }
    }

    function dynamicFilterType(type) {
        return {
            Q1  : "quarter1",
            Q2  : "quarter2",
            Q3  : "quarter3",
            Q4  : "quarter4",
            M1  : "january",
            M2  : "february",
            M3  : "march",
            M4  : "april",
            M5  : "may",
            M6  : "june",
            M7  : "july",
            M8  : "august",
            M9  : "september",
            M10 : "october",
            M11 : "november",
            M12 : "december"
        }[type.toUpperCase()] || type;
    }

    function getFilterVal(val) {
        let tmp = parseFloat(val);
        if (!isNaN(tmp) && tmp === val) {
            return tmp;
        }
        return val;
    }

    function withErrorLog(sheet, ref, func, context) {
        try {
            func();
            return false;
        } catch (ex) {
            let err = { context: context, error: String(ex) };
            if (sheet && sheet.name) {
                err.sheet = sheet.name();
            } else if (sheet) {
                err.sheet = sheet;
            }
            if (ref) {
                err.location = String(ref);
            }
            ERROR_LOG.push(err);
            return true;
        }
    }

    let BORDER_WIDTHS = {
        "none"            : 0,
        "thin"            : 1,
        "medium"          : 2,
        "dashed"          : 1,
        "dotted"          : 1,
        "thick"           : 3,
        "double"          : 3,
        "hair"            : 1,
        "mediumDashed"    : 2,
        "dashDot"         : 1,
        "mediumDashDot"   : 2,
        "dashDotDot"      : 1,
        "mediumDashDotDot": 2,
        "slantDashDot"    : 1
    };

    let DEFAULT_FORMATS = {
        0  : "General",
        1  : "0",
        2  : "0.00",
        3  : "#,##0",
        4  : "#,##0.00",
        9  : "0%",
        10 : "0.00%",
        11 : "0.00E+00",
        12 : "# ?/?",
        13 : "# ??/??",
        14 : "mm-dd-yy",
        15 : "d-mmm-yy",
        16 : "d-mmm",
        17 : "mmm-yy",
        18 : "h:mm AM/PM",
        19 : "h:mm:ss AM/PM",
        20 : "h:mm",
        21 : "h:mm:ss",
        22 : "m/d/yy h:mm",
        37 : "#,##0 ;(#,##0)",
        38 : "#,##0 ;[Red](#,##0)",
        39 : "#,##0.00;(#,##0.00)",
        40 : "#,##0.00;[Red](#,##0.00)",
        45 : "mm:ss",
        46 : "[h]:mm:ss",
        47 : "mmss.0",
        48 : "##0.0E+0",
        49 : "@"
    };

    function applyStyle(sheet, ref, styles, styleIndex) {
        let range = sheet.range(ref);
        let xf = styles.inlineStyles[styleIndex], base, value;
        if (xf.xfId) {
            base = styles.namedStyles[xf.xfId];
        }
        if (shouldSet("applyBorder", "borderId")) {
            setBorder(styles.borders[value]);
        }
        if (shouldSet("applyFont", "fontId")) {
            setFont(styles.fonts[value]);
        }
        if (shouldSet("applyAlignment", "textAlign")) {
            range.textAlign(value);
        }
        if (shouldSet("applyAlignment", "verticalAlign")) {
            range.verticalAlign(value);
        }
        if (shouldSet("applyAlignment", "indent")) {
            range.indent(value);
        }
        if (shouldSet("applyAlignment", "wrapText")) {
            // don't use range.wrap to avoid recomputing row height
            range._property("wrap", value);
        }
        if (shouldSet("applyFill", "fillId")) {
            setFill(styles.fills[value]);
        }
        if (shouldSet("applyNumberFormat", "numFmtId")) {
            setFormat(styles.numFmts[value] || DEFAULT_FORMATS[value]);
        }
        if (shouldSet("applyProtection", "protection")) {
            range.enable(!xf.protection.locked);
        }

        function setFormat(f) {
            let format = typeof f == "string" ? f : f.formatCode;
            if (format != null && !/^general$/i.test(format)) {
                // XXX: drop locale info.
                // http://stackoverflow.com/questions/894805/excel-number-format-what-is-409
                // not supported by the formatting library.
                format = format.replace(/^\[\$-[0-9]+\]/, "");
                range.format(format);
            }
        }

        function setFill(f) {
            if (f.type === "solid") {
                range.background(f.color);
            }
        }

        function setFont(f) {
            range.fontFamily(f.name);
            //range.fontSize(f.size); //XXX: will recalc row height.
            // converting from points to pixels
            if (f.size) {
                range._property("fontSize", f.size * 4 / 3);
            }
            if (f.bold) {
                range.bold(true);
            }
            if (f.italic) {
                range.italic(true);
            }
            if (f.underline) {
                range.underline(true);
            }
            if (f.color) {
                range.color(f.color);
            }
        }

        function setBorder(b) {
            function set(side, prop) {
                let border = b[side];
                if (!border) {
                    return;
                }

                let width = BORDER_WIDTHS[border.style];
                if (!width) {
                    return;
                }

                let color = border.color;
                if (color == null) {
                    color = "#000";
                }

                let value = { size: width, color: color };
                if (side === "diagonal") {
                    value.type = border.up << 1 | border.down;
                }

                range._property(prop, value);
            }

            set("left", "borderLeft");
            set("top", "borderTop");
            set("right", "borderRight");
            set("bottom", "borderBottom");
            set("diagonal", "dBorders");
        }

        function shouldSet(applyName, propName) {
            let t = xf[applyName];
            if (t != null && !t) {
                return false;
            }
            value = xf[propName];
            if (base && value == null) {
                t = base[applyName];
                if (t != null && !t) {
                    return false;
                }
                value = base[propName];
            }
            return value != null;
        }
    }

    function parse(zip, file, callbacks) {
        return new window.Promise(resolve => {
            let obj = zip.file(file);
            if (obj) {
                obj.async("uint8array").then(bytes => {
                    parseXML(bytes, callbacks);
                    resolve();
                });
            } else {
                resolve();
            }
        });
    }

    async function readStrings(zip) {
        let strings = [];
        let current = null;
        await parse(zip, "xl/sharedStrings.xml", {
            leave: function() {
                if (this.is(SEL_SHARED_STRING)) {
                    strings.push(current);
                    current = null;
                }
            },
            text: function(text) {
                if (this.is(SEL_TEXT)) {
                    if (current == null) {
                        current = "";
                    }
                    current += text;
                }
            }
        });
        return strings;
    }

    async function readRelationships(zip, file) {
        let map = { byId: {}, byType: { theme: [] }, bytes: {} };
        await parse(zip, xl(file) + ".rels", {
            enter: function(tag, attrs) {
                if (tag === "Relationship") {
                    map.byId[attrs.Id] = attrs.Target;

                    let type = attrs.Type.match(/\w+$/)[0];
                    let entries = map.byType[type] || [];
                    entries.push(attrs.Target);
                    map.byType[type] = entries;
                }
            }
        });
        let names = [];
        let promises = [];
        Object.keys(map.byId).forEach(id => {
            let filename = map.byId[id];
            let obj = zip.file(xl(filename));
            if (obj) {
                names.push(filename);
                promises.push(obj.async("uint8array"));
            }
        });
        let data = await window.Promise.all(promises);
        names.forEach((name, i) => map.bytes[name] = data[i]);
        return map;
    }

    let SEL_BORDER = ["borders", "border"];
    let SEL_FILL = ["fills", "fill"];
    let SEL_FONT = ["fonts", "font"];
    let SEL_INLINE_STYLE = ["cellXfs", "xf"];
    let SEL_NAMED_STYLE = ["cellStyleXfs", "xf"];
    let SEL_NUM_FMT = ["numFmts", "numFmt"];

    let INDEXED_COLORS = [
        toCSSColor("FF000000"), toCSSColor("FFFFFFFF"), toCSSColor("FFFF0000"),
        toCSSColor("FF00FF00"), toCSSColor("FF0000FF"), toCSSColor("FFFFFF00"),
        toCSSColor("FFFF00FF"), toCSSColor("FF00FFFF"), toCSSColor("FF000000"),
        toCSSColor("FFFFFFFF"), toCSSColor("FFFF0000"), toCSSColor("FF00FF00"),
        toCSSColor("FF0000FF"), toCSSColor("FFFFFF00"), toCSSColor("FFFF00FF"),
        toCSSColor("FF00FFFF"), toCSSColor("FF800000"), toCSSColor("FF008000"),
        toCSSColor("FF000080"), toCSSColor("FF808000"), toCSSColor("FF800080"),
        toCSSColor("FF008080"), toCSSColor("FFC0C0C0"), toCSSColor("FF808080"),
        toCSSColor("FF9999FF"), toCSSColor("FF993366"), toCSSColor("FFFFFFCC"),
        toCSSColor("FFCCFFFF"), toCSSColor("FF660066"), toCSSColor("FFFF8080"),
        toCSSColor("FF0066CC"), toCSSColor("FFCCCCFF"), toCSSColor("FF000080"),
        toCSSColor("FFFF00FF"), toCSSColor("FFFFFF00"), toCSSColor("FF00FFFF"),
        toCSSColor("FF800080"), toCSSColor("FF800000"), toCSSColor("FF008080"),
        toCSSColor("FF0000FF"), toCSSColor("FF00CCFF"), toCSSColor("FFCCFFFF"),
        toCSSColor("FFCCFFCC"), toCSSColor("FFFFFF99"), toCSSColor("FF99CCFF"),
        toCSSColor("FFFF99CC"), toCSSColor("FFCC99FF"), toCSSColor("FFFFCC99"),
        toCSSColor("FF3366FF"), toCSSColor("FF33CCCC"), toCSSColor("FF99CC00"),
        toCSSColor("FFFFCC00"), toCSSColor("FFFF9900"), toCSSColor("FFFF6600"),
        toCSSColor("FF666699"), toCSSColor("FF969696"), toCSSColor("FF003366"),
        toCSSColor("FF339966"), toCSSColor("FF003300"), toCSSColor("FF333300"),
        toCSSColor("FF993300"), toCSSColor("FF993366"), toCSSColor("FF333399"),
        toCSSColor("FF333333"),
        toCSSColor("FF000000"), // System Foreground
        toCSSColor("FFFFFFFF")  // System Background
    ];

    async function readStyles(zip, theme) {
        let styles = {
            fonts        : [],
            numFmts      : {},
            fills        : [],
            borders      : [],
            namedStyles  : [],
            inlineStyles : []
        };
        let font = null;
        let fill = null;
        let border = null;
        let xf = null;
        await parse(zip, "xl/styles.xml", {
            enter: function(tag, attrs, closed) {
                if (this.is(SEL_NUM_FMT)) {
                    styles.numFmts[attrs.numFmtId] = attrs;
                }
                else if (this.is(SEL_FONT)) {
                    styles.fonts.push(font = {});
                    if (closed) {
                        // apparently, there's XLSX in the wild with
                        // <font/>, because why not (also, <border/>).
                        // if we don't null the variable, we always
                        // enter below and effectively ignore the rest
                        // of the file.
                        font = null;
                    }
                } else if (font) {
                    if (tag === "sz") {
                        font.size = parseFloat(attrs.val);
                    } else if (tag === "name") {
                        font.name = attrs.val;
                    } else if (tag === "b") {
                        font.bold = bool(attrs.val, true);
                    } else if (tag === "i") {
                        font.italic = bool(attrs.val, true);
                    } else if (tag === "u") {
                        font.underline = (attrs.val == null || attrs.val === "single");
                    } else if (tag === "color") {
                        font.color = getColor(attrs, null);
                    }
                }
                else if (this.is(SEL_FILL)) {
                    styles.fills.push(fill = {});
                    if (closed) {
                        fill = null;
                    }
                } else if (fill) {
                    if (tag === "patternFill") {
                        fill.type = attrs.patternType;
                    } else if (tag === "fgColor" && fill.type === "solid") {
                        fill.color = getColor(attrs, INDEXED_COLORS[0]);
                    } else if (tag === "bgColor" && fill.type !== "solid") {
                        fill.color = getColor(attrs, INDEXED_COLORS[0]);
                    }
                }
                else if (this.is(SEL_BORDER)) {
                    styles.borders.push(border = {
                        diagonalUp   : +bool(attrs.diagonalUp, 0),
                        diagonalDown : +bool(attrs.diagonalDown, 0)
                    });
                    if (closed) {
                        border = null;
                    }
                } else if (border) {
                    if (/^(?:left|top|right|bottom|diagonal)$/.test(tag)) {
                        border[tag] = { style: attrs.style || "none" };
                        if (tag === "diagonal") {
                            border.diagonal.up = border.diagonalUp;
                            border.diagonal.down = border.diagonalDown;
                        }
                    }
                    if (tag === "color") {
                        let side = this.stack[this.stack.length - 2].$tag;
                        border[side].color = getColor(attrs, INDEXED_COLORS[0]);
                    }
                }
                else if (this.is(SEL_NAMED_STYLE)) {
                    xf = getXf(attrs);
                    styles.namedStyles.push(xf);
                    if (closed) {
                        xf = null;
                    }
                } else if (this.is(SEL_INLINE_STYLE)) {
                    xf = getXf(attrs);
                    styles.inlineStyles.push(xf);
                    if (closed) {
                        xf = null;
                    }
                } else if (xf) {
                    if (tag === "alignment") {
                        if (/^(?:left|center|right|justify)$/.test(attrs.horizontal)) {
                            xf.textAlign = attrs.horizontal;
                        }
                        if (/^(?:top|center|bottom)$/.test(attrs.vertical)) {
                            xf.verticalAlign = attrs.vertical;
                        }
                        if (attrs.wrapText != null) {
                            xf.wrapText = bool(attrs.wrapText);
                        }
                        if (attrs.indent != null) {
                            xf.indent = integer(attrs.indent);
                        }
                    } else if (tag == "protection") {
                        xf.protection = {
                            locked: bool(attrs.locked)
                        };
                    }
                }
            },
            leave: function(tag) {
                if (this.is(SEL_FONT)) {
                    font = null;
                } else if (this.is(SEL_FILL)) {
                    fill = null;
                } else if (this.is(SEL_BORDER)) {
                    border = null;
                } else if (tag === "xf") {
                    xf = null;
                }
            }
        });

        function getXf(attrs) {
            let xf = {
                borderId          : integer(attrs.borderId),
                fillId            : integer(attrs.fillId),
                fontId            : integer(attrs.fontId),
                numFmtId          : integer(attrs.numFmtId),
                pivotButton       : bool(attrs.pivotButton),
                quotePrefix       : bool(attrs.quotePrefix),
                xfId              : integer(attrs.xfId)
            };
            addBool("applyAlignment");
            addBool("applyBorder");
            addBool("applyFill");
            addBool("applyFont");
            addBool("applyNumberFormat");
            if (addBool("applyProtection")) {
                xf.protection = { locked: true };
            }
            function addBool(name) {
                if (attrs[name] != null) {
                    return xf[name] = bool(attrs[name]);
                }
            }
            return xf;
        }

        function getColor(attrs, defaultThemeColor) {
            if (attrs.rgb) {
                return toCSSColor(attrs.rgb);
            } else if (attrs.indexed) {
                return INDEXED_COLORS[integer(attrs.indexed)];
            } else if (attrs.theme) {
                let themeColor = theme.colorScheme[integer(attrs.theme)];
                if (!themeColor) {
                    // returning black by default for font color causes
                    // https://github.com/telerik/kendo-ui-core/issues/5826
                    // in default cell style, color is undefined
                    return defaultThemeColor;
                }

                let color = kendoDrawing.parseColor(themeColor);

                if (attrs.tint) {
                    color = color.toHSL();

                    let tint = parseFloat(attrs.tint);
                    if (tint < 0) {
                        color.l = color.l * (1 + tint);
                    } else {
                        color.l = color.l * (1 - tint) + (100 - 100 * (1 - tint));
                    }
                }

                return color.toCssRgba();
            }
        }

        return styles;
    }

    let SEL_SCHEME_RGBCLR = ["a:clrScheme", "*", "a:srgbClr"];
    let SEL_SCHEME_SYSCLR = ["a:clrScheme", "*", "a:sysClr"];
    async function readTheme(zip, rel) {
        let scheme = [];
        let theme = {
            colorScheme: scheme
        };

        let file = xl(rel);
        if (zip.file(file)) {
            await parse(zip, file, {
                enter: function(tag, attrs) {
                    if (this.is(SEL_SCHEME_SYSCLR)) {
                        scheme.push(toCSSColor(
                            attrs.val === "window" ? "FFFFFFFF" : "FF000000"
                        ));
                    } else if (this.is(SEL_SCHEME_RGBCLR)) {
                        scheme.push(toCSSColor("FF" + attrs.val));
                    }
                }
            });

            if (scheme.length > 3) {
                // lt1 <-> dk1
                swap(scheme, 0, 1);
                // lt2 <-> dk2
                swap(scheme, 2, 3);
            }
        }

        function swap(arr, a, b) {
            let tmp = arr[a];
            arr[a] = arr[b];
            arr[b] = tmp;
        }

        return theme;
    }

    function integer(val) {
        return val == null ? null : parseInt(val, 10);
    }

    function bool(val, def) {
        if (val == null) {
            return def;
        }
        return val === "true" || val === true || val === 1 || val === '1';
    }

    function toCSSColor(rgb) {
        let m = /^([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})$/i.exec(rgb);
        return "rgba(" +
            parseInt(m[2], 16) + ", " +
            parseInt(m[3], 16) + ", " +
            parseInt(m[4], 16) + ", " +
            parseInt(m[1], 16) / 255 + ")";
    }

    function relative_file(base, name) {
        base = base.split(/\/+/);
        name = name.split(/\/+/);
        base.pop();
        while (name.length) {
            let part = name.shift();
            if (part === "") {
                base = [];      // absolute
            } else if (part === ".") {
                continue;
            } else if (part === "..") {
                base.pop();
            } else {
                base.push(part);
            }
        }
        return base.join("/");
    }

    function excelToPixels(val) {
        return val / 9525;
    }

    /* eslint-disable no-undef */
    /* eslint-disable no-nested-ternary */
    /* eslint-disable key-spacing */
    /* eslint-disable consistent-return */
    /* eslint-disable no-param-reassign */


    const events$1 = [
        "cut",
        "copy",
        "paste",
        "changing",
        "change",
        "contextmenu",
        "excelImport",
        "excelExport",
        "insertSheet",
        "removeSheet",
        "selectSheet",
        "renameSheet",
        "insertRow",
        "insertColumn",
        "deleteRow",
        "deleteColumn",
        "hideRow",
        "hideColumn",
        "unhideRow",
        "unhideColumn",
        "select",
        "changeFormat",
        "dataBinding",
        "dataBound",
        "progress"
    ];

    function loadBinary(url, callback) {
        let xhr = new XMLHttpRequest();
        xhr.onload = function() {
            callback(xhr.response, xhr.getResponseHeader("Content-Type"));
        };
        xhr.onerror = function() {
            callback(null);
        };
        xhr.open("GET", url);
        xhr.responseType = "arraybuffer";
        xhr.send();
    }

    class Workbook extends Observable {
        constructor(options, view) {
            super();
            this.events = events$1;

            this.options = options;

            this._view = view;
            this._sheets = [];
            this._images = {};
            this._imgID = 0;

            this._sheetsSearchCache = {};

            this._sheet = this.insertSheet({
                rows: this.options.rows,
                columns: this.options.columns,
                rowHeight: this.options.rowHeight,
                columnWidth: this.options.columnWidth,
                headerHeight: this.options.headerHeight,
                headerWidth: this.options.headerWidth,
                dataSource: this.options.dataSource
            });

            this.undoRedoStack = new UndoRedoStack();
            this.undoRedoStack.bind(["undo", "redo"], this._onUndoRedo.bind(this));

            this._context = new FormulaContext(this);
            this._validationContext = new ValidationFormulaContext(this);
            this._names = Object.create(null);

            this.fromJSON(this.options);
        }

        clipboard() {
            if (!this._clipboard) {
                this._clipboard = new Clipboard(this);
            }
            return this._clipboard;
        }

        destroy() {
            this.unbind();

            if (this._clipboard) {
                this._clipboard.destroy();
            }
        }

        _sheetChanging(e) {
            if (this.trigger("changing", e)) {
                e.preventDefault();
            }
        }

        _sheetChange(e) {
            this.trigger("change", e);
        }

        _sheetInsertRow(e) {
            if (this.trigger("insertRow", {
                sheet: e.sender,
                index: e.index
            })) {
                e.preventDefault();
            }
        }

        _sheetInsertColumn(e) {
            if (this.trigger("insertColumn", {
                sheet: e.sender,
                index: e.index
            })) {
                e.preventDefault();
            }
        }

        _sheetDeleteRow(e) {
            if (this.trigger("deleteRow", {
                sheet: e.sender,
                index: e.index
            })) {
                e.preventDefault();
            }
        }

        _sheetDeleteColumn(e) {
            if (this.trigger("deleteColumn", {
                sheet: e.sender,
                index: e.index
            })) {
                e.preventDefault();
            }
        }

        _sheetHideRow(e) {
            if (this.trigger("hideRow", {
                sheet: e.sender,
                index: e.index
            })) {
                e.preventDefault();
            }
        }

        _sheetHideColumn(e) {
            if (this.trigger("hideColumn", {
                sheet: e.sender,
                index: e.index
            })) {
                e.preventDefault();
            }
        }

        _sheetUnhideRow(e) {
            if (this.trigger("unhideRow", {
                sheet: e.sender,
                index: e.index
            })) {
                e.preventDefault();
            }
        }

        _sheetUnhideColumn(e) {
            if (this.trigger("unhideColumn", {
                sheet: e.sender,
                index: e.index
            })) {
                e.preventDefault();
            }
        }

        _sheetSelect(e) {
            this.trigger("select", e);
        }

        _sheetDataBinding(e) {
            if (this.trigger("dataBinding", {
                sheet: e.sender
            })) {
                e.preventDefault();
            }
        }

        _sheetDataBound(e) {
            this.trigger("dataBound", {
                sheet: e.sender
            });
        }

        _sheetProgress(e) {
            let that = this;

            setTimeout(function() {
                that.trigger("progress", {
                    toggle: e.toggle
                });
            });
        }

        _sheetCommandRequest(e) {
            this.trigger("commandRequest", e);
        }

        _inputForRef(ref) {
            let self = this;
            return self._sheet.withCultureDecimals(function() {
                return new Range$1(ref, self._sheet).input();
            });
        }

        _onUndoRedo(e) {
            e.command.range().select();
        }

        execute(options) {
            let commandOptions = Object.assign({}, { workbook: this }, options.options);
            let command;

            if (this.options.getWorkbookCommand) {
                command = this.options.getWorkbookCommand(options.command, commandOptions);
            }

            command = command || new commands[options.command](commandOptions);
            let sheet = this.activeSheet();

            if (commandOptions.origin) {
                command.origin(commandOptions.origin);
            }

            if (commandOptions.operatingRange) {
                command.range(commandOptions.operatingRange);
            } else {
                command.range(sheet.selection());
            }

            if (commandOptions.editRange) {
                command._editRange = commandOptions.editRange;
            }

            let result = command.exec();

            if (!result || result.reason !== "error") {
                if (!command.cannotUndo) {
                    this.undoRedoStack.push(command);
                }
            }

            // when the undo/redo stack is truncated (by e.g. adding a
            // non-redo command after undoing) it's possible to
            // discard images from the dropped commands.
            this.cleanupImages();

            return result;
        }

        resetFormulas() {
            this._sheets.forEach(function(sheet) {
                sheet.resetFormulas();
            });
        }

        resetValidations() {
            this._sheets.forEach(function(sheet) {
                sheet.resetValidations();
            });
        }

        refresh(reason) {
            if (reason.recalc) {
                this.resetFormulas();
                this.resetValidations();
                this._sheet.recalc(this._context);
                this._sheet.revalidate(this._validationContext);
            }
        }

        activeSheet(sheet) {
            if (sheet === undefined) {
                return this._sheet;
            }

            if (!this.sheetByName(sheet.name())) {
                return undefined;
            }

            this._sheet = sheet;

            //TODO: better way to get all reasons?
            sheet.triggerChange(ALL_REASONS);
        }

        moveSheetToIndex(sheet, toIndex) {
            let fromIndex = this.sheetIndex(sheet);
            let sheets = this._sheets;

            if (fromIndex === -1) {
                return;
            }

            this._sheetsSearchCache = {};

            sheets.splice(toIndex, 0, sheets.splice(fromIndex, 1)[0]);

            this.trigger("change", { sheetSelection: true });
        }

        insertSheet(options) {
            options = options || {};
            let that = this;
            let insertIndex = typeof options.index === "number" ? options.index : that._sheets.length;
            let sheetName;
            let sheets = that._sheets;
            const messages = this.options.messages;

            let getUniqueSheetName = function(sheetNameSuffix) {
                sheetNameSuffix = sheetNameSuffix ? sheetNameSuffix : 1;

                let name = messages.workbook.defaultSheetName + sheetNameSuffix;

                if (!that.sheetByName(name)) {
                    return name;
                }

                return getUniqueSheetName(sheetNameSuffix + 1);
            };

            if (options.name && that.sheetByName(options.name)) {
                return undefined;
            }

            this._sheetsSearchCache = {};

            sheetName = options.name || getUniqueSheetName();

            let sheet = new Sheet(
                options.rows || this.options.rows,
                options.columns || this.options.columns,
                options.rowHeight || this.options.rowHeight,
                options.columnWidth || this.options.columnWidth,
                options.headerHeight || this.options.headerHeight,
                options.headerWidth || this.options.headerWidth,
                options.defaultCellStyle || this.options.defaultCellStyle,
                options.createSheetDataSource || this.options.createSheetDataSource
            );

            sheet._workbook = this;

            sheet._name(sheetName);
            sheet._state(options.state);

            this._bindSheetEvents(sheet);

            sheets.splice(insertIndex, 0, sheet);

            if (options.data) {
                sheet.fromJSON(options.data);
            }

            if (options.dataSource) {
                sheet.setDataSource(options.dataSource);
            }

            this.trigger("change", { sheetSelection: true });

            return sheet;
        }

        _bindSheetEvents(sheet) {
            sheet.bind("changing", this._sheetChanging.bind(this));
            sheet.bind("change", this._sheetChange.bind(this));
            sheet.bind("insertRow", this._sheetInsertRow.bind(this));
            sheet.bind("insertColumn", this._sheetInsertColumn.bind(this));
            sheet.bind("deleteRow", this._sheetDeleteRow.bind(this));
            sheet.bind("deleteColumn", this._sheetDeleteColumn.bind(this));
            sheet.bind("hideRow", this._sheetHideRow.bind(this));
            sheet.bind("hideColumn", this._sheetHideColumn.bind(this));
            sheet.bind("unhideRow", this._sheetUnhideRow.bind(this));
            sheet.bind("unhideColumn", this._sheetUnhideColumn.bind(this));
            sheet.bind("select", this._sheetSelect.bind(this));
            sheet.bind("commandRequest", this._sheetCommandRequest.bind(this));
            sheet.bind("dataBinding", this._sheetDataBinding.bind(this));
            sheet.bind("dataBound", this._sheetDataBound.bind(this));
            sheet.bind("progress", this._sheetProgress.bind(this));
        }

        sheets() {
            return this._sheets.slice();
        }

        sheetByName(sheetName) {
            return this._sheets[this.sheetIndex(sheetName)];
        }

        sheetByIndex(index) {
            return this._sheets[index];
        }

        sheetIndex(sheet) {
            let sheets = this._sheets;
            let sheetName = (typeof sheet == "string" ? sheet : sheet.name()).toLowerCase();
            let idx = this._sheetsSearchCache[sheetName];

            if (idx >= 0) {
                return idx;
            }

            for (idx = 0; idx < sheets.length; idx++) {
                let name = sheets[idx].name().toLowerCase();
                this._sheetsSearchCache[name] = idx;

                if (name === sheetName) {
                    return idx;
                }
            }

            return -1;
        }

        renameSheet(sheet, newSheetName) {
            let oldSheetName = sheet.name().toLowerCase();

            if (!newSheetName ||
                oldSheetName === newSheetName.toLowerCase() ||
                this.sheetByName(newSheetName)) {
                return;
            }

            sheet = this.sheetByName(oldSheetName);

            if (!sheet) {
                return;
            }

            this._sheetsSearchCache = {};

            if (this.trigger("renameSheet", {
                sheet: sheet,
                newSheetName: newSheetName
            })) {
                return;
            }

            // update references
            this._sheets.forEach(function(sheet) {
                sheet._forFormulas(function(formula) {
                    formula.renameSheet(oldSheetName, newSheetName);
                });
            });

            this.forEachName(function(def, name) {
                // 1. redefine sheet-local names
                if (def.nameref.renameSheet(oldSheetName, newSheetName)) {
                    this.undefineName(name);
                    def.name = def.nameref.print();
                    this.nameDefinition(def.name, def);
                }
                // 2. if the value is reference or formula, update it
                if (def.value instanceof Ref || def.value instanceof calc.runtime.Formula) {
                    def.value.renameSheet(oldSheetName, newSheetName);
                }
            }.bind(this));

            sheet._name(newSheetName);

            this.trigger("change", { sheetSelection: true });

            return sheet;
        }

        removeSheet(sheet) {
            let that = this;
            let sheets = that._sheets;
            let name = sheet.name();
            let index = that.sheetIndex(sheet);

            if (sheets.length === 1) {
                return;
            }

            if (this.trigger("removeSheet", { sheet: sheet })) {
                return;
            }

            this._sheetsSearchCache = {};

            if (index > -1) {
                sheet.unbind();

                sheets.splice(index, 1);

                if (that.activeSheet().name() === name) {
                    let newSheet = sheets[index === sheets.length ? index - 1 : index];
                    that.activeSheet(newSheet);
                } else {
                    this.trigger("change", { recalc: true, sheetSelection: true });
                }
            }
        }

        _clearSheets() {
            for (let i = 0; i < this._sheets.length; i++) {
                this._sheets[i]._activeDrawing = [];
                this._sheets[i]._drawings = [];
                this._sheets[i].unbind();
            }
            this._sheets = [];
            this._sheetsSearchCache = {};
            this._names = {};
            this._images = {};
            this._imgID = 0;
        }

        _loadImages() {
            let self = this;
            let ids = Object.keys(self._images);
            let count = ids.length;
            if (count) {
                ids.forEach(function(id){
                    let img = self._images[id];
                    if (!img.blob) {
                        loadBinary(img.url, function(data, type) {
                            // XXX: can we do something better in case of error?
                            if (data != null) {
                                img.blob = new Blob([ data ], { type: type });
                                delete img.url;
                            }
                            next();
                        });
                    }
                });
            } else {
                next();
            }
            function next() {
                if (--count <= 0) {
                    self.activeSheet().triggerChange({ layout: true });
                }
            }
        }

        fromJSON(json) {
            if (json.sheets) {
                this._clearSheets();

                if (json.images) {
                    this._imgID = 0;
                    this._images = {};
                    Object.keys(json.images).forEach(function(id) {
                        if (!isNaN(id)) {
                            let num = parseFloat(id);
                            if (isFinite(num)) {
                                this._imgID = Math.max(this._imgID, num);
                            }
                        }
                        this._images[id] = { url: json.images[id] };
                    }, this);
                    this._loadImages();
                }

                for (let idx = 0; idx < json.sheets.length; idx++) {
                    let data = json.sheets[idx];
                    let args = sheetParamsFromJSON(data, this.options);
                    let sheet = this.insertSheet({
                        rows         : args.rowCount,
                        columns      : args.columnCount,
                        rowHeight    : args.rowHeight,
                        columnWidth  : args.columnWidth,
                        headerHeight : args.headerHeight,
                        headerWidth  : args.headerWidth,
                        data         : data
                    });

                    if (data.dataSource) {
                        sheet.setDataSource(data.dataSource);
                    }
                }
            }

            if (json.activeSheet) {
                this.activeSheet(this.sheetByName(json.activeSheet));
            } else {
                this.activeSheet(this._sheets[0]);
            }

            if (json.names) {
                json.names.forEach(function(def) {
                    this.defineName(def.name, def.value, def.hidden);
                }, this);
            }
        }

        toJSON() {
            this.resetFormulas();
            this.resetValidations();
            let names = Object.keys(this._names).map(function(name) {
                let def = this._names[name];
                let val = def.value;
                if (val instanceof Ref || val instanceof calc.runtime.Formula) {
                    val = val.print(0, 0, true);
                } else if (val instanceof CalcError) {
                    val = String(val);
                } else {
                    val = JSON.stringify(val);
                }
                return {
                    value     : val,
                    hidden    : def.hidden,
                    name      : def.name,

                    // these two are not really useful in
                    // deserialization, but are handy in OOXML export.
                    sheet     : def.nameref.sheet,
                    localName : def.nameref.name
                };
            }, this);
            return {
                activeSheet: this.activeSheet().name(),
                sheets: this._sheets.map(function(sheet) {
                    sheet.recalc(this._context);
                    sheet.revalidate(this._validationContext);
                    return sheet.toJSON();
                }, this),
                names: names,
                images: {},
                columnWidth: this.options.columnWidth,
                rowHeight: this.options.rowHeight
            };
        }

        saveJSON() {
            let self = this;
            let data = self.toJSON();
            let ids = Object.keys(self._images).filter(function(id) {
                return self.usesImage(id) === 1;
            });
            let count = ids.length;

            const promises = [];

            if (count) {
                ids.forEach(function(id) {
                    let img = self._images[id];
                    if (img.blob) {
                        const promise = new Promise((resolve) => {
                            let reader = new FileReader();
                            reader.onload = function() {
                                data.images[id] = reader.result;
                                resolve();
                            };
                            reader.readAsDataURL(img.blob);
                        });
                        promises.push(promise);
                    } else {
                        data.images[id] = img.url;
                    }
                });
            }

            return Promise.all(promises).then(() => data);
        }

        fromFile(file) {
            const deferred = new Deferred();

            if (file && !this.trigger("excelImport", { file, deferred })) {
                this._clearSheets();
                this._readExcel(file, this, deferred);
            }

            return deferred.promise;
        }

        _readExcel(file, workbook, deferred) {
            readExcel(file, workbook, deferred);
        }

        saveAsExcel(options) {
            let self = this;
            options = deepExtend({}, self.options.excel, options);
            let data = self.toJSON();

            if (self.trigger("excelExport", { workbook: data })) {
                return;
            }

            let ids = Object.keys(self._images).filter(function(id) {
                return self.usesImage(id) === 1;
            });
            let count = ids.length;
            let images = count ? {} : null;
            const promises = [];

            if (count) {
                ids.forEach(function(id) {
                    let img = self._images[id];

                    if (img.blob) {
                        const promise = new Promise((resolve) => {
                            let reader = new FileReader();
                            reader.onload = function() {
                                images[id] = {
                                    type: img.blob.type,
                                    name: img.blob.name,
                                    data: reader.result
                                };

                                count--;
                                resolve();
                            };
                            reader.readAsArrayBuffer(img.blob);
                        });

                        promises.push(promise);
                    } else {
                        const promise = new Promise((resolve) => {
                            loadBinary(img.url, function(data, type) {
                                images[id] = { type: type, data: data };
                                count--;
                                resolve();
                            });
                        });
                        promises.push(promise);
                    }
                });

                return Promise.all(promises)
                        .then(() => {
                            return next();
                        });
            } else {
                return next();
            }

            function next() {
                if (--count <= 0) {
                    data.images = images;
                    let workbook = new options.Workbook(data);
                    const promise = options.forceProxy ? workbook.toDataURL() : workbook.toBlob();

                    if (!options.saveAs) {
                        return promise;
                    }

                    return promise.then(blob => {
                        options.saveAs(blob, data.fileName || options.fileName, {
                            proxyURL: options.proxyURL,
                            forceProxy: options.forceProxy
                        });
                    });
                }

                return Promise.resolve();
            }
        }

        draw(options, callback) {
            if (typeof options == "function" && !callback) {
                callback = options;
                options = {};
            }
            let parts = [], sheets = this._sheets;
            (function loop(i) {
                if (i < sheets.length) {
                    sheets[i].draw(SHEETREF, options, function(group) {
                        parts.push(group);
                        loop(i + 1);
                    });
                } else {
                    let group = parts[0];
                    for (i = 1; i < parts.length; ++i) {
                        group.children = group.children.concat(parts[i].children);
                    }
                    callback(group);
                }
            })(0);
        }

        nameForRef(ref, sheet) {
            if (sheet === undefined) {
                sheet = ref.sheet;
            }
            sheet = sheet.toLowerCase();
            let str = String(ref);
            for (let name in this._names) {
                let def = this._names[name];
                let val = def.value;
                if (val instanceof Ref) {
                    if (!val.sheet || (val.sheet && sheet === val.sheet.toLowerCase())) {
                        if (String(val) === str) {
                            return def;
                        }
                    }
                }
            }
            return { name: str };
        }

        defineName(name, value, hidden) {
            let x = calc.parseNameDefinition(name, value);
            name = x.name.print();
            this._names[name.toLowerCase()] = {
                value   : x.value,
                hidden  : hidden,
                name    : name,
                nameref : x.name
            };
        }

        undefineName(name) {
            delete this._names[name.toLowerCase()];
        }

        nameValue(name) {
            name = name.toLowerCase();
            if (name in this._names) {
                return this._names[name].value;
            }
            return null;
        }

        nameDefinition(name, def) {
            name = name.toLowerCase();
            if (arguments.length > 1) {
                if (def === undefined) {
                    delete this._names[name];
                } else {
                    this._names[name] = def;
                }
            }
            return this._names[name];
        }

        forEachName(func) {
            Object.keys(this._names).forEach(function(name) {
                func(this._names[name], name);
            }, this);
        }

        adjustNames(affectedSheet, forRow, start, delta) {
            affectedSheet = affectedSheet.toLowerCase();
            Object.keys(this._names).forEach(function(name) {
                let def = this._names[name];
                let x = def.value;
                if (x instanceof Ref &&
                    x.sheet.toLowerCase() === affectedSheet) {
                    def.value = x.adjust(null, null, null, null, forRow, start, delta);
                } else if (x instanceof calc.runtime.Formula) {
                    x.adjust(affectedSheet, forRow ? "row" : "col", start, delta);
                }
            }, this);
        }

        addImage(image) {
            let id = String(++this._imgID);
            if (typeof image == "string") {
                this._images[id] = { url: image };
            } else {
                this._images[id] = { blob: image };
            }
            return id;
        }

        imageUrl(id) {
            let img = this._images[id];
            let url = img.url;
            if (!url) {
                url = img.url = window.URL.createObjectURL(img.blob);
            }
            return url;
        }

        cleanupImages() {
            Object.keys(this._images).forEach(function(id) {
                if (!this.usesImage(id)) {
                    let url = this._images[id].url;
                    if (url) {
                        window.URL.revokeObjectURL(url);
                    }
                    delete this._images[id];
                }
            }, this);
        }

        usesImage(img) {
            let i;
            let sheets = this._sheets;
            for (i = sheets.length; --i >= 0;) {
                if (sheets[i].usesImage(img)) {
                    return 1;
                }
            }
            let stack = this.undoRedoStack.stack;
            for (i = stack.length; --i >= 0;) {
                if (stack[i].usesImage(img)) {
                    return 2; // signal that it's only in the undo stack
                }
            }
            return false;
        }
    }

    function sheetParamsFromJSON(data, options) {
        function or(a, b, c) {
            return a !== undefined ? a : b !== undefined ? b : c;
        }

        let rowCount = or(data.rowCount, options.rows, 200),
            columnCount = or(data.columnCount, options.columns, 50),
            rowHeight = or(data.rowHeight, options.rowHeight, 20),
            columnWidth = or(data.columnWidth, options.columnWidth, 64),
            headerHeight = or(data.headerHeight, options.headerHeight, 20),
            headerWidth = or(data.headerWidth, options.headerWidth, 32);

        if (data.rows !== undefined) {
            for (let i = 0; i < data.rows.length; ++i) {
                let row = data.rows[i];
                let ri = or(row.index, i);
                if (ri >= rowCount) { rowCount = ri + 1; }
                if (row.cells) {
                    for (let j = 0; j < row.cells.length; ++j) {
                        let cell = row.cells[j];
                        let ci = or(cell.index, j);
                        if (ci >= columnCount) { columnCount = ci + 1; }
                    }
                }
            }
        }

        return {
            rowCount     : rowCount,
            columnCount  : columnCount,
            rowHeight    : rowHeight,
            columnWidth  : columnWidth,
            headerHeight : headerHeight,
            headerWidth  : headerWidth
        };
    }

    // if (kendo.PDFMixin) {
    //     kendo.PDFMixin.extend(Workbook.prototype);

    //     Workbook.prototype.saveAsPDF = function(options) {
    //         let progress = new $.Deferred();
    //         let promise = progress.promise();
    //         let args = { promise: promise };
    //         if (this.trigger("pdfExport", args)) {
    //             return;
    //         }

    //         this._drawPDF(options, progress)
    //         .then(function(root) {
    //             return options.forceProxy
    //                 ? kendo.pdf.exportPDF(root) // produce data URI for proxy
    //                 : kendo.pdf.exportPDFToBlob(root);
    //         })
    //         .done(function(dataURI) {
    //             kendo.saveAs({
    //                 dataURI: dataURI,
    //                 fileName: options.fileName,
    //                 proxyURL: options.proxyURL,
    //                 forceProxy: options.forceProxy,
    //                 proxyTarget: options.proxyTarget
    //             });

    //             progress.resolve();
    //         })
    //         .fail(function(err) {
    //             progress.reject(err);
    //         });

    //         return promise;
    //     };

    //     Workbook.prototype._drawPDF = function(options) {
    //         let result = new $.Deferred();
    //         let callback = function(group) {
    //             result.resolve(group);
    //         };
    //         switch (options.area) {
    //         case "workbook":
    //             options.workbook.draw(options, callback);
    //             break;
    //         case "sheet":
    //             options.workbook.activeSheet().draw(options, callback);
    //             break;
    //         case "selection":
    //             options.workbook.activeSheet().selection().draw(options, callback);
    //             break;
    //         }

    //         return result.promise();
    //     };
    // }

    /* eslint-disable no-param-reassign */

    const events = [
        "cut",
        "copy",
        "paste",
        "pdfExport",
        "excelExport",
        "excelImport",
        "changing",
        "change",
        "render",
        "removeSheet",
        "selectSheet",
        "renameSheet",
        "insertRow",
        "insertColumn",
        "deleteRow",
        "insertSheet",
        "deleteColumn",
        "hideRow",
        "hideColumn",
        "unhideRow",
        "unhideColumn",
        "select",
        "changeFormat",
        "dataBinding",
        "dataBound",
        "update",
        "message",
        "contextmenu",
    ];

    class SpreadsheetWidget extends Widget {
        constructor(element, options$1) {
            super(element, deepExtend({}, options, options$1));
            this.events = events;
            this.bind(this.events, this.options);

            intl({ locale: this.options.locale, ...this.options.intl });
            initDynamicFilter();

            this._view = new View(this.element, {
                messages: this.options.messages.view,
                toolbar: this.options.toolbar,
                sheetsbar: this.options.sheetsbar,
                formulaBarInputRef: this.options.formulaBarInputRef,
                formulaCellInputRef: this.options.formulaCellInputRef,
                nameBoxRef: this.options.nameBoxRef,
                createTabStrip: this.options.createTabStrip,
                createFilterMenu: this.options.createFilterMenu,
                createContextMenus: this.options.createContextMenus,
                createSheetBar: this.options.createSheetBar,
                getIconHTMLString: this.options.getIconHTMLString,
                openDialogCallback: this.openDialog.bind(this),
            });

            this._workbook = new Workbook(this.options, this._view);

            this._controller = new Controller(this._view, this._workbook);

            this._autoRefresh = true;

            this._bindWorkbookEvents();
            this._bindViewEvents();

            this._view.workbook(this._workbook);

            this._view.enableClipboard(false);
            this.refresh();
            this._view.enableClipboard(true);

            this._resizeHandler = this.resize.bind(this);
            window.addEventListener('resize', this._resizeHandler);

            this._keyDownHandler = this._keyDown.bind(this);
            this.element.addEventListener("keydown", this._keyDownHandler);
        }

        get view() {
            return this._view;
        }

        get workbook () {
            return this._workbook;
        }

        _keyDown(e) {
            let key = e.keyCode;
            let controlKey = e.ctrlKey || e.metaKey;

            this.trigger("keydown", e);

            if (key === keys.F11 && e.shiftKey) {
                this._view.sheetsbar.onAddSelect();
                e.preventDefault();
                return;
            } else if (e.altKey && key === keys.PAGEDOWN) {
                let activeSheetIndex = this.sheetIndex(this.activeSheet());
                let nextSheetName = this.sheetByIndex(activeSheetIndex + 1)?.name();

                if (nextSheetName){
                    this._view.sheetsbar.onSheetSelect(nextSheetName);
                }
            } else if (e.altKey && key === keys.PAGEUP) {
                let activeSheetIndex = this.sheetIndex(this.activeSheet());
                let prevSheetName = this.sheetByIndex(activeSheetIndex - 1)?.name();

                if (prevSheetName) {
                    this._view.sheetsbar.onSheetSelect(prevSheetName);
                }
            } else if (e.altKey && key === keys.DELETE) {
                this._view.sheetsbar.onSheetRemove(this.activeSheet()._name());
                e.preventDefault();
                return;
            } else if (e.altKey && key === keys.R) {
                this.options.createSheetEditor?.();
                e.preventDefault();
                return;
            } else if (controlKey && key === keys.B) {
                this._handleTypographicalEmphasis('bold');
            } else if (controlKey && key === keys.I) {
                this._handleTypographicalEmphasis('italic');
            } else if (controlKey && key === keys.U) {
                this._handleTypographicalEmphasis('underline');
            } else if (e.altKey && key === keys.H) {
                this._view.tabstrip?.select("home");
                e.preventDefault();
                return;
            } else if (e.altKey && key === keys.N) {
                this._view.tabstrip?.select("insert");
                e.preventDefault();
                return;
            } else if (e.altKey && key === keys.A) {
                this._view.tabstrip?.select("data");
                e.preventDefault();
                return;
            } else if (key === keys.F10) {
                e.preventDefault();
                this._view.tabstrip?.focus();
            }
        }

        _handleTypographicalEmphasis(command) {
            const sheet = this.activeSheet();

            if (sheet) {
                this.executeCommand({
                    command: 'PropertyChangeCommand',
                    options: {
                        property: command,
                        value: !sheet.range(sheet.activeCell())[command]()
                    }
                });
            }
        }

        _resize() {
            this.refresh({ layout: true });
        }

        _workbookChanging(e) {
            if (this.trigger("changing", e)) {
                e.preventDefault();
            }
        }

        _workbookChange(e) {
            if (this._autoRefresh) {
                this.refresh(e);
            }

            if (e.recalc && e.ref) {
                let range = e.range || new Range$1(e.ref, this.activeSheet());
                this.trigger("change", { range: range });
            }
        }

        _workbookCut(e) {
            this.trigger("cut", e);
        }

        _workbookCopy(e) {
            this.trigger("copy", e);
        }

        _workbookPaste(e) {
            this.trigger("paste", e);
        }

        activeSheet(sheet) {
            return this._workbook.activeSheet(sheet);
        }

        moveSheetToIndex(sheet, index) {
            return this._workbook.moveSheetToIndex(sheet, index);
        }

        insertSheet(options) {
            return this._workbook.insertSheet(options);
        }

        sheets() {
            return this._workbook.sheets();
        }

        removeSheet(sheet) {
            return this._workbook.removeSheet(sheet);
        }

        sheetByName(sheetName) {
            return this._workbook.sheetByName(sheetName);
        }

        sheetIndex(sheet) {
            return this._workbook.sheetIndex(sheet);
        }

        sheetByIndex(index) {
            return this._workbook.sheetByIndex(index);
        }

        renameSheet(sheet, newSheetName) {
            return this._workbook.renameSheet(sheet, newSheetName);
        }

        executeCommand(options) {
            return this._controller.executeCommand(options);
        }

        refresh(reason) {
            if (!reason) {
                reason = ALL_REASONS;
            }

            if (!reason.editorClose) {
                this._view.sheet(this._workbook.activeSheet());
                this._controller.sheet(this._workbook.activeSheet());

                this._workbook.refresh(reason);
            }

            if (!reason.editorChange) {
                this._view.refresh(reason);
                this._controller.refresh();

                this._view.render(reason);
                this.trigger("render");
            }

            return this;
        }

        openDialog(name, options) {
            return this._view.openDialog(name, options);
        }

        autoRefresh(value) {
            if (value !== undefined) {
                this._autoRefresh = value;

                if (value === true) {
                    this.refresh();
                }

                return this;
            }

            return this._autoRefresh;
        }

        toJSON() {
            return this._workbook.toJSON();
        }

        fromJSON(json) {
            if (json.sheets) {
                this._workbook.destroy();

                this._workbook = new Workbook(deepExtend({}, this.options, json));

                this._bindWorkbookEvents();

                this._view.workbook(this._workbook);
                this._controller.workbook(this._workbook);

                this.activeSheet(this.activeSheet());
            } else {
                this.refresh();
            }
        }

        saveJSON() {
            return this._workbook.saveJSON();
        }

        fromFile(blob) {
            return this._workbook.fromFile(blob);
        }

        saveAsPDF(options) {
            this._workbook.saveAsPDF(
                deepExtend({}, this.options.pdf, options, { workbook: this._workbook })
            );
        }

        saveAsExcel(options) {
            return this._workbook.saveAsExcel(options);
        }

        draw(options, callback) {
            this._workbook.draw(options, callback);
        }

        _workbookExcelExport(e) {
            if (this.trigger("excelExport", e)) {
                e.preventDefault();
            }
        }

        _workbookExcelImport(e) {
            if (this.trigger("excelImport", e)) {
                e.preventDefault();
            }
        }

        // _initProgress(deferred) {
        //     let loading =
        //         $("<div class='k-loading-mask' " +
        //                "style='width: 100%; height: 100%; top: 0;'>" +
        //             "<div class='k-loading-color'></div>" +
        //         "</div>")
        //         .appendTo(this.element);

        //     let pb = $("<div class='k-loading-progress'>")
        //     .appendTo(loading)
        //     .kendoProgressBar({
        //         type: "chunk", chunkCount: 10,
        //         min: 0, max: 1, value: 0
        //     }).data("kendoProgressBar");

        //     deferred.progress(function(e) {
        //         pb.value(e.progress);
        //     })
        //     .always(function() {
        //         kendo.destroy(loading);
        //         loading.remove();
        //     });
        // }

        _workbookPdfExport(e) {
            if (this.trigger("pdfExport", e)) {
                e.preventDefault();
            }
        }

        _workbookInsertSheet(e) {
            if (this.trigger("insertSheet", e)) {
                e.preventDefault();
            }
        }

        _workbookRemoveSheet(e) {
            if (this.trigger("removeSheet", e)) {
                e.preventDefault();
            }
        }

        _workbookSelectSheet(e) {
            if (this.trigger("selectSheet", e)) {
                e.preventDefault();
            }
        }

        _workbookRenameSheet(e) {
            if (this.trigger("renameSheet", e)) {
                e.preventDefault();
            }
        }

        _workbookInsertRow(e) {
            if (this.trigger("insertRow", e)) {
                e.preventDefault();
            }
        }

        _workbookInsertColumn(e) {
            if (this.trigger("insertColumn", e)) {
                e.preventDefault();
            }
        }

        _workbookDeleteRow(e) {
            if (this.trigger("deleteRow", e)) {
                e.preventDefault();
            }
        }

        _workbookDeleteColumn(e) {
            if (this.trigger("deleteColumn", e)) {
                e.preventDefault();
            }
        }

        _workbookHideRow(e) {
            if (this.trigger("hideRow", e)) {
                e.preventDefault();
            }
        }

        _workbookHideColumn(e) {
            if (this.trigger("hideColumn", e)) {
                e.preventDefault();
            }
        }

        _workbookUnhideRow(e) {
            if (this.trigger("unhideRow", e)) {
                e.preventDefault();
            }
        }

        _workbookUnhideColumn(e) {
            if (this.trigger("unhideColumn", e)) {
                e.preventDefault();
            }
        }

        _workbookSelect(e) {
            this.trigger("select", e);
        }

        _workbookChangeFormat(e) {
            this.trigger("changeFormat", e);
        }

        _workbookDataBinding(e) {
            if (this.trigger("dataBinding", e)) {
                e.preventDefault();
            }
        }

        _workbookDataBound(e) {
            this.trigger("dataBound", e);
        }

        _workbookProgress() {
            // kendo.ui.progress(this.element, e.toggle);
        }

        _viewUpdate(e) {
            this.trigger("update", e);
        }

        _viewMessage(e) {
            this.trigger("message", e);
        }

        _onContextMenu(e) {
            this.trigger("contextmenu", e);
        }

        _bindWorkbookEvents() {
            this._workbook.bind("cut", this._workbookCut.bind(this));
            this._workbook.bind("copy", this._workbookCopy.bind(this));
            this._workbook.bind("paste", this._workbookPaste.bind(this));
            this._workbook.bind("changing", this._workbookChanging.bind(this));
            this._workbook.bind("change", this._workbookChange.bind(this));
            this._workbook.bind("excelExport", this._workbookExcelExport.bind(this));
            this._workbook.bind("excelImport", this._workbookExcelImport.bind(this));
            this._workbook.bind("pdfExport", this._workbookPdfExport.bind(this));
            this._workbook.bind("insertSheet", this._workbookInsertSheet.bind(this));
            this._workbook.bind("removeSheet", this._workbookRemoveSheet.bind(this));
            this._workbook.bind("selectSheet", this._workbookSelectSheet.bind(this));
            this._workbook.bind("renameSheet", this._workbookRenameSheet.bind(this));
            this._workbook.bind("insertRow", this._workbookInsertRow.bind(this));
            this._workbook.bind("insertColumn", this._workbookInsertColumn.bind(this));
            this._workbook.bind("deleteRow", this._workbookDeleteRow.bind(this));
            this._workbook.bind("deleteColumn", this._workbookDeleteColumn.bind(this));
            this._workbook.bind("hideRow", this._workbookHideRow.bind(this));
            this._workbook.bind("hideColumn", this._workbookHideColumn.bind(this));
            this._workbook.bind("unhideRow", this._workbookUnhideRow.bind(this));
            this._workbook.bind("unhideColumn", this._workbookUnhideColumn.bind(this));
            this._workbook.bind("select", this._workbookSelect.bind(this));
            this._workbook.bind("changeFormat", this._workbookChangeFormat.bind(this));
            this._workbook.bind("dataBinding", this._workbookDataBinding.bind(this));
            this._workbook.bind("dataBound", this._workbookDataBound.bind(this));
            this._workbook.bind("progress", this._workbookProgress.bind(this));
            this._workbook.bind("contextmenu", this._onContextMenu.bind(this));
        }

        _bindViewEvents() {
            this._view.bind("update", this._viewUpdate.bind(this));
            this._view.bind("message", this._viewMessage.bind(this));
        }

        destroy() {
            window.removeEventListener('resize', this._resizeHandler);
            this.element.removeEventListener("keydown", this._keyDownHandler);

            this.unbind();

            this._workbook.destroy();
            this._controller.destroy();
            this._view.destroy();
        }

        defineName(name, value, hidden) {
            return this._workbook.defineName(name, value, hidden);
        }

        undefineName(name) {
            return this._workbook.undefineName(name);
        }

        nameValue(name) {
            return this._workbook.nameValue(name);
        }

        forEachName(func) {
            return this._workbook.forEachName(func);
        }

        cellContextMenu() {
            return this._view.cellContextMenu;
        }

        rowHeaderContextMenu() {
            return this._view.rowHeaderContextMenu;
        }

        colHeaderContextMenu() {
            return this._view.colHeaderContextMenu;
        }

        addImage(image) {
            return this._workbook.addImage(image);
        }

        cleanupImages() {
            return this._workbook.cleanupImages();
        }
    }

    /* -----[ Excel operators ]----- */


    const {
        FUNCS,
        defineBuiltinFunction,
        limitPrecision,
        packDate: packDate$1,
        unpackDate: unpackDate$1,
        daysInMonth,
        daysInYear,
        isLeapYear,
    } = calc.runtime;

    defineBuiltinFunction('binary+', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $a = args[i++];
                if ($a instanceof CalcError)
                    return $a;
                if (!((typeof ($a = this.force($a)) == 'number' ? ($a = limitPrecision($a), true) : false) || (typeof $a == 'boolean' ? ($a = +$a, true) : false) || (typeof $a == 'string' && !/^(?:=|true|false)/i.test($a) ? (tmp = calc.parse(0, 0, 0, $a), /^date|number|percent$/.test(tmp.type) ? ($a = +tmp.value, true) : false) : false) || ($a == null ? ($a = 0, true) : false))) {
                    if ($a instanceof CalcError)
                        return $a;
                    return new CalcError(err);
                }
                xargs.push($a);
            }
            {
                var $b = args[i++];
                if ($b instanceof CalcError)
                    return $b;
                if (!((typeof ($b = this.force($b)) == 'number' ? ($b = limitPrecision($b), true) : false) || (typeof $b == 'boolean' ? ($b = +$b, true) : false) || (typeof $b == 'string' && !/^(?:=|true|false)/i.test($b) ? (tmp = calc.parse(0, 0, 0, $b), /^date|number|percent$/.test(tmp.type) ? ($b = +tmp.value, true) : false) : false) || ($b == null ? ($b = 0, true) : false))) {
                    if ($b instanceof CalcError)
                        return $b;
                    return new CalcError(err);
                }
                xargs.push($b);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $a = this._arrayArg(args[i]);
            if ($a) {
                xargs.push($a);
                width = Math.max(width, $a.width);
                height = Math.max(height, $a.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $b = this._arrayArg(args[i]);
            if ($b) {
                xargs.push($b);
                width = Math.max(width, $b.width);
                height = Math.max(height, $b.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (a, b) {
        return a + b;
    });

    defineBuiltinFunction('binary-', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $a = args[i++];
                if ($a instanceof CalcError)
                    return $a;
                if (!((typeof ($a = this.force($a)) == 'number' ? ($a = limitPrecision($a), true) : false) || (typeof $a == 'boolean' ? ($a = +$a, true) : false) || (typeof $a == 'string' && !/^(?:=|true|false)/i.test($a) ? (tmp = calc.parse(0, 0, 0, $a), /^date|number|percent$/.test(tmp.type) ? ($a = +tmp.value, true) : false) : false) || ($a == null ? ($a = 0, true) : false))) {
                    if ($a instanceof CalcError)
                        return $a;
                    return new CalcError(err);
                }
                xargs.push($a);
            }
            {
                var $b = args[i++];
                if ($b instanceof CalcError)
                    return $b;
                if (!((typeof ($b = this.force($b)) == 'number' ? ($b = limitPrecision($b), true) : false) || (typeof $b == 'boolean' ? ($b = +$b, true) : false) || (typeof $b == 'string' && !/^(?:=|true|false)/i.test($b) ? (tmp = calc.parse(0, 0, 0, $b), /^date|number|percent$/.test(tmp.type) ? ($b = +tmp.value, true) : false) : false) || ($b == null ? ($b = 0, true) : false))) {
                    if ($b instanceof CalcError)
                        return $b;
                    return new CalcError(err);
                }
                xargs.push($b);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $a = this._arrayArg(args[i]);
            if ($a) {
                xargs.push($a);
                width = Math.max(width, $a.width);
                height = Math.max(height, $a.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $b = this._arrayArg(args[i]);
            if ($b) {
                xargs.push($b);
                width = Math.max(width, $b.width);
                height = Math.max(height, $b.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (a, b) {
        return a - b;
    });

    defineBuiltinFunction('binary*', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $a = args[i++];
                if ($a instanceof CalcError)
                    return $a;
                if (!((typeof ($a = this.force($a)) == 'number' ? ($a = limitPrecision($a), true) : false) || (typeof $a == 'boolean' ? ($a = +$a, true) : false) || (typeof $a == 'string' && !/^(?:=|true|false)/i.test($a) ? (tmp = calc.parse(0, 0, 0, $a), /^date|number|percent$/.test(tmp.type) ? ($a = +tmp.value, true) : false) : false) || ($a == null ? ($a = 0, true) : false))) {
                    if ($a instanceof CalcError)
                        return $a;
                    return new CalcError(err);
                }
                xargs.push($a);
            }
            {
                var $b = args[i++];
                if ($b instanceof CalcError)
                    return $b;
                if (!((typeof ($b = this.force($b)) == 'number' ? ($b = limitPrecision($b), true) : false) || (typeof $b == 'boolean' ? ($b = +$b, true) : false) || (typeof $b == 'string' && !/^(?:=|true|false)/i.test($b) ? (tmp = calc.parse(0, 0, 0, $b), /^date|number|percent$/.test(tmp.type) ? ($b = +tmp.value, true) : false) : false) || ($b == null ? ($b = 0, true) : false))) {
                    if ($b instanceof CalcError)
                        return $b;
                    return new CalcError(err);
                }
                xargs.push($b);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $a = this._arrayArg(args[i]);
            if ($a) {
                xargs.push($a);
                width = Math.max(width, $a.width);
                height = Math.max(height, $a.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $b = this._arrayArg(args[i]);
            if ($b) {
                xargs.push($b);
                width = Math.max(width, $b.width);
                height = Math.max(height, $b.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (a, b) {
        return a * b;
    });

    defineBuiltinFunction('binary/', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $a = args[i++];
                if ($a instanceof CalcError)
                    return $a;
                if (!((typeof ($a = this.force($a)) == 'number' ? ($a = limitPrecision($a), true) : false) || (typeof $a == 'boolean' ? ($a = +$a, true) : false) || (typeof $a == 'string' && !/^(?:=|true|false)/i.test($a) ? (tmp = calc.parse(0, 0, 0, $a), /^date|number|percent$/.test(tmp.type) ? ($a = +tmp.value, true) : false) : false) || ($a == null ? ($a = 0, true) : false))) {
                    if ($a instanceof CalcError)
                        return $a;
                    return new CalcError(err);
                }
                xargs.push($a);
            }
            {
                var $b = args[i++];
                if ($b instanceof CalcError)
                    return $b;
                if (!(((typeof ($b = this.force($b)) == 'number' ? ($b = limitPrecision($b), true) : false) || (typeof $b == 'boolean' ? ($b = +$b, true) : false) || (typeof $b == 'string' && !/^(?:=|true|false)/i.test($b) ? (tmp = calc.parse(0, 0, 0, $b), /^date|number|percent$/.test(tmp.type) ? ($b = +tmp.value, true) : false) : false)) && ($b == 0 ? (err = 'DIV/0', false) : true))) {
                    if ($b instanceof CalcError)
                        return $b;
                    return new CalcError(err);
                }
                xargs.push($b);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $a = this._arrayArg(args[i]);
            if ($a) {
                xargs.push($a);
                width = Math.max(width, $a.width);
                height = Math.max(height, $a.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $b = this._arrayArg(args[i]);
            if ($b) {
                xargs.push($b);
                width = Math.max(width, $b.width);
                height = Math.max(height, $b.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (a, b) {
        return a / b;
    });

    defineBuiltinFunction('binary^', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $a = args[i++];
                if ($a instanceof CalcError)
                    return $a;
                if (!((typeof ($a = this.force($a)) == 'number' ? ($a = limitPrecision($a), true) : false) || (typeof $a == 'boolean' ? ($a = +$a, true) : false) || (typeof $a == 'string' && !/^(?:=|true|false)/i.test($a) ? (tmp = calc.parse(0, 0, 0, $a), /^date|number|percent$/.test(tmp.type) ? ($a = +tmp.value, true) : false) : false) || ($a == null ? ($a = 0, true) : false))) {
                    if ($a instanceof CalcError)
                        return $a;
                    return new CalcError(err);
                }
                xargs.push($a);
            }
            {
                var $b = args[i++];
                if ($b instanceof CalcError)
                    return $b;
                if (!((typeof ($b = this.force($b)) == 'number' ? ($b = limitPrecision($b), true) : false) || (typeof $b == 'boolean' ? ($b = +$b, true) : false) || (typeof $b == 'string' && !/^(?:=|true|false)/i.test($b) ? (tmp = calc.parse(0, 0, 0, $b), /^date|number|percent$/.test(tmp.type) ? ($b = +tmp.value, true) : false) : false) || ($b == null ? ($b = 0, true) : false))) {
                    if ($b instanceof CalcError)
                        return $b;
                    return new CalcError(err);
                }
                xargs.push($b);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $a = this._arrayArg(args[i]);
            if ($a) {
                xargs.push($a);
                width = Math.max(width, $a.width);
                height = Math.max(height, $a.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $b = this._arrayArg(args[i]);
            if ($b) {
                xargs.push($b);
                width = Math.max(width, $b.width);
                height = Math.max(height, $b.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (a, b) {
        return Math.pow(a, b);
    });

    defineBuiltinFunction('binary&', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $a = args[i++];
                if ($a instanceof CalcError)
                    return $a;
                if (!((typeof ($a = this.force($a)) == 'number' ? ($a = limitPrecision($a), true) : false) || (typeof $a == 'boolean' ? ($a = +$a, true) : false) || (typeof $a == 'string' && !/^(?:=|true|false)/i.test($a) ? (tmp = calc.parse(0, 0, 0, $a), /^date|number|percent$/.test(tmp.type) ? ($a = +tmp.value, true) : false) : false) || (typeof $a == 'string' || typeof $a == 'boolean' || typeof $a == 'number' ? ($a += '', true) : $a === undefined ? ($a = '', true) : false) || typeof $a == 'boolean' || $a == null)) {
                    if ($a instanceof CalcError)
                        return $a;
                    return new CalcError(err);
                }
                xargs.push($a);
            }
            {
                var $b = args[i++];
                if ($b instanceof CalcError)
                    return $b;
                if (!((typeof ($b = this.force($b)) == 'number' ? ($b = limitPrecision($b), true) : false) || (typeof $b == 'boolean' ? ($b = +$b, true) : false) || (typeof $b == 'string' && !/^(?:=|true|false)/i.test($b) ? (tmp = calc.parse(0, 0, 0, $b), /^date|number|percent$/.test(tmp.type) ? ($b = +tmp.value, true) : false) : false) || (typeof $b == 'string' || typeof $b == 'boolean' || typeof $b == 'number' ? ($b += '', true) : $b === undefined ? ($b = '', true) : false) || typeof $b == 'boolean' || $b == null)) {
                    if ($b instanceof CalcError)
                        return $b;
                    return new CalcError(err);
                }
                xargs.push($b);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $a = this._arrayArg(args[i]);
            if ($a) {
                xargs.push($a);
                width = Math.max(width, $a.width);
                height = Math.max(height, $a.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $b = this._arrayArg(args[i]);
            if ($b) {
                xargs.push($b);
                width = Math.max(width, $b.width);
                height = Math.max(height, $b.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (a, b) {
        if (a == null) {
            a = '';
        }
        if (b == null) {
            b = '';
        }
        return '' + a + b;
    });

    function equals(a, b) {
        a = typeof(a) === "string" ? a.toLowerCase() : a;
        b = typeof(b) === "string" ? b.toLowerCase() : b;

        // special cases
        if (a === false && b == null) { return true; }
        if (b === false && a == null) { return true; }
        if (a === 0 && b == null) { return true; }
        if (b === 0 && a == null) { return true; }
        if (a === "" && b == null) { return true; }
        if (b === "" && a == null) { return true; }

        return a === b;
    }

    defineBuiltinFunction('binary=', false, function () {
        function check(args) {
            var xargs = [], i = 0, err = 'VALUE';
            {
                var $a = args[i++];
                if ($a instanceof CalcError)
                    return $a;
                if (!($a = this.force($a), i <= args.length)) {
                    if ($a instanceof CalcError)
                        return $a;
                    return new CalcError(err);
                }
                xargs.push($a);
            }
            {
                var $b = args[i++];
                if ($b instanceof CalcError)
                    return $b;
                if (!($b = this.force($b), i <= args.length)) {
                    if ($b instanceof CalcError)
                        return $b;
                    return new CalcError(err);
                }
                xargs.push($b);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $a = this._arrayArg(args[i]);
            if ($a) {
                xargs.push($a);
                width = Math.max(width, $a.width);
                height = Math.max(height, $a.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $b = this._arrayArg(args[i]);
            if ($b) {
                xargs.push($b);
                width = Math.max(width, $b.width);
                height = Math.max(height, $b.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (a, b) {
        return equals(a, b);
    });

    defineBuiltinFunction('binary<>', false, function () {
        function check(args) {
            var xargs = [], i = 0, err = 'VALUE';
            {
                var $a = args[i++];
                if ($a instanceof CalcError)
                    return $a;
                if (!($a = this.force($a), i <= args.length)) {
                    if ($a instanceof CalcError)
                        return $a;
                    return new CalcError(err);
                }
                xargs.push($a);
            }
            {
                var $b = args[i++];
                if ($b instanceof CalcError)
                    return $b;
                if (!($b = this.force($b), i <= args.length)) {
                    if ($b instanceof CalcError)
                        return $b;
                    return new CalcError(err);
                }
                xargs.push($b);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $a = this._arrayArg(args[i]);
            if ($a) {
                xargs.push($a);
                width = Math.max(width, $a.width);
                height = Math.max(height, $a.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $b = this._arrayArg(args[i]);
            if ($b) {
                xargs.push($b);
                width = Math.max(width, $b.width);
                height = Math.max(height, $b.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (a, b) {
        return !equals(a, b);
    });

    function binaryCompare(left, right, func) {
        if (typeof left == "string" && typeof right != "string") {
            right = right == null ? "" : right + "";
        }
        if (typeof left != "string" && typeof right == "string") {
            left = left == null ? "" : left + "";
        }
        if (typeof left == "number" && right == null) {
            right = 0;
        }
        if (typeof right == "number" && left == null) {
            left = 0;
        }
        if (typeof left == "string" && typeof right == "string") {
            // string comparison is case insensitive
            left = left.toLowerCase();
            right = right.toLowerCase();
        }
        if (typeof right == typeof left) {
            // for issue https://github.com/telerik/kendo-ui-core/issues/6879, limitPrecision
            // digits got bumped to 16, but it's too much for the case 9.302 - 0.002 (issue
            // https://github.com/telerik/kendo-ui-core/issues/7170).
            left = maybeRoundFloatErrors(left, 15);
            right = maybeRoundFloatErrors(right, 15);
            return func(left, right);
        } else {
            return new CalcError("VALUE");
        }
    }

    defineBuiltinFunction('binary<', false, function () {
        function check(args) {
            var xargs = [], i = 0, err = 'VALUE';
            {
                var $a = args[i++];
                if ($a instanceof CalcError)
                    return $a;
                if (!($a = this.force($a), i <= args.length)) {
                    if ($a instanceof CalcError)
                        return $a;
                    return new CalcError(err);
                }
                xargs.push($a);
            }
            {
                var $b = args[i++];
                if ($b instanceof CalcError)
                    return $b;
                if (!($b = this.force($b), i <= args.length)) {
                    if ($b instanceof CalcError)
                        return $b;
                    return new CalcError(err);
                }
                xargs.push($b);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $a = this._arrayArg(args[i]);
            if ($a) {
                xargs.push($a);
                width = Math.max(width, $a.width);
                height = Math.max(height, $a.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $b = this._arrayArg(args[i]);
            if ($b) {
                xargs.push($b);
                width = Math.max(width, $b.width);
                height = Math.max(height, $b.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (a, b) {
        return binaryCompare(a, b, (a, b) => a < b);
    });

    defineBuiltinFunction('binary<=', false, function () {
        function check(args) {
            var xargs = [], i = 0, err = 'VALUE';
            {
                var $a = args[i++];
                if ($a instanceof CalcError)
                    return $a;
                if (!($a = this.force($a), i <= args.length)) {
                    if ($a instanceof CalcError)
                        return $a;
                    return new CalcError(err);
                }
                xargs.push($a);
            }
            {
                var $b = args[i++];
                if ($b instanceof CalcError)
                    return $b;
                if (!($b = this.force($b), i <= args.length)) {
                    if ($b instanceof CalcError)
                        return $b;
                    return new CalcError(err);
                }
                xargs.push($b);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $a = this._arrayArg(args[i]);
            if ($a) {
                xargs.push($a);
                width = Math.max(width, $a.width);
                height = Math.max(height, $a.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $b = this._arrayArg(args[i]);
            if ($b) {
                xargs.push($b);
                width = Math.max(width, $b.width);
                height = Math.max(height, $b.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (a, b) {
        return binaryCompare(a, b, (a, b) => a <= b);
    });

    defineBuiltinFunction('binary>', false, function () {
        function check(args) {
            var xargs = [], i = 0, err = 'VALUE';
            {
                var $a = args[i++];
                if ($a instanceof CalcError)
                    return $a;
                if (!($a = this.force($a), i <= args.length)) {
                    if ($a instanceof CalcError)
                        return $a;
                    return new CalcError(err);
                }
                xargs.push($a);
            }
            {
                var $b = args[i++];
                if ($b instanceof CalcError)
                    return $b;
                if (!($b = this.force($b), i <= args.length)) {
                    if ($b instanceof CalcError)
                        return $b;
                    return new CalcError(err);
                }
                xargs.push($b);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $a = this._arrayArg(args[i]);
            if ($a) {
                xargs.push($a);
                width = Math.max(width, $a.width);
                height = Math.max(height, $a.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $b = this._arrayArg(args[i]);
            if ($b) {
                xargs.push($b);
                width = Math.max(width, $b.width);
                height = Math.max(height, $b.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (a, b) {
        return binaryCompare(a, b, (a, b) => a > b);
    });

    defineBuiltinFunction('binary>=', false, function () {
        function check(args) {
            var xargs = [], i = 0, err = 'VALUE';
            {
                var $a = args[i++];
                if ($a instanceof CalcError)
                    return $a;
                if (!($a = this.force($a), i <= args.length)) {
                    if ($a instanceof CalcError)
                        return $a;
                    return new CalcError(err);
                }
                xargs.push($a);
            }
            {
                var $b = args[i++];
                if ($b instanceof CalcError)
                    return $b;
                if (!($b = this.force($b), i <= args.length)) {
                    if ($b instanceof CalcError)
                        return $b;
                    return new CalcError(err);
                }
                xargs.push($b);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $a = this._arrayArg(args[i]);
            if ($a) {
                xargs.push($a);
                width = Math.max(width, $a.width);
                height = Math.max(height, $a.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $b = this._arrayArg(args[i]);
            if ($b) {
                xargs.push($b);
                width = Math.max(width, $b.width);
                height = Math.max(height, $b.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (a, b) {
        return binaryCompare(a, b, (a, b) => a >= b);
    });

    defineBuiltinFunction('unary+', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $a = args[i++];
                if ($a instanceof CalcError)
                    return $a;
                if (!((typeof ($a = this.force($a)) == 'number' ? ($a = limitPrecision($a), true) : false) || (typeof $a == 'boolean' ? ($a = +$a, true) : false) || (typeof $a == 'string' && !/^(?:=|true|false)/i.test($a) ? (tmp = calc.parse(0, 0, 0, $a), /^date|number|percent$/.test(tmp.type) ? ($a = +tmp.value, true) : false) : false) || ($a == null ? ($a = 0, true) : false))) {
                    if ($a instanceof CalcError)
                        return $a;
                    return new CalcError(err);
                }
                xargs.push($a);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $a = this._arrayArg(args[i]);
            if ($a) {
                xargs.push($a);
                width = Math.max(width, $a.width);
                height = Math.max(height, $a.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (a) {
        return a;
    });

    defineBuiltinFunction('unary-', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $a = args[i++];
                if ($a instanceof CalcError)
                    return $a;
                if (!((typeof ($a = this.force($a)) == 'number' ? ($a = limitPrecision($a), true) : false) || (typeof $a == 'boolean' ? ($a = +$a, true) : false) || (typeof $a == 'string' && !/^(?:=|true|false)/i.test($a) ? (tmp = calc.parse(0, 0, 0, $a), /^date|number|percent$/.test(tmp.type) ? ($a = +tmp.value, true) : false) : false) || ($a == null ? ($a = 0, true) : false))) {
                    if ($a instanceof CalcError)
                        return $a;
                    return new CalcError(err);
                }
                xargs.push($a);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $a = this._arrayArg(args[i]);
            if ($a) {
                xargs.push($a);
                width = Math.max(width, $a.width);
                height = Math.max(height, $a.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (a) {
        return -a;
    });

    defineBuiltinFunction('unary%', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $a = args[i++];
                if ($a instanceof CalcError)
                    return $a;
                if (!((typeof ($a = this.force($a)) == 'number' ? ($a = limitPrecision($a), true) : false) || (typeof $a == 'boolean' ? ($a = +$a, true) : false) || (typeof $a == 'string' && !/^(?:=|true|false)/i.test($a) ? (tmp = calc.parse(0, 0, 0, $a), /^date|number|percent$/.test(tmp.type) ? ($a = +tmp.value, true) : false) : false) || ($a == null ? ($a = 0, true) : false))) {
                    if ($a instanceof CalcError)
                        return $a;
                    return new CalcError(err);
                }
                xargs.push($a);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $a = this._arrayArg(args[i]);
            if ($a) {
                xargs.push($a);
                width = Math.max(width, $a.width);
                height = Math.max(height, $a.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (a) {
        return a / 100;
    });

    // range operator
    defineBuiltinFunction('binary:', false, function () {
        function check(args) {
            var xargs = [], i = 0, err = 'VALUE';
            {
                var $a = args[i++];
                if ($a instanceof CalcError)
                    return $a;
                if (!($a instanceof CellRef)) {
                    return new CalcError(err);
                }
                xargs.push($a);
            }
            {
                var $b = args[i++];
                if ($b instanceof CalcError)
                    return $b;
                if (!($b instanceof CellRef)) {
                    return new CalcError(err);
                }
                xargs.push($b);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        return { check: check };
    }(), function (a, b) {
        return new RangeRef(a, b).setSheet(a.sheet || this.formula.sheet, a.hasSheet());
    });

    // union operator
    defineBuiltinFunction('binary,', false, function () {
        function check(args) {
            var xargs = [], i = 0, err = 'VALUE';
            {
                var $a = args[i++];
                if ($a instanceof CalcError)
                    return $a;
                if (!($a instanceof Ref)) {
                    return new CalcError(err);
                }
                xargs.push($a);
            }
            {
                var $b = args[i++];
                if ($b instanceof CalcError)
                    return $b;
                if (!($b instanceof Ref)) {
                    return new CalcError(err);
                }
                xargs.push($b);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        return { check: check };
    }(), function (a, b) {
        return new UnionRef([
            a,
            b
        ]);
    });

    // intersection operator
    defineBuiltinFunction('binary ', false, function () {
        function check(args) {
            var xargs = [], i = 0, err = 'VALUE';
            {
                var $a = args[i++];
                if ($a instanceof CalcError)
                    return $a;
                if (!($a instanceof Ref)) {
                    return new CalcError(err);
                }
                xargs.push($a);
            }
            {
                var $b = args[i++];
                if ($b instanceof CalcError)
                    return $b;
                if (!($b instanceof Ref)) {
                    return new CalcError(err);
                }
                xargs.push($b);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        return { check: check };
    }(), function (a, b) {
        return a.intersect(b);
    });

    /* -----[ conditionals ]----- */

    defineBuiltinFunction('not', false, function () {
        function check(args) {
            var xargs = [], i = 0, err = 'VALUE';
            {
                var $a = args[i++];
                if ($a instanceof CalcError)
                    return $a;
                if (!(($a = this.force($a)) != null && i <= args.length || ($a == null ? ($a = 0, true) : false))) {
                    if ($a instanceof CalcError)
                        return $a;
                    return new CalcError(err);
                }
                xargs.push($a);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $a = this._arrayArg(args[i]);
            if ($a) {
                xargs.push($a);
                width = Math.max(width, $a.width);
                height = Math.max(height, $a.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (a) {
        return !this.bool(a);
    });

    /* -----[ the IS* functions ]----- */

    defineBuiltinFunction('isblank', false, function () {
        function check(args) {
            var xargs = [], i = 0, err = 'VALUE';
            {
                var $value = args[i++];
                if (!(i <= args.length)) {
                    return new CalcError(err);
                }
                xargs.push($value);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $value = this._arrayArg(args[i]);
            if ($value) {
                xargs.push($value);
                width = Math.max(width, $value.width);
                height = Math.max(height, $value.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            arrayArgs: arrayArgs
        };
    }(), function (val) {
        if (val instanceof CellRef) {
            val = this.getRefData(val);
            return val == null;
        }
        return false;
    });

    defineBuiltinFunction('iserror', false, function () {
        function check(args) {
            var xargs = [], i = 0, err = 'VALUE';
            {
                var $value = args[i++];
                if (!($value = this.force($value), i <= args.length)) {
                    return new CalcError(err);
                }
                xargs.push($value);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $value = this._arrayArg(args[i]);
            if ($value) {
                xargs.push($value);
                width = Math.max(width, $value.width);
                height = Math.max(height, $value.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (val) {
        return val instanceof CalcError;
    });

    defineBuiltinFunction('iserr', false, function () {
        function check(args) {
            var xargs = [], i = 0, err = 'VALUE';
            {
                var $value = args[i++];
                if (!($value = this.force($value), i <= args.length)) {
                    return new CalcError(err);
                }
                xargs.push($value);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $value = this._arrayArg(args[i]);
            if ($value) {
                xargs.push($value);
                width = Math.max(width, $value.width);
                height = Math.max(height, $value.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (val) {
        return val instanceof CalcError && val.code != 'N/A';
    });

    defineBuiltinFunction('isna', false, function () {
        function check(args) {
            var xargs = [], i = 0, err = 'VALUE';
            {
                var $value = args[i++];
                if (!($value = this.force($value), i <= args.length)) {
                    return new CalcError(err);
                }
                xargs.push($value);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $value = this._arrayArg(args[i]);
            if ($value) {
                xargs.push($value);
                width = Math.max(width, $value.width);
                height = Math.max(height, $value.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (val) {
        return val instanceof CalcError && val.code == 'N/A';
    });

    defineBuiltinFunction('islogical', false, function () {
        function check(args) {
            var xargs = [], i = 0, err = 'VALUE';
            {
                var $value = args[i++];
                if (!($value = this.force($value), i <= args.length)) {
                    return new CalcError(err);
                }
                xargs.push($value);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $value = this._arrayArg(args[i]);
            if ($value) {
                xargs.push($value);
                width = Math.max(width, $value.width);
                height = Math.max(height, $value.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (val) {
        return typeof val == 'boolean';
    });

    defineBuiltinFunction('isnontext', false, function () {
        function check(args) {
            var xargs = [], i = 0, err = 'VALUE';
            {
                var $value = args[i++];
                if (!($value = this.force($value), i <= args.length)) {
                    return new CalcError(err);
                }
                xargs.push($value);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $value = this._arrayArg(args[i]);
            if ($value) {
                xargs.push($value);
                width = Math.max(width, $value.width);
                height = Math.max(height, $value.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (val) {
        return typeof val != 'string';
    });

    defineBuiltinFunction('istext', false, function () {
        function check(args) {
            var xargs = [], i = 0, err = 'VALUE';
            {
                var $value = args[i++];
                if (!($value = this.force($value), i <= args.length)) {
                    return new CalcError(err);
                }
                xargs.push($value);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $value = this._arrayArg(args[i]);
            if ($value) {
                xargs.push($value);
                width = Math.max(width, $value.width);
                height = Math.max(height, $value.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (val) {
        return typeof val == 'string';
    });

    defineBuiltinFunction('isnumber', false, function () {
        function check(args) {
            var xargs = [], i = 0, err = 'VALUE';
            {
                var $value = args[i++];
                if (!($value = this.force($value), i <= args.length)) {
                    return new CalcError(err);
                }
                xargs.push($value);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $value = this._arrayArg(args[i]);
            if ($value) {
                xargs.push($value);
                width = Math.max(width, $value.width);
                height = Math.max(height, $value.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (val) {
        return typeof val == 'number';
    });

    defineBuiltinFunction('isref', false, function () {
        function check(args) {
            var xargs = [], i = 0, err = 'VALUE';
            {
                var $value = args[i++];
                if (!(i <= args.length)) {
                    return new CalcError(err);
                }
                xargs.push($value);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $value = this._arrayArg(args[i]);
            if ($value) {
                xargs.push($value);
                width = Math.max(width, $value.width);
                height = Math.max(height, $value.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            arrayArgs: arrayArgs
        };
    }(), function (val) {
        return val instanceof CellRef || val instanceof RangeRef;
    });

    defineBuiltinFunction('_matrix', false, function () {
        function check(args) {
            var xargs = [], i = 0, m, err = 'VALUE';
            {
                var $m = args[i++];
                if ($m instanceof CalcError)
                    return $m;
                if (!(((m = this.asMatrix($m)) ? $m = m : false) || (typeof $m == 'string' || typeof $m == 'boolean' || typeof $m == 'number' ? ($m += '', true) : $m === undefined ? ($m = '', true) : false))) {
                    if ($m instanceof CalcError)
                        return $m;
                    return new CalcError(err);
                }
                xargs.push($m);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (m) {
        if (typeof m == 'string') {
            m = this.asMatrix([m.split(/\s*,\s*/)]);
        }
        return m;
    });

    /* -----[ resolve NameRef-s ]----- */

    FUNCS[",getname"] = function(callback, args) {
        this.fetchName(args[0], callback);
    };

    // --------------------------------------------runtime-functions.js

    /* -----[ Math functions ]----- */

    defineBuiltinFunction('abs', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $n = args[i++];
                if ($n instanceof CalcError)
                    return $n;
                if (!((typeof ($n = this.force($n)) == 'number' ? ($n = limitPrecision($n), true) : false) || (typeof $n == 'boolean' ? ($n = +$n, true) : false) || (typeof $n == 'string' && !/^(?:=|true|false)/i.test($n) ? (tmp = calc.parse(0, 0, 0, $n), /^date|number|percent$/.test(tmp.type) ? ($n = +tmp.value, true) : false) : false))) {
                    if ($n instanceof CalcError)
                        return $n;
                    return new CalcError(err);
                }
                xargs.push($n);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $n = this._arrayArg(args[i]);
            if ($n) {
                xargs.push($n);
                width = Math.max(width, $n.width);
                height = Math.max(height, $n.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), Math.abs);
    defineBuiltinFunction('cos', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $n = args[i++];
                if ($n instanceof CalcError)
                    return $n;
                if (!((typeof ($n = this.force($n)) == 'number' ? ($n = limitPrecision($n), true) : false) || (typeof $n == 'boolean' ? ($n = +$n, true) : false) || (typeof $n == 'string' && !/^(?:=|true|false)/i.test($n) ? (tmp = calc.parse(0, 0, 0, $n), /^date|number|percent$/.test(tmp.type) ? ($n = +tmp.value, true) : false) : false))) {
                    if ($n instanceof CalcError)
                        return $n;
                    return new CalcError(err);
                }
                xargs.push($n);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $n = this._arrayArg(args[i]);
            if ($n) {
                xargs.push($n);
                width = Math.max(width, $n.width);
                height = Math.max(height, $n.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), Math.cos);
    defineBuiltinFunction('sin', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $n = args[i++];
                if ($n instanceof CalcError)
                    return $n;
                if (!((typeof ($n = this.force($n)) == 'number' ? ($n = limitPrecision($n), true) : false) || (typeof $n == 'boolean' ? ($n = +$n, true) : false) || (typeof $n == 'string' && !/^(?:=|true|false)/i.test($n) ? (tmp = calc.parse(0, 0, 0, $n), /^date|number|percent$/.test(tmp.type) ? ($n = +tmp.value, true) : false) : false))) {
                    if ($n instanceof CalcError)
                        return $n;
                    return new CalcError(err);
                }
                xargs.push($n);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $n = this._arrayArg(args[i]);
            if ($n) {
                xargs.push($n);
                width = Math.max(width, $n.width);
                height = Math.max(height, $n.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), Math.sin);
    defineBuiltinFunction('acos', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $n = args[i++];
                if ($n instanceof CalcError)
                    return $n;
                if (!((typeof ($n = this.force($n)) == 'number' ? ($n = limitPrecision($n), true) : false) || (typeof $n == 'boolean' ? ($n = +$n, true) : false) || (typeof $n == 'string' && !/^(?:=|true|false)/i.test($n) ? (tmp = calc.parse(0, 0, 0, $n), /^date|number|percent$/.test(tmp.type) ? ($n = +tmp.value, true) : false) : false))) {
                    if ($n instanceof CalcError)
                        return $n;
                    return new CalcError(err);
                }
                xargs.push($n);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $n = this._arrayArg(args[i]);
            if ($n) {
                xargs.push($n);
                width = Math.max(width, $n.width);
                height = Math.max(height, $n.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), Math.acos);
    defineBuiltinFunction('asin', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $n = args[i++];
                if ($n instanceof CalcError)
                    return $n;
                if (!((typeof ($n = this.force($n)) == 'number' ? ($n = limitPrecision($n), true) : false) || (typeof $n == 'boolean' ? ($n = +$n, true) : false) || (typeof $n == 'string' && !/^(?:=|true|false)/i.test($n) ? (tmp = calc.parse(0, 0, 0, $n), /^date|number|percent$/.test(tmp.type) ? ($n = +tmp.value, true) : false) : false))) {
                    if ($n instanceof CalcError)
                        return $n;
                    return new CalcError(err);
                }
                xargs.push($n);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $n = this._arrayArg(args[i]);
            if ($n) {
                xargs.push($n);
                width = Math.max(width, $n.width);
                height = Math.max(height, $n.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), Math.asin);
    defineBuiltinFunction('tan', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $n = args[i++];
                if ($n instanceof CalcError)
                    return $n;
                if (!((typeof ($n = this.force($n)) == 'number' ? ($n = limitPrecision($n), true) : false) || (typeof $n == 'boolean' ? ($n = +$n, true) : false) || (typeof $n == 'string' && !/^(?:=|true|false)/i.test($n) ? (tmp = calc.parse(0, 0, 0, $n), /^date|number|percent$/.test(tmp.type) ? ($n = +tmp.value, true) : false) : false))) {
                    if ($n instanceof CalcError)
                        return $n;
                    return new CalcError(err);
                }
                xargs.push($n);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $n = this._arrayArg(args[i]);
            if ($n) {
                xargs.push($n);
                width = Math.max(width, $n.width);
                height = Math.max(height, $n.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), Math.tan);
    defineBuiltinFunction('atan', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $n = args[i++];
                if ($n instanceof CalcError)
                    return $n;
                if (!((typeof ($n = this.force($n)) == 'number' ? ($n = limitPrecision($n), true) : false) || (typeof $n == 'boolean' ? ($n = +$n, true) : false) || (typeof $n == 'string' && !/^(?:=|true|false)/i.test($n) ? (tmp = calc.parse(0, 0, 0, $n), /^date|number|percent$/.test(tmp.type) ? ($n = +tmp.value, true) : false) : false))) {
                    if ($n instanceof CalcError)
                        return $n;
                    return new CalcError(err);
                }
                xargs.push($n);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $n = this._arrayArg(args[i]);
            if ($n) {
                xargs.push($n);
                width = Math.max(width, $n.width);
                height = Math.max(height, $n.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), Math.atan);
    defineBuiltinFunction('exp', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $n = args[i++];
                if ($n instanceof CalcError)
                    return $n;
                if (!((typeof ($n = this.force($n)) == 'number' ? ($n = limitPrecision($n), true) : false) || (typeof $n == 'boolean' ? ($n = +$n, true) : false) || (typeof $n == 'string' && !/^(?:=|true|false)/i.test($n) ? (tmp = calc.parse(0, 0, 0, $n), /^date|number|percent$/.test(tmp.type) ? ($n = +tmp.value, true) : false) : false))) {
                    if ($n instanceof CalcError)
                        return $n;
                    return new CalcError(err);
                }
                xargs.push($n);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $n = this._arrayArg(args[i]);
            if ($n) {
                xargs.push($n);
                width = Math.max(width, $n.width);
                height = Math.max(height, $n.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), Math.exp);
    defineBuiltinFunction('sqrt', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $n = args[i++];
                if ($n instanceof CalcError)
                    return $n;
                if (!((typeof ($n = this.force($n)) == 'number' ? ($n = limitPrecision($n), true) : false) || (typeof $n == 'boolean' ? ($n = +$n, true) : false) || (typeof $n == 'string' && !/^(?:=|true|false)/i.test($n) ? (tmp = calc.parse(0, 0, 0, $n), /^date|number|percent$/.test(tmp.type) ? ($n = +tmp.value, true) : false) : false))) {
                    if ($n instanceof CalcError)
                        return $n;
                    return new CalcError(err);
                }
                xargs.push($n);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $n = this._arrayArg(args[i]);
            if ($n) {
                xargs.push($n);
                width = Math.max(width, $n.width);
                height = Math.max(height, $n.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), Math.sqrt);
    defineBuiltinFunction('ln', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $n = args[i++];
                if ($n instanceof CalcError)
                    return $n;
                if (!((typeof ($n = this.force($n)) == 'number' ? ($n = limitPrecision($n), true) : false) || (typeof $n == 'boolean' ? ($n = +$n, true) : false) || (typeof $n == 'string' && !/^(?:=|true|false)/i.test($n) ? (tmp = calc.parse(0, 0, 0, $n), /^date|number|percent$/.test(tmp.type) ? ($n = +tmp.value, true) : false) : false))) {
                    if ($n instanceof CalcError)
                        return $n;
                    return new CalcError(err);
                }
                xargs.push($n);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $n = this._arrayArg(args[i]);
            if ($n) {
                xargs.push($n);
                width = Math.max(width, $n.width);
                height = Math.max(height, $n.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), Math.log);

    defineBuiltinFunction('log', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $num = args[i++];
                if ($num instanceof CalcError)
                    return $num;
                if (!(((typeof ($num = this.force($num)) == 'number' ? ($num = limitPrecision($num), true) : false) || (typeof $num == 'boolean' ? ($num = +$num, true) : false) || (typeof $num == 'string' && !/^(?:=|true|false)/i.test($num) ? (tmp = calc.parse(0, 0, 0, $num), /^date|number|percent$/.test(tmp.type) ? ($num = +tmp.value, true) : false) : false)) && ($num > 0 ? true : (err = 'NUM', false)))) {
                    if ($num instanceof CalcError)
                        return $num;
                    return new CalcError(err);
                }
                xargs.push($num);
            }
            {
                var $base = args[i++];
                if ($base instanceof CalcError)
                    return $base;
                if (!(((typeof ($base = this.force($base)) == 'number' ? ($base = limitPrecision($base), true) : false) || (typeof $base == 'boolean' ? ($base = +$base, true) : false) || (typeof $base == 'string' && !/^(?:=|true|false)/i.test($base) ? (tmp = calc.parse(0, 0, 0, $base), /^date|number|percent$/.test(tmp.type) ? ($base = +tmp.value, true) : false) : false)) && ($base > 0 ? true : (err = 'NUM', false)) || ($base == null ? ($base = 10, true) : false))) {
                    if ($base instanceof CalcError)
                        return $base;
                    return new CalcError(err);
                }
                xargs.push($base);
            }
            {
                if (!($base != 1 ? true : (err = 'DIV/0', false)))
                    return new CalcError(err);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $num = this._arrayArg(args[i]);
            if ($num) {
                xargs.push($num);
                width = Math.max(width, $num.width);
                height = Math.max(height, $num.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $base = this._arrayArg(args[i]);
            if ($base) {
                xargs.push($base);
                width = Math.max(width, $base.width);
                height = Math.max(height, $base.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (num, base) {
        return Math.log(num) / Math.log(base);
    });

    defineBuiltinFunction('log10', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $num = args[i++];
                if ($num instanceof CalcError)
                    return $num;
                if (!(((typeof ($num = this.force($num)) == 'number' ? ($num = limitPrecision($num), true) : false) || (typeof $num == 'boolean' ? ($num = +$num, true) : false) || (typeof $num == 'string' && !/^(?:=|true|false)/i.test($num) ? (tmp = calc.parse(0, 0, 0, $num), /^date|number|percent$/.test(tmp.type) ? ($num = +tmp.value, true) : false) : false)) && ($num > 0 ? true : (err = 'NUM', false)))) {
                    if ($num instanceof CalcError)
                        return $num;
                    return new CalcError(err);
                }
                xargs.push($num);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $num = this._arrayArg(args[i]);
            if ($num) {
                xargs.push($num);
                width = Math.max(width, $num.width);
                height = Math.max(height, $num.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (num) {
        return Math.log(num) / Math.log(10);
    });

    defineBuiltinFunction('pi', false, function () {
        function check(args) {
            var xargs = [], i = 0;
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        return { check: check };
    }(), function () {
        return Math.PI;
    });

    defineBuiltinFunction('sqrtpi', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $num = args[i++];
                if ($num instanceof CalcError)
                    return $num;
                if (!(((typeof ($num = this.force($num)) == 'number' ? ($num = limitPrecision($num), true) : false) || (typeof $num == 'boolean' ? ($num = +$num, true) : false) || (typeof $num == 'string' && !/^(?:=|true|false)/i.test($num) ? (tmp = calc.parse(0, 0, 0, $num), /^date|number|percent$/.test(tmp.type) ? ($num = +tmp.value, true) : false) : false)) && ($num >= 0 ? true : (err = 'NUM', false)))) {
                    if ($num instanceof CalcError)
                        return $num;
                    return new CalcError(err);
                }
                xargs.push($num);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $num = this._arrayArg(args[i]);
            if ($num) {
                xargs.push($num);
                width = Math.max(width, $num.width);
                height = Math.max(height, $num.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (n) {
        return Math.sqrt(n * Math.PI);
    });

    defineBuiltinFunction('degrees', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $radians = args[i++];
                if ($radians instanceof CalcError)
                    return $radians;
                if (!((typeof ($radians = this.force($radians)) == 'number' ? ($radians = limitPrecision($radians), true) : false) || (typeof $radians == 'boolean' ? ($radians = +$radians, true) : false) || (typeof $radians == 'string' && !/^(?:=|true|false)/i.test($radians) ? (tmp = calc.parse(0, 0, 0, $radians), /^date|number|percent$/.test(tmp.type) ? ($radians = +tmp.value, true) : false) : false))) {
                    if ($radians instanceof CalcError)
                        return $radians;
                    return new CalcError(err);
                }
                xargs.push($radians);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $radians = this._arrayArg(args[i]);
            if ($radians) {
                xargs.push($radians);
                width = Math.max(width, $radians.width);
                height = Math.max(height, $radians.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (rad) {
        return 180 * rad / Math.PI % 360;
    });

    defineBuiltinFunction('radians', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $degrees = args[i++];
                if ($degrees instanceof CalcError)
                    return $degrees;
                if (!((typeof ($degrees = this.force($degrees)) == 'number' ? ($degrees = limitPrecision($degrees), true) : false) || (typeof $degrees == 'boolean' ? ($degrees = +$degrees, true) : false) || (typeof $degrees == 'string' && !/^(?:=|true|false)/i.test($degrees) ? (tmp = calc.parse(0, 0, 0, $degrees), /^date|number|percent$/.test(tmp.type) ? ($degrees = +tmp.value, true) : false) : false))) {
                    if ($degrees instanceof CalcError)
                        return $degrees;
                    return new CalcError(err);
                }
                xargs.push($degrees);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $degrees = this._arrayArg(args[i]);
            if ($degrees) {
                xargs.push($degrees);
                width = Math.max(width, $degrees.width);
                height = Math.max(height, $degrees.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (deg) {
        return Math.PI * deg / 180;
    });

    function _cosh(n){
        return (Math.exp(n) + Math.exp(-n)) / 2;
    }

    defineBuiltinFunction('cosh', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $num = args[i++];
                if ($num instanceof CalcError)
                    return $num;
                if (!((typeof ($num = this.force($num)) == 'number' ? ($num = limitPrecision($num), true) : false) || (typeof $num == 'boolean' ? ($num = +$num, true) : false) || (typeof $num == 'string' && !/^(?:=|true|false)/i.test($num) ? (tmp = calc.parse(0, 0, 0, $num), /^date|number|percent$/.test(tmp.type) ? ($num = +tmp.value, true) : false) : false))) {
                    if ($num instanceof CalcError)
                        return $num;
                    return new CalcError(err);
                }
                xargs.push($num);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $num = this._arrayArg(args[i]);
            if ($num) {
                xargs.push($num);
                width = Math.max(width, $num.width);
                height = Math.max(height, $num.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), _cosh);

    defineBuiltinFunction('acosh', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $num = args[i++];
                if ($num instanceof CalcError)
                    return $num;
                if (!((typeof ($num = this.force($num)) == 'number' ? ($num = limitPrecision($num), true) : false) || (typeof $num == 'boolean' ? ($num = +$num, true) : false) || (typeof $num == 'string' && !/^(?:=|true|false)/i.test($num) ? (tmp = calc.parse(0, 0, 0, $num), /^date|number|percent$/.test(tmp.type) ? ($num = +tmp.value, true) : false) : false))) {
                    if ($num instanceof CalcError)
                        return $num;
                    return new CalcError(err);
                }
                xargs.push($num);
            }
            {
                if (!($num >= 1 ? true : (err = 'N/A', false)))
                    return new CalcError(err);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $num = this._arrayArg(args[i]);
            if ($num) {
                xargs.push($num);
                width = Math.max(width, $num.width);
                height = Math.max(height, $num.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (n) {
        return Math.log(n + Math.sqrt(n - 1) * Math.sqrt(n + 1));
    });

    function _sinh(n){
        return (Math.exp(n) - Math.exp(-n)) / 2;
    }

    defineBuiltinFunction('sinh', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $num = args[i++];
                if ($num instanceof CalcError)
                    return $num;
                if (!((typeof ($num = this.force($num)) == 'number' ? ($num = limitPrecision($num), true) : false) || (typeof $num == 'boolean' ? ($num = +$num, true) : false) || (typeof $num == 'string' && !/^(?:=|true|false)/i.test($num) ? (tmp = calc.parse(0, 0, 0, $num), /^date|number|percent$/.test(tmp.type) ? ($num = +tmp.value, true) : false) : false))) {
                    if ($num instanceof CalcError)
                        return $num;
                    return new CalcError(err);
                }
                xargs.push($num);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $num = this._arrayArg(args[i]);
            if ($num) {
                xargs.push($num);
                width = Math.max(width, $num.width);
                height = Math.max(height, $num.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), _sinh);

    defineBuiltinFunction('asinh', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $num = args[i++];
                if ($num instanceof CalcError)
                    return $num;
                if (!((typeof ($num = this.force($num)) == 'number' ? ($num = limitPrecision($num), true) : false) || (typeof $num == 'boolean' ? ($num = +$num, true) : false) || (typeof $num == 'string' && !/^(?:=|true|false)/i.test($num) ? (tmp = calc.parse(0, 0, 0, $num), /^date|number|percent$/.test(tmp.type) ? ($num = +tmp.value, true) : false) : false))) {
                    if ($num instanceof CalcError)
                        return $num;
                    return new CalcError(err);
                }
                xargs.push($num);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $num = this._arrayArg(args[i]);
            if ($num) {
                xargs.push($num);
                width = Math.max(width, $num.width);
                height = Math.max(height, $num.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (n) {
        return Math.log(n + Math.sqrt(n * n + 1));
    });

    defineBuiltinFunction('sec', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $num = args[i++];
                if ($num instanceof CalcError)
                    return $num;
                if (!((typeof ($num = this.force($num)) == 'number' ? ($num = limitPrecision($num), true) : false) || (typeof $num == 'boolean' ? ($num = +$num, true) : false) || (typeof $num == 'string' && !/^(?:=|true|false)/i.test($num) ? (tmp = calc.parse(0, 0, 0, $num), /^date|number|percent$/.test(tmp.type) ? ($num = +tmp.value, true) : false) : false))) {
                    if ($num instanceof CalcError)
                        return $num;
                    return new CalcError(err);
                }
                xargs.push($num);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $num = this._arrayArg(args[i]);
            if ($num) {
                xargs.push($num);
                width = Math.max(width, $num.width);
                height = Math.max(height, $num.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (n) {
        return 1 / Math.cos(n);
    });

    defineBuiltinFunction('sech', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $num = args[i++];
                if ($num instanceof CalcError)
                    return $num;
                if (!((typeof ($num = this.force($num)) == 'number' ? ($num = limitPrecision($num), true) : false) || (typeof $num == 'boolean' ? ($num = +$num, true) : false) || (typeof $num == 'string' && !/^(?:=|true|false)/i.test($num) ? (tmp = calc.parse(0, 0, 0, $num), /^date|number|percent$/.test(tmp.type) ? ($num = +tmp.value, true) : false) : false))) {
                    if ($num instanceof CalcError)
                        return $num;
                    return new CalcError(err);
                }
                xargs.push($num);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $num = this._arrayArg(args[i]);
            if ($num) {
                xargs.push($num);
                width = Math.max(width, $num.width);
                height = Math.max(height, $num.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (n) {
        return 1 / _cosh(n);
    });

    defineBuiltinFunction('csc', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $num = args[i++];
                if ($num instanceof CalcError)
                    return $num;
                if (!((typeof ($num = this.force($num)) == 'number' ? ($num = limitPrecision($num), true) : false) || (typeof $num == 'boolean' ? ($num = +$num, true) : false) || (typeof $num == 'string' && !/^(?:=|true|false)/i.test($num) ? (tmp = calc.parse(0, 0, 0, $num), /^date|number|percent$/.test(tmp.type) ? ($num = +tmp.value, true) : false) : false))) {
                    if ($num instanceof CalcError)
                        return $num;
                    return new CalcError(err);
                }
                xargs.push($num);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $num = this._arrayArg(args[i]);
            if ($num) {
                xargs.push($num);
                width = Math.max(width, $num.width);
                height = Math.max(height, $num.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (n) {
        return 1 / Math.sin(n);
    });

    defineBuiltinFunction('csch', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $num = args[i++];
                if ($num instanceof CalcError)
                    return $num;
                if (!((typeof ($num = this.force($num)) == 'number' ? ($num = limitPrecision($num), true) : false) || (typeof $num == 'boolean' ? ($num = +$num, true) : false) || (typeof $num == 'string' && !/^(?:=|true|false)/i.test($num) ? (tmp = calc.parse(0, 0, 0, $num), /^date|number|percent$/.test(tmp.type) ? ($num = +tmp.value, true) : false) : false))) {
                    if ($num instanceof CalcError)
                        return $num;
                    return new CalcError(err);
                }
                xargs.push($num);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $num = this._arrayArg(args[i]);
            if ($num) {
                xargs.push($num);
                width = Math.max(width, $num.width);
                height = Math.max(height, $num.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (n) {
        return 1 / _sinh(n);
    });

    defineBuiltinFunction('atan2', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $x = args[i++];
                if ($x instanceof CalcError)
                    return $x;
                if (!(((typeof ($x = this.force($x)) == 'number' ? ($x = limitPrecision($x), true) : false) || (typeof $x == 'boolean' ? ($x = +$x, true) : false) || (typeof $x == 'string' && !/^(?:=|true|false)/i.test($x) ? (tmp = calc.parse(0, 0, 0, $x), /^date|number|percent$/.test(tmp.type) ? ($x = +tmp.value, true) : false) : false)) && ($x == 0 ? (err = 'DIV/0', false) : true))) {
                    if ($x instanceof CalcError)
                        return $x;
                    return new CalcError(err);
                }
                xargs.push($x);
            }
            {
                var $y = args[i++];
                if ($y instanceof CalcError)
                    return $y;
                if (!((typeof ($y = this.force($y)) == 'number' ? ($y = limitPrecision($y), true) : false) || (typeof $y == 'boolean' ? ($y = +$y, true) : false) || (typeof $y == 'string' && !/^(?:=|true|false)/i.test($y) ? (tmp = calc.parse(0, 0, 0, $y), /^date|number|percent$/.test(tmp.type) ? ($y = +tmp.value, true) : false) : false))) {
                    if ($y instanceof CalcError)
                        return $y;
                    return new CalcError(err);
                }
                xargs.push($y);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $x = this._arrayArg(args[i]);
            if ($x) {
                xargs.push($x);
                width = Math.max(width, $x.width);
                height = Math.max(height, $x.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $y = this._arrayArg(args[i]);
            if ($y) {
                xargs.push($y);
                width = Math.max(width, $y.width);
                height = Math.max(height, $y.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (x, y) {
        return Math.atan(y / x);
    });

    function _tanh(n) {
        return _sinh(n) / _cosh(n);
    }

    defineBuiltinFunction('tanh', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $num = args[i++];
                if ($num instanceof CalcError)
                    return $num;
                if (!((typeof ($num = this.force($num)) == 'number' ? ($num = limitPrecision($num), true) : false) || (typeof $num == 'boolean' ? ($num = +$num, true) : false) || (typeof $num == 'string' && !/^(?:=|true|false)/i.test($num) ? (tmp = calc.parse(0, 0, 0, $num), /^date|number|percent$/.test(tmp.type) ? ($num = +tmp.value, true) : false) : false))) {
                    if ($num instanceof CalcError)
                        return $num;
                    return new CalcError(err);
                }
                xargs.push($num);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $num = this._arrayArg(args[i]);
            if ($num) {
                xargs.push($num);
                width = Math.max(width, $num.width);
                height = Math.max(height, $num.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), _tanh);

    defineBuiltinFunction('atanh', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $num = args[i++];
                if ($num instanceof CalcError)
                    return $num;
                if (!(((typeof ($num = this.force($num)) == 'number' ? ($num = limitPrecision($num), true) : false) || (typeof $num == 'boolean' ? ($num = +$num, true) : false) || (typeof $num == 'string' && !/^(?:=|true|false)/i.test($num) ? (tmp = calc.parse(0, 0, 0, $num), /^date|number|percent$/.test(tmp.type) ? ($num = +tmp.value, true) : false) : false)) && ($num > -1 && $num < 1 ? true : (err = 'NUM', false)))) {
                    if ($num instanceof CalcError)
                        return $num;
                    return new CalcError(err);
                }
                xargs.push($num);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $num = this._arrayArg(args[i]);
            if ($num) {
                xargs.push($num);
                width = Math.max(width, $num.width);
                height = Math.max(height, $num.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (n) {
        return Math.log(Math.sqrt(1 - n * n) / (1 - n));
    });

    defineBuiltinFunction('cot', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $num = args[i++];
                if ($num instanceof CalcError)
                    return $num;
                if (!(((typeof ($num = this.force($num)) == 'number' ? ($num = limitPrecision($num), true) : false) || (typeof $num == 'boolean' ? ($num = +$num, true) : false) || (typeof $num == 'string' && !/^(?:=|true|false)/i.test($num) ? (tmp = calc.parse(0, 0, 0, $num), /^date|number|percent$/.test(tmp.type) ? ($num = +tmp.value, true) : false) : false)) && ($num == 0 ? (err = 'DIV/0', false) : true))) {
                    if ($num instanceof CalcError)
                        return $num;
                    return new CalcError(err);
                }
                xargs.push($num);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $num = this._arrayArg(args[i]);
            if ($num) {
                xargs.push($num);
                width = Math.max(width, $num.width);
                height = Math.max(height, $num.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (n) {
        return 1 / Math.tan(n);
    });

    defineBuiltinFunction('coth', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $num = args[i++];
                if ($num instanceof CalcError)
                    return $num;
                if (!(((typeof ($num = this.force($num)) == 'number' ? ($num = limitPrecision($num), true) : false) || (typeof $num == 'boolean' ? ($num = +$num, true) : false) || (typeof $num == 'string' && !/^(?:=|true|false)/i.test($num) ? (tmp = calc.parse(0, 0, 0, $num), /^date|number|percent$/.test(tmp.type) ? ($num = +tmp.value, true) : false) : false)) && ($num == 0 ? (err = 'DIV/0', false) : true))) {
                    if ($num instanceof CalcError)
                        return $num;
                    return new CalcError(err);
                }
                xargs.push($num);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $num = this._arrayArg(args[i]);
            if ($num) {
                xargs.push($num);
                width = Math.max(width, $num.width);
                height = Math.max(height, $num.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (n) {
        return 1 / _tanh(n);
    });

    defineBuiltinFunction('acot', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $num = args[i++];
                if ($num instanceof CalcError)
                    return $num;
                if (!((typeof ($num = this.force($num)) == 'number' ? ($num = limitPrecision($num), true) : false) || (typeof $num == 'boolean' ? ($num = +$num, true) : false) || (typeof $num == 'string' && !/^(?:=|true|false)/i.test($num) ? (tmp = calc.parse(0, 0, 0, $num), /^date|number|percent$/.test(tmp.type) ? ($num = +tmp.value, true) : false) : false))) {
                    if ($num instanceof CalcError)
                        return $num;
                    return new CalcError(err);
                }
                xargs.push($num);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $num = this._arrayArg(args[i]);
            if ($num) {
                xargs.push($num);
                width = Math.max(width, $num.width);
                height = Math.max(height, $num.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (n) {
        return Math.PI / 2 - Math.atan(n);
    });

    defineBuiltinFunction('acoth', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $num = args[i++];
                if ($num instanceof CalcError)
                    return $num;
                if (!((typeof ($num = this.force($num)) == 'number' ? ($num = limitPrecision($num), true) : false) || (typeof $num == 'boolean' ? ($num = +$num, true) : false) || (typeof $num == 'string' && !/^(?:=|true|false)/i.test($num) ? (tmp = calc.parse(0, 0, 0, $num), /^date|number|percent$/.test(tmp.type) ? ($num = +tmp.value, true) : false) : false))) {
                    if ($num instanceof CalcError)
                        return $num;
                    return new CalcError(err);
                }
                xargs.push($num);
            }
            {
                if (!(($num < -1 ? true : (err = 'N/A', false)) || ($num > 1 ? true : (err = 'N/A', false))))
                    return new CalcError(err);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $num = this._arrayArg(args[i]);
            if ($num) {
                xargs.push($num);
                width = Math.max(width, $num.width);
                height = Math.max(height, $num.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (n) {
        return Math.log((n + 1) / (n - 1)) / 2;
    });

    defineBuiltinFunction('power', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $a = args[i++];
                if ($a instanceof CalcError)
                    return $a;
                if (!((typeof ($a = this.force($a)) == 'number' ? ($a = limitPrecision($a), true) : false) || (typeof $a == 'boolean' ? ($a = +$a, true) : false) || (typeof $a == 'string' && !/^(?:=|true|false)/i.test($a) ? (tmp = calc.parse(0, 0, 0, $a), /^date|number|percent$/.test(tmp.type) ? ($a = +tmp.value, true) : false) : false))) {
                    if ($a instanceof CalcError)
                        return $a;
                    return new CalcError(err);
                }
                xargs.push($a);
            }
            {
                var $b = args[i++];
                if ($b instanceof CalcError)
                    return $b;
                if (!((typeof ($b = this.force($b)) == 'number' ? ($b = limitPrecision($b), true) : false) || (typeof $b == 'boolean' ? ($b = +$b, true) : false) || (typeof $b == 'string' && !/^(?:=|true|false)/i.test($b) ? (tmp = calc.parse(0, 0, 0, $b), /^date|number|percent$/.test(tmp.type) ? ($b = +tmp.value, true) : false) : false))) {
                    if ($b instanceof CalcError)
                        return $b;
                    return new CalcError(err);
                }
                xargs.push($b);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $a = this._arrayArg(args[i]);
            if ($a) {
                xargs.push($a);
                width = Math.max(width, $a.width);
                height = Math.max(height, $a.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $b = this._arrayArg(args[i]);
            if ($b) {
                xargs.push($b);
                width = Math.max(width, $b.width);
                height = Math.max(height, $b.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (a, b) {
        return Math.pow(a, b);
    });

    defineBuiltinFunction('mod', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $a = args[i++];
                if ($a instanceof CalcError)
                    return $a;
                if (!((typeof ($a = this.force($a)) == 'number' ? ($a = limitPrecision($a), true) : false) || (typeof $a == 'boolean' ? ($a = +$a, true) : false) || (typeof $a == 'string' && !/^(?:=|true|false)/i.test($a) ? (tmp = calc.parse(0, 0, 0, $a), /^date|number|percent$/.test(tmp.type) ? ($a = +tmp.value, true) : false) : false))) {
                    if ($a instanceof CalcError)
                        return $a;
                    return new CalcError(err);
                }
                xargs.push($a);
            }
            {
                var $b = args[i++];
                if ($b instanceof CalcError)
                    return $b;
                if (!(((typeof ($b = this.force($b)) == 'number' ? ($b = limitPrecision($b), true) : false) || (typeof $b == 'boolean' ? ($b = +$b, true) : false) || (typeof $b == 'string' && !/^(?:=|true|false)/i.test($b) ? (tmp = calc.parse(0, 0, 0, $b), /^date|number|percent$/.test(tmp.type) ? ($b = +tmp.value, true) : false) : false)) && ($b == 0 ? (err = 'DIV/0', false) : true))) {
                    if ($b instanceof CalcError)
                        return $b;
                    return new CalcError(err);
                }
                xargs.push($b);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $a = this._arrayArg(args[i]);
            if ($a) {
                xargs.push($a);
                width = Math.max(width, $a.width);
                height = Math.max(height, $a.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $b = this._arrayArg(args[i]);
            if ($b) {
                xargs.push($b);
                width = Math.max(width, $b.width);
                height = Math.max(height, $b.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (a, b) {
        return a % b;
    });

    defineBuiltinFunction('quotient', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $a = args[i++];
                if ($a instanceof CalcError)
                    return $a;
                if (!((typeof ($a = this.force($a)) == 'number' ? ($a = limitPrecision($a), true) : false) || (typeof $a == 'boolean' ? ($a = +$a, true) : false) || (typeof $a == 'string' && !/^(?:=|true|false)/i.test($a) ? (tmp = calc.parse(0, 0, 0, $a), /^date|number|percent$/.test(tmp.type) ? ($a = +tmp.value, true) : false) : false))) {
                    if ($a instanceof CalcError)
                        return $a;
                    return new CalcError(err);
                }
                xargs.push($a);
            }
            {
                var $b = args[i++];
                if ($b instanceof CalcError)
                    return $b;
                if (!(((typeof ($b = this.force($b)) == 'number' ? ($b = limitPrecision($b), true) : false) || (typeof $b == 'boolean' ? ($b = +$b, true) : false) || (typeof $b == 'string' && !/^(?:=|true|false)/i.test($b) ? (tmp = calc.parse(0, 0, 0, $b), /^date|number|percent$/.test(tmp.type) ? ($b = +tmp.value, true) : false) : false)) && ($b == 0 ? (err = 'DIV/0', false) : true))) {
                    if ($b instanceof CalcError)
                        return $b;
                    return new CalcError(err);
                }
                xargs.push($b);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $a = this._arrayArg(args[i]);
            if ($a) {
                xargs.push($a);
                width = Math.max(width, $a.width);
                height = Math.max(height, $a.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $b = this._arrayArg(args[i]);
            if ($b) {
                xargs.push($b);
                width = Math.max(width, $b.width);
                height = Math.max(height, $b.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (a, b) {
        return Math.floor(a / b);
    });

    defineBuiltinFunction('ceiling', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $number = args[i++];
                if ($number instanceof CalcError)
                    return $number;
                if (!((typeof ($number = this.force($number)) == 'number' ? ($number = limitPrecision($number), true) : false) || (typeof $number == 'boolean' ? ($number = +$number, true) : false) || (typeof $number == 'string' && !/^(?:=|true|false)/i.test($number) ? (tmp = calc.parse(0, 0, 0, $number), /^date|number|percent$/.test(tmp.type) ? ($number = +tmp.value, true) : false) : false))) {
                    if ($number instanceof CalcError)
                        return $number;
                    return new CalcError(err);
                }
                xargs.push($number);
            }
            {
                var $significance = args[i++];
                if ($significance instanceof CalcError)
                    return $significance;
                if (!((typeof ($significance = this.force($significance)) == 'number' ? ($significance = limitPrecision($significance), true) : false) || (typeof $significance == 'boolean' ? ($significance = +$significance, true) : false) || (typeof $significance == 'string' && !/^(?:=|true|false)/i.test($significance) ? (tmp = calc.parse(0, 0, 0, $significance), /^date|number|percent$/.test(tmp.type) ? ($significance = +tmp.value, true) : false) : false))) {
                    if ($significance instanceof CalcError)
                        return $significance;
                    return new CalcError(err);
                }
                xargs.push($significance);
            }
            {
                if (!($significance >= 0 || $number < 0 ? true : (err = 'N/A', false)))
                    return new CalcError(err);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $number = this._arrayArg(args[i]);
            if ($number) {
                xargs.push($number);
                width = Math.max(width, $number.width);
                height = Math.max(height, $number.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $significance = this._arrayArg(args[i]);
            if ($significance) {
                xargs.push($significance);
                width = Math.max(width, $significance.width);
                height = Math.max(height, $significance.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (num, s) {
        return s ? s * Math.ceil(num / s) : 0;
    });

    defineBuiltinFunction('ceiling.precise', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $number = args[i++];
                if ($number instanceof CalcError)
                    return $number;
                if (!((typeof ($number = this.force($number)) == 'number' ? ($number = limitPrecision($number), true) : false) || (typeof $number == 'boolean' ? ($number = +$number, true) : false) || (typeof $number == 'string' && !/^(?:=|true|false)/i.test($number) ? (tmp = calc.parse(0, 0, 0, $number), /^date|number|percent$/.test(tmp.type) ? ($number = +tmp.value, true) : false) : false))) {
                    if ($number instanceof CalcError)
                        return $number;
                    return new CalcError(err);
                }
                xargs.push($number);
            }
            {
                var $significance = args[i++];
                if ($significance instanceof CalcError)
                    return $significance;
                if (!((typeof ($significance = this.force($significance)) == 'number' ? ($significance = limitPrecision($significance), true) : false) || (typeof $significance == 'boolean' ? ($significance = +$significance, true) : false) || (typeof $significance == 'string' && !/^(?:=|true|false)/i.test($significance) ? (tmp = calc.parse(0, 0, 0, $significance), /^date|number|percent$/.test(tmp.type) ? ($significance = +tmp.value, true) : false) : false) || ($significance == null ? ($significance = 1, true) : false))) {
                    if ($significance instanceof CalcError)
                        return $significance;
                    return new CalcError(err);
                }
                xargs.push($significance);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $number = this._arrayArg(args[i]);
            if ($number) {
                xargs.push($number);
                width = Math.max(width, $number.width);
                height = Math.max(height, $number.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $significance = this._arrayArg(args[i]);
            if ($significance) {
                xargs.push($significance);
                width = Math.max(width, $significance.width);
                height = Math.max(height, $significance.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (num, s) {
        s = Math.abs(s);
        return s ? s * Math.ceil(num / s) : 0;
    });

    calc.runtime.defineAlias("iso.ceiling", "ceiling.precise");

    // XXX: how do we know if this function is correct?
    //
    // https://support.office.com/en-gb/article/CEILING-MATH-function-80f95d2f-b499-4eee-9f16-f795a8e306c8
    //
    // “There are many combinations of Significance and Mode values that affect rounding of negative
    // numbers in different ways.” — right, thanks for the info. :-\
    defineBuiltinFunction('ceiling.math', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $number = args[i++];
                if ($number instanceof CalcError)
                    return $number;
                if (!((typeof ($number = this.force($number)) == 'number' ? ($number = limitPrecision($number), true) : false) || (typeof $number == 'boolean' ? ($number = +$number, true) : false) || (typeof $number == 'string' && !/^(?:=|true|false)/i.test($number) ? (tmp = calc.parse(0, 0, 0, $number), /^date|number|percent$/.test(tmp.type) ? ($number = +tmp.value, true) : false) : false))) {
                    if ($number instanceof CalcError)
                        return $number;
                    return new CalcError(err);
                }
                xargs.push($number);
            }
            {
                var $significance = args[i++];
                if ($significance instanceof CalcError)
                    return $significance;
                if (!((typeof ($significance = this.force($significance)) == 'number' ? ($significance = limitPrecision($significance), true) : false) || (typeof $significance == 'boolean' ? ($significance = +$significance, true) : false) || (typeof $significance == 'string' && !/^(?:=|true|false)/i.test($significance) ? (tmp = calc.parse(0, 0, 0, $significance), /^date|number|percent$/.test(tmp.type) ? ($significance = +tmp.value, true) : false) : false) || ($significance == null ? ($significance = $number < 0 ? -1 : 1, true) : false))) {
                    if ($significance instanceof CalcError)
                        return $significance;
                    return new CalcError(err);
                }
                xargs.push($significance);
            }
            {
                var $mode = args[i++];
                if ($mode instanceof CalcError)
                    return $mode;
                if (!(typeof ($mode = this.force($mode)) == 'boolean' || (typeof $mode == 'number' ? ($mode = !!$mode, true) : false) || ($mode == null ? ($mode = 0, true) : false))) {
                    if ($mode instanceof CalcError)
                        return $mode;
                    return new CalcError(err);
                }
                xargs.push($mode);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $number = this._arrayArg(args[i]);
            if ($number) {
                xargs.push($number);
                width = Math.max(width, $number.width);
                height = Math.max(height, $number.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $significance = this._arrayArg(args[i]);
            if ($significance) {
                xargs.push($significance);
                width = Math.max(width, $significance.width);
                height = Math.max(height, $significance.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $mode = this._arrayArg(args[i]);
            if ($mode) {
                xargs.push($mode);
                width = Math.max(width, $mode.width);
                height = Math.max(height, $mode.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (num, s, mode) {
        if (!s || !num) {
            return 0;
        }
        if (num < 0 && (!mode && s < 0 || mode && s > 0)) {
            s = -s;
        }
        return s ? s * Math.ceil(num / s) : 0;
    });

    defineBuiltinFunction('floor', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $number = args[i++];
                if ($number instanceof CalcError)
                    return $number;
                if (!((typeof ($number = this.force($number)) == 'number' ? ($number = limitPrecision($number), true) : false) || (typeof $number == 'boolean' ? ($number = +$number, true) : false) || (typeof $number == 'string' && !/^(?:=|true|false)/i.test($number) ? (tmp = calc.parse(0, 0, 0, $number), /^date|number|percent$/.test(tmp.type) ? ($number = +tmp.value, true) : false) : false))) {
                    if ($number instanceof CalcError)
                        return $number;
                    return new CalcError(err);
                }
                xargs.push($number);
            }
            {
                var $significance = args[i++];
                if ($significance instanceof CalcError)
                    return $significance;
                if (!((typeof ($significance = this.force($significance)) == 'number' ? ($significance = limitPrecision($significance), true) : false) || (typeof $significance == 'boolean' ? ($significance = +$significance, true) : false) || (typeof $significance == 'string' && !/^(?:=|true|false)/i.test($significance) ? (tmp = calc.parse(0, 0, 0, $significance), /^date|number|percent$/.test(tmp.type) ? ($significance = +tmp.value, true) : false) : false))) {
                    if ($significance instanceof CalcError)
                        return $significance;
                    return new CalcError(err);
                }
                xargs.push($significance);
            }
            {
                if (!($significance >= 0 || $number < 0 ? true : (err = 'N/A', false)))
                    return new CalcError(err);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $number = this._arrayArg(args[i]);
            if ($number) {
                xargs.push($number);
                width = Math.max(width, $number.width);
                height = Math.max(height, $number.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $significance = this._arrayArg(args[i]);
            if ($significance) {
                xargs.push($significance);
                width = Math.max(width, $significance.width);
                height = Math.max(height, $significance.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (num, s) {
        return s ? s * Math.floor(num / s) : 0;
    });

    defineBuiltinFunction('floor.precise', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $number = args[i++];
                if ($number instanceof CalcError)
                    return $number;
                if (!((typeof ($number = this.force($number)) == 'number' ? ($number = limitPrecision($number), true) : false) || (typeof $number == 'boolean' ? ($number = +$number, true) : false) || (typeof $number == 'string' && !/^(?:=|true|false)/i.test($number) ? (tmp = calc.parse(0, 0, 0, $number), /^date|number|percent$/.test(tmp.type) ? ($number = +tmp.value, true) : false) : false))) {
                    if ($number instanceof CalcError)
                        return $number;
                    return new CalcError(err);
                }
                xargs.push($number);
            }
            {
                var $significance = args[i++];
                if ($significance instanceof CalcError)
                    return $significance;
                if (!((typeof ($significance = this.force($significance)) == 'number' ? ($significance = limitPrecision($significance), true) : false) || (typeof $significance == 'boolean' ? ($significance = +$significance, true) : false) || (typeof $significance == 'string' && !/^(?:=|true|false)/i.test($significance) ? (tmp = calc.parse(0, 0, 0, $significance), /^date|number|percent$/.test(tmp.type) ? ($significance = +tmp.value, true) : false) : false) || ($significance == null ? ($significance = 1, true) : false))) {
                    if ($significance instanceof CalcError)
                        return $significance;
                    return new CalcError(err);
                }
                xargs.push($significance);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $number = this._arrayArg(args[i]);
            if ($number) {
                xargs.push($number);
                width = Math.max(width, $number.width);
                height = Math.max(height, $number.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $significance = this._arrayArg(args[i]);
            if ($significance) {
                xargs.push($significance);
                width = Math.max(width, $significance.width);
                height = Math.max(height, $significance.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (num, s) {
        s = Math.abs(s);
        return s ? s * Math.floor(num / s) : 0;
    });

    // XXX: check this
    defineBuiltinFunction('floor.math', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $number = args[i++];
                if ($number instanceof CalcError)
                    return $number;
                if (!((typeof ($number = this.force($number)) == 'number' ? ($number = limitPrecision($number), true) : false) || (typeof $number == 'boolean' ? ($number = +$number, true) : false) || (typeof $number == 'string' && !/^(?:=|true|false)/i.test($number) ? (tmp = calc.parse(0, 0, 0, $number), /^date|number|percent$/.test(tmp.type) ? ($number = +tmp.value, true) : false) : false))) {
                    if ($number instanceof CalcError)
                        return $number;
                    return new CalcError(err);
                }
                xargs.push($number);
            }
            {
                var $significance = args[i++];
                if ($significance instanceof CalcError)
                    return $significance;
                if (!((typeof ($significance = this.force($significance)) == 'number' ? ($significance = limitPrecision($significance), true) : false) || (typeof $significance == 'boolean' ? ($significance = +$significance, true) : false) || (typeof $significance == 'string' && !/^(?:=|true|false)/i.test($significance) ? (tmp = calc.parse(0, 0, 0, $significance), /^date|number|percent$/.test(tmp.type) ? ($significance = +tmp.value, true) : false) : false) || ($significance == null ? ($significance = $number < 0 ? -1 : 1, true) : false))) {
                    if ($significance instanceof CalcError)
                        return $significance;
                    return new CalcError(err);
                }
                xargs.push($significance);
            }
            {
                var $mode = args[i++];
                if ($mode instanceof CalcError)
                    return $mode;
                if (!(typeof ($mode = this.force($mode)) == 'boolean' || (typeof $mode == 'number' ? ($mode = !!$mode, true) : false) || ($mode == null ? ($mode = 0, true) : false))) {
                    if ($mode instanceof CalcError)
                        return $mode;
                    return new CalcError(err);
                }
                xargs.push($mode);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $number = this._arrayArg(args[i]);
            if ($number) {
                xargs.push($number);
                width = Math.max(width, $number.width);
                height = Math.max(height, $number.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $significance = this._arrayArg(args[i]);
            if ($significance) {
                xargs.push($significance);
                width = Math.max(width, $significance.width);
                height = Math.max(height, $significance.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $mode = this._arrayArg(args[i]);
            if ($mode) {
                xargs.push($mode);
                width = Math.max(width, $mode.width);
                height = Math.max(height, $mode.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (num, s, mode) {
        if (!s || !num) {
            return 0;
        }
        if (num < 0 && (!mode && s < 0 || mode && s > 0)) {
            s = -s;
        }
        return s ? s * Math.floor(num / s) : 0;
    });

    defineBuiltinFunction('int', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $number = args[i++];
                if ($number instanceof CalcError)
                    return $number;
                if (!((typeof ($number = this.force($number)) == 'number' ? ($number = limitPrecision($number), true) : false) || (typeof $number == 'boolean' ? ($number = +$number, true) : false) || (typeof $number == 'string' && !/^(?:=|true|false)/i.test($number) ? (tmp = calc.parse(0, 0, 0, $number), /^date|number|percent$/.test(tmp.type) ? ($number = +tmp.value, true) : false) : false))) {
                    if ($number instanceof CalcError)
                        return $number;
                    return new CalcError(err);
                }
                xargs.push($number);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $number = this._arrayArg(args[i]);
            if ($number) {
                xargs.push($number);
                width = Math.max(width, $number.width);
                height = Math.max(height, $number.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), Math.floor);

    defineBuiltinFunction('mround', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $number = args[i++];
                if ($number instanceof CalcError)
                    return $number;
                if (!((typeof ($number = this.force($number)) == 'number' ? ($number = limitPrecision($number), true) : false) || (typeof $number == 'boolean' ? ($number = +$number, true) : false) || (typeof $number == 'string' && !/^(?:=|true|false)/i.test($number) ? (tmp = calc.parse(0, 0, 0, $number), /^date|number|percent$/.test(tmp.type) ? ($number = +tmp.value, true) : false) : false))) {
                    if ($number instanceof CalcError)
                        return $number;
                    return new CalcError(err);
                }
                xargs.push($number);
            }
            {
                var $multiple = args[i++];
                if ($multiple instanceof CalcError)
                    return $multiple;
                if (!((typeof ($multiple = this.force($multiple)) == 'number' ? ($multiple = limitPrecision($multiple), true) : false) || (typeof $multiple == 'boolean' ? ($multiple = +$multiple, true) : false) || (typeof $multiple == 'string' && !/^(?:=|true|false)/i.test($multiple) ? (tmp = calc.parse(0, 0, 0, $multiple), /^date|number|percent$/.test(tmp.type) ? ($multiple = +tmp.value, true) : false) : false))) {
                    if ($multiple instanceof CalcError)
                        return $multiple;
                    return new CalcError(err);
                }
                xargs.push($multiple);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $number = this._arrayArg(args[i]);
            if ($number) {
                xargs.push($number);
                width = Math.max(width, $number.width);
                height = Math.max(height, $number.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $multiple = this._arrayArg(args[i]);
            if ($multiple) {
                xargs.push($multiple);
                width = Math.max(width, $multiple.width);
                height = Math.max(height, $multiple.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (num, mult) {
        return mult ? mult * Math.round(num / mult) : 0;
    });

    defineBuiltinFunction('round', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $number = args[i++];
                if ($number instanceof CalcError)
                    return $number;
                if (!((typeof ($number = this.force($number)) == 'number' ? ($number = limitPrecision($number), true) : false) || (typeof $number == 'boolean' ? ($number = +$number, true) : false) || (typeof $number == 'string' && !/^(?:=|true|false)/i.test($number) ? (tmp = calc.parse(0, 0, 0, $number), /^date|number|percent$/.test(tmp.type) ? ($number = +tmp.value, true) : false) : false))) {
                    if ($number instanceof CalcError)
                        return $number;
                    return new CalcError(err);
                }
                xargs.push($number);
            }
            {
                var $digits = args[i++];
                if ($digits instanceof CalcError)
                    return $digits;
                if (!((typeof ($digits = this.force($digits)) == 'number' ? ($digits = limitPrecision($digits), true) : false) || (typeof $digits == 'boolean' ? ($digits = +$digits, true) : false) || (typeof $digits == 'string' && !/^(?:=|true|false)/i.test($digits) ? (tmp = calc.parse(0, 0, 0, $digits), /^date|number|percent$/.test(tmp.type) ? ($digits = +tmp.value, true) : false) : false))) {
                    if ($digits instanceof CalcError)
                        return $digits;
                    return new CalcError(err);
                }
                xargs.push($digits);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $number = this._arrayArg(args[i]);
            if ($number) {
                xargs.push($number);
                width = Math.max(width, $number.width);
                height = Math.max(height, $number.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $digits = this._arrayArg(args[i]);
            if ($digits) {
                xargs.push($digits);
                width = Math.max(width, $digits.width);
                height = Math.max(height, $digits.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (num, digits) {
        var sign = num < 0 ? -1 : 1;
        if (sign < 0) {
            num = -num;
        }
        digits = Math.pow(10, digits);
        num = limitPrecision(num * digits);
        num = Math.round(num);
        return sign * num / digits;
    });

    defineBuiltinFunction('roundup', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $number = args[i++];
                if ($number instanceof CalcError)
                    return $number;
                if (!((typeof ($number = this.force($number)) == 'number' ? ($number = limitPrecision($number), true) : false) || (typeof $number == 'boolean' ? ($number = +$number, true) : false) || (typeof $number == 'string' && !/^(?:=|true|false)/i.test($number) ? (tmp = calc.parse(0, 0, 0, $number), /^date|number|percent$/.test(tmp.type) ? ($number = +tmp.value, true) : false) : false))) {
                    if ($number instanceof CalcError)
                        return $number;
                    return new CalcError(err);
                }
                xargs.push($number);
            }
            {
                var $digits = args[i++];
                if ($digits instanceof CalcError)
                    return $digits;
                if (!((typeof ($digits = this.force($digits)) == 'number' ? ($digits = limitPrecision($digits), true) : false) || (typeof $digits == 'boolean' ? ($digits = +$digits, true) : false) || (typeof $digits == 'string' && !/^(?:=|true|false)/i.test($digits) ? (tmp = calc.parse(0, 0, 0, $digits), /^date|number|percent$/.test(tmp.type) ? ($digits = +tmp.value, true) : false) : false))) {
                    if ($digits instanceof CalcError)
                        return $digits;
                    return new CalcError(err);
                }
                xargs.push($digits);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $number = this._arrayArg(args[i]);
            if ($number) {
                xargs.push($number);
                width = Math.max(width, $number.width);
                height = Math.max(height, $number.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $digits = this._arrayArg(args[i]);
            if ($digits) {
                xargs.push($digits);
                width = Math.max(width, $digits.width);
                height = Math.max(height, $digits.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (num, digits) {
        digits = Math.pow(10, digits);
        num = limitPrecision(num * digits);
        num = num < 0 ? Math.floor(num) : Math.ceil(num);
        return num / digits;
    });

    defineBuiltinFunction('rounddown', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $number = args[i++];
                if ($number instanceof CalcError)
                    return $number;
                if (!((typeof ($number = this.force($number)) == 'number' ? ($number = limitPrecision($number), true) : false) || (typeof $number == 'boolean' ? ($number = +$number, true) : false) || (typeof $number == 'string' && !/^(?:=|true|false)/i.test($number) ? (tmp = calc.parse(0, 0, 0, $number), /^date|number|percent$/.test(tmp.type) ? ($number = +tmp.value, true) : false) : false))) {
                    if ($number instanceof CalcError)
                        return $number;
                    return new CalcError(err);
                }
                xargs.push($number);
            }
            {
                var $digits = args[i++];
                if ($digits instanceof CalcError)
                    return $digits;
                if (!((typeof ($digits = this.force($digits)) == 'number' ? ($digits = limitPrecision($digits), true) : false) || (typeof $digits == 'boolean' ? ($digits = +$digits, true) : false) || (typeof $digits == 'string' && !/^(?:=|true|false)/i.test($digits) ? (tmp = calc.parse(0, 0, 0, $digits), /^date|number|percent$/.test(tmp.type) ? ($digits = +tmp.value, true) : false) : false))) {
                    if ($digits instanceof CalcError)
                        return $digits;
                    return new CalcError(err);
                }
                xargs.push($digits);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $number = this._arrayArg(args[i]);
            if ($number) {
                xargs.push($number);
                width = Math.max(width, $number.width);
                height = Math.max(height, $number.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $digits = this._arrayArg(args[i]);
            if ($digits) {
                xargs.push($digits);
                width = Math.max(width, $digits.width);
                height = Math.max(height, $digits.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (num, digits) {
        digits = Math.pow(10, digits);
        num = limitPrecision(num * digits);
        num = num < 0 ? Math.ceil(num) : Math.floor(num);
        return num / digits;
    });

    defineBuiltinFunction('even', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $number = args[i++];
                if ($number instanceof CalcError)
                    return $number;
                if (!((typeof ($number = this.force($number)) == 'number' ? ($number = limitPrecision($number), true) : false) || (typeof $number == 'boolean' ? ($number = +$number, true) : false) || (typeof $number == 'string' && !/^(?:=|true|false)/i.test($number) ? (tmp = calc.parse(0, 0, 0, $number), /^date|number|percent$/.test(tmp.type) ? ($number = +tmp.value, true) : false) : false))) {
                    if ($number instanceof CalcError)
                        return $number;
                    return new CalcError(err);
                }
                xargs.push($number);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $number = this._arrayArg(args[i]);
            if ($number) {
                xargs.push($number);
                width = Math.max(width, $number.width);
                height = Math.max(height, $number.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (num) {
        var n = num < 0 ? Math.floor(num) : Math.ceil(num);
        return n % 2 ? n + (n < 0 ? -1 : 1) : n;
    });

    defineBuiltinFunction('odd', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $number = args[i++];
                if ($number instanceof CalcError)
                    return $number;
                if (!((typeof ($number = this.force($number)) == 'number' ? ($number = limitPrecision($number), true) : false) || (typeof $number == 'boolean' ? ($number = +$number, true) : false) || (typeof $number == 'string' && !/^(?:=|true|false)/i.test($number) ? (tmp = calc.parse(0, 0, 0, $number), /^date|number|percent$/.test(tmp.type) ? ($number = +tmp.value, true) : false) : false))) {
                    if ($number instanceof CalcError)
                        return $number;
                    return new CalcError(err);
                }
                xargs.push($number);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $number = this._arrayArg(args[i]);
            if ($number) {
                xargs.push($number);
                width = Math.max(width, $number.width);
                height = Math.max(height, $number.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (num) {
        var n = num < 0 ? Math.floor(num) : Math.ceil(num);
        return n % 2 ? n : n + (n < 0 ? -1 : 1);
    });

    defineBuiltinFunction('sign', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $number = args[i++];
                if ($number instanceof CalcError)
                    return $number;
                if (!((typeof ($number = this.force($number)) == 'number' ? ($number = limitPrecision($number), true) : false) || (typeof $number == 'boolean' ? ($number = +$number, true) : false) || (typeof $number == 'string' && !/^(?:=|true|false)/i.test($number) ? (tmp = calc.parse(0, 0, 0, $number), /^date|number|percent$/.test(tmp.type) ? ($number = +tmp.value, true) : false) : false))) {
                    if ($number instanceof CalcError)
                        return $number;
                    return new CalcError(err);
                }
                xargs.push($number);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $number = this._arrayArg(args[i]);
            if ($number) {
                xargs.push($number);
                width = Math.max(width, $number.width);
                height = Math.max(height, $number.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (num) {
        return num < 0 ? -1 : num > 0 ? 1 : 0;
    });

    function _gcd(a, b) {
        while (b) {
            var r = a % b;
            a = b;
            b = r;
        }
        return a;
    }

    function _lcm(a, b) {
        return Math.abs(a * b) / _gcd(a, b);
    }

    defineBuiltinFunction('gcd', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0;
            {
                try {
                    var $numbers = this.cellValues(args.slice(i)).reduce(function (ret, $numbers) {
                        if ($numbers instanceof CalcError)
                            throw $numbers;
                        if ((typeof $numbers == 'number' ? ($numbers = limitPrecision($numbers), true) : false) || (typeof $numbers == 'boolean' ? ($numbers = +$numbers, true) : false) || (typeof $numbers == 'string' && !/^(?:=|true|false)/i.test($numbers) ? (tmp = calc.parse(0, 0, 0, $numbers), /^date|number|percent$/.test(tmp.type) ? ($numbers = +tmp.value, true) : false) : false))
                            ret.push($numbers);
                        return ret;
                    }.bind(this), []);
                    i = args.length;
                    xargs.push($numbers);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args.slice(i));
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (args) {
        var a = args[0];
        for (var i = 1; i < args.length; ++i) {
            a = _gcd(a, args[i]);
        }
        return a;
    });

    defineBuiltinFunction('lcm', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0;
            {
                try {
                    var $numbers = this.cellValues(args.slice(i)).reduce(function (ret, $numbers) {
                        if ($numbers instanceof CalcError)
                            throw $numbers;
                        if ((typeof $numbers == 'number' ? ($numbers = limitPrecision($numbers), true) : false) || (typeof $numbers == 'boolean' ? ($numbers = +$numbers, true) : false) || (typeof $numbers == 'string' && !/^(?:=|true|false)/i.test($numbers) ? (tmp = calc.parse(0, 0, 0, $numbers), /^date|number|percent$/.test(tmp.type) ? ($numbers = +tmp.value, true) : false) : false))
                            ret.push($numbers);
                        return ret;
                    }.bind(this), []);
                    i = args.length;
                    xargs.push($numbers);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args.slice(i));
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (args) {
        var a = args[0];
        for (var i = 1; i < args.length; ++i) {
            a = _lcm(a, args[i]);
        }
        return a;
    });

    defineBuiltinFunction('sum', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0;
            {
                try {
                    var $numbers = this.cellValues(args.slice(i)).reduce(function (ret, $numbers) {
                        if ($numbers instanceof CalcError)
                            throw $numbers;
                        if ((typeof $numbers == 'number' ? ($numbers = limitPrecision($numbers), true) : false) || (typeof $numbers == 'boolean' ? ($numbers = +$numbers, true) : false) || (typeof $numbers == 'string' && !/^(?:=|true|false)/i.test($numbers) ? (tmp = calc.parse(0, 0, 0, $numbers), /^date|number|percent$/.test(tmp.type) ? ($numbers = +tmp.value, true) : false) : false))
                            ret.push($numbers);
                        return ret;
                    }.bind(this), []);
                    i = args.length;
                    xargs.push($numbers);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args.slice(i));
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (numbers) {
        return numbers.reduce(function (sum, num) {
            return sum + num;
        }, 0);
    });

    defineBuiltinFunction('product', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0;
            {
                try {
                    var $numbers = this.cellValues(args.slice(i)).reduce(function (ret, $numbers) {
                        if ($numbers instanceof CalcError)
                            throw $numbers;
                        if ((typeof $numbers == 'number' ? ($numbers = limitPrecision($numbers), true) : false) || (typeof $numbers == 'boolean' ? ($numbers = +$numbers, true) : false) || (typeof $numbers == 'string' && !/^(?:=|true|false)/i.test($numbers) ? (tmp = calc.parse(0, 0, 0, $numbers), /^date|number|percent$/.test(tmp.type) ? ($numbers = +tmp.value, true) : false) : false))
                            ret.push($numbers);
                        return ret;
                    }.bind(this), []);
                    i = args.length;
                    xargs.push($numbers);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args.slice(i));
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (numbers) {
        return numbers.reduce(function (prod, num) {
            return prod * num;
        }, 1);
    });

    defineBuiltinFunction('sumproduct', false, function () {
        function check(args) {
            var stack = [], tmp, xargs = [], i = 0, m, err = 'VALUE';
            {
                var $a1 = args[i++];
                if ($a1 instanceof CalcError)
                    return $a1;
                if (!((m = this.asMatrix($a1)) ? $a1 = m : false)) {
                    if ($a1 instanceof CalcError)
                        return $a1;
                    return new CalcError(err);
                }
                xargs.push($a1);
            }
            {
                if (i >= args.length)
                    return new CalcError('N/A');
                xargs.push(tmp = []);
                stack.push(xargs);
                xargs = tmp;
                do {
                    {
                        var $a2 = args[i++];
                        if ($a2 instanceof CalcError)
                            return $a2;
                        if (!(((m = this.asMatrix($a2)) ? $a2 = m : false) && ($a2.width == $a1.width ? true : (err = 'N/A', false)) && ($a2.height == $a1.height ? true : (err = 'N/A', false)))) {
                            if ($a2 instanceof CalcError)
                                return $a2;
                            return new CalcError(err);
                        }
                        xargs.push($a2);
                    }
                } while (i < args.length);
                xargs = stack.pop();
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            while (i < args.length) {
                toResolve.push(args[i++]);
            }
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (first, rest) {
        var sum = 0;
        first.each(function (p, row, col) {
            if (typeof p == 'number') {
                for (var i = 0; i < rest.length; ++i) {
                    var v = rest[i].get(row, col);
                    if (typeof v != 'number') {
                        return;
                    }
                    p *= v;
                }
                sum += p;
            }
        });
        return sum;
    });

    defineBuiltinFunction('sumsq', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0;
            {
                try {
                    var $numbers = this.cellValues(args.slice(i)).reduce(function (ret, $numbers) {
                        if ($numbers instanceof CalcError)
                            throw $numbers;
                        if ((typeof $numbers == 'number' ? ($numbers = limitPrecision($numbers), true) : false) || (typeof $numbers == 'boolean' ? ($numbers = +$numbers, true) : false) || (typeof $numbers == 'string' && !/^(?:=|true|false)/i.test($numbers) ? (tmp = calc.parse(0, 0, 0, $numbers), /^date|number|percent$/.test(tmp.type) ? ($numbers = +tmp.value, true) : false) : false))
                            ret.push($numbers);
                        return ret;
                    }.bind(this), []);
                    i = args.length;
                    xargs.push($numbers);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args.slice(i));
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (numbers) {
        return numbers.reduce(function (sum, num) {
            return sum + num * num;
        }, 0);
    });

    defineBuiltinFunction('sumx2my2', false, function () {
        function check(args) {
            var xargs = [], i = 0, m, err = 'VALUE';
            {
                var $a = args[i++];
                if ($a instanceof CalcError)
                    return $a;
                if (!((m = this.asMatrix($a)) ? $a = m : false)) {
                    if ($a instanceof CalcError)
                        return $a;
                    return new CalcError(err);
                }
                xargs.push($a);
            }
            {
                var $b = args[i++];
                if ($b instanceof CalcError)
                    return $b;
                if (!(((m = this.asMatrix($b)) ? $b = m : false) && ($b.width == $a.width ? true : (err = 'N/A', false)) && ($b.height == $a.height ? true : (err = 'N/A', false)))) {
                    if ($b instanceof CalcError)
                        return $b;
                    return new CalcError(err);
                }
                xargs.push($b);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (a, b) {
        var sum = 0;
        a.each(function (x, row, col) {
            var y = b.get(row, col);
            if (typeof x == 'number' && typeof y == 'number') {
                sum += x * x - y * y;
            }
        });
        return sum;
    });

    defineBuiltinFunction('sumx2py2', false, function () {
        function check(args) {
            var xargs = [], i = 0, m, err = 'VALUE';
            {
                var $a = args[i++];
                if ($a instanceof CalcError)
                    return $a;
                if (!((m = this.asMatrix($a)) ? $a = m : false)) {
                    if ($a instanceof CalcError)
                        return $a;
                    return new CalcError(err);
                }
                xargs.push($a);
            }
            {
                var $b = args[i++];
                if ($b instanceof CalcError)
                    return $b;
                if (!(((m = this.asMatrix($b)) ? $b = m : false) && ($b.width == $a.width ? true : (err = 'N/A', false)) && ($b.height == $a.height ? true : (err = 'N/A', false)))) {
                    if ($b instanceof CalcError)
                        return $b;
                    return new CalcError(err);
                }
                xargs.push($b);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (a, b) {
        var sum = 0;
        a.each(function (x, row, col) {
            var y = b.get(row, col);
            if (typeof x == 'number' && typeof y == 'number') {
                sum += x * x + y * y;
            }
        });
        return sum;
    });

    defineBuiltinFunction('sumxmy2', false, function () {
        function check(args) {
            var xargs = [], i = 0, m, err = 'VALUE';
            {
                var $a = args[i++];
                if ($a instanceof CalcError)
                    return $a;
                if (!((m = this.asMatrix($a)) ? $a = m : false)) {
                    if ($a instanceof CalcError)
                        return $a;
                    return new CalcError(err);
                }
                xargs.push($a);
            }
            {
                var $b = args[i++];
                if ($b instanceof CalcError)
                    return $b;
                if (!(((m = this.asMatrix($b)) ? $b = m : false) && ($b.width == $a.width ? true : (err = 'N/A', false)) && ($b.height == $a.height ? true : (err = 'N/A', false)))) {
                    if ($b instanceof CalcError)
                        return $b;
                    return new CalcError(err);
                }
                xargs.push($b);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (a, b) {
        var sum = 0;
        a.each(function (x, row, col) {
            var y = b.get(row, col);
            if (typeof x == 'number' && typeof y == 'number') {
                sum += (x - y) * (x - y);
            }
        });
        return sum;
    });

    defineBuiltinFunction('seriessum', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, m, err = 'VALUE';
            {
                var $x = args[i++];
                if ($x instanceof CalcError)
                    return $x;
                if (!((typeof ($x = this.force($x)) == 'number' ? ($x = limitPrecision($x), true) : false) || (typeof $x == 'boolean' ? ($x = +$x, true) : false) || (typeof $x == 'string' && !/^(?:=|true|false)/i.test($x) ? (tmp = calc.parse(0, 0, 0, $x), /^date|number|percent$/.test(tmp.type) ? ($x = +tmp.value, true) : false) : false))) {
                    if ($x instanceof CalcError)
                        return $x;
                    return new CalcError(err);
                }
                xargs.push($x);
            }
            {
                var $y = args[i++];
                if ($y instanceof CalcError)
                    return $y;
                if (!((typeof ($y = this.force($y)) == 'number' ? ($y = limitPrecision($y), true) : false) || (typeof $y == 'boolean' ? ($y = +$y, true) : false) || (typeof $y == 'string' && !/^(?:=|true|false)/i.test($y) ? (tmp = calc.parse(0, 0, 0, $y), /^date|number|percent$/.test(tmp.type) ? ($y = +tmp.value, true) : false) : false))) {
                    if ($y instanceof CalcError)
                        return $y;
                    return new CalcError(err);
                }
                xargs.push($y);
            }
            {
                var $m = args[i++];
                if ($m instanceof CalcError)
                    return $m;
                if (!((typeof ($m = this.force($m)) == 'number' ? ($m = limitPrecision($m), true) : false) || (typeof $m == 'boolean' ? ($m = +$m, true) : false) || (typeof $m == 'string' && !/^(?:=|true|false)/i.test($m) ? (tmp = calc.parse(0, 0, 0, $m), /^date|number|percent$/.test(tmp.type) ? ($m = +tmp.value, true) : false) : false))) {
                    if ($m instanceof CalcError)
                        return $m;
                    return new CalcError(err);
                }
                xargs.push($m);
            }
            {
                var $a = args[i++];
                if ($a instanceof CalcError)
                    return $a;
                if (!((m = this.asMatrix($a)) ? $a = m : false)) {
                    if ($a instanceof CalcError)
                        return $a;
                    return new CalcError(err);
                }
                xargs.push($a);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (x, n, m, a) {
        var sum = 0;
        a.each(function (coef) {
            if (typeof coef != 'number') {
                throw new CalcError('VALUE');
            }
            sum += coef * Math.pow(x, n);
            n += m;
        });
        return sum;
    });

    defineBuiltinFunction('min', false, function () {
        function check(args) {
            var xargs = [], i = 0;
            {
                try {
                    var $numbers = this.cellValues(args.slice(i)).reduce(function (ret, $numbers) {
                        if ($numbers instanceof CalcError)
                            throw $numbers;
                        if (typeof $numbers == 'number' ? ($numbers = limitPrecision($numbers), true) : false)
                            ret.push($numbers);
                        return ret;
                    }.bind(this), []);
                    i = args.length;
                    xargs.push($numbers);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args.slice(i));
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (numbers) {
        return numbers.length ? Math.min.apply(Math, numbers) : 0;
    });

    defineBuiltinFunction('max', false, function () {
        function check(args) {
            var xargs = [], i = 0;
            {
                try {
                    var $numbers = this.cellValues(args.slice(i)).reduce(function (ret, $numbers) {
                        if ($numbers instanceof CalcError)
                            throw $numbers;
                        if (typeof $numbers == 'number' ? ($numbers = limitPrecision($numbers), true) : false)
                            ret.push($numbers);
                        return ret;
                    }.bind(this), []);
                    i = args.length;
                    xargs.push($numbers);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args.slice(i));
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (numbers) {
        return numbers.length ? Math.max.apply(Math, numbers) : 0;
    });

    defineBuiltinFunction('counta', false, function () {
        function check(args) {
            var xargs = [], i = 0;
            {
                try {
                    var $values = this.cellValues(args.slice(i)).reduce(function (ret, $values) {
                        if ($values != null && i <= args.length)
                            ret.push($values);
                        return ret;
                    }.bind(this), []);
                    i = args.length;
                    xargs.push($values);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args.slice(i));
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (values) {
        return values.length;
    });

    defineBuiltinFunction('count', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0;
            {
                try {
                    var $numbers = this.cellValues(args.slice(i)).reduce(function (ret, $numbers) {
                        if ((typeof $numbers == 'number' ? ($numbers = limitPrecision($numbers), true) : false) || (typeof $numbers == 'boolean' ? ($numbers = +$numbers, true) : false) || (typeof $numbers == 'string' && !/^(?:=|true|false)/i.test($numbers) ? (tmp = calc.parse(0, 0, 0, $numbers), /^date|number|percent$/.test(tmp.type) ? ($numbers = +tmp.value, true) : false) : false))
                            ret.push($numbers);
                        return ret;
                    }.bind(this), []);
                    i = args.length;
                    xargs.push($numbers);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args.slice(i));
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (numbers) {
        return numbers.length;
    });

    defineBuiltinFunction('countunique', false, function () {
        function check(args) {
            var xargs = [], i = 0;
            {
                try {
                    var $values = this.cellValues(args.slice(i)).reduce(function (ret, $values) {
                        if ($values != null && i <= args.length)
                            ret.push($values);
                        return ret;
                    }.bind(this), []);
                    i = args.length;
                    xargs.push($values);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args.slice(i));
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (values) {
        var count = 0, seen = [];
        values.forEach(function (val) {
            if (seen.indexOf(val) < 0) {
                count++;
                seen.push(val);
            }
        });
        return count;
    });

    defineBuiltinFunction('countblank', false, function () {
        function check(args) {
            var stack = [], tmp, xargs = [], i = 0, m, err = 'VALUE';
            {
                if (i >= args.length)
                    return new CalcError('N/A');
                xargs.push(tmp = []);
                stack.push(xargs);
                xargs = tmp;
                do {
                    {
                        var $args = args[i++];
                        if ($args instanceof CalcError)
                            return $args;
                        if (!(((m = this.asMatrix($args)) ? $args = m : false) || $args != null && i <= args.length)) {
                            if ($args instanceof CalcError)
                                return $args;
                            return new CalcError(err);
                        }
                        xargs.push($args);
                    }
                } while (i < args.length);
                xargs = stack.pop();
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            while (i < args.length) {
                toResolve.push(args[i++]);
            }
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (a) {
        var count = 0;
        function add(val) {
            if (val == null || val === '') {
                count++;
            }
        }
        function loop(args) {
            for (var i = 0; i < args.length; ++i) {
                var x = args[i];
                if (x instanceof Matrix) {
                    x.each(add, true);
                } else {
                    add(x);
                }
            }
        }
        loop(a);
        return count;
    });

    defineBuiltinFunction('iseven', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $number = args[i++];
                if ($number instanceof CalcError)
                    return $number;
                if (!((typeof ($number = this.force($number)) == 'number' ? ($number = limitPrecision($number), true) : false) || (typeof $number == 'boolean' ? ($number = +$number, true) : false) || (typeof $number == 'string' && !/^(?:=|true|false)/i.test($number) ? (tmp = calc.parse(0, 0, 0, $number), /^date|number|percent$/.test(tmp.type) ? ($number = +tmp.value, true) : false) : false))) {
                    if ($number instanceof CalcError)
                        return $number;
                    return new CalcError(err);
                }
                xargs.push($number);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $number = this._arrayArg(args[i]);
            if ($number) {
                xargs.push($number);
                width = Math.max(width, $number.width);
                height = Math.max(height, $number.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (num) {
        return num % 2 === 0;
    });

    defineBuiltinFunction('isodd', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $number = args[i++];
                if ($number instanceof CalcError)
                    return $number;
                if (!((typeof ($number = this.force($number)) == 'number' ? ($number = limitPrecision($number), true) : false) || (typeof $number == 'boolean' ? ($number = +$number, true) : false) || (typeof $number == 'string' && !/^(?:=|true|false)/i.test($number) ? (tmp = calc.parse(0, 0, 0, $number), /^date|number|percent$/.test(tmp.type) ? ($number = +tmp.value, true) : false) : false))) {
                    if ($number instanceof CalcError)
                        return $number;
                    return new CalcError(err);
                }
                xargs.push($number);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $number = this._arrayArg(args[i]);
            if ($number) {
                xargs.push($number);
                width = Math.max(width, $number.width);
                height = Math.max(height, $number.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (num) {
        return num % 2 !== 0;
    });

    defineBuiltinFunction('n', false, function () {
        function check(args) {
            var xargs = [], i = 0, err = 'VALUE';
            {
                var $value = args[i++];
                if ($value instanceof CalcError)
                    return $value;
                if (!(($value = this.force($value)) != null && i <= args.length)) {
                    if ($value instanceof CalcError)
                        return $value;
                    return new CalcError(err);
                }
                xargs.push($value);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $value = this._arrayArg(args[i]);
            if ($value) {
                xargs.push($value);
                width = Math.max(width, $value.width);
                height = Math.max(height, $value.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (val) {
        if (typeof val == 'boolean') {
            return val ? 1 : 0;
        }
        if (typeof val == 'number') {
            return val;
        }
        return 0;
    });

    defineBuiltinFunction('na', false, function () {
        function check(args) {
            var xargs = [], i = 0;
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        return { check: check };
    }(), function () {
        return new CalcError('N/A');
    });

    /* -----[ the "*IFS" functions ]----- */

    // helper function: take `args` like COUNTIFS (see Excel docs) and
    // calls `f` for each cell matching all criteria.  `f` receives
    // `chunks` (parsed args containing matrix and predicate) and
    // row,col of matching cells.
    function forIFS(args, f) {
        var chunks = [], i = 0, matrix = args[0];
        while (i < args.length) {
            chunks.push({
                matrix: args[i++],
                pred: parseCriteria(args[i++])
            });
        }
        for (var row = 0; row < matrix.height; ++row) {
            COL: for (var col = 0; col < matrix.width; ++col) {
                for (i = 0; i < chunks.length; ++i) {
                    var val = chunks[i].matrix.get(row, col);
                    if (!chunks[i].pred(val == null || val === "" ? 0 : val)) {
                        continue COL;
                    }
                }
                f(row, col);
            }
        }
    }

    defineBuiltinFunction('countifs', false, function () {
        function check(args) {
            var stack = [], tmp, xargs = [], i = 0, m, err = 'VALUE';
            {
                var $m1 = args[i++];
                if ($m1 instanceof CalcError)
                    return $m1;
                if (!((m = this.asMatrix($m1)) ? $m1 = m : false)) {
                    if ($m1 instanceof CalcError)
                        return $m1;
                    return new CalcError(err);
                }
                xargs.push($m1);
            }
            {
                var $c1 = args[i++];
                if ($c1 instanceof CalcError)
                    return $c1;
                if (!(($c1 = this.force($c1)) != null && i <= args.length)) {
                    if ($c1 instanceof CalcError)
                        return $c1;
                    return new CalcError(err);
                }
                xargs.push($c1);
            }
            {
                xargs.push(tmp = []);
                stack.push(xargs);
                xargs = tmp;
                while (i < args.length) {
                    {
                        var $m2 = args[i++];
                        if ($m2 instanceof CalcError)
                            return $m2;
                        if (!((m = this.asMatrix($m2)) ? $m2 = m : false)) {
                            if ($m2 instanceof CalcError)
                                return $m2;
                            return new CalcError(err);
                        }
                        xargs.push($m2);
                    }
                    {
                        var $c2 = args[i++];
                        if ($c2 instanceof CalcError)
                            return $c2;
                        if (!(($c2 = this.force($c2)) != null && i <= args.length)) {
                            if ($c2 instanceof CalcError)
                                return $c2;
                            return new CalcError(err);
                        }
                        xargs.push($c2);
                    }
                }
                xargs = stack.pop();
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            while (i < args.length) {
                toResolve.push(args[i++]);
                toResolve.push(args[i++]);
            }
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (m1, c1, rest) {
        var count = 0;
        rest.unshift(m1, c1);
        forIFS(rest, function () {
            count++;
        });
        return count;
    });

    defineBuiltinFunction('sumifs', false, function () {
        function check(args) {
            var stack = [], tmp, xargs = [], i = 0, m, err = 'VALUE';
            {
                var $range = args[i++];
                if ($range instanceof CalcError)
                    return $range;
                if (!((m = this.asMatrix($range)) ? $range = m : false)) {
                    if ($range instanceof CalcError)
                        return $range;
                    return new CalcError(err);
                }
                xargs.push($range);
            }
            {
                var $m1 = args[i++];
                if ($m1 instanceof CalcError)
                    return $m1;
                if (!((m = this.asMatrix($m1)) ? $m1 = m : false)) {
                    if ($m1 instanceof CalcError)
                        return $m1;
                    return new CalcError(err);
                }
                xargs.push($m1);
            }
            {
                var $c1 = args[i++];
                if ($c1 instanceof CalcError)
                    return $c1;
                if (!(($c1 = this.force($c1)) != null && i <= args.length)) {
                    if ($c1 instanceof CalcError)
                        return $c1;
                    return new CalcError(err);
                }
                xargs.push($c1);
            }
            {
                xargs.push(tmp = []);
                stack.push(xargs);
                xargs = tmp;
                while (i < args.length) {
                    {
                        var $m2 = args[i++];
                        if ($m2 instanceof CalcError)
                            return $m2;
                        if (!((m = this.asMatrix($m2)) ? $m2 = m : false)) {
                            if ($m2 instanceof CalcError)
                                return $m2;
                            return new CalcError(err);
                        }
                        xargs.push($m2);
                    }
                    {
                        var $c2 = args[i++];
                        if ($c2 instanceof CalcError)
                            return $c2;
                        if (!(($c2 = this.force($c2)) != null && i <= args.length)) {
                            if ($c2 instanceof CalcError)
                                return $c2;
                            return new CalcError(err);
                        }
                        xargs.push($c2);
                    }
                }
                xargs = stack.pop();
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            while (i < args.length) {
                toResolve.push(args[i++]);
                toResolve.push(args[i++]);
            }
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (range, m1, c1, args) {
        args.unshift(range, numericPredicate, m1, c1);
        var sum = 0;
        forIFS(args, function (row, col) {
            var val = range.get(row, col);
            if (val) {
                sum += val;
            }
        });
        return sum;
    });

    // similar to sumifs, but compute average of matching cells
    defineBuiltinFunction('averageifs', false, function () {
        function check(args) {
            var stack = [], tmp, xargs = [], i = 0, m, err = 'VALUE';
            {
                var $range = args[i++];
                if ($range instanceof CalcError)
                    return $range;
                if (!((m = this.asMatrix($range)) ? $range = m : false)) {
                    if ($range instanceof CalcError)
                        return $range;
                    return new CalcError(err);
                }
                xargs.push($range);
            }
            {
                var $m1 = args[i++];
                if ($m1 instanceof CalcError)
                    return $m1;
                if (!((m = this.asMatrix($m1)) ? $m1 = m : false)) {
                    if ($m1 instanceof CalcError)
                        return $m1;
                    return new CalcError(err);
                }
                xargs.push($m1);
            }
            {
                var $c1 = args[i++];
                if ($c1 instanceof CalcError)
                    return $c1;
                if (!(($c1 = this.force($c1)) != null && i <= args.length)) {
                    if ($c1 instanceof CalcError)
                        return $c1;
                    return new CalcError(err);
                }
                xargs.push($c1);
            }
            {
                xargs.push(tmp = []);
                stack.push(xargs);
                xargs = tmp;
                while (i < args.length) {
                    {
                        var $m2 = args[i++];
                        if ($m2 instanceof CalcError)
                            return $m2;
                        if (!((m = this.asMatrix($m2)) ? $m2 = m : false)) {
                            if ($m2 instanceof CalcError)
                                return $m2;
                            return new CalcError(err);
                        }
                        xargs.push($m2);
                    }
                    {
                        var $c2 = args[i++];
                        if ($c2 instanceof CalcError)
                            return $c2;
                        if (!(($c2 = this.force($c2)) != null && i <= args.length)) {
                            if ($c2 instanceof CalcError)
                                return $c2;
                            return new CalcError(err);
                        }
                        xargs.push($c2);
                    }
                }
                xargs = stack.pop();
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            while (i < args.length) {
                toResolve.push(args[i++]);
                toResolve.push(args[i++]);
            }
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (range, m1, c1, args) {
        args.unshift(range, numericPredicate, m1, c1);
        var sum = 0, count = 0;
        forIFS(args, function (row, col) {
            var val = range.get(row, col);
            if (val == null || val === '') {
                val = 0;
            }
            sum += val;
            count++;
        });
        return count ? sum / count : new CalcError('DIV/0');
    });

    defineBuiltinFunction('countif', false, function () {
        function check(args) {
            var xargs = [], i = 0, m, err = 'VALUE';
            {
                var $range = args[i++];
                if ($range instanceof CalcError)
                    return $range;
                if (!((m = this.asMatrix($range)) ? $range = m : false)) {
                    if ($range instanceof CalcError)
                        return $range;
                    return new CalcError(err);
                }
                xargs.push($range);
            }
            {
                var $criteria = args[i++];
                if ($criteria instanceof CalcError)
                    return $criteria;
                if (!(($criteria = this.force($criteria)) != null && i <= args.length)) {
                    if ($criteria instanceof CalcError)
                        return $criteria;
                    return new CalcError(err);
                }
                xargs.push($criteria);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            xargs.push(args[i++]);
            arrays.push(false);
            var $criteria = this._arrayArg(args[i]);
            if ($criteria) {
                xargs.push($criteria);
                width = Math.max(width, $criteria.width);
                height = Math.max(height, $criteria.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (matrix, criteria) {
        criteria = parseCriteria(criteria);
        var count = 0;
        matrix.each(function (val) {
            if (criteria(val)) {
                count++;
            }
        });
        return count;
    });

    function fetchSumRange(continuation) {
        return function(callback, range, criteria, sumRange) {
            var self = this;
            if (sumRange instanceof Ref) {
                // make sure it covers the same area as `range`, as the “spec” mentions:
                //
                //     The sum_range argument does not have to be the same size and shape as the
                //     range argument. The actual cells that are added are determined by using the
                //     upper leftmost cell in the sum_range argument as the beginning cell, and then
                //     including cells that correspond in size and shape to the range argument.
                //
                // It does make one wonder, since only the top-left cell in `sumRange` matters, why
                // should it be a range at all?  Oh well, Excel.
                var r = sumRange.clone().toRangeRef();
                if (r.width() != range.width || r.height() != range.height) {
                    if (!isFinite(r.topLeft.row)) {
                        r.topLeft.row = 0;
                    }
                    if (!isFinite(r.topLeft.col)) {
                        r.topLeft.col = 0;
                    }
                    r.bottomRight.row = r.topLeft.row + range.height - 1;
                    r.bottomRight.col = r.topLeft.col + range.width - 1;
                    return self.resolveCells([ r ], function(){
                        callback(continuation(range, criteria, self.asMatrix(r)));
                    });
                }
            }
            callback(continuation(range, criteria, self.asMatrix(sumRange)));
        };
    }

    defineBuiltinFunction('sumif', true, function () {
        function check(args) {
            var xargs = [], i = 0, m, err = 'VALUE';
            {
                var $range = args[i++];
                if ($range instanceof CalcError)
                    return $range;
                if (!((m = this.asMatrix($range)) ? $range = m : false)) {
                    if ($range instanceof CalcError)
                        return $range;
                    return new CalcError(err);
                }
                xargs.push($range);
            }
            {
                var $criteria = args[i++];
                if ($criteria instanceof CalcError)
                    return $criteria;
                if (!(($criteria = this.force($criteria)) != null && i <= args.length)) {
                    if ($criteria instanceof CalcError)
                        return $criteria;
                    return new CalcError(err);
                }
                xargs.push($criteria);
            }
            {
                var $sumRange = args[i++];
                if ($sumRange instanceof CalcError)
                    return $sumRange;
                if (!($sumRange instanceof CellRef || $sumRange instanceof RangeRef || ((m = this.asMatrix($sumRange)) ? $sumRange = m : false) || (($sumRange = this.force($sumRange)) == null ? ($sumRange = $range, true) : false))) {
                    if ($sumRange instanceof CalcError)
                        return $sumRange;
                    return new CalcError(err);
                }
                xargs.push($sumRange);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            xargs.push(args[i++]);
            arrays.push(false);
            var $criteria = this._arrayArg(args[i]);
            if ($criteria) {
                xargs.push($criteria);
                width = Math.max(width, $criteria.width);
                height = Math.max(height, $criteria.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            xargs.push(args[i++]);
            arrays.push(false);
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), fetchSumRange(function (range, criteria, sumRange) {
        var sum = 0;
        criteria = parseCriteria(criteria);
        range.each(function (val, row, col) {
            if (criteria(val)) {
                var v = sumRange.get(row, col);
                if (numericPredicate(v)) {
                    sum += v || 0;
                }
            }
        });
        return sum;
    }));

    defineBuiltinFunction('averageif', true, function () {
        function check(args) {
            var xargs = [], i = 0, m, err = 'VALUE';
            {
                var $range = args[i++];
                if ($range instanceof CalcError)
                    return $range;
                if (!((m = this.asMatrix($range)) ? $range = m : false)) {
                    if ($range instanceof CalcError)
                        return $range;
                    return new CalcError(err);
                }
                xargs.push($range);
            }
            {
                var $criteria = args[i++];
                if ($criteria instanceof CalcError)
                    return $criteria;
                if (!(($criteria = this.force($criteria)) != null && i <= args.length)) {
                    if ($criteria instanceof CalcError)
                        return $criteria;
                    return new CalcError(err);
                }
                xargs.push($criteria);
            }
            {
                var $sumRange = args[i++];
                if ($sumRange instanceof CalcError)
                    return $sumRange;
                if (!($sumRange instanceof CellRef || $sumRange instanceof RangeRef || ((m = this.asMatrix($sumRange)) ? $sumRange = m : false) || (($sumRange = this.force($sumRange)) == null ? ($sumRange = $range, true) : false))) {
                    if ($sumRange instanceof CalcError)
                        return $sumRange;
                    return new CalcError(err);
                }
                xargs.push($sumRange);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            xargs.push(args[i++]);
            arrays.push(false);
            var $criteria = this._arrayArg(args[i]);
            if ($criteria) {
                xargs.push($criteria);
                width = Math.max(width, $criteria.width);
                height = Math.max(height, $criteria.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            xargs.push(args[i++]);
            arrays.push(false);
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), fetchSumRange(function (range, criteria, sumRange) {
        var sum = 0, count = 0;
        criteria = parseCriteria(criteria);
        range.each(function (val, row, col) {
            if (criteria(val)) {
                var v = sumRange.get(row, col);
                if (numericPredicate(v)) {
                    sum += v || 0;
                    count++;
                }
            }
        });
        return count ? sum / count : new CalcError('DIV/0');
    }));

    function _extreme(matrix, nth, order){
        var numbers = [];
        var error = matrix.each(function(val){
            if (val instanceof CalcError) {
                return val;
            }
            if (typeof val == "number") {
                numbers.push(val);
            }
        });
        if (error) {
            return error;
        }
        if (nth > numbers.length) {
            return new CalcError("NUM");
        }
        return numbers.sort(order)[nth - 1];
    }

    defineBuiltinFunction('large', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, m, err = 'VALUE';
            {
                var $array = args[i++];
                if ($array instanceof CalcError)
                    return $array;
                if (!((m = this.asMatrix($array)) ? $array = m : false)) {
                    if ($array instanceof CalcError)
                        return $array;
                    return new CalcError(err);
                }
                xargs.push($array);
            }
            {
                var $nth = args[i++];
                if ($nth instanceof CalcError)
                    return $nth;
                if (!(((typeof ($nth = this.force($nth)) == 'number' ? ($nth = limitPrecision($nth), true) : false) || (typeof $nth == 'boolean' ? ($nth = +$nth, true) : false) || (typeof $nth == 'string' && !/^(?:=|true|false)/i.test($nth) ? (tmp = calc.parse(0, 0, 0, $nth), /^date|number|percent$/.test(tmp.type) ? ($nth = +tmp.value, true) : false) : false)) && ($nth > 0 ? true : (err = 'NUM', false)))) {
                    if ($nth instanceof CalcError)
                        return $nth;
                    return new CalcError(err);
                }
                xargs.push($nth);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            xargs.push(args[i++]);
            arrays.push(false);
            var $nth = this._arrayArg(args[i]);
            if ($nth) {
                xargs.push($nth);
                width = Math.max(width, $nth.width);
                height = Math.max(height, $nth.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (matrix, nth) {
        return _extreme(matrix, nth, descending);
    });

    defineBuiltinFunction('small', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, m, err = 'VALUE';
            {
                var $array = args[i++];
                if ($array instanceof CalcError)
                    return $array;
                if (!((m = this.asMatrix($array)) ? $array = m : false)) {
                    if ($array instanceof CalcError)
                        return $array;
                    return new CalcError(err);
                }
                xargs.push($array);
            }
            {
                var $nth = args[i++];
                if ($nth instanceof CalcError)
                    return $nth;
                if (!(((typeof ($nth = this.force($nth)) == 'number' ? ($nth = limitPrecision($nth), true) : false) || (typeof $nth == 'boolean' ? ($nth = +$nth, true) : false) || (typeof $nth == 'string' && !/^(?:=|true|false)/i.test($nth) ? (tmp = calc.parse(0, 0, 0, $nth), /^date|number|percent$/.test(tmp.type) ? ($nth = +tmp.value, true) : false) : false)) && ($nth > 0 ? true : (err = 'NUM', false)))) {
                    if ($nth instanceof CalcError)
                        return $nth;
                    return new CalcError(err);
                }
                xargs.push($nth);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            xargs.push(args[i++]);
            arrays.push(false);
            var $nth = this._arrayArg(args[i]);
            if ($nth) {
                xargs.push($nth);
                width = Math.max(width, $nth.width);
                height = Math.max(height, $nth.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (matrix, nth) {
        return _extreme(matrix, nth, ascending);
    });

    function _avg(numbers) {
        return numbers.reduce(function(sum, num){
            return sum + num;
        }, 0) / numbers.length;
    }

    function _var_sp(numbers, divisor, avg) {
        if (avg == null) {
            avg = _avg(numbers);
        }
        return numbers.reduce(function(sum, num){
            return sum + Math.pow(num - avg, 2);
        }, 0) / divisor;
    }

    function _stdev_sp(numbers, divisor) {
        return Math.sqrt(_var_sp(numbers, divisor));
    }

    // https://support.office.com/en-sg/article/STDEV-S-function-7d69cf97-0c1f-4acf-be27-f3e83904cc23
    defineBuiltinFunction('stdev.s', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                try {
                    var $numbers = this.cellValues(args.slice(i)).reduce(function (ret, $numbers) {
                        if ($numbers instanceof CalcError)
                            throw $numbers;
                        if ((typeof $numbers == 'number' ? ($numbers = limitPrecision($numbers), true) : false) || (typeof $numbers == 'boolean' ? ($numbers = +$numbers, true) : false) || (typeof $numbers == 'string' && !/^(?:=|true|false)/i.test($numbers) ? (tmp = calc.parse(0, 0, 0, $numbers), /^date|number|percent$/.test(tmp.type) ? ($numbers = +tmp.value, true) : false) : false))
                            ret.push($numbers);
                        return ret;
                    }.bind(this), []);
                    i = args.length;
                    xargs.push($numbers);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            {
                if (!($numbers.length >= 2 ? true : (err = 'NUM', false)))
                    return new CalcError(err);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args.slice(i));
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (numbers) {
        return _stdev_sp(numbers, numbers.length - 1);
    });

    // https://support.office.com/en-sg/article/STDEV-P-function-6e917c05-31a0-496f-ade7-4f4e7462f285
    defineBuiltinFunction('stdev.p', false, function () {
        function check(args) {
            var xargs = [], i = 0, err = 'VALUE';
            {
                try {
                    var $numbers = this.cellValues(args.slice(i)).reduce(function (ret, $numbers) {
                        if ($numbers instanceof CalcError)
                            throw $numbers;
                        if (typeof $numbers == 'number' ? ($numbers = limitPrecision($numbers), true) : false)
                            ret.push($numbers);
                        return ret;
                    }.bind(this), []);
                    i = args.length;
                    xargs.push($numbers);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            {
                if (!($numbers.length >= 1 ? true : (err = 'NUM', false)))
                    return new CalcError(err);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args.slice(i));
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (numbers) {
        return _stdev_sp(numbers, numbers.length);
    });

    defineBuiltinFunction('var.s', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                try {
                    var $numbers = this.cellValues(args.slice(i)).reduce(function (ret, $numbers) {
                        if ($numbers instanceof CalcError)
                            throw $numbers;
                        if ((typeof $numbers == 'number' ? ($numbers = limitPrecision($numbers), true) : false) || (typeof $numbers == 'boolean' ? ($numbers = +$numbers, true) : false) || (typeof $numbers == 'string' && !/^(?:=|true|false)/i.test($numbers) ? (tmp = calc.parse(0, 0, 0, $numbers), /^date|number|percent$/.test(tmp.type) ? ($numbers = +tmp.value, true) : false) : false))
                            ret.push($numbers);
                        return ret;
                    }.bind(this), []);
                    i = args.length;
                    xargs.push($numbers);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            {
                if (!($numbers.length >= 2 ? true : (err = 'NUM', false)))
                    return new CalcError(err);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args.slice(i));
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (numbers) {
        return _var_sp(numbers, numbers.length - 1);
    });

    defineBuiltinFunction('var.p', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                try {
                    var $numbers = this.cellValues(args.slice(i)).reduce(function (ret, $numbers) {
                        if ($numbers instanceof CalcError)
                            throw $numbers;
                        if ((typeof $numbers == 'number' ? ($numbers = limitPrecision($numbers), true) : false) || (typeof $numbers == 'boolean' ? ($numbers = +$numbers, true) : false) || (typeof $numbers == 'string' && !/^(?:=|true|false)/i.test($numbers) ? (tmp = calc.parse(0, 0, 0, $numbers), /^date|number|percent$/.test(tmp.type) ? ($numbers = +tmp.value, true) : false) : false))
                            ret.push($numbers);
                        return ret;
                    }.bind(this), []);
                    i = args.length;
                    xargs.push($numbers);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            {
                if (!($numbers.length >= 2 ? true : (err = 'NUM', false)))
                    return new CalcError(err);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args.slice(i));
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (numbers) {
        return _var_sp(numbers, numbers.length);
    });

    defineBuiltinFunction('median', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                try {
                    var $numbers = this.cellValues(args.slice(i)).reduce(function (ret, $numbers) {
                        if ($numbers instanceof CalcError)
                            throw $numbers;
                        if ((typeof $numbers == 'number' ? ($numbers = limitPrecision($numbers), true) : false) || (typeof $numbers == 'boolean' ? ($numbers = +$numbers, true) : false) || (typeof $numbers == 'string' && !/^(?:=|true|false)/i.test($numbers) ? (tmp = calc.parse(0, 0, 0, $numbers), /^date|number|percent$/.test(tmp.type) ? ($numbers = +tmp.value, true) : false) : false))
                            ret.push($numbers);
                        return ret;
                    }.bind(this), []);
                    i = args.length;
                    xargs.push($numbers);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            {
                if (!($numbers.length > 0 ? true : (err = 'N/A', false)))
                    return new CalcError(err);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args.slice(i));
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (numbers) {
        var n = numbers.length;
        numbers.sort(ascending);
        if (n % 2) {
            return numbers[n >> 1];
        }
        return (numbers[n >>= 1] + numbers[n - 1]) / 2;
    });

    defineBuiltinFunction('mode.sngl', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0;
            {
                try {
                    var $numbers = this.cellValues(args.slice(i)).reduce(function (ret, $numbers) {
                        if ($numbers instanceof CalcError)
                            throw $numbers;
                        if ((typeof $numbers == 'number' ? ($numbers = limitPrecision($numbers), true) : false) || (typeof $numbers == 'boolean' ? ($numbers = +$numbers, true) : false) || (typeof $numbers == 'string' && !/^(?:=|true|false)/i.test($numbers) ? (tmp = calc.parse(0, 0, 0, $numbers), /^date|number|percent$/.test(tmp.type) ? ($numbers = +tmp.value, true) : false) : false))
                            ret.push($numbers);
                        return ret;
                    }.bind(this), []);
                    i = args.length;
                    xargs.push($numbers);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args.slice(i));
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (numbers) {
        numbers.sort(ascending);
        var prev = null, count = 0, max = 1, mode = null;
        for (var i = 0; i < numbers.length; ++i) {
            var n = numbers[i];
            if (n != prev) {
                count = 1;
                prev = n;
            } else {
                count++;
            }
            if (count > max) {
                max = count;
                mode = n;
            }
        }
        return mode == null ? new CalcError('N/A') : mode;
    });

    defineBuiltinFunction('mode.mult', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0;
            {
                try {
                    var $numbers = this.cellValues(args.slice(i)).reduce(function (ret, $numbers) {
                        if ($numbers instanceof CalcError)
                            throw $numbers;
                        if ((typeof $numbers == 'number' ? ($numbers = limitPrecision($numbers), true) : false) || (typeof $numbers == 'boolean' ? ($numbers = +$numbers, true) : false) || (typeof $numbers == 'string' && !/^(?:=|true|false)/i.test($numbers) ? (tmp = calc.parse(0, 0, 0, $numbers), /^date|number|percent$/.test(tmp.type) ? ($numbers = +tmp.value, true) : false) : false))
                            ret.push($numbers);
                        return ret;
                    }.bind(this), []);
                    i = args.length;
                    xargs.push($numbers);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args.slice(i));
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (numbers) {
        var seen = Object.create(null), max = 2, res = [];
        numbers.forEach(function (num) {
            var s = seen[num] || 0;
            seen[num] = ++s;
            if (s == max) {
                res.push(num);
            } else if (s > max) {
                max = s;
                res = [num];
            }
        });
        var m = new Matrix(this);
        res.forEach(function (num, i) {
            m.set(i, 0, num);
        });
        return m;
    });

    defineBuiltinFunction('geomean', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                try {
                    var $numbers = this.cellValues(args.slice(i)).reduce(function (ret, $numbers) {
                        if ($numbers instanceof CalcError)
                            throw $numbers;
                        if ((typeof $numbers == 'number' ? ($numbers = limitPrecision($numbers), true) : false) || (typeof $numbers == 'boolean' ? ($numbers = +$numbers, true) : false) || (typeof $numbers == 'string' && !/^(?:=|true|false)/i.test($numbers) ? (tmp = calc.parse(0, 0, 0, $numbers), /^date|number|percent$/.test(tmp.type) ? ($numbers = +tmp.value, true) : false) : false))
                            ret.push($numbers);
                        return ret;
                    }.bind(this), []);
                    i = args.length;
                    xargs.push($numbers);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            {
                if (!($numbers.length > 0 ? true : (err = 'NUM', false)))
                    return new CalcError(err);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args.slice(i));
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (numbers) {
        var n = numbers.length;
        var p = numbers.reduce(function (p, num) {
            if (num < 0) {
                throw new CalcError('NUM');
            }
            return p * num;
        }, 1);
        return Math.pow(p, 1 / n);
    });

    defineBuiltinFunction('harmean', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                try {
                    var $numbers = this.cellValues(args.slice(i)).reduce(function (ret, $numbers) {
                        if ($numbers instanceof CalcError)
                            throw $numbers;
                        if ((typeof $numbers == 'number' ? ($numbers = limitPrecision($numbers), true) : false) || (typeof $numbers == 'boolean' ? ($numbers = +$numbers, true) : false) || (typeof $numbers == 'string' && !/^(?:=|true|false)/i.test($numbers) ? (tmp = calc.parse(0, 0, 0, $numbers), /^date|number|percent$/.test(tmp.type) ? ($numbers = +tmp.value, true) : false) : false))
                            ret.push($numbers);
                        return ret;
                    }.bind(this), []);
                    i = args.length;
                    xargs.push($numbers);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            {
                if (!($numbers.length > 0 ? true : (err = 'NUM', false)))
                    return new CalcError(err);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args.slice(i));
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (numbers) {
        var n = numbers.length;
        var s = numbers.reduce(function (s, num) {
            if (!num) {
                throw new CalcError('DIV/0');
            }
            return s + 1 / num;
        }, 0);
        return n / s;
    });

    defineBuiltinFunction('trimmean', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                try {
                    var $numbers = this.cellValues(args.slice(i, i + 1)).reduce(function (ret, $numbers) {
                        if ($numbers instanceof CalcError)
                            throw $numbers;
                        if ((typeof $numbers == 'number' ? ($numbers = limitPrecision($numbers), true) : false) || (typeof $numbers == 'boolean' ? ($numbers = +$numbers, true) : false) || (typeof $numbers == 'string' && !/^(?:=|true|false)/i.test($numbers) ? (tmp = calc.parse(0, 0, 0, $numbers), /^date|number|percent$/.test(tmp.type) ? ($numbers = +tmp.value, true) : false) : false))
                            ret.push($numbers);
                        return ret;
                    }.bind(this), []);
                    i += 1;
                    xargs.push($numbers);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            {
                var $percent = args[i++];
                if ($percent instanceof CalcError)
                    return $percent;
                if (!(((typeof ($percent = this.force($percent)) == 'number' ? ($percent = limitPrecision($percent), true) : false) || (typeof $percent == 'boolean' ? ($percent = +$percent, true) : false) || (typeof $percent == 'string' && !/^(?:=|true|false)/i.test($percent) ? (tmp = calc.parse(0, 0, 0, $percent), /^date|number|percent$/.test(tmp.type) ? ($percent = +tmp.value, true) : false) : false)) && ($percent >= 0 && $percent < 1 ? true : (err = 'NUM', false)))) {
                    if ($percent instanceof CalcError)
                        return $percent;
                    return new CalcError(err);
                }
                xargs.push($percent);
            }
            {
                if (!($numbers.length > 0 ? true : (err = 'NUM', false)))
                    return new CalcError(err);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args.slice(i));
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (numbers, p) {
        var n = numbers.length;
        numbers.sort(ascending);
        var discard = Math.floor(n * p);
        if (discard % 2) {
            --discard;
        }
        discard /= 2;
        var sum = 0;
        for (var i = discard; i < n - discard; ++i) {
            sum += numbers[i];
        }
        return sum / (n - discard * 2);
    });

    defineBuiltinFunction('frequency', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0;
            {
                try {
                    var $data = this.cellValues(args.slice(i, i + 1)).reduce(function (ret, $data) {
                        if ($data instanceof CalcError)
                            throw $data;
                        if ((typeof $data == 'number' ? ($data = limitPrecision($data), true) : false) || (typeof $data == 'boolean' ? ($data = +$data, true) : false) || (typeof $data == 'string' && !/^(?:=|true|false)/i.test($data) ? (tmp = calc.parse(0, 0, 0, $data), /^date|number|percent$/.test(tmp.type) ? ($data = +tmp.value, true) : false) : false))
                            ret.push($data);
                        return ret;
                    }.bind(this), []);
                    i += 1;
                    xargs.push($data);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            {
                try {
                    var $bins = this.cellValues(args.slice(i, i + 1)).reduce(function (ret, $bins) {
                        if ($bins instanceof CalcError)
                            throw $bins;
                        if ((typeof $bins == 'number' ? ($bins = limitPrecision($bins), true) : false) || (typeof $bins == 'boolean' ? ($bins = +$bins, true) : false) || (typeof $bins == 'string' && !/^(?:=|true|false)/i.test($bins) ? (tmp = calc.parse(0, 0, 0, $bins), /^date|number|percent$/.test(tmp.type) ? ($bins = +tmp.value, true) : false) : false))
                            ret.push($bins);
                        return ret;
                    }.bind(this), []);
                    i += 1;
                    xargs.push($bins);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args.slice(i));
            toResolve.push(args.slice(i));
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (data, bins) {
        data.sort(ascending);
        bins.sort(ascending);
        var prev = -Infinity;
        var i = 0;
        function count(max) {
            var n = 0;
            while (i < data.length && data[i] > prev && data[i] <= max) {
                ++n;
                ++i;
            }
            return n;
        }
        var m = new Matrix(this);
        bins.forEach(function (val, i) {
            var n = count(val);
            prev = val;
            m.set(i, 0, n);
        });
        m.set(m.height, 0, data.length - i);
        return m;
    });

    defineBuiltinFunction('rank.eq', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $value = args[i++];
                if ($value instanceof CalcError)
                    return $value;
                if (!((typeof ($value = this.force($value)) == 'number' ? ($value = limitPrecision($value), true) : false) || (typeof $value == 'boolean' ? ($value = +$value, true) : false) || (typeof $value == 'string' && !/^(?:=|true|false)/i.test($value) ? (tmp = calc.parse(0, 0, 0, $value), /^date|number|percent$/.test(tmp.type) ? ($value = +tmp.value, true) : false) : false))) {
                    if ($value instanceof CalcError)
                        return $value;
                    return new CalcError(err);
                }
                xargs.push($value);
            }
            {
                try {
                    var $numbers = this.cellValues(args.slice(i, i + 1)).reduce(function (ret, $numbers) {
                        if ($numbers instanceof CalcError)
                            throw $numbers;
                        if ((typeof $numbers == 'number' ? ($numbers = limitPrecision($numbers), true) : false) || (typeof $numbers == 'boolean' ? ($numbers = +$numbers, true) : false) || (typeof $numbers == 'string' && !/^(?:=|true|false)/i.test($numbers) ? (tmp = calc.parse(0, 0, 0, $numbers), /^date|number|percent$/.test(tmp.type) ? ($numbers = +tmp.value, true) : false) : false))
                            ret.push($numbers);
                        return ret;
                    }.bind(this), []);
                    i += 1;
                    xargs.push($numbers);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            {
                var $order = args[i++];
                if ($order instanceof CalcError)
                    return $order;
                if (!(typeof ($order = this.force($order)) == 'boolean' || (typeof $order == 'number' ? ($order = !!$order, true) : false) || ($order == null ? ($order = false, true) : false))) {
                    if ($order instanceof CalcError)
                        return $order;
                    return new CalcError(err);
                }
                xargs.push($order);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args.slice(i));
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (val, numbers, asc) {
        numbers.sort(asc ? ascending : descending);
        var pos = numbers.indexOf(val);
        return pos < 0 ? new CalcError('N/A') : pos + 1;
    });

    calc.runtime.defineAlias("rank", "rank.eq");

    defineBuiltinFunction('rank.avg', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $value = args[i++];
                if ($value instanceof CalcError)
                    return $value;
                if (!((typeof ($value = this.force($value)) == 'number' ? ($value = limitPrecision($value), true) : false) || (typeof $value == 'boolean' ? ($value = +$value, true) : false) || (typeof $value == 'string' && !/^(?:=|true|false)/i.test($value) ? (tmp = calc.parse(0, 0, 0, $value), /^date|number|percent$/.test(tmp.type) ? ($value = +tmp.value, true) : false) : false))) {
                    if ($value instanceof CalcError)
                        return $value;
                    return new CalcError(err);
                }
                xargs.push($value);
            }
            {
                try {
                    var $numbers = this.cellValues(args.slice(i)).reduce(function (ret, $numbers) {
                        if ($numbers instanceof CalcError)
                            throw $numbers;
                        if ((typeof $numbers == 'number' ? ($numbers = limitPrecision($numbers), true) : false) || (typeof $numbers == 'boolean' ? ($numbers = +$numbers, true) : false) || (typeof $numbers == 'string' && !/^(?:=|true|false)/i.test($numbers) ? (tmp = calc.parse(0, 0, 0, $numbers), /^date|number|percent$/.test(tmp.type) ? ($numbers = +tmp.value, true) : false) : false))
                            ret.push($numbers);
                        return ret;
                    }.bind(this), []);
                    i = args.length;
                    xargs.push($numbers);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            {
                var $order = args[i++];
                if ($order instanceof CalcError)
                    return $order;
                if (!(typeof ($order = this.force($order)) == 'boolean' || (typeof $order == 'number' ? ($order = !!$order, true) : false) || ($order == null ? ($order = false, true) : false))) {
                    if ($order instanceof CalcError)
                        return $order;
                    return new CalcError(err);
                }
                xargs.push($order);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args.slice(i));
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (val, numbers, asc) {
        numbers.sort(asc ? ascending : descending);
        var pos = numbers.indexOf(val);
        if (pos < 0) {
            return new CalcError('N/A');
        }
        for (var i = pos; numbers[i] == val; ++i);
        return (pos + i + 1) / 2;
    });

    // formula available at https://support.office.microsoft.com/en-us/article/KURT-function-cbbc2312-dfa6-4cc4-b5c0-1b3c59cc9377
    defineBuiltinFunction('kurt', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                try {
                    var $numbers = this.cellValues(args.slice(i)).reduce(function (ret, $numbers) {
                        if ($numbers instanceof CalcError)
                            throw $numbers;
                        if ((typeof $numbers == 'number' ? ($numbers = limitPrecision($numbers), true) : false) || (typeof $numbers == 'boolean' ? ($numbers = +$numbers, true) : false) || (typeof $numbers == 'string' && !/^(?:=|true|false)/i.test($numbers) ? (tmp = calc.parse(0, 0, 0, $numbers), /^date|number|percent$/.test(tmp.type) ? ($numbers = +tmp.value, true) : false) : false))
                            ret.push($numbers);
                        return ret;
                    }.bind(this), []);
                    i = args.length;
                    xargs.push($numbers);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            {
                if (!($numbers.length >= 4 ? true : (err = 'NUM', false)))
                    return new CalcError(err);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args.slice(i));
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (numbers) {
        var n = numbers.length;
        var avg = _avg(numbers);
        var variance = _var_sp(numbers, n - 1, avg);
        var stddev = Math.sqrt(variance);
        var sum = numbers.reduce(function (sum, num) {
            return sum + Math.pow((num - avg) / stddev, 4);
        }, 0);
        return n * (n + 1) / ((n - 1) * (n - 2) * (n - 3)) * sum - 3 * Math.pow(n - 1, 2) / ((n - 2) * (n - 3));
    });

    function _percentrank(numbers, x, exc) {
        var nlt = 0, ngt = 0, left = null, right = null, found = false;
        numbers.forEach(function(num){
            if (num < x) {
                nlt++;
                left = left == null ? num : Math.max(left, num);
            } else if (num > x) {
                ngt++;
                right = right == null ? num : Math.min(right, num);
            } else {
                found = true;
            }
        });
        if (!nlt && !ngt) {
            return new CalcError("N/A");
        }
        if (found) {
            if (exc) {
                return (nlt + 1) / (numbers.length + 1);
            }
            return nlt / (nlt + ngt);
        }
        return ((right - x) * _percentrank(numbers, left, exc) +
                (x - left) * _percentrank(numbers, right, exc)) / (right - left);
    }

    defineBuiltinFunction('percentrank.inc', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                try {
                    var $array = this.cellValues(args.slice(i, i + 1)).reduce(function (ret, $array) {
                        if ($array instanceof CalcError)
                            throw $array;
                        if ((typeof $array == 'number' ? ($array = limitPrecision($array), true) : false) || (typeof $array == 'boolean' ? ($array = +$array, true) : false) || (typeof $array == 'string' && !/^(?:=|true|false)/i.test($array) ? (tmp = calc.parse(0, 0, 0, $array), /^date|number|percent$/.test(tmp.type) ? ($array = +tmp.value, true) : false) : false))
                            ret.push($array);
                        return ret;
                    }.bind(this), []);
                    i += 1;
                    xargs.push($array);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            {
                var $x = args[i++];
                if ($x instanceof CalcError)
                    return $x;
                if (!((typeof ($x = this.force($x)) == 'number' ? ($x = limitPrecision($x), true) : false) || (typeof $x == 'boolean' ? ($x = +$x, true) : false) || (typeof $x == 'string' && !/^(?:=|true|false)/i.test($x) ? (tmp = calc.parse(0, 0, 0, $x), /^date|number|percent$/.test(tmp.type) ? ($x = +tmp.value, true) : false) : false))) {
                    if ($x instanceof CalcError)
                        return $x;
                    return new CalcError(err);
                }
                xargs.push($x);
            }
            {
                var $significance = args[i++];
                if ($significance instanceof CalcError)
                    return $significance;
                if (!((($significance = this.force($significance)) == null ? ($significance = 3, true) : false) || (typeof $significance == 'number' || (typeof $significance == 'boolean' ? ($significance = +$significance, true) : false) || (typeof $significance == 'string' && !/^(?:=|true|false)/i.test($significance) ? (tmp = calc.parse(0, 0, 0, $significance), /^date|number|percent$/.test(tmp.type) ? ($significance = +tmp.value, true) : false) : false)) && (($significance |= 0) > 0 ? true : (err = 'NUM', false)))) {
                    if ($significance instanceof CalcError)
                        return $significance;
                    return new CalcError(err);
                }
                xargs.push($significance);
            }
            {
                if (!($array.length > 0 ? true : (err = 'NUM', false)))
                    return new CalcError(err);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args.slice(i));
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (numbers, x, significance) {
        var p = _percentrank(numbers, x, 0);
        p = p.toFixed(significance + 1);
        return parseFloat(p.substr(0, p.length - 1));
    });

    defineBuiltinFunction('percentrank.exc', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                try {
                    var $array = this.cellValues(args.slice(i, i + 1)).reduce(function (ret, $array) {
                        if ($array instanceof CalcError)
                            throw $array;
                        if ((typeof $array == 'number' ? ($array = limitPrecision($array), true) : false) || (typeof $array == 'boolean' ? ($array = +$array, true) : false) || (typeof $array == 'string' && !/^(?:=|true|false)/i.test($array) ? (tmp = calc.parse(0, 0, 0, $array), /^date|number|percent$/.test(tmp.type) ? ($array = +tmp.value, true) : false) : false))
                            ret.push($array);
                        return ret;
                    }.bind(this), []);
                    i += 1;
                    xargs.push($array);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            {
                var $x = args[i++];
                if ($x instanceof CalcError)
                    return $x;
                if (!((typeof ($x = this.force($x)) == 'number' ? ($x = limitPrecision($x), true) : false) || (typeof $x == 'boolean' ? ($x = +$x, true) : false) || (typeof $x == 'string' && !/^(?:=|true|false)/i.test($x) ? (tmp = calc.parse(0, 0, 0, $x), /^date|number|percent$/.test(tmp.type) ? ($x = +tmp.value, true) : false) : false))) {
                    if ($x instanceof CalcError)
                        return $x;
                    return new CalcError(err);
                }
                xargs.push($x);
            }
            {
                var $significance = args[i++];
                if ($significance instanceof CalcError)
                    return $significance;
                if (!((($significance = this.force($significance)) == null ? ($significance = 3, true) : false) || (typeof $significance == 'number' || (typeof $significance == 'boolean' ? ($significance = +$significance, true) : false) || (typeof $significance == 'string' && !/^(?:=|true|false)/i.test($significance) ? (tmp = calc.parse(0, 0, 0, $significance), /^date|number|percent$/.test(tmp.type) ? ($significance = +tmp.value, true) : false) : false)) && (($significance |= 0) > 0 ? true : (err = 'NUM', false)))) {
                    if ($significance instanceof CalcError)
                        return $significance;
                    return new CalcError(err);
                }
                xargs.push($significance);
            }
            {
                if (!($array.length > 0 ? true : (err = 'NUM', false)))
                    return new CalcError(err);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args.slice(i));
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (numbers, x, significance) {
        var p = _percentrank(numbers, x, 1);
        p = p.toFixed(significance + 1);
        return parseFloat(p.substr(0, p.length - 1));
    });

    calc.runtime.defineAlias("percentrank", "percentrank.inc");

    function _covariance(x, y, divisor) {
        var sum = 0;
        var ax = _avg(x);
        var ay = _avg(y);
        var n = x.length;
        for (var i = 0; i < n; ++i) {
            sum += (x[i] - ax) * (y[i] - ay);
        }
        return sum / divisor;
    }

    defineBuiltinFunction('covariance.p', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                try {
                    var $array1 = this.cellValues(args.slice(i, i + 1)).reduce(function (ret, $array1) {
                        if ($array1 instanceof CalcError)
                            throw $array1;
                        if ((typeof $array1 == 'number' ? ($array1 = limitPrecision($array1), true) : false) || (typeof $array1 == 'boolean' ? ($array1 = +$array1, true) : false) || (typeof $array1 == 'string' && !/^(?:=|true|false)/i.test($array1) ? (tmp = calc.parse(0, 0, 0, $array1), /^date|number|percent$/.test(tmp.type) ? ($array1 = +tmp.value, true) : false) : false))
                            ret.push($array1);
                        return ret;
                    }.bind(this), []);
                    i += 1;
                    xargs.push($array1);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            {
                try {
                    var $array2 = this.cellValues(args.slice(i, i + 1)).reduce(function (ret, $array2) {
                        if ($array2 instanceof CalcError)
                            throw $array2;
                        if ((typeof $array2 == 'number' ? ($array2 = limitPrecision($array2), true) : false) || (typeof $array2 == 'boolean' ? ($array2 = +$array2, true) : false) || (typeof $array2 == 'string' && !/^(?:=|true|false)/i.test($array2) ? (tmp = calc.parse(0, 0, 0, $array2), /^date|number|percent$/.test(tmp.type) ? ($array2 = +tmp.value, true) : false) : false))
                            ret.push($array2);
                        return ret;
                    }.bind(this), []);
                    i += 1;
                    xargs.push($array2);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            {
                if (!($array1.length == $array2.length ? true : (err = 'N/A', false)))
                    return new CalcError(err);
            }
            {
                if (!($array1.length > 0 ? true : (err = 'DIV/0', false)))
                    return new CalcError(err);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args.slice(i));
            toResolve.push(args.slice(i));
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (x, y) {
        return _covariance(x, y, x.length);
    });

    defineBuiltinFunction('covariance.s', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                try {
                    var $array1 = this.cellValues(args.slice(i, i + 1)).reduce(function (ret, $array1) {
                        if ($array1 instanceof CalcError)
                            throw $array1;
                        if ((typeof $array1 == 'number' ? ($array1 = limitPrecision($array1), true) : false) || (typeof $array1 == 'boolean' ? ($array1 = +$array1, true) : false) || (typeof $array1 == 'string' && !/^(?:=|true|false)/i.test($array1) ? (tmp = calc.parse(0, 0, 0, $array1), /^date|number|percent$/.test(tmp.type) ? ($array1 = +tmp.value, true) : false) : false))
                            ret.push($array1);
                        return ret;
                    }.bind(this), []);
                    i += 1;
                    xargs.push($array1);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            {
                try {
                    var $array2 = this.cellValues(args.slice(i, i + 1)).reduce(function (ret, $array2) {
                        if ($array2 instanceof CalcError)
                            throw $array2;
                        if ((typeof $array2 == 'number' ? ($array2 = limitPrecision($array2), true) : false) || (typeof $array2 == 'boolean' ? ($array2 = +$array2, true) : false) || (typeof $array2 == 'string' && !/^(?:=|true|false)/i.test($array2) ? (tmp = calc.parse(0, 0, 0, $array2), /^date|number|percent$/.test(tmp.type) ? ($array2 = +tmp.value, true) : false) : false))
                            ret.push($array2);
                        return ret;
                    }.bind(this), []);
                    i += 1;
                    xargs.push($array2);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            {
                if (!($array1.length == $array2.length ? true : (err = 'N/A', false)))
                    return new CalcError(err);
            }
            {
                if (!($array1.length > 1 ? true : (err = 'DIV/0', false)))
                    return new CalcError(err);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args.slice(i));
            toResolve.push(args.slice(i));
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (x, y) {
        return _covariance(x, y, x.length - 1);
    });

    calc.runtime.defineAlias("covar", "covariance.p");

    /* -----[ Factorials ]----- */

    var _fact = memoize(function(n){
        for (var i = 2, fact = 1; i <= n; ++i) {
            fact *= i;
        }
        return fact;
    });

    defineBuiltinFunction('fact', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $n = args[i++];
                if ($n instanceof CalcError)
                    return $n;
                if (!((typeof ($n = this.force($n)) == 'number' || (typeof $n == 'boolean' ? ($n = +$n, true) : false) || (typeof $n == 'string' && !/^(?:=|true|false)/i.test($n) ? (tmp = calc.parse(0, 0, 0, $n), /^date|number|percent$/.test(tmp.type) ? ($n = +tmp.value, true) : false) : false)) && (($n |= 0) >= 0 ? true : (err = 'NUM', false)))) {
                    if ($n instanceof CalcError)
                        return $n;
                    return new CalcError(err);
                }
                xargs.push($n);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $n = this._arrayArg(args[i]);
            if ($n) {
                xargs.push($n);
                width = Math.max(width, $n.width);
                height = Math.max(height, $n.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), _fact);

    defineBuiltinFunction('factdouble', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $n = args[i++];
                if ($n instanceof CalcError)
                    return $n;
                if (!((typeof ($n = this.force($n)) == 'number' || (typeof $n == 'boolean' ? ($n = +$n, true) : false) || (typeof $n == 'string' && !/^(?:=|true|false)/i.test($n) ? (tmp = calc.parse(0, 0, 0, $n), /^date|number|percent$/.test(tmp.type) ? ($n = +tmp.value, true) : false) : false)) && (($n |= 0) >= 0 ? true : (err = 'NUM', false)))) {
                    if ($n instanceof CalcError)
                        return $n;
                    return new CalcError(err);
                }
                xargs.push($n);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $n = this._arrayArg(args[i]);
            if ($n) {
                xargs.push($n);
                width = Math.max(width, $n.width);
                height = Math.max(height, $n.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (n) {
        for (var i = 2 + (n & 1), fact = 1; i <= n; i += 2) {
            fact *= i;
        }
        return fact;
    });

    defineBuiltinFunction('multinomial', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0;
            {
                try {
                    var $numbers = this.cellValues(args.slice(i)).reduce(function (ret, $numbers) {
                        if ($numbers instanceof CalcError)
                            throw $numbers;
                        if ((typeof $numbers == 'number' ? ($numbers = limitPrecision($numbers), true) : false) || (typeof $numbers == 'boolean' ? ($numbers = +$numbers, true) : false) || (typeof $numbers == 'string' && !/^(?:=|true|false)/i.test($numbers) ? (tmp = calc.parse(0, 0, 0, $numbers), /^date|number|percent$/.test(tmp.type) ? ($numbers = +tmp.value, true) : false) : false))
                            ret.push($numbers);
                        return ret;
                    }.bind(this), []);
                    i = args.length;
                    xargs.push($numbers);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args.slice(i));
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (numbers) {
        var div = 1, sum = 0;
        numbers.forEach(function (n) {
            if (n < 0) {
                throw new CalcError('NUM');
            }
            sum += n;
            div *= _fact(n);
        });
        return _fact(sum) / div;
    });

    var _combinations = memoize(function(n, k){
        for (var f1 = k + 1, f2 = 1, p1 = 1, p2 = 1; f2 <= n - k; ++f1, ++f2) {
            p1 *= f1;
            p2 *= f2;
        }
        return p1/p2;
    });

    defineBuiltinFunction('combin', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $n = args[i++];
                if ($n instanceof CalcError)
                    return $n;
                if (!((typeof ($n = this.force($n)) == 'number' || (typeof $n == 'boolean' ? ($n = +$n, true) : false) || (typeof $n == 'string' && !/^(?:=|true|false)/i.test($n) ? (tmp = calc.parse(0, 0, 0, $n), /^date|number|percent$/.test(tmp.type) ? ($n = +tmp.value, true) : false) : false)) && (($n |= 0) > 0 ? true : (err = 'NUM', false)))) {
                    if ($n instanceof CalcError)
                        return $n;
                    return new CalcError(err);
                }
                xargs.push($n);
            }
            {
                var $k = args[i++];
                if ($k instanceof CalcError)
                    return $k;
                if (!((typeof ($k = this.force($k)) == 'number' || (typeof $k == 'boolean' ? ($k = +$k, true) : false) || (typeof $k == 'string' && !/^(?:=|true|false)/i.test($k) ? (tmp = calc.parse(0, 0, 0, $k), /^date|number|percent$/.test(tmp.type) ? ($k = +tmp.value, true) : false) : false)) && ($k |= 0, true) && ($k >= 0 && $k <= $n ? true : (err = 'NUM', false)))) {
                    if ($k instanceof CalcError)
                        return $k;
                    return new CalcError(err);
                }
                xargs.push($k);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $n = this._arrayArg(args[i]);
            if ($n) {
                xargs.push($n);
                width = Math.max(width, $n.width);
                height = Math.max(height, $n.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $k = this._arrayArg(args[i]);
            if ($k) {
                xargs.push($k);
                width = Math.max(width, $k.width);
                height = Math.max(height, $k.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), _combinations);

    defineBuiltinFunction('combina', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $n = args[i++];
                if ($n instanceof CalcError)
                    return $n;
                if (!((typeof ($n = this.force($n)) == 'number' || (typeof $n == 'boolean' ? ($n = +$n, true) : false) || (typeof $n == 'string' && !/^(?:=|true|false)/i.test($n) ? (tmp = calc.parse(0, 0, 0, $n), /^date|number|percent$/.test(tmp.type) ? ($n = +tmp.value, true) : false) : false)) && (($n |= 0) > 0 ? true : (err = 'NUM', false)))) {
                    if ($n instanceof CalcError)
                        return $n;
                    return new CalcError(err);
                }
                xargs.push($n);
            }
            {
                var $k = args[i++];
                if ($k instanceof CalcError)
                    return $k;
                if (!((typeof ($k = this.force($k)) == 'number' || (typeof $k == 'boolean' ? ($k = +$k, true) : false) || (typeof $k == 'string' && !/^(?:=|true|false)/i.test($k) ? (tmp = calc.parse(0, 0, 0, $k), /^date|number|percent$/.test(tmp.type) ? ($k = +tmp.value, true) : false) : false)) && ($k |= 0, true) && ($k >= 1 && $k <= $n ? true : (err = 'NUM', false)))) {
                    if ($k instanceof CalcError)
                        return $k;
                    return new CalcError(err);
                }
                xargs.push($k);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $n = this._arrayArg(args[i]);
            if ($n) {
                xargs.push($n);
                width = Math.max(width, $n.width);
                height = Math.max(height, $n.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $k = this._arrayArg(args[i]);
            if ($k) {
                xargs.push($k);
                width = Math.max(width, $k.width);
                height = Math.max(height, $k.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (n, k) {
        return _combinations(n + k - 1, n - 1);
    });

    /* -----[ Statistical functions ]----- */

    defineBuiltinFunction('average', false, function () {
        function check(args) {
            var xargs = [], i = 0, err = 'VALUE';
            {
                try {
                    var $numbers = this.cellValues(args.slice(i)).reduce(function (ret, $numbers) {
                        if ($numbers instanceof CalcError)
                            throw $numbers;
                        if (typeof $numbers == 'number' ? ($numbers = limitPrecision($numbers), true) : false)
                            ret.push($numbers);
                        return ret;
                    }.bind(this), []);
                    i = args.length;
                    xargs.push($numbers);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            {
                if (!($numbers.length > 0 ? true : (err = 'DIV/0', false)))
                    return new CalcError(err);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args.slice(i));
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (numbers) {
        var sum = numbers.reduce(function (sum, num) {
            return sum + num;
        }, 0);
        return sum / numbers.length;
    });

    defineBuiltinFunction('averagea', false, function () {
        function check(args) {
            var xargs = [], i = 0;
            {
                try {
                    var $values = this.cellValues(args.slice(i)).reduce(function (ret, $values) {
                        if ($values instanceof CalcError)
                            throw $values;
                        if ($values != null && i <= args.length)
                            ret.push($values);
                        return ret;
                    }.bind(this), []);
                    i = args.length;
                    xargs.push($values);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args.slice(i));
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (values) {
        var sum = 0, count = 0;
        values.forEach(function (num) {
            if (typeof num != 'string') {
                sum += num;
            }
            ++count;
        });
        return count ? sum / count : new CalcError('DIV/0');
    });

    function _percentile(numbers, rank) {
        numbers.sort(ascending);
        var n = numbers.length;
        var k = rank | 0, d = rank - k;
        if (k === 0) {
            return numbers[0];
        }
        if (k >= n) {
            return numbers[n - 1];
        }
        --k;
        return numbers[k] + d * (numbers[k + 1] - numbers[k]);
    }

    function _percentile_inc(numbers, p){
        // algorithm from https://en.wikipedia.org/wiki/Percentile#Microsoft_Excel_method
        var rank = p * (numbers.length - 1) + 1;
        return _percentile(numbers, rank);
    }

    function _percentile_exc(numbers, p){
        // https://en.wikipedia.org/wiki/Percentile#NIST_method
        var rank = p * (numbers.length + 1);
        return _percentile(numbers, rank);
    }

    defineBuiltinFunction('percentile.inc', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                try {
                    var $numbers = this.cellValues(args.slice(i, i + 1)).reduce(function (ret, $numbers) {
                        if ($numbers instanceof CalcError)
                            throw $numbers;
                        if ((typeof $numbers == 'number' ? ($numbers = limitPrecision($numbers), true) : false) || (typeof $numbers == 'boolean' ? ($numbers = +$numbers, true) : false) || (typeof $numbers == 'string' && !/^(?:=|true|false)/i.test($numbers) ? (tmp = calc.parse(0, 0, 0, $numbers), /^date|number|percent$/.test(tmp.type) ? ($numbers = +tmp.value, true) : false) : false))
                            ret.push($numbers);
                        return ret;
                    }.bind(this), []);
                    i += 1;
                    xargs.push($numbers);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            {
                var $p = args[i++];
                if ($p instanceof CalcError)
                    return $p;
                if (!(((typeof ($p = this.force($p)) == 'number' ? ($p = limitPrecision($p), true) : false) || (typeof $p == 'boolean' ? ($p = +$p, true) : false) || (typeof $p == 'string' && !/^(?:=|true|false)/i.test($p) ? (tmp = calc.parse(0, 0, 0, $p), /^date|number|percent$/.test(tmp.type) ? ($p = +tmp.value, true) : false) : false)) && ($p >= 0 && $p <= 1 ? true : (err = 'NUM', false)))) {
                    if ($p instanceof CalcError)
                        return $p;
                    return new CalcError(err);
                }
                xargs.push($p);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args.slice(i));
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), _percentile_inc);

    defineBuiltinFunction('percentile.exc', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                try {
                    var $numbers = this.cellValues(args.slice(i, i + 1)).reduce(function (ret, $numbers) {
                        if ($numbers instanceof CalcError)
                            throw $numbers;
                        if ((typeof $numbers == 'number' ? ($numbers = limitPrecision($numbers), true) : false) || (typeof $numbers == 'boolean' ? ($numbers = +$numbers, true) : false) || (typeof $numbers == 'string' && !/^(?:=|true|false)/i.test($numbers) ? (tmp = calc.parse(0, 0, 0, $numbers), /^date|number|percent$/.test(tmp.type) ? ($numbers = +tmp.value, true) : false) : false))
                            ret.push($numbers);
                        return ret;
                    }.bind(this), []);
                    i += 1;
                    xargs.push($numbers);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            {
                var $p = args[i++];
                if ($p instanceof CalcError)
                    return $p;
                if (!(((typeof ($p = this.force($p)) == 'number' ? ($p = limitPrecision($p), true) : false) || (typeof $p == 'boolean' ? ($p = +$p, true) : false) || (typeof $p == 'string' && !/^(?:=|true|false)/i.test($p) ? (tmp = calc.parse(0, 0, 0, $p), /^date|number|percent$/.test(tmp.type) ? ($p = +tmp.value, true) : false) : false)) && ($p > 0 && $p < 1 ? true : (err = 'NUM', false)))) {
                    if ($p instanceof CalcError)
                        return $p;
                    return new CalcError(err);
                }
                xargs.push($p);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args.slice(i));
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), _percentile_exc);

    defineBuiltinFunction('quartile.inc', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                try {
                    var $numbers = this.cellValues(args.slice(i, i + 1)).reduce(function (ret, $numbers) {
                        if ($numbers instanceof CalcError)
                            throw $numbers;
                        if ((typeof $numbers == 'number' ? ($numbers = limitPrecision($numbers), true) : false) || (typeof $numbers == 'boolean' ? ($numbers = +$numbers, true) : false) || (typeof $numbers == 'string' && !/^(?:=|true|false)/i.test($numbers) ? (tmp = calc.parse(0, 0, 0, $numbers), /^date|number|percent$/.test(tmp.type) ? ($numbers = +tmp.value, true) : false) : false))
                            ret.push($numbers);
                        return ret;
                    }.bind(this), []);
                    i += 1;
                    xargs.push($numbers);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            {
                var $quarter = args[i++];
                if ($quarter instanceof CalcError)
                    return $quarter;
                if (!(($quarter = this.force($quarter)) === 0 || $quarter === 1 || $quarter === 2 || $quarter === 3 || $quarter === 4)) {
                    if ($quarter instanceof CalcError)
                        return $quarter;
                    return new CalcError(err);
                }
                xargs.push($quarter);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args.slice(i));
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (numbers, quarter) {
        return _percentile_inc(numbers, quarter / 4);
    });

    defineBuiltinFunction('quartile.exc', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                try {
                    var $numbers = this.cellValues(args.slice(i, i + 1)).reduce(function (ret, $numbers) {
                        if ($numbers instanceof CalcError)
                            throw $numbers;
                        if ((typeof $numbers == 'number' ? ($numbers = limitPrecision($numbers), true) : false) || (typeof $numbers == 'boolean' ? ($numbers = +$numbers, true) : false) || (typeof $numbers == 'string' && !/^(?:=|true|false)/i.test($numbers) ? (tmp = calc.parse(0, 0, 0, $numbers), /^date|number|percent$/.test(tmp.type) ? ($numbers = +tmp.value, true) : false) : false))
                            ret.push($numbers);
                        return ret;
                    }.bind(this), []);
                    i += 1;
                    xargs.push($numbers);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            {
                var $quarter = args[i++];
                if ($quarter instanceof CalcError)
                    return $quarter;
                if (!(($quarter = this.force($quarter)) === 0 || $quarter === 1 || $quarter === 2 || $quarter === 3 || $quarter === 4)) {
                    if ($quarter instanceof CalcError)
                        return $quarter;
                    return new CalcError(err);
                }
                xargs.push($quarter);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args.slice(i));
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (numbers, quarter) {
        return _percentile_exc(numbers, quarter / 4);
    });

    calc.runtime.defineAlias("quartile", "quartile.inc");
    calc.runtime.defineAlias("percentile", "percentile.inc");

    var AGGREGATE_FUNCS = [
        "AVERAGE", "COUNT", "COUNTA", "MAX", "MIN", "PRODUCT",
        "STDEV.S", "STDEV.P", "SUM", "VAR.S", "VAR.P", "MEDIAN",
        "MODE.SNGL", "LARGE", "SMALL", "PERCENTILE.INC",
        "QUARTILE.INC", "PERCENTILE.EXC", "QUARTILE.EXC"
    ];

    function fetchValuesForAggregate(self, args, options) {
        var values = [];
        var opt_ignore_hidden_rows = 1;
        var opt_ignore_errors = 2;
        var opt_use_aggregates = 4;
        (function fetchValues(args) {
            if (args instanceof Ref) {
                self.getRefCells(args, true).forEach(function(cell){
                    var value = cell.value;
                    if ((options & opt_ignore_hidden_rows) && cell.hidden) {
                        return;
                    }
                    if (cell.formula) {
                        // XXX: formula.print is fast, but still, can't we do any better here?
                        //      perhaps access the input string directly somehow?
                        var str = cell.formula.print(cell.row, cell.col);
                        if (/^\s*(?:aggregate|subtotal)\s*\(/i.test(str)) {
                            if (!(options & opt_use_aggregates)) {
                                return;
                            }
                        }
                    }
                    if ((options & opt_ignore_errors) && value instanceof CalcError) {
                        return;
                    }
                    if (typeof value == "number" || value instanceof CalcError) {
                        values.push(value);
                    }
                });
            } else if (Array.isArray(args)) {
                for (var i = 0; i < args.length; ++i) {
                    fetchValues(args[i]);
                }
            } else if (args instanceof Matrix) {
                args.each(fetchValues);
            } else if (typeof args == "number") {
                values.push(args);
            } else if (args instanceof CalcError && !(options & opt_ignore_errors)) {
                values.push(args);
            }
        })(args);
        return values;
    }

    // AGGREGATE function
    //
    // https://support.office.com/en-SG/article/aggregate-function-c8caed56-07df-4aeb-9741-23693ffbe525
    //
    // we can only partially type-check this function.  also, we need to use the async version in
    // order to resolve references and delegate values to the function to aggregate.
    defineBuiltinFunction('aggregate', true, function () {
        function check(args) {
            var xargs = [], i = 0, err = 'VALUE';
            {
                var $funcId = args[i++];
                if ($funcId instanceof CalcError)
                    return $funcId;
                if (!(($funcId = this.force($funcId)) === 1 || $funcId === 2 || $funcId === 3 || $funcId === 4 || $funcId === 5 || $funcId === 6 || $funcId === 7 || $funcId === 8 || $funcId === 9 || $funcId === 10 || $funcId === 11 || $funcId === 12 || $funcId === 13 || $funcId === 14 || $funcId === 15 || $funcId === 16 || $funcId === 17 || $funcId === 18 || $funcId === 19)) {
                    if ($funcId instanceof CalcError)
                        return $funcId;
                    return new CalcError(err);
                }
                xargs.push($funcId);
            }
            {
                var $options = args[i++];
                if ($options instanceof CalcError)
                    return $options;
                if (!((($options = this.force($options)) == null ? ($options = 0, true) : false) || ($options === 0 || $options === 1 || $options === 2 || $options === 3 || $options === 4 || $options === 5 || $options === 6 || $options === 7))) {
                    if ($options instanceof CalcError)
                        return $options;
                    return new CalcError(err);
                }
                xargs.push($options);
            }
            {
                xargs.push(args.slice(i));
                i = args.length;
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (callback, funcId, options, args) {
        var self = this;
        self.resolveCells(args, function () {
            var values;
            if (funcId > 12) {
                values = fetchValuesForAggregate(self, args[0], options);
                var k = args[1];
                if (k instanceof CellRef) {
                    k = self.getRefData(k);
                }
                if (typeof k != 'number') {
                    return callback(new CalcError('VALUE'));
                }
            } else {
                values = fetchValuesForAggregate(self, args, options);
            }
            self.func(AGGREGATE_FUNCS[funcId - 1], callback, values);
        });
    });

    defineBuiltinFunction('subtotal', true, function () {
        function check(args) {
            var stack = [], tmp, xargs = [], i = 0, m, err = 'VALUE';
            {
                var $funcId = args[i++];
                if ($funcId instanceof CalcError)
                    return $funcId;
                if (!(($funcId = this.force($funcId)) === 1 || $funcId === 2 || $funcId === 3 || $funcId === 4 || $funcId === 5 || $funcId === 6 || $funcId === 7 || $funcId === 8 || $funcId === 9 || $funcId === 10 || $funcId === 11 || $funcId === 101 || $funcId === 102 || $funcId === 103 || $funcId === 104 || $funcId === 105 || $funcId === 106 || $funcId === 107 || $funcId === 108 || $funcId === 109 || $funcId === 110 || $funcId === 111)) {
                    if ($funcId instanceof CalcError)
                        return $funcId;
                    return new CalcError(err);
                }
                xargs.push($funcId);
            }
            {
                if (i >= args.length)
                    return new CalcError('N/A');
                xargs.push(tmp = []);
                stack.push(xargs);
                xargs = tmp;
                do {
                    {
                        var $ref = args[i++];
                        if ($ref instanceof CalcError)
                            return $ref;
                        if (!($ref instanceof Ref || ((m = this.asMatrix($ref)) ? $ref = m : false))) {
                            return new CalcError(err);
                        }
                        xargs.push($ref);
                    }
                } while (i < args.length);
                xargs = stack.pop();
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            while (i < args.length) {
                i++;
            }
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (callback, funcId) {
        var self = this;
        var ignoreHidden = funcId > 100;
        if (ignoreHidden) {
            funcId -= 100;
        }
        var args = [];
        for (var i = 2; i < arguments.length; ++i) {
            args.push(arguments[i]);
        }
        self.resolveCells(args, function () {
            var values = fetchValuesForAggregate(self, args, ignoreHidden ? 1 : 0);
            self.func(AGGREGATE_FUNCS[funcId - 1], callback, values);
        });
    });

    // https://support.office.com/en-sg/article/AVEDEV-function-ec78fa01-4755-466c-9a2b-0c4f9eacaf6d
    defineBuiltinFunction('avedev', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                try {
                    var $numbers = this.cellValues(args.slice(i)).reduce(function (ret, $numbers) {
                        if ($numbers instanceof CalcError)
                            throw $numbers;
                        if ((typeof $numbers == 'number' ? ($numbers = limitPrecision($numbers), true) : false) || (typeof $numbers == 'boolean' ? ($numbers = +$numbers, true) : false) || (typeof $numbers == 'string' && !/^(?:=|true|false)/i.test($numbers) ? (tmp = calc.parse(0, 0, 0, $numbers), /^date|number|percent$/.test(tmp.type) ? ($numbers = +tmp.value, true) : false) : false))
                            ret.push($numbers);
                        return ret;
                    }.bind(this), []);
                    i = args.length;
                    xargs.push($numbers);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            {
                if (!($numbers.length >= 2 ? true : (err = 'NUM', false)))
                    return new CalcError(err);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args.slice(i));
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (numbers) {
        var avg = numbers.reduce(function (sum, num) {
            return sum + num;
        }, 0) / numbers.length;
        return numbers.reduce(function (sum, num) {
            return sum + Math.abs(num - avg);
        }, 0) / numbers.length;
    });

    function _binom_dist(x, n, p, cumulative) {
        if (!cumulative) {
            return _combinations(n, x) * Math.pow(p, x) * Math.pow(1-p, n-x);
        } else {
            var sum = 0;
            for (var j = 0; j <= x; ++j) {
                sum += _combinations(n, j) * Math.pow(p, j) * Math.pow(1-p, n-j);
            }
            return sum;
        }
    }

    defineBuiltinFunction('binom.dist', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $successes = args[i++];
                if ($successes instanceof CalcError)
                    return $successes;
                if (!((typeof ($successes = this.force($successes)) == 'number' || (typeof $successes == 'boolean' ? ($successes = +$successes, true) : false) || (typeof $successes == 'string' && !/^(?:=|true|false)/i.test($successes) ? (tmp = calc.parse(0, 0, 0, $successes), /^date|number|percent$/.test(tmp.type) ? ($successes = +tmp.value, true) : false) : false)) && (($successes |= 0) >= 0 ? true : (err = 'NUM', false)))) {
                    if ($successes instanceof CalcError)
                        return $successes;
                    return new CalcError(err);
                }
                xargs.push($successes);
            }
            {
                var $trials = args[i++];
                if ($trials instanceof CalcError)
                    return $trials;
                if (!((typeof ($trials = this.force($trials)) == 'number' || (typeof $trials == 'boolean' ? ($trials = +$trials, true) : false) || (typeof $trials == 'string' && !/^(?:=|true|false)/i.test($trials) ? (tmp = calc.parse(0, 0, 0, $trials), /^date|number|percent$/.test(tmp.type) ? ($trials = +tmp.value, true) : false) : false)) && ($trials |= 0, true) && ($trials >= $successes ? true : (err = 'N/A', false)))) {
                    if ($trials instanceof CalcError)
                        return $trials;
                    return new CalcError(err);
                }
                xargs.push($trials);
            }
            {
                var $probability = args[i++];
                if ($probability instanceof CalcError)
                    return $probability;
                if (!(((typeof ($probability = this.force($probability)) == 'number' ? ($probability = limitPrecision($probability), true) : false) || (typeof $probability == 'boolean' ? ($probability = +$probability, true) : false) || (typeof $probability == 'string' && !/^(?:=|true|false)/i.test($probability) ? (tmp = calc.parse(0, 0, 0, $probability), /^date|number|percent$/.test(tmp.type) ? ($probability = +tmp.value, true) : false) : false)) && ($probability >= 0 && $probability <= 1 ? true : (err = 'NUM', false)))) {
                    if ($probability instanceof CalcError)
                        return $probability;
                    return new CalcError(err);
                }
                xargs.push($probability);
            }
            {
                var $cumulative = args[i++];
                if ($cumulative instanceof CalcError)
                    return $cumulative;
                if (!(typeof ($cumulative = this.force($cumulative)) == 'boolean' || (typeof $cumulative == 'number' ? ($cumulative = !!$cumulative, true) : false))) {
                    if ($cumulative instanceof CalcError)
                        return $cumulative;
                    return new CalcError(err);
                }
                xargs.push($cumulative);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), _binom_dist);

    calc.runtime.defineAlias("binomdist", "binom.dist");

    defineBuiltinFunction('binom.inv', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $trials = args[i++];
                if ($trials instanceof CalcError)
                    return $trials;
                if (!((typeof ($trials = this.force($trials)) == 'number' || (typeof $trials == 'boolean' ? ($trials = +$trials, true) : false) || (typeof $trials == 'string' && !/^(?:=|true|false)/i.test($trials) ? (tmp = calc.parse(0, 0, 0, $trials), /^date|number|percent$/.test(tmp.type) ? ($trials = +tmp.value, true) : false) : false)) && (($trials |= 0) >= 0 ? true : (err = 'NUM', false)))) {
                    if ($trials instanceof CalcError)
                        return $trials;
                    return new CalcError(err);
                }
                xargs.push($trials);
            }
            {
                var $probability = args[i++];
                if ($probability instanceof CalcError)
                    return $probability;
                if (!(((typeof ($probability = this.force($probability)) == 'number' ? ($probability = limitPrecision($probability), true) : false) || (typeof $probability == 'boolean' ? ($probability = +$probability, true) : false) || (typeof $probability == 'string' && !/^(?:=|true|false)/i.test($probability) ? (tmp = calc.parse(0, 0, 0, $probability), /^date|number|percent$/.test(tmp.type) ? ($probability = +tmp.value, true) : false) : false)) && ($probability >= 0 && $probability <= 1 ? true : (err = 'NUM', false)))) {
                    if ($probability instanceof CalcError)
                        return $probability;
                    return new CalcError(err);
                }
                xargs.push($probability);
            }
            {
                var $alpha = args[i++];
                if ($alpha instanceof CalcError)
                    return $alpha;
                if (!(((typeof ($alpha = this.force($alpha)) == 'number' ? ($alpha = limitPrecision($alpha), true) : false) || (typeof $alpha == 'boolean' ? ($alpha = +$alpha, true) : false) || (typeof $alpha == 'string' && !/^(?:=|true|false)/i.test($alpha) ? (tmp = calc.parse(0, 0, 0, $alpha), /^date|number|percent$/.test(tmp.type) ? ($alpha = +tmp.value, true) : false) : false)) && ($alpha >= 0 && $alpha <= 1 ? true : (err = 'NUM', false)))) {
                    if ($alpha instanceof CalcError)
                        return $alpha;
                    return new CalcError(err);
                }
                xargs.push($alpha);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (n, p, alpha) {
        for (var x = 0; x <= n; ++x) {
            if (_binom_dist(x, n, p, true) >= alpha) {
                return x;
            }
        }
        return new CalcError('N/A');
    });

    calc.runtime.defineAlias("critbinom", "binom.inv");

    defineBuiltinFunction('binom.dist.range', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $trials = args[i++];
                if ($trials instanceof CalcError)
                    return $trials;
                if (!((typeof ($trials = this.force($trials)) == 'number' || (typeof $trials == 'boolean' ? ($trials = +$trials, true) : false) || (typeof $trials == 'string' && !/^(?:=|true|false)/i.test($trials) ? (tmp = calc.parse(0, 0, 0, $trials), /^date|number|percent$/.test(tmp.type) ? ($trials = +tmp.value, true) : false) : false)) && (($trials |= 0) >= 0 ? true : (err = 'NUM', false)))) {
                    if ($trials instanceof CalcError)
                        return $trials;
                    return new CalcError(err);
                }
                xargs.push($trials);
            }
            {
                var $probability = args[i++];
                if ($probability instanceof CalcError)
                    return $probability;
                if (!(((typeof ($probability = this.force($probability)) == 'number' ? ($probability = limitPrecision($probability), true) : false) || (typeof $probability == 'boolean' ? ($probability = +$probability, true) : false) || (typeof $probability == 'string' && !/^(?:=|true|false)/i.test($probability) ? (tmp = calc.parse(0, 0, 0, $probability), /^date|number|percent$/.test(tmp.type) ? ($probability = +tmp.value, true) : false) : false)) && ($probability >= 0 && $probability <= 1 ? true : (err = 'NUM', false)))) {
                    if ($probability instanceof CalcError)
                        return $probability;
                    return new CalcError(err);
                }
                xargs.push($probability);
            }
            {
                var $successes_min = args[i++];
                if ($successes_min instanceof CalcError)
                    return $successes_min;
                if (!((typeof ($successes_min = this.force($successes_min)) == 'number' || (typeof $successes_min == 'boolean' ? ($successes_min = +$successes_min, true) : false) || (typeof $successes_min == 'string' && !/^(?:=|true|false)/i.test($successes_min) ? (tmp = calc.parse(0, 0, 0, $successes_min), /^date|number|percent$/.test(tmp.type) ? ($successes_min = +tmp.value, true) : false) : false)) && ($successes_min |= 0, true) && ($successes_min >= 0 && $successes_min <= $trials ? true : (err = 'NUM', false)))) {
                    if ($successes_min instanceof CalcError)
                        return $successes_min;
                    return new CalcError(err);
                }
                xargs.push($successes_min);
            }
            {
                var $successes_max = args[i++];
                if ($successes_max instanceof CalcError)
                    return $successes_max;
                if (!((typeof ($successes_max = this.force($successes_max)) == 'number' || (typeof $successes_max == 'boolean' ? ($successes_max = +$successes_max, true) : false) || (typeof $successes_max == 'string' && !/^(?:=|true|false)/i.test($successes_max) ? (tmp = calc.parse(0, 0, 0, $successes_max), /^date|number|percent$/.test(tmp.type) ? ($successes_max = +tmp.value, true) : false) : false)) && ($successes_max |= 0, true) && ($successes_max >= $successes_min && $successes_max <= $trials ? true : (err = 'NUM', false)) || ($successes_max == null ? ($successes_max = $successes_min, true) : false))) {
                    if ($successes_max instanceof CalcError)
                        return $successes_max;
                    return new CalcError(err);
                }
                xargs.push($successes_max);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (n, p, s, s2) {
        var sum = 0;
        for (var k = s; k <= s2; ++k) {
            sum += _combinations(n, k) * Math.pow(p, k) * Math.pow(1 - p, n - k);
        }
        return sum;
    });

    defineBuiltinFunction('negbinom.dist', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $number_f = args[i++];
                if ($number_f instanceof CalcError)
                    return $number_f;
                if (!((typeof ($number_f = this.force($number_f)) == 'number' || (typeof $number_f == 'boolean' ? ($number_f = +$number_f, true) : false) || (typeof $number_f == 'string' && !/^(?:=|true|false)/i.test($number_f) ? (tmp = calc.parse(0, 0, 0, $number_f), /^date|number|percent$/.test(tmp.type) ? ($number_f = +tmp.value, true) : false) : false)) && (($number_f |= 0) >= 0 ? true : (err = 'NUM', false)))) {
                    if ($number_f instanceof CalcError)
                        return $number_f;
                    return new CalcError(err);
                }
                xargs.push($number_f);
            }
            {
                var $number_s = args[i++];
                if ($number_s instanceof CalcError)
                    return $number_s;
                if (!((typeof ($number_s = this.force($number_s)) == 'number' || (typeof $number_s == 'boolean' ? ($number_s = +$number_s, true) : false) || (typeof $number_s == 'string' && !/^(?:=|true|false)/i.test($number_s) ? (tmp = calc.parse(0, 0, 0, $number_s), /^date|number|percent$/.test(tmp.type) ? ($number_s = +tmp.value, true) : false) : false)) && (($number_s |= 0) >= 0 ? true : (err = 'NUM', false)))) {
                    if ($number_s instanceof CalcError)
                        return $number_s;
                    return new CalcError(err);
                }
                xargs.push($number_s);
            }
            {
                var $probability_s = args[i++];
                if ($probability_s instanceof CalcError)
                    return $probability_s;
                if (!(((typeof ($probability_s = this.force($probability_s)) == 'number' ? ($probability_s = limitPrecision($probability_s), true) : false) || (typeof $probability_s == 'boolean' ? ($probability_s = +$probability_s, true) : false) || (typeof $probability_s == 'string' && !/^(?:=|true|false)/i.test($probability_s) ? (tmp = calc.parse(0, 0, 0, $probability_s), /^date|number|percent$/.test(tmp.type) ? ($probability_s = +tmp.value, true) : false) : false)) && ($probability_s >= 0 && $probability_s <= 1 ? true : (err = 'NUM', false)))) {
                    if ($probability_s instanceof CalcError)
                        return $probability_s;
                    return new CalcError(err);
                }
                xargs.push($probability_s);
            }
            {
                var $cumulative = args[i++];
                if ($cumulative instanceof CalcError)
                    return $cumulative;
                if (!(typeof ($cumulative = this.force($cumulative)) == 'boolean' || (typeof $cumulative == 'number' ? ($cumulative = !!$cumulative, true) : false))) {
                    if ($cumulative instanceof CalcError)
                        return $cumulative;
                    return new CalcError(err);
                }
                xargs.push($cumulative);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (x, k, p, cumulative) {
        if (cumulative) {
            var sum = 0;
            while (x >= 0) {
                sum += _combinations(x + k - 1, x) * Math.pow(p, k) * Math.pow(1 - p, x);
                x--;
            }
            return sum;
        }
        return _combinations(x + k - 1, x) * Math.pow(p, k) * Math.pow(1 - p, x);
    });

    calc.runtime.defineAlias("negbinomdist", "negbinom.dist");

    /* -----[ lookup functions ]----- */

    defineBuiltinFunction('address', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $row = args[i++];
                if ($row instanceof CalcError)
                    return $row;
                if (!((typeof ($row = this.force($row)) == 'number' || (typeof $row == 'boolean' ? ($row = +$row, true) : false) || (typeof $row == 'string' && !/^(?:=|true|false)/i.test($row) ? (tmp = calc.parse(0, 0, 0, $row), /^date|number|percent$/.test(tmp.type) ? ($row = +tmp.value, true) : false) : false)) && (($row |= 0) > 0 ? true : (err = 'NUM', false)))) {
                    if ($row instanceof CalcError)
                        return $row;
                    return new CalcError(err);
                }
                xargs.push($row);
            }
            {
                var $col = args[i++];
                if ($col instanceof CalcError)
                    return $col;
                if (!((typeof ($col = this.force($col)) == 'number' || (typeof $col == 'boolean' ? ($col = +$col, true) : false) || (typeof $col == 'string' && !/^(?:=|true|false)/i.test($col) ? (tmp = calc.parse(0, 0, 0, $col), /^date|number|percent$/.test(tmp.type) ? ($col = +tmp.value, true) : false) : false)) && (($col |= 0) > 0 ? true : (err = 'NUM', false)))) {
                    if ($col instanceof CalcError)
                        return $col;
                    return new CalcError(err);
                }
                xargs.push($col);
            }
            {
                var $abs = args[i++];
                if ($abs instanceof CalcError)
                    return $abs;
                if (!((($abs = this.force($abs)) == null ? ($abs = 1, true) : false) || ($abs === 1 || $abs === 2 || $abs === 3 || $abs === 4))) {
                    if ($abs instanceof CalcError)
                        return $abs;
                    return new CalcError(err);
                }
                xargs.push($abs);
            }
            {
                var $a1 = args[i++];
                if ($a1 instanceof CalcError)
                    return $a1;
                if (!((($a1 = this.force($a1)) == null ? ($a1 = true, true) : false) || (typeof $a1 == 'boolean' || (typeof $a1 == 'number' ? ($a1 = !!$a1, true) : false)))) {
                    if ($a1 instanceof CalcError)
                        return $a1;
                    return new CalcError(err);
                }
                xargs.push($a1);
            }
            {
                var $sheet = args[i++];
                if ($sheet instanceof CalcError)
                    return $sheet;
                if (!(($sheet = this.force($sheet)) == null || (typeof $sheet == 'string' || typeof $sheet == 'boolean' || typeof $sheet == 'number' ? ($sheet += '', true) : $sheet === undefined ? ($sheet = '', true) : false))) {
                    if ($sheet instanceof CalcError)
                        return $sheet;
                    return new CalcError(err);
                }
                xargs.push($sheet);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (row, col, abs, a1, sheet) {
        var cell = new CellRef(row - 1, col - 1, abs - 1);
        if (sheet) {
            cell.setSheet(sheet, true);
        }
        return a1 ? cell.print(0, 0) : cell.print();
    });

    defineBuiltinFunction('areas', false, function () {
        function check(args) {
            var xargs = [], i = 0, err = 'VALUE';
            {
                var $ref = args[i++];
                if ($ref instanceof CalcError)
                    return $ref;
                if (!($ref instanceof Ref)) {
                    return new CalcError(err);
                }
                xargs.push($ref);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        return { check: check };
    }(), function (ref) {
        var count = 0;
        (function loop(x) {
            if (x instanceof CellRef || x instanceof RangeRef) {
                count++;
            } else if (x instanceof UnionRef) {
                x.refs.forEach(loop);
            }
        }(ref));
        return count;
    });

    defineBuiltinFunction('choose', false, function () {
        function check(args) {
            var stack = [], tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $index = args[i++];
                if ($index instanceof CalcError)
                    return $index;
                if (!((typeof ($index = this.force($index)) == 'number' || (typeof $index == 'boolean' ? ($index = +$index, true) : false) || (typeof $index == 'string' && !/^(?:=|true|false)/i.test($index) ? (tmp = calc.parse(0, 0, 0, $index), /^date|number|percent$/.test(tmp.type) ? ($index = +tmp.value, true) : false) : false)) && ($index |= 0, true))) {
                    if ($index instanceof CalcError)
                        return $index;
                    return new CalcError(err);
                }
                xargs.push($index);
            }
            {
                if (i >= args.length)
                    return new CalcError('N/A');
                xargs.push(tmp = []);
                stack.push(xargs);
                xargs = tmp;
                do {
                    {
                        var $value = args[i++];
                        if ($value instanceof CalcError)
                            return $value;
                        if (!(i <= args.length)) {
                            return new CalcError(err);
                        }
                        xargs.push($value);
                    }
                } while (i < args.length);
                xargs = stack.pop();
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            while (i < args.length) {
                i++;
            }
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $index = this._arrayArg(args[i]);
            if ($index) {
                xargs.push($index);
                width = Math.max(width, $index.width);
                height = Math.max(height, $index.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            while (i < args.length) {
                xargs.push(args[i++]);
                arrays.push(false);
            }
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (index, args) {
        if (index > args.length) {
            return new CalcError('N/A');
        } else {
            return args[index - 1];
        }
    });

    defineBuiltinFunction('column', false, function () {
        function check(args) {
            var xargs = [], i = 0, err = 'VALUE';
            {
                var $ref = args[i++];
                if ($ref instanceof CalcError)
                    return $ref;
                if (!($ref instanceof CellRef || $ref instanceof RangeRef || ($ref = this.force($ref)) == null)) {
                    if ($ref instanceof CalcError)
                        return $ref;
                    return new CalcError(err);
                }
                xargs.push($ref);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (ref) {
        if (!ref) {
            return this.formula.col + 1;
        }
        if (ref instanceof CellRef) {
            return ref.col + 1;
        }
        return this.asMatrix(ref).mapCol(function (col) {
            return col + ref.topLeft.col + 1;
        });
    });

    defineBuiltinFunction('columns', false, function () {
        function check(args) {
            var xargs = [], i = 0, m, err = 'VALUE';
            {
                var $ref = args[i++];
                if ($ref instanceof CalcError)
                    return $ref;
                if (!($ref instanceof CellRef || $ref instanceof RangeRef || ((m = this.asMatrix($ref)) ? $ref = m : false))) {
                    return new CalcError(err);
                }
                xargs.push($ref);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        return { check: check };
    }(), function (m) {
        return m instanceof Ref ? m.width() : m.width;
    });

    defineBuiltinFunction('formulatext', false, function () {
        function check(args) {
            var xargs = [], i = 0, err = 'VALUE';
            {
                var $ref = args[i++];
                if ($ref instanceof CalcError)
                    return $ref;
                if (!($ref instanceof Ref)) {
                    return new CalcError(err);
                }
                xargs.push($ref);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        return { check: check };
    }(), function (ref) {
        var cell = this.getRefCells(ref)[0];
        if (!cell.formula) {
            return new CalcError('N/A');
        }
        return cell.formula.print(cell.row, cell.col);
    });

    defineBuiltinFunction('hlookup', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, m, err = 'VALUE';
            {
                var $value = args[i++];
                if ($value instanceof CalcError)
                    return $value;
                if (!(($value = this.force($value)) != null && i <= args.length)) {
                    if ($value instanceof CalcError)
                        return $value;
                    return new CalcError(err);
                }
                xargs.push($value);
            }
            {
                var $range = args[i++];
                if ($range instanceof CalcError)
                    return $range;
                if (!((m = this.asMatrix($range)) ? $range = m : false)) {
                    if ($range instanceof CalcError)
                        return $range;
                    return new CalcError(err);
                }
                xargs.push($range);
            }
            {
                var $row = args[i++];
                if ($row instanceof CalcError)
                    return $row;
                if (!((typeof ($row = this.force($row)) == 'number' || (typeof $row == 'boolean' ? ($row = +$row, true) : false) || (typeof $row == 'string' && !/^(?:=|true|false)/i.test($row) ? (tmp = calc.parse(0, 0, 0, $row), /^date|number|percent$/.test(tmp.type) ? ($row = +tmp.value, true) : false) : false)) && (($row |= 0) > 0 ? true : (err = 'NUM', false)))) {
                    if ($row instanceof CalcError)
                        return $row;
                    return new CalcError(err);
                }
                xargs.push($row);
            }
            {
                var $approx = args[i++];
                if ($approx instanceof CalcError)
                    return $approx;
                if (!(typeof ($approx = this.force($approx)) == 'boolean' || (typeof $approx == 'number' ? ($approx = !!$approx, true) : false) || ($approx == null ? ($approx = true, true) : false))) {
                    if ($approx instanceof CalcError)
                        return $approx;
                    return new CalcError(err);
                }
                xargs.push($approx);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (value, m, row, approx) {
        var resultCol = null;
        m.eachCol(function (col) {
            var data = m.get(0, col);
            if (approx) {
                if (data > value) {
                    return true;
                }
                resultCol = col;
            } else if (data === value) {
                resultCol = col;
                return true;
            }
        });
        if (resultCol == null) {
            return new CalcError('N/A');
        }
        return m.get(row - 1, resultCol);
    });

    defineBuiltinFunction('index', true, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, m, err = 'VALUE';
            {
                var $range = args[i++];
                if ($range instanceof CalcError)
                    return $range;
                if (!($range instanceof Ref || ((m = this.asMatrix($range)) ? $range = m : false))) {
                    if ($range instanceof CalcError)
                        return $range;
                    return new CalcError(err);
                }
                xargs.push($range);
            }
            {
                var $row = args[i++];
                if ($row instanceof CalcError)
                    return $row;
                if (!((typeof ($row = this.force($row)) == 'number' || (typeof $row == 'boolean' ? ($row = +$row, true) : false) || (typeof $row == 'string' && !/^(?:=|true|false)/i.test($row) ? (tmp = calc.parse(0, 0, 0, $row), /^date|number|percent$/.test(tmp.type) ? ($row = +tmp.value, true) : false) : false)) && (($row |= 0) >= 0 ? true : (err = 'NUM', false)) || $row == null)) {
                    if ($row instanceof CalcError)
                        return $row;
                    return new CalcError(err);
                }
                xargs.push($row);
            }
            {
                var $col = args[i++];
                if ($col instanceof CalcError)
                    return $col;
                if (!((typeof ($col = this.force($col)) == 'number' || (typeof $col == 'boolean' ? ($col = +$col, true) : false) || (typeof $col == 'string' && !/^(?:=|true|false)/i.test($col) ? (tmp = calc.parse(0, 0, 0, $col), /^date|number|percent$/.test(tmp.type) ? ($col = +tmp.value, true) : false) : false)) && (($col |= 0) >= 0 ? true : (err = 'NUM', false)) || $col == null)) {
                    if ($col instanceof CalcError)
                        return $col;
                    return new CalcError(err);
                }
                xargs.push($col);
            }
            {
                var $areanum = args[i++];
                if ($areanum instanceof CalcError)
                    return $areanum;
                if (!((typeof ($areanum = this.force($areanum)) == 'number' || (typeof $areanum == 'boolean' ? ($areanum = +$areanum, true) : false) || (typeof $areanum == 'string' && !/^(?:=|true|false)/i.test($areanum) ? (tmp = calc.parse(0, 0, 0, $areanum), /^date|number|percent$/.test(tmp.type) ? ($areanum = +tmp.value, true) : false) : false)) && (($areanum |= 0) > 0 ? true : (err = 'NUM', false)) || ($areanum == null ? ($areanum = 1, true) : false))) {
                    if ($areanum instanceof CalcError)
                        return $areanum;
                    return new CalcError(err);
                }
                xargs.push($areanum);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (callback, ref, row, col, areanum) {
        var self = this;
        if (ref instanceof UnionRef) {
            ref = ref.refs[areanum - 1];
        }
        if (!row && !col || !ref) {
            return callback(new CalcError('N/A'));
        }
        if (ref instanceof CellRef) {
            ref = ref.toRangeRef();
        }
        if (ref instanceof RangeRef) {
            if (row && col) {
                if (col > ref.width() || row > ref.height()) {
                    return callback(new CalcError('REF'));
                }
                var cell = ref.toCell(row - 1, col - 1);
                self.resolveCells([cell], function () {
                    callback(self.getRefData(cell));
                });
                return;
            }
            if (!row) {
                var colRange = ref.toColumn(col - 1);
                self.resolveCells([colRange], function () {
                    callback(self.asMatrix(colRange));
                });
                return;
            }
            if (!col) {
                var rowRange = ref.toRow(row - 1);
                self.resolveCells([rowRange], function () {
                    callback(self.asMatrix(rowRange));
                });
                return;
            }
        } else if (ref instanceof Matrix) {
            if (ref.width > 1 && ref.height > 1) {
                if (row && col) {
                    return callback(ref.get(row - 1, col - 1));
                }
                if (!row) {
                    return callback(ref.mapRow(function (row) {
                        return ref.get(row, col - 1);
                    }));
                }
                if (!col) {
                    return callback(ref.mapCol(function (col) {
                        return ref.get(row - 1, col);
                    }));
                }
            }
            if (ref.width == 1) {
                return callback(ref.get((row || 1) - 1, 0));
            }
            if (ref.height == 1) {
                return callback(ref.get(0, (col || 1) - 1));
            }
        } else {
            callback(new CalcError('REF'));
        }
    });

    defineBuiltinFunction('indirect', false, function () {
        function check(args) {
            var xargs = [], i = 0, err = 'VALUE';
            {
                var $thing = args[i++];
                if ($thing instanceof CalcError)
                    return $thing;
                if (!(typeof ($thing = this.force($thing)) == 'string' || typeof $thing == 'boolean' || typeof $thing == 'number' ? ($thing += '', true) : $thing === undefined ? ($thing = '', true) : false)) {
                    if ($thing instanceof CalcError)
                        return $thing;
                    return new CalcError(err);
                }
                xargs.push($thing);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (thing) {
        try {
            var f = this.formula;
            var exp = calc.parseFormula(f.sheet, f.row, f.col, thing);
            var ref = exp.ast;
            if (ref instanceof NameRef) {
                ref = this.ss.nameValue(ref, f.sheet, f.row, f.col);
            }
            if (!(ref instanceof Ref)) {
                throw 1;
            }
            return ref.absolute(f.row, f.col);
        } catch (ex) {
            return new CalcError('REF');
        }
    });

    // XXX: LOOKUP.  seems to be deprecated in favor of HLOOKUP/VLOOKUP

    // XXX: double-check this one.
    defineBuiltinFunction('match', false, function () {
        function check(args) {
            var xargs = [], i = 0, m, err = 'VALUE';
            {
                var $value = args[i++];
                if ($value instanceof CalcError)
                    return $value;
                if (!(($value = this.force($value)) != null && i <= args.length)) {
                    if ($value instanceof CalcError)
                        return $value;
                    return new CalcError(err);
                }
                xargs.push($value);
            }
            {
                var $range = args[i++];
                if ($range instanceof CalcError)
                    return $range;
                if (!((m = this.asMatrix($range)) ? $range = m : false)) {
                    if ($range instanceof CalcError)
                        return $range;
                    return new CalcError(err);
                }
                xargs.push($range);
            }
            {
                var $type = args[i++];
                if ($type instanceof CalcError)
                    return $type;
                if (!(($type = this.force($type)) === -1 || $type === 0 || $type === 1 || ($type == null ? ($type = 1, true) : false))) {
                    if ($type instanceof CalcError)
                        return $type;
                    return new CalcError(err);
                }
                xargs.push($type);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (val, m, type) {
        var index = 1, cmp;
        if (type === 0) {
            cmp = parseCriteria(val);
        } else if (type === -1) {
            cmp = parseCriteria('<=' + val);
        } else if (type === 1) {
            cmp = parseCriteria('>=' + val);
        }
        if (m.each(function (el) {
                if (el != null && cmp(el)) {
                    if (type !== 0 && val != el) {
                        --index;
                    }
                    return true;
                }
                index++;
            }, true) && index > 0) {
            return index;
        } else {
            return new CalcError('N/A');
        }
    });

    defineBuiltinFunction('offset', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $ref = args[i++];
                if ($ref instanceof CalcError)
                    return $ref;
                if (!($ref instanceof CellRef || $ref instanceof RangeRef)) {
                    return new CalcError(err);
                }
                xargs.push($ref);
            }
            {
                var $rows = args[i++];
                if ($rows instanceof CalcError)
                    return $rows;
                if (!((typeof ($rows = this.force($rows)) == 'number' || (typeof $rows == 'boolean' ? ($rows = +$rows, true) : false) || (typeof $rows == 'string' && !/^(?:=|true|false)/i.test($rows) ? (tmp = calc.parse(0, 0, 0, $rows), /^date|number|percent$/.test(tmp.type) ? ($rows = +tmp.value, true) : false) : false)) && ($rows |= 0, true))) {
                    if ($rows instanceof CalcError)
                        return $rows;
                    return new CalcError(err);
                }
                xargs.push($rows);
            }
            {
                var $cols = args[i++];
                if ($cols instanceof CalcError)
                    return $cols;
                if (!((typeof ($cols = this.force($cols)) == 'number' || (typeof $cols == 'boolean' ? ($cols = +$cols, true) : false) || (typeof $cols == 'string' && !/^(?:=|true|false)/i.test($cols) ? (tmp = calc.parse(0, 0, 0, $cols), /^date|number|percent$/.test(tmp.type) ? ($cols = +tmp.value, true) : false) : false)) && ($cols |= 0, true))) {
                    if ($cols instanceof CalcError)
                        return $cols;
                    return new CalcError(err);
                }
                xargs.push($cols);
            }
            {
                var $height = args[i++];
                if ($height instanceof CalcError)
                    return $height;
                if (!((typeof ($height = this.force($height)) == 'number' || (typeof $height == 'boolean' ? ($height = +$height, true) : false) || (typeof $height == 'string' && !/^(?:=|true|false)/i.test($height) ? (tmp = calc.parse(0, 0, 0, $height), /^date|number|percent$/.test(tmp.type) ? ($height = +tmp.value, true) : false) : false)) && (($height |= 0) > 0 ? true : (err = 'NUM', false)) || ($height == null ? ($height = $ref.height(), true) : false))) {
                    if ($height instanceof CalcError)
                        return $height;
                    return new CalcError(err);
                }
                xargs.push($height);
            }
            {
                var $width = args[i++];
                if ($width instanceof CalcError)
                    return $width;
                if (!((typeof ($width = this.force($width)) == 'number' || (typeof $width == 'boolean' ? ($width = +$width, true) : false) || (typeof $width == 'string' && !/^(?:=|true|false)/i.test($width) ? (tmp = calc.parse(0, 0, 0, $width), /^date|number|percent$/.test(tmp.type) ? ($width = +tmp.value, true) : false) : false)) && (($width |= 0) > 0 ? true : (err = 'NUM', false)) || ($width == null ? ($width = $ref.width(), true) : false))) {
                    if ($width instanceof CalcError)
                        return $width;
                    return new CalcError(err);
                }
                xargs.push($width);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            i++;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            xargs.push(args[i++]);
            arrays.push(false);
            var $rows = this._arrayArg(args[i]);
            if ($rows) {
                xargs.push($rows);
                width = Math.max(width, $rows.width);
                height = Math.max(height, $rows.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $cols = this._arrayArg(args[i]);
            if ($cols) {
                xargs.push($cols);
                width = Math.max(width, $cols.width);
                height = Math.max(height, $cols.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $height = this._arrayArg(args[i]);
            if ($height) {
                xargs.push($height);
                width = Math.max(width, $height.width);
                height = Math.max(height, $height.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $width = this._arrayArg(args[i]);
            if ($width) {
                xargs.push($width);
                width = Math.max(width, $width.width);
                height = Math.max(height, $width.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (ref, rows, cols, height, width) {
        var topLeft = (ref instanceof CellRef ? ref : ref.topLeft).clone();
        topLeft.row += rows;
        topLeft.col += cols;
        if (topLeft.row < 0 || topLeft.col < 0) {
            return new CalcError('VALUE');
        }
        if (height > 1 || width > 1) {
            return new RangeRef(topLeft, new CellRef(topLeft.row + height - 1, topLeft.col + width - 1)).setSheet(ref.sheet, ref.hasSheet());
        }
        return topLeft;
    });

    defineBuiltinFunction('row', false, function () {
        function check(args) {
            var xargs = [], i = 0, err = 'VALUE';
            {
                var $ref = args[i++];
                if ($ref instanceof CalcError)
                    return $ref;
                if (!($ref instanceof CellRef || $ref instanceof RangeRef || ($ref = this.force($ref)) == null)) {
                    if ($ref instanceof CalcError)
                        return $ref;
                    return new CalcError(err);
                }
                xargs.push($ref);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (ref) {
        if (!ref) {
            return this.formula.row + 1;
        }
        if (ref instanceof CellRef) {
            return ref.row + 1;
        }
        return this.asMatrix(ref).mapRow(function (row) {
            return row + ref.topLeft.row + 1;
        });
    });

    defineBuiltinFunction('rows', false, function () {
        function check(args) {
            var xargs = [], i = 0, m, err = 'VALUE';
            {
                var $ref = args[i++];
                if ($ref instanceof CalcError)
                    return $ref;
                if (!($ref instanceof CellRef || $ref instanceof RangeRef || ((m = this.asMatrix($ref)) ? $ref = m : false))) {
                    return new CalcError(err);
                }
                xargs.push($ref);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        return { check: check };
    }(), function (m) {
        return m instanceof Ref ? m.height() : m.height;
    });

    defineBuiltinFunction('vlookup', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, m, err = 'VALUE';
            {
                var $value = args[i++];
                if ($value instanceof CalcError)
                    return $value;
                if (!(($value = this.force($value)) != null && i <= args.length)) {
                    if ($value instanceof CalcError)
                        return $value;
                    return new CalcError(err);
                }
                xargs.push($value);
            }
            {
                var $range = args[i++];
                if ($range instanceof CalcError)
                    return $range;
                if (!((m = this.asMatrix($range)) ? $range = m : false)) {
                    if ($range instanceof CalcError)
                        return $range;
                    return new CalcError(err);
                }
                xargs.push($range);
            }
            {
                var $col = args[i++];
                if ($col instanceof CalcError)
                    return $col;
                if (!((typeof ($col = this.force($col)) == 'number' || (typeof $col == 'boolean' ? ($col = +$col, true) : false) || (typeof $col == 'string' && !/^(?:=|true|false)/i.test($col) ? (tmp = calc.parse(0, 0, 0, $col), /^date|number|percent$/.test(tmp.type) ? ($col = +tmp.value, true) : false) : false)) && (($col |= 0) > 0 ? true : (err = 'NUM', false)))) {
                    if ($col instanceof CalcError)
                        return $col;
                    return new CalcError(err);
                }
                xargs.push($col);
            }
            {
                var $approx = args[i++];
                if ($approx instanceof CalcError)
                    return $approx;
                if (!(typeof ($approx = this.force($approx)) == 'boolean' || (typeof $approx == 'number' ? ($approx = !!$approx, true) : false) || ($approx == null ? ($approx = true, true) : false))) {
                    if ($approx instanceof CalcError)
                        return $approx;
                    return new CalcError(err);
                }
                xargs.push($approx);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (value, m, col, approx) {
        var resultRow = null;
        if (typeof value != 'number') {
            approx = false;
        }
        if (typeof value == 'string') {
            value = value.toLowerCase();
        }
        m.eachRow(function (row) {
            var data = m.get(row, 0);
            if (approx) {
                if (data > value) {
                    return true;
                }
                resultRow = row;
            } else {
                if (typeof data == 'string') {
                    data = data.toLowerCase();
                }
                if (data === value) {
                    resultRow = row;
                    return true;
                }
            }
        });
        if (resultRow == null) {
            return new CalcError('N/A');
        }
        return m.get(resultRow, col - 1);
    });

    /* -----[ Date and time functions ]----- */

    defineBuiltinFunction('date', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $year = args[i++];
                if ($year instanceof CalcError)
                    return $year;
                if (!((typeof ($year = this.force($year)) == 'number' || (typeof $year == 'boolean' ? ($year = +$year, true) : false) || (typeof $year == 'string' && !/^(?:=|true|false)/i.test($year) ? (tmp = calc.parse(0, 0, 0, $year), /^date|number|percent$/.test(tmp.type) ? ($year = +tmp.value, true) : false) : false)) && ($year |= 0, true))) {
                    if ($year instanceof CalcError)
                        return $year;
                    return new CalcError(err);
                }
                xargs.push($year);
            }
            {
                var $month = args[i++];
                if ($month instanceof CalcError)
                    return $month;
                if (!((typeof ($month = this.force($month)) == 'number' || (typeof $month == 'boolean' ? ($month = +$month, true) : false) || (typeof $month == 'string' && !/^(?:=|true|false)/i.test($month) ? (tmp = calc.parse(0, 0, 0, $month), /^date|number|percent$/.test(tmp.type) ? ($month = +tmp.value, true) : false) : false)) && ($month |= 0, true))) {
                    if ($month instanceof CalcError)
                        return $month;
                    return new CalcError(err);
                }
                xargs.push($month);
            }
            {
                var $date = args[i++];
                if ($date instanceof CalcError)
                    return $date;
                if (!((typeof ($date = this.force($date)) == 'number' || (typeof $date == 'boolean' ? ($date = +$date, true) : false) || (typeof $date == 'string' && !/^(?:=|true|false)/i.test($date) ? (tmp = calc.parse(0, 0, 0, $date), /^date|number|percent$/.test(tmp.type) ? ($date = +tmp.value, true) : false) : false)) && ($date |= 0, true))) {
                    if ($date instanceof CalcError)
                        return $date;
                    return new CalcError(err);
                }
                xargs.push($date);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $year = this._arrayArg(args[i]);
            if ($year) {
                xargs.push($year);
                width = Math.max(width, $year.width);
                height = Math.max(height, $year.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $month = this._arrayArg(args[i]);
            if ($month) {
                xargs.push($month);
                width = Math.max(width, $month.width);
                height = Math.max(height, $month.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $date = this._arrayArg(args[i]);
            if ($date) {
                xargs.push($date);
                width = Math.max(width, $date.width);
                height = Math.max(height, $date.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (year, month, date) {
        return packDate$1(year, month - 1, date);
    });

    defineBuiltinFunction('day', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $date = args[i++];
                if ($date instanceof CalcError)
                    return $date;
                if (!((typeof ($date = this.force($date)) == 'number' || (typeof $date == 'boolean' ? ($date = +$date, true) : false) || (typeof $date == 'string' && !/^(?:=|true|false)/i.test($date) ? (tmp = calc.parse(0, 0, 0, $date), /^date|number|percent$/.test(tmp.type) ? ($date = +tmp.value, true) : false) : false)) && ($date |= 0, true))) {
                    if ($date instanceof CalcError)
                        return $date;
                    return new CalcError(err);
                }
                xargs.push($date);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $date = this._arrayArg(args[i]);
            if ($date) {
                xargs.push($date);
                width = Math.max(width, $date.width);
                height = Math.max(height, $date.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (date) {
        return unpackDate$1(date).date;
    });

    defineBuiltinFunction('month', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $date = args[i++];
                if ($date instanceof CalcError)
                    return $date;
                if (!((typeof ($date = this.force($date)) == 'number' || (typeof $date == 'boolean' ? ($date = +$date, true) : false) || (typeof $date == 'string' && !/^(?:=|true|false)/i.test($date) ? (tmp = calc.parse(0, 0, 0, $date), /^date|number|percent$/.test(tmp.type) ? ($date = +tmp.value, true) : false) : false)) && ($date |= 0, true))) {
                    if ($date instanceof CalcError)
                        return $date;
                    return new CalcError(err);
                }
                xargs.push($date);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $date = this._arrayArg(args[i]);
            if ($date) {
                xargs.push($date);
                width = Math.max(width, $date.width);
                height = Math.max(height, $date.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (date) {
        return unpackDate$1(date).month + 1;
    });

    defineBuiltinFunction('year', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $date = args[i++];
                if ($date instanceof CalcError)
                    return $date;
                if (!((typeof ($date = this.force($date)) == 'number' || (typeof $date == 'boolean' ? ($date = +$date, true) : false) || (typeof $date == 'string' && !/^(?:=|true|false)/i.test($date) ? (tmp = calc.parse(0, 0, 0, $date), /^date|number|percent$/.test(tmp.type) ? ($date = +tmp.value, true) : false) : false)) && ($date |= 0, true))) {
                    if ($date instanceof CalcError)
                        return $date;
                    return new CalcError(err);
                }
                xargs.push($date);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $date = this._arrayArg(args[i]);
            if ($date) {
                xargs.push($date);
                width = Math.max(width, $date.width);
                height = Math.max(height, $date.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (date) {
        return unpackDate$1(date).year;
    });

    defineBuiltinFunction('weekday', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $date = args[i++];
                if ($date instanceof CalcError)
                    return $date;
                if (!((typeof ($date = this.force($date)) == 'number' || (typeof $date == 'boolean' ? ($date = +$date, true) : false) || (typeof $date == 'string' && !/^(?:=|true|false)/i.test($date) ? (tmp = calc.parse(0, 0, 0, $date), /^date|number|percent$/.test(tmp.type) ? ($date = +tmp.value, true) : false) : false)) && ($date |= 0, true))) {
                    if ($date instanceof CalcError)
                        return $date;
                    return new CalcError(err);
                }
                xargs.push($date);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $date = this._arrayArg(args[i]);
            if ($date) {
                xargs.push($date);
                width = Math.max(width, $date.width);
                height = Math.max(height, $date.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (date) {
        return unpackDate$1(date).day + 1;
    });

    // https://support.office.com/en-GB/article/WEEKNUM-function-e5c43a03-b4ab-426c-b411-b18c13c75340
    // XXX: this is a mess.
    defineBuiltinFunction('weeknum', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $date = args[i++];
                if ($date instanceof CalcError)
                    return $date;
                if (!((typeof ($date = this.force($date)) == 'number' || (typeof $date == 'boolean' ? ($date = +$date, true) : false) || (typeof $date == 'string' && !/^(?:=|true|false)/i.test($date) ? (tmp = calc.parse(0, 0, 0, $date), /^date|number|percent$/.test(tmp.type) ? ($date = +tmp.value, true) : false) : false)) && ($date |= 0, true))) {
                    if ($date instanceof CalcError)
                        return $date;
                    return new CalcError(err);
                }
                xargs.push($date);
            }
            {
                var $type = args[i++];
                if ($type instanceof CalcError)
                    return $type;
                if (!((($type = this.force($type)) == null ? ($type = 1, true) : false) || ($type === 1 || $type === 2 || $type === 11 || $type === 12 || $type === 13 || $type === 14 || $type === 15 || $type === 16 || $type === 17 || $type === 21))) {
                    if ($type instanceof CalcError)
                        return $type;
                    return new CalcError(err);
                }
                xargs.push($type);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $date = this._arrayArg(args[i]);
            if ($date) {
                xargs.push($date);
                width = Math.max(width, $date.width);
                height = Math.max(height, $date.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $type = this._arrayArg(args[i]);
            if ($type) {
                xargs.push($type);
                width = Math.max(width, $type.width);
                height = Math.max(height, $type.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (date, type) {
        var fw = packDate$1(unpackDate$1(date).year, 0, 1);
        var sy = unpackDate$1(fw);
        var diff;
        if (type == 21) {
            diff = 3 - (sy.day + 6) % 7;
            if (diff < 0) {
                diff += 7;
            }
            fw += diff;
            sy.date += diff;
            sy.day = 4;
            type = 1;
        } else {
            if (type == 1) {
                type = 0;
            } else if (type == 2) {
                type = 1;
            } else {
                type = (type - 10) % 7;
            }
        }
        diff = sy.day - type;
        if (diff < 0) {
            diff += 7;
        }
        fw -= diff;
        return Math.ceil((date + 1 - fw) / 7);
    });

    function weeksInYear(year) {
        var d = unpackDate$1(packDate$1(year, 0, 1));
        if ((d.day == 4) || (d.day == 3 && calc.runtime.isLeapYear(year))) {
            // long year
            return 53;
        }
        return 52;
    }

    defineBuiltinFunction('isoweeknum', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $date = args[i++];
                if ($date instanceof CalcError)
                    return $date;
                if (!((typeof ($date = this.force($date)) == 'number' || (typeof $date == 'boolean' ? ($date = +$date, true) : false) || (typeof $date == 'string' && !/^(?:=|true|false)/i.test($date) ? (tmp = calc.parse(0, 0, 0, $date), /^date|number|percent$/.test(tmp.type) ? ($date = +tmp.value, true) : false) : false)) && ($date |= 0, true))) {
                    if ($date instanceof CalcError)
                        return $date;
                    return new CalcError(err);
                }
                xargs.push($date);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $date = this._arrayArg(args[i]);
            if ($date) {
                xargs.push($date);
                width = Math.max(width, $date.width);
                height = Math.max(height, $date.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function isoweeknum(date) {
        var d = unpackDate$1(date);
        var dow = d.day || 7;
        var wk = Math.floor((d.ord - dow + 10) / 7);
        if (wk < 1) {
            return weeksInYear(d.year - 1);
        } else if (wk == 53 && wk > weeksInYear(d.year)) {
            return 1;
        }
        return wk;
    });

    defineBuiltinFunction('now', false, function () {
        function check(args) {
            var xargs = [], i = 0;
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        return { check: check };
    }(), function () {
        return calc.runtime.dateToSerial(new Date());
    });

    defineBuiltinFunction('today', false, function () {
        function check(args) {
            var xargs = [], i = 0;
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        return { check: check };
    }(), function () {
        return calc.runtime.dateToSerial(new Date()) | 0;
    });

    defineBuiltinFunction('time', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $hours = args[i++];
                if ($hours instanceof CalcError)
                    return $hours;
                if (!((typeof ($hours = this.force($hours)) == 'number' || (typeof $hours == 'boolean' ? ($hours = +$hours, true) : false) || (typeof $hours == 'string' && !/^(?:=|true|false)/i.test($hours) ? (tmp = calc.parse(0, 0, 0, $hours), /^date|number|percent$/.test(tmp.type) ? ($hours = +tmp.value, true) : false) : false)) && ($hours |= 0, true))) {
                    if ($hours instanceof CalcError)
                        return $hours;
                    return new CalcError(err);
                }
                xargs.push($hours);
            }
            {
                var $minutes = args[i++];
                if ($minutes instanceof CalcError)
                    return $minutes;
                if (!((typeof ($minutes = this.force($minutes)) == 'number' || (typeof $minutes == 'boolean' ? ($minutes = +$minutes, true) : false) || (typeof $minutes == 'string' && !/^(?:=|true|false)/i.test($minutes) ? (tmp = calc.parse(0, 0, 0, $minutes), /^date|number|percent$/.test(tmp.type) ? ($minutes = +tmp.value, true) : false) : false)) && ($minutes |= 0, true))) {
                    if ($minutes instanceof CalcError)
                        return $minutes;
                    return new CalcError(err);
                }
                xargs.push($minutes);
            }
            {
                var $seconds = args[i++];
                if ($seconds instanceof CalcError)
                    return $seconds;
                if (!((typeof ($seconds = this.force($seconds)) == 'number' || (typeof $seconds == 'boolean' ? ($seconds = +$seconds, true) : false) || (typeof $seconds == 'string' && !/^(?:=|true|false)/i.test($seconds) ? (tmp = calc.parse(0, 0, 0, $seconds), /^date|number|percent$/.test(tmp.type) ? ($seconds = +tmp.value, true) : false) : false)) && ($seconds |= 0, true))) {
                    if ($seconds instanceof CalcError)
                        return $seconds;
                    return new CalcError(err);
                }
                xargs.push($seconds);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $hours = this._arrayArg(args[i]);
            if ($hours) {
                xargs.push($hours);
                width = Math.max(width, $hours.width);
                height = Math.max(height, $hours.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $minutes = this._arrayArg(args[i]);
            if ($minutes) {
                xargs.push($minutes);
                width = Math.max(width, $minutes.width);
                height = Math.max(height, $minutes.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $seconds = this._arrayArg(args[i]);
            if ($seconds) {
                xargs.push($seconds);
                width = Math.max(width, $seconds.width);
                height = Math.max(height, $seconds.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (hh, mm, ss) {
        return calc.runtime.packTime(hh, mm, ss, 0);
    });

    defineBuiltinFunction('hour', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $time = args[i++];
                if ($time instanceof CalcError)
                    return $time;
                if (!((typeof ($time = this.force($time)) == 'number' ? ($time = limitPrecision($time), true) : false) || (typeof $time == 'boolean' ? ($time = +$time, true) : false) || (typeof $time == 'string' && !/^(?:=|true|false)/i.test($time) ? (tmp = calc.parse(0, 0, 0, $time), /^date|number|percent$/.test(tmp.type) ? ($time = +tmp.value, true) : false) : false))) {
                    if ($time instanceof CalcError)
                        return $time;
                    return new CalcError(err);
                }
                xargs.push($time);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $time = this._arrayArg(args[i]);
            if ($time) {
                xargs.push($time);
                width = Math.max(width, $time.width);
                height = Math.max(height, $time.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (time) {
        return calc.runtime.unpackTime(time).hours;
    });

    defineBuiltinFunction('minute', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $time = args[i++];
                if ($time instanceof CalcError)
                    return $time;
                if (!((typeof ($time = this.force($time)) == 'number' ? ($time = limitPrecision($time), true) : false) || (typeof $time == 'boolean' ? ($time = +$time, true) : false) || (typeof $time == 'string' && !/^(?:=|true|false)/i.test($time) ? (tmp = calc.parse(0, 0, 0, $time), /^date|number|percent$/.test(tmp.type) ? ($time = +tmp.value, true) : false) : false))) {
                    if ($time instanceof CalcError)
                        return $time;
                    return new CalcError(err);
                }
                xargs.push($time);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $time = this._arrayArg(args[i]);
            if ($time) {
                xargs.push($time);
                width = Math.max(width, $time.width);
                height = Math.max(height, $time.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (time) {
        return calc.runtime.unpackTime(time).minutes;
    });

    defineBuiltinFunction('second', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $time = args[i++];
                if ($time instanceof CalcError)
                    return $time;
                if (!((typeof ($time = this.force($time)) == 'number' ? ($time = limitPrecision($time), true) : false) || (typeof $time == 'boolean' ? ($time = +$time, true) : false) || (typeof $time == 'string' && !/^(?:=|true|false)/i.test($time) ? (tmp = calc.parse(0, 0, 0, $time), /^date|number|percent$/.test(tmp.type) ? ($time = +tmp.value, true) : false) : false))) {
                    if ($time instanceof CalcError)
                        return $time;
                    return new CalcError(err);
                }
                xargs.push($time);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $time = this._arrayArg(args[i]);
            if ($time) {
                xargs.push($time);
                width = Math.max(width, $time.width);
                height = Math.max(height, $time.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (time) {
        return calc.runtime.unpackTime(time).seconds;
    });

    defineBuiltinFunction('edate', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $start_date = args[i++];
                if ($start_date instanceof CalcError)
                    return $start_date;
                if (!((typeof ($start_date = this.force($start_date)) == 'number' || (typeof $start_date == 'boolean' ? ($start_date = +$start_date, true) : false) || (typeof $start_date == 'string' && !/^(?:=|true|false)/i.test($start_date) ? (tmp = calc.parse(0, 0, 0, $start_date), /^date|number|percent$/.test(tmp.type) ? ($start_date = +tmp.value, true) : false) : false)) && ($start_date |= 0, true))) {
                    if ($start_date instanceof CalcError)
                        return $start_date;
                    return new CalcError(err);
                }
                xargs.push($start_date);
            }
            {
                var $months = args[i++];
                if ($months instanceof CalcError)
                    return $months;
                if (!((typeof ($months = this.force($months)) == 'number' || (typeof $months == 'boolean' ? ($months = +$months, true) : false) || (typeof $months == 'string' && !/^(?:=|true|false)/i.test($months) ? (tmp = calc.parse(0, 0, 0, $months), /^date|number|percent$/.test(tmp.type) ? ($months = +tmp.value, true) : false) : false)) && ($months |= 0, true))) {
                    if ($months instanceof CalcError)
                        return $months;
                    return new CalcError(err);
                }
                xargs.push($months);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $start_date = this._arrayArg(args[i]);
            if ($start_date) {
                xargs.push($start_date);
                width = Math.max(width, $start_date.width);
                height = Math.max(height, $start_date.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $months = this._arrayArg(args[i]);
            if ($months) {
                xargs.push($months);
                width = Math.max(width, $months.width);
                height = Math.max(height, $months.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (base, months) {
        var d = unpackDate$1(base);
        var m = d.month + months;
        var y = d.year + Math.floor(m / 12);
        m %= 12;
        if (m < 0) {
            m += 12;
        }
        d = Math.min(d.date, daysInMonth(y, m));
        return packDate$1(y, m, d);
    });

    defineBuiltinFunction('eomonth', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $start_date = args[i++];
                if ($start_date instanceof CalcError)
                    return $start_date;
                if (!((typeof ($start_date = this.force($start_date)) == 'number' || (typeof $start_date == 'boolean' ? ($start_date = +$start_date, true) : false) || (typeof $start_date == 'string' && !/^(?:=|true|false)/i.test($start_date) ? (tmp = calc.parse(0, 0, 0, $start_date), /^date|number|percent$/.test(tmp.type) ? ($start_date = +tmp.value, true) : false) : false)) && ($start_date |= 0, true))) {
                    if ($start_date instanceof CalcError)
                        return $start_date;
                    return new CalcError(err);
                }
                xargs.push($start_date);
            }
            {
                var $months = args[i++];
                if ($months instanceof CalcError)
                    return $months;
                if (!((typeof ($months = this.force($months)) == 'number' || (typeof $months == 'boolean' ? ($months = +$months, true) : false) || (typeof $months == 'string' && !/^(?:=|true|false)/i.test($months) ? (tmp = calc.parse(0, 0, 0, $months), /^date|number|percent$/.test(tmp.type) ? ($months = +tmp.value, true) : false) : false)) && ($months |= 0, true))) {
                    if ($months instanceof CalcError)
                        return $months;
                    return new CalcError(err);
                }
                xargs.push($months);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $start_date = this._arrayArg(args[i]);
            if ($start_date) {
                xargs.push($start_date);
                width = Math.max(width, $start_date.width);
                height = Math.max(height, $start_date.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $months = this._arrayArg(args[i]);
            if ($months) {
                xargs.push($months);
                width = Math.max(width, $months.width);
                height = Math.max(height, $months.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (base, months) {
        var d = unpackDate$1(base);
        var m = d.month + months;
        var y = d.year + Math.floor(m / 12);
        m %= 12;
        if (m < 0) {
            m += 12;
        }
        d = daysInMonth(y, m);
        return packDate$1(y, m, d);
    });

    defineBuiltinFunction('workday', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $start_date = args[i++];
                if ($start_date instanceof CalcError)
                    return $start_date;
                if (!((typeof ($start_date = this.force($start_date)) == 'number' || (typeof $start_date == 'boolean' ? ($start_date = +$start_date, true) : false) || (typeof $start_date == 'string' && !/^(?:=|true|false)/i.test($start_date) ? (tmp = calc.parse(0, 0, 0, $start_date), /^date|number|percent$/.test(tmp.type) ? ($start_date = +tmp.value, true) : false) : false)) && ($start_date |= 0, true))) {
                    if ($start_date instanceof CalcError)
                        return $start_date;
                    return new CalcError(err);
                }
                xargs.push($start_date);
            }
            {
                var $days = args[i++];
                if ($days instanceof CalcError)
                    return $days;
                if (!((typeof ($days = this.force($days)) == 'number' || (typeof $days == 'boolean' ? ($days = +$days, true) : false) || (typeof $days == 'string' && !/^(?:=|true|false)/i.test($days) ? (tmp = calc.parse(0, 0, 0, $days), /^date|number|percent$/.test(tmp.type) ? ($days = +tmp.value, true) : false) : false)) && ($days |= 0, true))) {
                    if ($days instanceof CalcError)
                        return $days;
                    return new CalcError(err);
                }
                xargs.push($days);
            }
            {
                try {
                    var $holidays = this.cellValues(args.slice(i)).reduce(function (ret, $holidays) {
                        if ($holidays instanceof CalcError)
                            throw $holidays;
                        if ((typeof $holidays == 'number' || (typeof $holidays == 'boolean' ? ($holidays = +$holidays, true) : false) || (typeof $holidays == 'string' && !/^(?:=|true|false)/i.test($holidays) ? (tmp = calc.parse(0, 0, 0, $holidays), /^date|number|percent$/.test(tmp.type) ? ($holidays = +tmp.value, true) : false) : false)) && ($holidays |= 0, true))
                            ret.push($holidays);
                        return ret;
                    }.bind(this), []);
                    i = args.length;
                    xargs.push($holidays);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args.slice(i));
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (date, n, holidays) {
        var inc = n > 0 ? 1 : -1;
        n = Math.abs(n);
        var dow = unpackDate$1(date).day;
        while (n > 0) {
            date += inc;
            dow = (dow + inc) % 7;
            if (dow > 0 && dow < 6 && holidays.indexOf(date) < 0) {
                --n;
            }
        }
        return date;
    });

    defineBuiltinFunction('networkdays', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $start_date = args[i++];
                if ($start_date instanceof CalcError)
                    return $start_date;
                if (!((typeof ($start_date = this.force($start_date)) == 'number' || (typeof $start_date == 'boolean' ? ($start_date = +$start_date, true) : false) || (typeof $start_date == 'string' && !/^(?:=|true|false)/i.test($start_date) ? (tmp = calc.parse(0, 0, 0, $start_date), /^date|number|percent$/.test(tmp.type) ? ($start_date = +tmp.value, true) : false) : false)) && ($start_date |= 0, true))) {
                    if ($start_date instanceof CalcError)
                        return $start_date;
                    return new CalcError(err);
                }
                xargs.push($start_date);
            }
            {
                var $end_date = args[i++];
                if ($end_date instanceof CalcError)
                    return $end_date;
                if (!((typeof ($end_date = this.force($end_date)) == 'number' || (typeof $end_date == 'boolean' ? ($end_date = +$end_date, true) : false) || (typeof $end_date == 'string' && !/^(?:=|true|false)/i.test($end_date) ? (tmp = calc.parse(0, 0, 0, $end_date), /^date|number|percent$/.test(tmp.type) ? ($end_date = +tmp.value, true) : false) : false)) && ($end_date |= 0, true))) {
                    if ($end_date instanceof CalcError)
                        return $end_date;
                    return new CalcError(err);
                }
                xargs.push($end_date);
            }
            {
                try {
                    var $holidays = this.cellValues(args.slice(i)).reduce(function (ret, $holidays) {
                        if ($holidays instanceof CalcError)
                            throw $holidays;
                        if ((typeof $holidays == 'number' || (typeof $holidays == 'boolean' ? ($holidays = +$holidays, true) : false) || (typeof $holidays == 'string' && !/^(?:=|true|false)/i.test($holidays) ? (tmp = calc.parse(0, 0, 0, $holidays), /^date|number|percent$/.test(tmp.type) ? ($holidays = +tmp.value, true) : false) : false)) && ($holidays |= 0, true))
                            ret.push($holidays);
                        return ret;
                    }.bind(this), []);
                    i = args.length;
                    xargs.push($holidays);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args.slice(i));
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (date, end, holidays) {
        if (date > end) {
            var tmp = date;
            date = end;
            end = tmp;
        }
        var count = 0;
        var dow = unpackDate$1(date).day;
        while (date <= end) {
            if (dow > 0 && dow < 6 && holidays.indexOf(date) < 0) {
                count++;
            }
            date++;
            dow = (dow + 1) % 7;
        }
        return count;
    });

    defineBuiltinFunction('days', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $start_date = args[i++];
                if ($start_date instanceof CalcError)
                    return $start_date;
                if (!((typeof ($start_date = this.force($start_date)) == 'number' || (typeof $start_date == 'boolean' ? ($start_date = +$start_date, true) : false) || (typeof $start_date == 'string' && !/^(?:=|true|false)/i.test($start_date) ? (tmp = calc.parse(0, 0, 0, $start_date), /^date|number|percent$/.test(tmp.type) ? ($start_date = +tmp.value, true) : false) : false)) && ($start_date |= 0, true))) {
                    if ($start_date instanceof CalcError)
                        return $start_date;
                    return new CalcError(err);
                }
                xargs.push($start_date);
            }
            {
                var $end_date = args[i++];
                if ($end_date instanceof CalcError)
                    return $end_date;
                if (!((typeof ($end_date = this.force($end_date)) == 'number' || (typeof $end_date == 'boolean' ? ($end_date = +$end_date, true) : false) || (typeof $end_date == 'string' && !/^(?:=|true|false)/i.test($end_date) ? (tmp = calc.parse(0, 0, 0, $end_date), /^date|number|percent$/.test(tmp.type) ? ($end_date = +tmp.value, true) : false) : false)) && ($end_date |= 0, true))) {
                    if ($end_date instanceof CalcError)
                        return $end_date;
                    return new CalcError(err);
                }
                xargs.push($end_date);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $start_date = this._arrayArg(args[i]);
            if ($start_date) {
                xargs.push($start_date);
                width = Math.max(width, $start_date.width);
                height = Math.max(height, $start_date.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $end_date = this._arrayArg(args[i]);
            if ($end_date) {
                xargs.push($end_date);
                width = Math.max(width, $end_date.width);
                height = Math.max(height, $end_date.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (end, start) {
        return end - start;
    });

    function _days_360(start, end, method) {
        var d1 = unpackDate$1(start);
        var d2 = unpackDate$1(end);

        // https://en.wikipedia.org/wiki/360-day_calendar
        // humanity is a mess.
        if (method) {
            // EU method
            if (d1.date == 31) {
                d1.date = 30;
            }
            if (d2.date == 31) {
                d2.date = 30;
            }
        } else {
            // US method
            if (d1.month == 1 && d2.month == 1
                && d1.date == daysInMonth(d1.year, 1)
                && d2.date == daysInMonth(d2.year, 1)) {
                d2.date = 30;
            }
            if (d1.date == daysInMonth(d1.year, d1.month)) {
                d1.date = 30;
                if (d2.date == 31) {
                    d2.date = 30;
                }
            } else {
                if (d1.date == 30 && d2.date == 31) {
                    d2.date = 30;
                }
            }
        }

        return (360 * (d2.year - d1.year)
                + 30 * (d2.month - d1.month)
                + (d2.date - d1.date));
    }

    calc.runtime._days_360 = _days_360;

    defineBuiltinFunction('days360', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $start_date = args[i++];
                if ($start_date instanceof CalcError)
                    return $start_date;
                if (!((typeof ($start_date = this.force($start_date)) == 'number' || (typeof $start_date == 'boolean' ? ($start_date = +$start_date, true) : false) || (typeof $start_date == 'string' && !/^(?:=|true|false)/i.test($start_date) ? (tmp = calc.parse(0, 0, 0, $start_date), /^date|number|percent$/.test(tmp.type) ? ($start_date = +tmp.value, true) : false) : false)) && ($start_date |= 0, true))) {
                    if ($start_date instanceof CalcError)
                        return $start_date;
                    return new CalcError(err);
                }
                xargs.push($start_date);
            }
            {
                var $end_date = args[i++];
                if ($end_date instanceof CalcError)
                    return $end_date;
                if (!((typeof ($end_date = this.force($end_date)) == 'number' || (typeof $end_date == 'boolean' ? ($end_date = +$end_date, true) : false) || (typeof $end_date == 'string' && !/^(?:=|true|false)/i.test($end_date) ? (tmp = calc.parse(0, 0, 0, $end_date), /^date|number|percent$/.test(tmp.type) ? ($end_date = +tmp.value, true) : false) : false)) && ($end_date |= 0, true))) {
                    if ($end_date instanceof CalcError)
                        return $end_date;
                    return new CalcError(err);
                }
                xargs.push($end_date);
            }
            {
                var $method = args[i++];
                if ($method instanceof CalcError)
                    return $method;
                if (!(typeof ($method = this.force($method)) == 'boolean' || (typeof $method == 'number' ? ($method = !!$method, true) : false) || ($method == null ? ($method = false, true) : false))) {
                    if ($method instanceof CalcError)
                        return $method;
                    return new CalcError(err);
                }
                xargs.push($method);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $start_date = this._arrayArg(args[i]);
            if ($start_date) {
                xargs.push($start_date);
                width = Math.max(width, $start_date.width);
                height = Math.max(height, $start_date.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $end_date = this._arrayArg(args[i]);
            if ($end_date) {
                xargs.push($end_date);
                width = Math.max(width, $end_date.width);
                height = Math.max(height, $end_date.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $method = this._arrayArg(args[i]);
            if ($method) {
                xargs.push($method);
                width = Math.max(width, $method.width);
                height = Math.max(height, $method.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), _days_360);

    defineBuiltinFunction('yearfrac', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $start_date = args[i++];
                if ($start_date instanceof CalcError)
                    return $start_date;
                if (!((typeof ($start_date = this.force($start_date)) == 'number' || (typeof $start_date == 'boolean' ? ($start_date = +$start_date, true) : false) || (typeof $start_date == 'string' && !/^(?:=|true|false)/i.test($start_date) ? (tmp = calc.parse(0, 0, 0, $start_date), /^date|number|percent$/.test(tmp.type) ? ($start_date = +tmp.value, true) : false) : false)) && ($start_date |= 0, true))) {
                    if ($start_date instanceof CalcError)
                        return $start_date;
                    return new CalcError(err);
                }
                xargs.push($start_date);
            }
            {
                var $end_date = args[i++];
                if ($end_date instanceof CalcError)
                    return $end_date;
                if (!((typeof ($end_date = this.force($end_date)) == 'number' || (typeof $end_date == 'boolean' ? ($end_date = +$end_date, true) : false) || (typeof $end_date == 'string' && !/^(?:=|true|false)/i.test($end_date) ? (tmp = calc.parse(0, 0, 0, $end_date), /^date|number|percent$/.test(tmp.type) ? ($end_date = +tmp.value, true) : false) : false)) && ($end_date |= 0, true))) {
                    if ($end_date instanceof CalcError)
                        return $end_date;
                    return new CalcError(err);
                }
                xargs.push($end_date);
            }
            {
                var $method = args[i++];
                if ($method instanceof CalcError)
                    return $method;
                if (!((($method = this.force($method)) == null ? ($method = 0, true) : false) || ($method === 0 || $method === 1 || $method === 2 || $method === 3 || $method === 4))) {
                    if ($method instanceof CalcError)
                        return $method;
                    return new CalcError(err);
                }
                xargs.push($method);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $start_date = this._arrayArg(args[i]);
            if ($start_date) {
                xargs.push($start_date);
                width = Math.max(width, $start_date.width);
                height = Math.max(height, $start_date.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $end_date = this._arrayArg(args[i]);
            if ($end_date) {
                xargs.push($end_date);
                width = Math.max(width, $end_date.width);
                height = Math.max(height, $end_date.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $method = this._arrayArg(args[i]);
            if ($method) {
                xargs.push($method);
                width = Math.max(width, $method.width);
                height = Math.max(height, $method.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (start, end, method) {
        switch (method) {
        case 0:
            return _days_360(start, end, false) / 360;
        case 1:
            return (end - start) / daysInYear(unpackDate$1(start).year);
        case 2:
            return (end - start) / 360;
        case 3:
            return (end - start) / 365;
        case 4:
            return _days_360(start, end, true) / 360;
        }
    });

    defineBuiltinFunction('datevalue', false, function () {
        function check(args) {
            var xargs = [], i = 0, err = 'VALUE';
            {
                var $text = args[i++];
                if ($text instanceof CalcError)
                    return $text;
                if (!(typeof ($text = this.force($text)) == 'string' || typeof $text == 'boolean' || typeof $text == 'number' ? ($text += '', true) : $text === undefined ? ($text = '', true) : false)) {
                    if ($text instanceof CalcError)
                        return $text;
                    return new CalcError(err);
                }
                xargs.push($text);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $text = this._arrayArg(args[i]);
            if ($text) {
                xargs.push($text);
                width = Math.max(width, $text.width);
                height = Math.max(height, $text.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (text) {
        var date = calc.runtime.parseDate(text);
        if (date) {
            return calc.runtime.dateToSerial(date);
        }
        return new CalcError('VALUE');
    });

    defineBuiltinFunction('timevalue', false, function () {
        function check(args) {
            var xargs = [], i = 0, err = 'VALUE';
            {
                var $text = args[i++];
                if ($text instanceof CalcError)
                    return $text;
                if (!(typeof ($text = this.force($text)) == 'string' || typeof $text == 'boolean' || typeof $text == 'number' ? ($text += '', true) : $text === undefined ? ($text = '', true) : false)) {
                    if ($text instanceof CalcError)
                        return $text;
                    return new CalcError(err);
                }
                xargs.push($text);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $text = this._arrayArg(args[i]);
            if ($text) {
                xargs.push($text);
                width = Math.max(width, $text.width);
                height = Math.max(height, $text.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (text) {
        var m = text.toLowerCase().match(/(\d+):(\d+)(:(\d+)(\.(\d+))?)?\s*(am?|pm?)?/);
        if (m) {
            var hh = parseFloat(m[1]);
            var mm = parseFloat(m[2]);
            var ss = m[3] ? parseFloat(m[4]) : 0;
            var ampm = m[7];
            if (ampm && (hh > 12 || hh < 1)) {
                return new CalcError('VALUE');
            }
            if (/^p/.test(ampm)) {
                hh += 12;
            }
            return calc.runtime.packTime(hh, mm, ss, 0);
        }
        return new CalcError('VALUE');
    });

    /* -----[ Matrix functions ]----- */

    defineBuiltinFunction('mdeterm', false, function () {
        function check(args) {
            var xargs = [], i = 0, m, err = 'VALUE';
            {
                var $m = args[i++];
                if ($m instanceof CalcError)
                    return $m;
                if (!(((m = this.asMatrix($m)) ? $m = m : false) && ($m.width == $m.height ? true : (err = 'N/A', false)))) {
                    if ($m instanceof CalcError)
                        return $m;
                    return new CalcError(err);
                }
                xargs.push($m);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (m) {
        var error = m.each(function (val) {
            if (typeof val != 'number') {
                return new CalcError('VALUE');
            }
        }, true);
        return error || m.determinant();
    });

    defineBuiltinFunction('transpose', false, function () {
        function check(args) {
            var xargs = [], i = 0, m, err = 'VALUE';
            {
                var $range = args[i++];
                if ($range instanceof CalcError)
                    return $range;
                if (!((m = this.asMatrix($range)) ? $range = m : false)) {
                    if ($range instanceof CalcError)
                        return $range;
                    return new CalcError(err);
                }
                xargs.push($range);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (m) {
        return m.transpose();
    });

    defineBuiltinFunction('mmult', false, function () {
        function check(args) {
            var xargs = [], i = 0, m, err = 'VALUE';
            {
                var $a = args[i++];
                if ($a instanceof CalcError)
                    return $a;
                if (!((m = this.asMatrix($a)) ? $a = m : false)) {
                    if ($a instanceof CalcError)
                        return $a;
                    return new CalcError(err);
                }
                xargs.push($a);
            }
            {
                var $b = args[i++];
                if ($b instanceof CalcError)
                    return $b;
                if (!(((m = this.asMatrix($b)) ? $b = m : false) && ($b.height == $a.width ? true : (err = 'N/A', false)))) {
                    if ($b instanceof CalcError)
                        return $b;
                    return new CalcError(err);
                }
                xargs.push($b);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (a, b) {
        return a.multiply(b);
    });

    defineBuiltinFunction('munit', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $n = args[i++];
                if ($n instanceof CalcError)
                    return $n;
                if (!((typeof ($n = this.force($n)) == 'number' || (typeof $n == 'boolean' ? ($n = +$n, true) : false) || (typeof $n == 'string' && !/^(?:=|true|false)/i.test($n) ? (tmp = calc.parse(0, 0, 0, $n), /^date|number|percent$/.test(tmp.type) ? ($n = +tmp.value, true) : false) : false)) && (($n |= 0) >= 0 ? true : (err = 'NUM', false)))) {
                    if ($n instanceof CalcError)
                        return $n;
                    return new CalcError(err);
                }
                xargs.push($n);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (n) {
        return new Matrix(this).unit(n);
    });

    defineBuiltinFunction('minverse', false, function () {
        function check(args) {
            var xargs = [], i = 0, m, err = 'VALUE';
            {
                var $m = args[i++];
                if ($m instanceof CalcError)
                    return $m;
                if (!(((m = this.asMatrix($m)) ? $m = m : false) && ($m.width == $m.height ? true : (err = 'N/A', false)))) {
                    if ($m instanceof CalcError)
                        return $m;
                    return new CalcError(err);
                }
                xargs.push($m);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (m) {
        var error = m.each(function (val) {
            if (typeof val != 'number') {
                return new CalcError('VALUE');
            }
        }, true);
        return error || m.inverse() || new CalcError('VALUE');
    });

    /* -----[ Other ]----- */

    defineBuiltinFunction('rand', false, function () {
        function check(args) {
            var xargs = [], i = 0;
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        return { check: check };
    }(), function () {
        return Math.random();
    });

    defineBuiltinFunction('randbetween', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $min = args[i++];
                if ($min instanceof CalcError)
                    return $min;
                if (!((typeof ($min = this.force($min)) == 'number' || (typeof $min == 'boolean' ? ($min = +$min, true) : false) || (typeof $min == 'string' && !/^(?:=|true|false)/i.test($min) ? (tmp = calc.parse(0, 0, 0, $min), /^date|number|percent$/.test(tmp.type) ? ($min = +tmp.value, true) : false) : false)) && ($min |= 0, true))) {
                    if ($min instanceof CalcError)
                        return $min;
                    return new CalcError(err);
                }
                xargs.push($min);
            }
            {
                var $max = args[i++];
                if ($max instanceof CalcError)
                    return $max;
                if (!((typeof ($max = this.force($max)) == 'number' || (typeof $max == 'boolean' ? ($max = +$max, true) : false) || (typeof $max == 'string' && !/^(?:=|true|false)/i.test($max) ? (tmp = calc.parse(0, 0, 0, $max), /^date|number|percent$/.test(tmp.type) ? ($max = +tmp.value, true) : false) : false)) && ($max |= 0, true) && ($max >= $min ? true : (err = 'N/A', false)))) {
                    if ($max instanceof CalcError)
                        return $max;
                    return new CalcError(err);
                }
                xargs.push($max);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (min, max) {
        return min + Math.floor((max - min + 1) * Math.random());
    });

    defineBuiltinFunction('true', false, function () {
        function check(args) {
            var xargs = [], i = 0;
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        return { check: check };
    }(), function () {
        return true;
    });

    defineBuiltinFunction('false', false, function () {
        function check(args) {
            var xargs = [], i = 0;
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        return { check: check };
    }(), function () {
        return true;
    });

    defineBuiltinFunction('roman', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $number = args[i++];
                if ($number instanceof CalcError)
                    return $number;
                if (!((typeof ($number = this.force($number)) == 'number' || (typeof $number == 'boolean' ? ($number = +$number, true) : false) || (typeof $number == 'string' && !/^(?:=|true|false)/i.test($number) ? (tmp = calc.parse(0, 0, 0, $number), /^date|number|percent$/.test(tmp.type) ? ($number = +tmp.value, true) : false) : false)) && ($number |= 0, true))) {
                    if ($number instanceof CalcError)
                        return $number;
                    return new CalcError(err);
                }
                xargs.push($number);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $number = this._arrayArg(args[i]);
            if ($number) {
                xargs.push($number);
                width = Math.max(width, $number.width);
                height = Math.max(height, $number.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (num) {
        return arabicToRoman(num).toUpperCase();
    });

    defineBuiltinFunction('arabic', false, function () {
        function check(args) {
            var xargs = [], i = 0, err = 'VALUE';
            {
                var $roman = args[i++];
                if ($roman instanceof CalcError)
                    return $roman;
                if (!(typeof ($roman = this.force($roman)) == 'string' || typeof $roman == 'boolean' || typeof $roman == 'number' ? ($roman += '', true) : $roman === undefined ? ($roman = '', true) : false)) {
                    if ($roman instanceof CalcError)
                        return $roman;
                    return new CalcError(err);
                }
                xargs.push($roman);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $roman = this._arrayArg(args[i]);
            if ($roman) {
                xargs.push($roman);
                width = Math.max(width, $roman.width);
                height = Math.max(height, $roman.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (rom) {
        var num = romanToArabic(rom);
        return num == null ? new CalcError('VALUE') : num;
    });

    defineBuiltinFunction('base', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $number = args[i++];
                if ($number instanceof CalcError)
                    return $number;
                if (!((typeof ($number = this.force($number)) == 'number' || (typeof $number == 'boolean' ? ($number = +$number, true) : false) || (typeof $number == 'string' && !/^(?:=|true|false)/i.test($number) ? (tmp = calc.parse(0, 0, 0, $number), /^date|number|percent$/.test(tmp.type) ? ($number = +tmp.value, true) : false) : false)) && ($number |= 0, true))) {
                    if ($number instanceof CalcError)
                        return $number;
                    return new CalcError(err);
                }
                xargs.push($number);
            }
            {
                var $radix = args[i++];
                if ($radix instanceof CalcError)
                    return $radix;
                if (!((typeof ($radix = this.force($radix)) == 'number' || (typeof $radix == 'boolean' ? ($radix = +$radix, true) : false) || (typeof $radix == 'string' && !/^(?:=|true|false)/i.test($radix) ? (tmp = calc.parse(0, 0, 0, $radix), /^date|number|percent$/.test(tmp.type) ? ($radix = +tmp.value, true) : false) : false)) && ($radix |= 0, true) && ($radix >= 2 && $radix <= 36 ? true : (err = 'NUM', false)))) {
                    if ($radix instanceof CalcError)
                        return $radix;
                    return new CalcError(err);
                }
                xargs.push($radix);
            }
            {
                var $minLen = args[i++];
                if ($minLen instanceof CalcError)
                    return $minLen;
                if (!((typeof ($minLen = this.force($minLen)) == 'number' || (typeof $minLen == 'boolean' ? ($minLen = +$minLen, true) : false) || (typeof $minLen == 'string' && !/^(?:=|true|false)/i.test($minLen) ? (tmp = calc.parse(0, 0, 0, $minLen), /^date|number|percent$/.test(tmp.type) ? ($minLen = +tmp.value, true) : false) : false)) && (($minLen |= 0) >= 0 ? true : (err = 'NUM', false)) || ($minLen == null ? ($minLen = 0, true) : false))) {
                    if ($minLen instanceof CalcError)
                        return $minLen;
                    return new CalcError(err);
                }
                xargs.push($minLen);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $number = this._arrayArg(args[i]);
            if ($number) {
                xargs.push($number);
                width = Math.max(width, $number.width);
                height = Math.max(height, $number.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $radix = this._arrayArg(args[i]);
            if ($radix) {
                xargs.push($radix);
                width = Math.max(width, $radix.width);
                height = Math.max(height, $radix.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $minLen = this._arrayArg(args[i]);
            if ($minLen) {
                xargs.push($minLen);
                width = Math.max(width, $minLen.width);
                height = Math.max(height, $minLen.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (number, radix, minLen) {
        var str = number.toString(radix).toUpperCase();
        while (str.length < minLen) {
            str = '0' + str;
        }
        return str;
    });

    defineBuiltinFunction('decimal', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $text = args[i++];
                if ($text instanceof CalcError)
                    return $text;
                if (!(typeof ($text = this.force($text)) == 'string' || typeof $text == 'boolean' || typeof $text == 'number' ? ($text += '', true) : $text === undefined ? ($text = '', true) : false)) {
                    if ($text instanceof CalcError)
                        return $text;
                    return new CalcError(err);
                }
                xargs.push($text);
            }
            {
                var $radix = args[i++];
                if ($radix instanceof CalcError)
                    return $radix;
                if (!((typeof ($radix = this.force($radix)) == 'number' || (typeof $radix == 'boolean' ? ($radix = +$radix, true) : false) || (typeof $radix == 'string' && !/^(?:=|true|false)/i.test($radix) ? (tmp = calc.parse(0, 0, 0, $radix), /^date|number|percent$/.test(tmp.type) ? ($radix = +tmp.value, true) : false) : false)) && ($radix |= 0, true) && ($radix >= 2 && $radix <= 36 ? true : (err = 'NUM', false)))) {
                    if ($radix instanceof CalcError)
                        return $radix;
                    return new CalcError(err);
                }
                xargs.push($radix);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $text = this._arrayArg(args[i]);
            if ($text) {
                xargs.push($text);
                width = Math.max(width, $text.width);
                height = Math.max(height, $text.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $radix = this._arrayArg(args[i]);
            if ($radix) {
                xargs.push($radix);
                width = Math.max(width, $radix.width);
                height = Math.max(height, $radix.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (text, radix) {
        text = text.toUpperCase();
        var val = 0;
        for (var i = 0; i < text.length; ++i) {
            var d = text.charCodeAt(i);
            if (d >= 48 && d <= 57) {
                d -= 48;
            } else if (d >= 65 && d < 55 + radix) {
                d -= 55;
            } else {
                return new CalcError('VALUE');
            }
            val = val * radix + d;
        }
        return val;
    });

    /* -----[ String functions ]----- */

    defineBuiltinFunction('char', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $code = args[i++];
                if ($code instanceof CalcError)
                    return $code;
                if (!((typeof ($code = this.force($code)) == 'number' || (typeof $code == 'boolean' ? ($code = +$code, true) : false) || (typeof $code == 'string' && !/^(?:=|true|false)/i.test($code) ? (tmp = calc.parse(0, 0, 0, $code), /^date|number|percent$/.test(tmp.type) ? ($code = +tmp.value, true) : false) : false)) && (($code |= 0) >= 0 ? true : (err = 'NUM', false)))) {
                    if ($code instanceof CalcError)
                        return $code;
                    return new CalcError(err);
                }
                xargs.push($code);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $code = this._arrayArg(args[i]);
            if ($code) {
                xargs.push($code);
                width = Math.max(width, $code.width);
                height = Math.max(height, $code.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (code) {
        return String.fromCharCode(code);
    });

    // From XRegExp
    var RX_NON_PRINTABLE = /[\0-\x1F\x7F-\x9F\xAD\u0378\u0379\u037F-\u0383\u038B\u038D\u03A2\u0528-\u0530\u0557\u0558\u0560\u0588\u058B-\u058E\u0590\u05C8-\u05CF\u05EB-\u05EF\u05F5-\u0605\u061C\u061D\u06DD\u070E\u070F\u074B\u074C\u07B2-\u07BF\u07FB-\u07FF\u082E\u082F\u083F\u085C\u085D\u085F-\u089F\u08A1\u08AD-\u08E3\u08FF\u0978\u0980\u0984\u098D\u098E\u0991\u0992\u09A9\u09B1\u09B3-\u09B5\u09BA\u09BB\u09C5\u09C6\u09C9\u09CA\u09CF-\u09D6\u09D8-\u09DB\u09DE\u09E4\u09E5\u09FC-\u0A00\u0A04\u0A0B-\u0A0E\u0A11\u0A12\u0A29\u0A31\u0A34\u0A37\u0A3A\u0A3B\u0A3D\u0A43-\u0A46\u0A49\u0A4A\u0A4E-\u0A50\u0A52-\u0A58\u0A5D\u0A5F-\u0A65\u0A76-\u0A80\u0A84\u0A8E\u0A92\u0AA9\u0AB1\u0AB4\u0ABA\u0ABB\u0AC6\u0ACA\u0ACE\u0ACF\u0AD1-\u0ADF\u0AE4\u0AE5\u0AF2-\u0B00\u0B04\u0B0D\u0B0E\u0B11\u0B12\u0B29\u0B31\u0B34\u0B3A\u0B3B\u0B45\u0B46\u0B49\u0B4A\u0B4E-\u0B55\u0B58-\u0B5B\u0B5E\u0B64\u0B65\u0B78-\u0B81\u0B84\u0B8B-\u0B8D\u0B91\u0B96-\u0B98\u0B9B\u0B9D\u0BA0-\u0BA2\u0BA5-\u0BA7\u0BAB-\u0BAD\u0BBA-\u0BBD\u0BC3-\u0BC5\u0BC9\u0BCE\u0BCF\u0BD1-\u0BD6\u0BD8-\u0BE5\u0BFB-\u0C00\u0C04\u0C0D\u0C11\u0C29\u0C34\u0C3A-\u0C3C\u0C45\u0C49\u0C4E-\u0C54\u0C57\u0C5A-\u0C5F\u0C64\u0C65\u0C70-\u0C77\u0C80\u0C81\u0C84\u0C8D\u0C91\u0CA9\u0CB4\u0CBA\u0CBB\u0CC5\u0CC9\u0CCE-\u0CD4\u0CD7-\u0CDD\u0CDF\u0CE4\u0CE5\u0CF0\u0CF3-\u0D01\u0D04\u0D0D\u0D11\u0D3B\u0D3C\u0D45\u0D49\u0D4F-\u0D56\u0D58-\u0D5F\u0D64\u0D65\u0D76-\u0D78\u0D80\u0D81\u0D84\u0D97-\u0D99\u0DB2\u0DBC\u0DBE\u0DBF\u0DC7-\u0DC9\u0DCB-\u0DCE\u0DD5\u0DD7\u0DE0-\u0DF1\u0DF5-\u0E00\u0E3B-\u0E3E\u0E5C-\u0E80\u0E83\u0E85\u0E86\u0E89\u0E8B\u0E8C\u0E8E-\u0E93\u0E98\u0EA0\u0EA4\u0EA6\u0EA8\u0EA9\u0EAC\u0EBA\u0EBE\u0EBF\u0EC5\u0EC7\u0ECE\u0ECF\u0EDA\u0EDB\u0EE0-\u0EFF\u0F48\u0F6D-\u0F70\u0F98\u0FBD\u0FCD\u0FDB-\u0FFF\u10C6\u10C8-\u10CC\u10CE\u10CF\u1249\u124E\u124F\u1257\u1259\u125E\u125F\u1289\u128E\u128F\u12B1\u12B6\u12B7\u12BF\u12C1\u12C6\u12C7\u12D7\u1311\u1316\u1317\u135B\u135C\u137D-\u137F\u139A-\u139F\u13F5-\u13FF\u169D-\u169F\u16F1-\u16FF\u170D\u1715-\u171F\u1737-\u173F\u1754-\u175F\u176D\u1771\u1774-\u177F\u17DE\u17DF\u17EA-\u17EF\u17FA-\u17FF\u180F\u181A-\u181F\u1878-\u187F\u18AB-\u18AF\u18F6-\u18FF\u191D-\u191F\u192C-\u192F\u193C-\u193F\u1941-\u1943\u196E\u196F\u1975-\u197F\u19AC-\u19AF\u19CA-\u19CF\u19DB-\u19DD\u1A1C\u1A1D\u1A5F\u1A7D\u1A7E\u1A8A-\u1A8F\u1A9A-\u1A9F\u1AAE-\u1AFF\u1B4C-\u1B4F\u1B7D-\u1B7F\u1BF4-\u1BFB\u1C38-\u1C3A\u1C4A-\u1C4C\u1C80-\u1CBF\u1CC8-\u1CCF\u1CF7-\u1CFF\u1DE7-\u1DFB\u1F16\u1F17\u1F1E\u1F1F\u1F46\u1F47\u1F4E\u1F4F\u1F58\u1F5A\u1F5C\u1F5E\u1F7E\u1F7F\u1FB5\u1FC5\u1FD4\u1FD5\u1FDC\u1FF0\u1FF1\u1FF5\u1FFF\u200B-\u200F\u202A-\u202E\u2060-\u206F\u2072\u2073\u208F\u209D-\u209F\u20BB-\u20CF\u20F1-\u20FF\u218A-\u218F\u23F4-\u23FF\u2427-\u243F\u244B-\u245F\u2700\u2B4D-\u2B4F\u2B5A-\u2BFF\u2C2F\u2C5F\u2CF4-\u2CF8\u2D26\u2D28-\u2D2C\u2D2E\u2D2F\u2D68-\u2D6E\u2D71-\u2D7E\u2D97-\u2D9F\u2DA7\u2DAF\u2DB7\u2DBF\u2DC7\u2DCF\u2DD7\u2DDF\u2E3C-\u2E7F\u2E9A\u2EF4-\u2EFF\u2FD6-\u2FEF\u2FFC-\u2FFF\u3040\u3097\u3098\u3100-\u3104\u312E-\u3130\u318F\u31BB-\u31BF\u31E4-\u31EF\u321F\u32FF\u4DB6-\u4DBF\u9FCD-\u9FFF\uA48D-\uA48F\uA4C7-\uA4CF\uA62C-\uA63F\uA698-\uA69E\uA6F8-\uA6FF\uA78F\uA794-\uA79F\uA7AB-\uA7F7\uA82C-\uA82F\uA83A-\uA83F\uA878-\uA87F\uA8C5-\uA8CD\uA8DA-\uA8DF\uA8FC-\uA8FF\uA954-\uA95E\uA97D-\uA97F\uA9CE\uA9DA-\uA9DD\uA9E0-\uA9FF\uAA37-\uAA3F\uAA4E\uAA4F\uAA5A\uAA5B\uAA7C-\uAA7F\uAAC3-\uAADA\uAAF7-\uAB00\uAB07\uAB08\uAB0F\uAB10\uAB17-\uAB1F\uAB27\uAB2F-\uABBF\uABEE\uABEF\uABFA-\uABFF\uD7A4-\uD7AF\uD7C7-\uD7CA\uD7FC-\uF8FF\uFA6E\uFA6F\uFADA-\uFAFF\uFB07-\uFB12\uFB18-\uFB1C\uFB37\uFB3D\uFB3F\uFB42\uFB45\uFBC2-\uFBD2\uFD40-\uFD4F\uFD90\uFD91\uFDC8-\uFDEF\uFDFE\uFDFF\uFE1A-\uFE1F\uFE27-\uFE2F\uFE53\uFE67\uFE6C-\uFE6F\uFE75\uFEFD-\uFF00\uFFBF-\uFFC1\uFFC8\uFFC9\uFFD0\uFFD1\uFFD8\uFFD9\uFFDD-\uFFDF\uFFE7\uFFEF-\uFFFB\uFFFE\uFFFF]/g;

    defineBuiltinFunction('clean', false, function () {
        function check(args) {
            var xargs = [], i = 0, err = 'VALUE';
            {
                var $text = args[i++];
                if ($text instanceof CalcError)
                    return $text;
                if (!(typeof ($text = this.force($text)) == 'string' || typeof $text == 'boolean' || typeof $text == 'number' ? ($text += '', true) : $text === undefined ? ($text = '', true) : false)) {
                    if ($text instanceof CalcError)
                        return $text;
                    return new CalcError(err);
                }
                xargs.push($text);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $text = this._arrayArg(args[i]);
            if ($text) {
                xargs.push($text);
                width = Math.max(width, $text.width);
                height = Math.max(height, $text.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (text) {
        return text.replace(RX_NON_PRINTABLE, '');
    });

    defineBuiltinFunction('code', false, function () {
        function check(args) {
            var xargs = [], i = 0, err = 'VALUE';
            {
                var $text = args[i++];
                if ($text instanceof CalcError)
                    return $text;
                if (!(typeof ($text = this.force($text)) == 'string' || typeof $text == 'boolean' || typeof $text == 'number' ? ($text += '', true) : $text === undefined ? ($text = '', true) : false)) {
                    if ($text instanceof CalcError)
                        return $text;
                    return new CalcError(err);
                }
                xargs.push($text);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $text = this._arrayArg(args[i]);
            if ($text) {
                xargs.push($text);
                width = Math.max(width, $text.width);
                height = Math.max(height, $text.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (text) {
        return text.charAt(0);
    });

    calc.runtime.defineAlias("unichar", "char");
    calc.runtime.defineAlias("unicode", "code");

    defineBuiltinFunction('concatenate', false, function () {
        function check(args) {
            var stack = [], tmp, xargs = [], i = 0, err = 'VALUE';
            {
                if (i >= args.length)
                    return new CalcError('N/A');
                xargs.push(tmp = []);
                stack.push(xargs);
                xargs = tmp;
                do {
                    {
                        var $text = args[i++];
                        if ($text instanceof CalcError)
                            return $text;
                        if (!(typeof ($text = this.force($text)) == 'string' || typeof $text == 'boolean' || typeof $text == 'number' ? ($text += '', true) : $text === undefined ? ($text = '', true) : false)) {
                            if ($text instanceof CalcError)
                                return $text;
                            return new CalcError(err);
                        }
                        xargs.push($text);
                    }
                } while (i < args.length);
                xargs = stack.pop();
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            while (i < args.length) {
                toResolve.push(args[i++]);
            }
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            while (i < args.length) {
                var $text = this._arrayArg(args[i]);
                if ($text) {
                    xargs.push($text);
                    width = Math.max(width, $text.width);
                    height = Math.max(height, $text.height);
                    arrays.push(true);
                } else {
                    xargs.push(args[i]);
                    arrays.push(false);
                }
                i++;
            }
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (args) {
        var out = '';
        for (var i = 0; i < args.length; ++i) {
            out += args[i];
        }
        return out;
    });

    defineBuiltinFunction('dollar', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $number = args[i++];
                if ($number instanceof CalcError)
                    return $number;
                if (!((typeof ($number = this.force($number)) == 'number' ? ($number = limitPrecision($number), true) : false) || (typeof $number == 'boolean' ? ($number = +$number, true) : false) || (typeof $number == 'string' && !/^(?:=|true|false)/i.test($number) ? (tmp = calc.parse(0, 0, 0, $number), /^date|number|percent$/.test(tmp.type) ? ($number = +tmp.value, true) : false) : false))) {
                    if ($number instanceof CalcError)
                        return $number;
                    return new CalcError(err);
                }
                xargs.push($number);
            }
            {
                var $decimals = args[i++];
                if ($decimals instanceof CalcError)
                    return $decimals;
                if (!((typeof ($decimals = this.force($decimals)) == 'number' || (typeof $decimals == 'boolean' ? ($decimals = +$decimals, true) : false) || (typeof $decimals == 'string' && !/^(?:=|true|false)/i.test($decimals) ? (tmp = calc.parse(0, 0, 0, $decimals), /^date|number|percent$/.test(tmp.type) ? ($decimals = +tmp.value, true) : false) : false)) && ($decimals |= 0, true) || ($decimals == null ? ($decimals = 2, true) : false))) {
                    if ($decimals instanceof CalcError)
                        return $decimals;
                    return new CalcError(err);
                }
                xargs.push($decimals);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $number = this._arrayArg(args[i]);
            if ($number) {
                xargs.push($number);
                width = Math.max(width, $number.width);
                height = Math.max(height, $number.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $decimals = this._arrayArg(args[i]);
            if ($decimals) {
                xargs.push($decimals);
                width = Math.max(width, $decimals.width);
                height = Math.max(height, $decimals.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (number, decimals) {
        var format = '$#,##0DECIMALS;($#,##0DECIMALS)';
        var dec = '';
        var denomitator = 1;
        while (decimals-- > 0) {
            dec += '0';
        }
        while (++decimals < 0) {
            denomitator *= 10;
        }
        if (dec !== '') {
            dec = '.' + dec;
        } else if (denomitator !== 1) {
            number = Math.round(number / denomitator) * denomitator;
        }
        format = format.replace(/DECIMALS/g, dec);
        return formatting.text(number, format);
    });

    defineBuiltinFunction('exact', false, function () {
        function check(args) {
            var xargs = [], i = 0, err = 'VALUE';
            {
                var $text1 = args[i++];
                if ($text1 instanceof CalcError)
                    return $text1;
                if (!(typeof ($text1 = this.force($text1)) == 'string' || typeof $text1 == 'boolean' || typeof $text1 == 'number' ? ($text1 += '', true) : $text1 === undefined ? ($text1 = '', true) : false)) {
                    if ($text1 instanceof CalcError)
                        return $text1;
                    return new CalcError(err);
                }
                xargs.push($text1);
            }
            {
                var $text2 = args[i++];
                if ($text2 instanceof CalcError)
                    return $text2;
                if (!(typeof ($text2 = this.force($text2)) == 'string' || typeof $text2 == 'boolean' || typeof $text2 == 'number' ? ($text2 += '', true) : $text2 === undefined ? ($text2 = '', true) : false)) {
                    if ($text2 instanceof CalcError)
                        return $text2;
                    return new CalcError(err);
                }
                xargs.push($text2);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $text1 = this._arrayArg(args[i]);
            if ($text1) {
                xargs.push($text1);
                width = Math.max(width, $text1.width);
                height = Math.max(height, $text1.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $text2 = this._arrayArg(args[i]);
            if ($text2) {
                xargs.push($text2);
                width = Math.max(width, $text2.width);
                height = Math.max(height, $text2.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (a, b) {
        return a === b;
    });

    defineBuiltinFunction('find', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $substring = args[i++];
                if ($substring instanceof CalcError)
                    return $substring;
                if (!(typeof ($substring = this.force($substring)) == 'string' || typeof $substring == 'boolean' || typeof $substring == 'number' ? ($substring += '', true) : $substring === undefined ? ($substring = '', true) : false)) {
                    if ($substring instanceof CalcError)
                        return $substring;
                    return new CalcError(err);
                }
                xargs.push($substring);
            }
            {
                var $string = args[i++];
                if ($string instanceof CalcError)
                    return $string;
                if (!(typeof ($string = this.force($string)) == 'string' || typeof $string == 'boolean' || typeof $string == 'number' ? ($string += '', true) : $string === undefined ? ($string = '', true) : false)) {
                    if ($string instanceof CalcError)
                        return $string;
                    return new CalcError(err);
                }
                xargs.push($string);
            }
            {
                var $start = args[i++];
                if ($start instanceof CalcError)
                    return $start;
                if (!((typeof ($start = this.force($start)) == 'number' || (typeof $start == 'boolean' ? ($start = +$start, true) : false) || (typeof $start == 'string' && !/^(?:=|true|false)/i.test($start) ? (tmp = calc.parse(0, 0, 0, $start), /^date|number|percent$/.test(tmp.type) ? ($start = +tmp.value, true) : false) : false)) && (($start |= 0) > 0 ? true : (err = 'NUM', false)) || ($start == null ? ($start = 1, true) : false))) {
                    if ($start instanceof CalcError)
                        return $start;
                    return new CalcError(err);
                }
                xargs.push($start);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $substring = this._arrayArg(args[i]);
            if ($substring) {
                xargs.push($substring);
                width = Math.max(width, $substring.width);
                height = Math.max(height, $substring.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $string = this._arrayArg(args[i]);
            if ($string) {
                xargs.push($string);
                width = Math.max(width, $string.width);
                height = Math.max(height, $string.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $start = this._arrayArg(args[i]);
            if ($start) {
                xargs.push($start);
                width = Math.max(width, $start.width);
                height = Math.max(height, $start.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (substring, string, start) {
        var pos = string.indexOf(substring, start - 1);
        return pos < 0 ? new CalcError('VALUE') : pos + 1;
    });

    defineBuiltinFunction('fixed', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $number = args[i++];
                if ($number instanceof CalcError)
                    return $number;
                if (!((typeof ($number = this.force($number)) == 'number' ? ($number = limitPrecision($number), true) : false) || (typeof $number == 'boolean' ? ($number = +$number, true) : false) || (typeof $number == 'string' && !/^(?:=|true|false)/i.test($number) ? (tmp = calc.parse(0, 0, 0, $number), /^date|number|percent$/.test(tmp.type) ? ($number = +tmp.value, true) : false) : false))) {
                    if ($number instanceof CalcError)
                        return $number;
                    return new CalcError(err);
                }
                xargs.push($number);
            }
            {
                var $decimals = args[i++];
                if ($decimals instanceof CalcError)
                    return $decimals;
                if (!((typeof ($decimals = this.force($decimals)) == 'number' || (typeof $decimals == 'boolean' ? ($decimals = +$decimals, true) : false) || (typeof $decimals == 'string' && !/^(?:=|true|false)/i.test($decimals) ? (tmp = calc.parse(0, 0, 0, $decimals), /^date|number|percent$/.test(tmp.type) ? ($decimals = +tmp.value, true) : false) : false)) && ($decimals |= 0, true) || ($decimals == null ? ($decimals = 2, true) : false))) {
                    if ($decimals instanceof CalcError)
                        return $decimals;
                    return new CalcError(err);
                }
                xargs.push($decimals);
            }
            {
                var $noCommas = args[i++];
                if ($noCommas instanceof CalcError)
                    return $noCommas;
                if (!(typeof ($noCommas = this.force($noCommas)) == 'boolean' || ($noCommas == null ? ($noCommas = false, true) : false))) {
                    if ($noCommas instanceof CalcError)
                        return $noCommas;
                    return new CalcError(err);
                }
                xargs.push($noCommas);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $number = this._arrayArg(args[i]);
            if ($number) {
                xargs.push($number);
                width = Math.max(width, $number.width);
                height = Math.max(height, $number.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $decimals = this._arrayArg(args[i]);
            if ($decimals) {
                xargs.push($decimals);
                width = Math.max(width, $decimals.width);
                height = Math.max(height, $decimals.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $noCommas = this._arrayArg(args[i]);
            if ($noCommas) {
                xargs.push($noCommas);
                width = Math.max(width, $noCommas.width);
                height = Math.max(height, $noCommas.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (number, decimals, noCommas) {
        var scale = Math.pow(10, decimals);
        number = Math.round(number * scale) / scale;
        var format = noCommas ? '0' : '#,##0';
        if (decimals > 0) {
            format += '.';
            while (decimals-- > 0) {
                format += '0';
            }
        }
        return formatting.text(number, format);
    });

    defineBuiltinFunction('left', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $text = args[i++];
                if ($text instanceof CalcError)
                    return $text;
                if (!(typeof ($text = this.force($text)) == 'string' || typeof $text == 'boolean' || typeof $text == 'number' ? ($text += '', true) : $text === undefined ? ($text = '', true) : false)) {
                    if ($text instanceof CalcError)
                        return $text;
                    return new CalcError(err);
                }
                xargs.push($text);
            }
            {
                var $length = args[i++];
                if ($length instanceof CalcError)
                    return $length;
                if (!((typeof ($length = this.force($length)) == 'number' || (typeof $length == 'boolean' ? ($length = +$length, true) : false) || (typeof $length == 'string' && !/^(?:=|true|false)/i.test($length) ? (tmp = calc.parse(0, 0, 0, $length), /^date|number|percent$/.test(tmp.type) ? ($length = +tmp.value, true) : false) : false)) && (($length |= 0) >= 0 ? true : (err = 'NUM', false)) || ($length == null ? ($length = 1, true) : false))) {
                    if ($length instanceof CalcError)
                        return $length;
                    return new CalcError(err);
                }
                xargs.push($length);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $text = this._arrayArg(args[i]);
            if ($text) {
                xargs.push($text);
                width = Math.max(width, $text.width);
                height = Math.max(height, $text.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $length = this._arrayArg(args[i]);
            if ($length) {
                xargs.push($length);
                width = Math.max(width, $length.width);
                height = Math.max(height, $length.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (text, length) {
        return text.substr(0, length);
    });

    defineBuiltinFunction('right', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $text = args[i++];
                if ($text instanceof CalcError)
                    return $text;
                if (!(typeof ($text = this.force($text)) == 'string' || typeof $text == 'boolean' || typeof $text == 'number' ? ($text += '', true) : $text === undefined ? ($text = '', true) : false)) {
                    if ($text instanceof CalcError)
                        return $text;
                    return new CalcError(err);
                }
                xargs.push($text);
            }
            {
                var $length = args[i++];
                if ($length instanceof CalcError)
                    return $length;
                if (!((typeof ($length = this.force($length)) == 'number' || (typeof $length == 'boolean' ? ($length = +$length, true) : false) || (typeof $length == 'string' && !/^(?:=|true|false)/i.test($length) ? (tmp = calc.parse(0, 0, 0, $length), /^date|number|percent$/.test(tmp.type) ? ($length = +tmp.value, true) : false) : false)) && (($length |= 0) >= 0 ? true : (err = 'NUM', false)) || ($length == null ? ($length = 1, true) : false))) {
                    if ($length instanceof CalcError)
                        return $length;
                    return new CalcError(err);
                }
                xargs.push($length);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $text = this._arrayArg(args[i]);
            if ($text) {
                xargs.push($text);
                width = Math.max(width, $text.width);
                height = Math.max(height, $text.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $length = this._arrayArg(args[i]);
            if ($length) {
                xargs.push($length);
                width = Math.max(width, $length.width);
                height = Math.max(height, $length.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (text, length) {
        return text.substr(-length);
    });

    defineBuiltinFunction('len', false, function () {
        function check(args) {
            var xargs = [], i = 0, err = 'VALUE';
            {
                var $text = args[i++];
                if ($text instanceof CalcError)
                    return $text;
                if (!(typeof ($text = this.force($text)) == 'string' || typeof $text == 'boolean' || typeof $text == 'number' ? ($text += '', true) : $text === undefined ? ($text = '', true) : false)) {
                    if ($text instanceof CalcError)
                        return $text;
                    return new CalcError(err);
                }
                xargs.push($text);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $text = this._arrayArg(args[i]);
            if ($text) {
                xargs.push($text);
                width = Math.max(width, $text.width);
                height = Math.max(height, $text.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (text) {
        return text.length;
    });

    defineBuiltinFunction('lower', false, function () {
        function check(args) {
            var xargs = [], i = 0, err = 'VALUE';
            {
                var $text = args[i++];
                if ($text instanceof CalcError)
                    return $text;
                if (!(typeof ($text = this.force($text)) == 'string' || typeof $text == 'boolean' || typeof $text == 'number' ? ($text += '', true) : $text === undefined ? ($text = '', true) : false)) {
                    if ($text instanceof CalcError)
                        return $text;
                    return new CalcError(err);
                }
                xargs.push($text);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $text = this._arrayArg(args[i]);
            if ($text) {
                xargs.push($text);
                width = Math.max(width, $text.width);
                height = Math.max(height, $text.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (text) {
        return text.toLowerCase();
    });

    defineBuiltinFunction('upper', false, function () {
        function check(args) {
            var xargs = [], i = 0, err = 'VALUE';
            {
                var $text = args[i++];
                if ($text instanceof CalcError)
                    return $text;
                if (!(typeof ($text = this.force($text)) == 'string' || typeof $text == 'boolean' || typeof $text == 'number' ? ($text += '', true) : $text === undefined ? ($text = '', true) : false)) {
                    if ($text instanceof CalcError)
                        return $text;
                    return new CalcError(err);
                }
                xargs.push($text);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $text = this._arrayArg(args[i]);
            if ($text) {
                xargs.push($text);
                width = Math.max(width, $text.width);
                height = Math.max(height, $text.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (text) {
        return text.toUpperCase();
    });

    defineBuiltinFunction('ltrim', false, function () {
        function check(args) {
            var xargs = [], i = 0, err = 'VALUE';
            {
                var $text = args[i++];
                if ($text instanceof CalcError)
                    return $text;
                if (!(typeof ($text = this.force($text)) == 'string' || typeof $text == 'boolean' || typeof $text == 'number' ? ($text += '', true) : $text === undefined ? ($text = '', true) : false)) {
                    if ($text instanceof CalcError)
                        return $text;
                    return new CalcError(err);
                }
                xargs.push($text);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $text = this._arrayArg(args[i]);
            if ($text) {
                xargs.push($text);
                width = Math.max(width, $text.width);
                height = Math.max(height, $text.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (text) {
        return text.replace(/^\s+/, '');
    });

    defineBuiltinFunction('rtrim', false, function () {
        function check(args) {
            var xargs = [], i = 0, err = 'VALUE';
            {
                var $text = args[i++];
                if ($text instanceof CalcError)
                    return $text;
                if (!(typeof ($text = this.force($text)) == 'string' || typeof $text == 'boolean' || typeof $text == 'number' ? ($text += '', true) : $text === undefined ? ($text = '', true) : false)) {
                    if ($text instanceof CalcError)
                        return $text;
                    return new CalcError(err);
                }
                xargs.push($text);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $text = this._arrayArg(args[i]);
            if ($text) {
                xargs.push($text);
                width = Math.max(width, $text.width);
                height = Math.max(height, $text.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (text) {
        return text.replace(/\s+$/, '');
    });

    defineBuiltinFunction('trim', false, function () {
        function check(args) {
            var xargs = [], i = 0, err = 'VALUE';
            {
                var $text = args[i++];
                if ($text instanceof CalcError)
                    return $text;
                if (!(typeof ($text = this.force($text)) == 'string' || typeof $text == 'boolean' || typeof $text == 'number' ? ($text += '', true) : $text === undefined ? ($text = '', true) : false)) {
                    if ($text instanceof CalcError)
                        return $text;
                    return new CalcError(err);
                }
                xargs.push($text);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $text = this._arrayArg(args[i]);
            if ($text) {
                xargs.push($text);
                width = Math.max(width, $text.width);
                height = Math.max(height, $text.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (text) {
        return text.replace(/^\s+|\s+$/, '');
    });

    defineBuiltinFunction('mid', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $text = args[i++];
                if ($text instanceof CalcError)
                    return $text;
                if (!(typeof ($text = this.force($text)) == 'string' || typeof $text == 'boolean' || typeof $text == 'number' ? ($text += '', true) : $text === undefined ? ($text = '', true) : false)) {
                    if ($text instanceof CalcError)
                        return $text;
                    return new CalcError(err);
                }
                xargs.push($text);
            }
            {
                var $start = args[i++];
                if ($start instanceof CalcError)
                    return $start;
                if (!((typeof ($start = this.force($start)) == 'number' || (typeof $start == 'boolean' ? ($start = +$start, true) : false) || (typeof $start == 'string' && !/^(?:=|true|false)/i.test($start) ? (tmp = calc.parse(0, 0, 0, $start), /^date|number|percent$/.test(tmp.type) ? ($start = +tmp.value, true) : false) : false)) && (($start |= 0) > 0 ? true : (err = 'NUM', false)))) {
                    if ($start instanceof CalcError)
                        return $start;
                    return new CalcError(err);
                }
                xargs.push($start);
            }
            {
                var $length = args[i++];
                if ($length instanceof CalcError)
                    return $length;
                if (!((typeof ($length = this.force($length)) == 'number' || (typeof $length == 'boolean' ? ($length = +$length, true) : false) || (typeof $length == 'string' && !/^(?:=|true|false)/i.test($length) ? (tmp = calc.parse(0, 0, 0, $length), /^date|number|percent$/.test(tmp.type) ? ($length = +tmp.value, true) : false) : false)) && (($length |= 0) >= 0 ? true : (err = 'NUM', false)))) {
                    if ($length instanceof CalcError)
                        return $length;
                    return new CalcError(err);
                }
                xargs.push($length);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $text = this._arrayArg(args[i]);
            if ($text) {
                xargs.push($text);
                width = Math.max(width, $text.width);
                height = Math.max(height, $text.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $start = this._arrayArg(args[i]);
            if ($start) {
                xargs.push($start);
                width = Math.max(width, $start.width);
                height = Math.max(height, $start.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $length = this._arrayArg(args[i]);
            if ($length) {
                xargs.push($length);
                width = Math.max(width, $length.width);
                height = Math.max(height, $length.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (text, start, length) {
        return text.substr(start - 1, length);
    });

    defineBuiltinFunction('proper', false, function () {
        function check(args) {
            var xargs = [], i = 0, err = 'VALUE';
            {
                var $text = args[i++];
                if ($text instanceof CalcError)
                    return $text;
                if (!(typeof ($text = this.force($text)) == 'string' || typeof $text == 'boolean' || typeof $text == 'number' ? ($text += '', true) : $text === undefined ? ($text = '', true) : false)) {
                    if ($text instanceof CalcError)
                        return $text;
                    return new CalcError(err);
                }
                xargs.push($text);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $text = this._arrayArg(args[i]);
            if ($text) {
                xargs.push($text);
                width = Math.max(width, $text.width);
                height = Math.max(height, $text.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (text) {
        return text.toLowerCase().replace(/\b./g, function (s) {
            return s.toUpperCase();
        });
    });

    defineBuiltinFunction('replace', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $text = args[i++];
                if ($text instanceof CalcError)
                    return $text;
                if (!(typeof ($text = this.force($text)) == 'string' || typeof $text == 'boolean' || typeof $text == 'number' ? ($text += '', true) : $text === undefined ? ($text = '', true) : false)) {
                    if ($text instanceof CalcError)
                        return $text;
                    return new CalcError(err);
                }
                xargs.push($text);
            }
            {
                var $start = args[i++];
                if ($start instanceof CalcError)
                    return $start;
                if (!((typeof ($start = this.force($start)) == 'number' || (typeof $start == 'boolean' ? ($start = +$start, true) : false) || (typeof $start == 'string' && !/^(?:=|true|false)/i.test($start) ? (tmp = calc.parse(0, 0, 0, $start), /^date|number|percent$/.test(tmp.type) ? ($start = +tmp.value, true) : false) : false)) && (($start |= 0) > 0 ? true : (err = 'NUM', false)))) {
                    if ($start instanceof CalcError)
                        return $start;
                    return new CalcError(err);
                }
                xargs.push($start);
            }
            {
                var $length = args[i++];
                if ($length instanceof CalcError)
                    return $length;
                if (!((typeof ($length = this.force($length)) == 'number' || (typeof $length == 'boolean' ? ($length = +$length, true) : false) || (typeof $length == 'string' && !/^(?:=|true|false)/i.test($length) ? (tmp = calc.parse(0, 0, 0, $length), /^date|number|percent$/.test(tmp.type) ? ($length = +tmp.value, true) : false) : false)) && (($length |= 0) >= 0 ? true : (err = 'NUM', false)))) {
                    if ($length instanceof CalcError)
                        return $length;
                    return new CalcError(err);
                }
                xargs.push($length);
            }
            {
                var $newText = args[i++];
                if ($newText instanceof CalcError)
                    return $newText;
                if (!(typeof ($newText = this.force($newText)) == 'string' || typeof $newText == 'boolean' || typeof $newText == 'number' ? ($newText += '', true) : $newText === undefined ? ($newText = '', true) : false)) {
                    if ($newText instanceof CalcError)
                        return $newText;
                    return new CalcError(err);
                }
                xargs.push($newText);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $text = this._arrayArg(args[i]);
            if ($text) {
                xargs.push($text);
                width = Math.max(width, $text.width);
                height = Math.max(height, $text.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $start = this._arrayArg(args[i]);
            if ($start) {
                xargs.push($start);
                width = Math.max(width, $start.width);
                height = Math.max(height, $start.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $length = this._arrayArg(args[i]);
            if ($length) {
                xargs.push($length);
                width = Math.max(width, $length.width);
                height = Math.max(height, $length.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $newText = this._arrayArg(args[i]);
            if ($newText) {
                xargs.push($newText);
                width = Math.max(width, $newText.width);
                height = Math.max(height, $newText.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (text, start, length, newText) {
        return text.substr(0, --start) + newText + text.substr(start + length);
    });

    defineBuiltinFunction('rept', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $text = args[i++];
                if ($text instanceof CalcError)
                    return $text;
                if (!(typeof ($text = this.force($text)) == 'string' || typeof $text == 'boolean' || typeof $text == 'number' ? ($text += '', true) : $text === undefined ? ($text = '', true) : false)) {
                    if ($text instanceof CalcError)
                        return $text;
                    return new CalcError(err);
                }
                xargs.push($text);
            }
            {
                var $number = args[i++];
                if ($number instanceof CalcError)
                    return $number;
                if (!((typeof ($number = this.force($number)) == 'number' || (typeof $number == 'boolean' ? ($number = +$number, true) : false) || (typeof $number == 'string' && !/^(?:=|true|false)/i.test($number) ? (tmp = calc.parse(0, 0, 0, $number), /^date|number|percent$/.test(tmp.type) ? ($number = +tmp.value, true) : false) : false)) && (($number |= 0) >= 0 ? true : (err = 'NUM', false)))) {
                    if ($number instanceof CalcError)
                        return $number;
                    return new CalcError(err);
                }
                xargs.push($number);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $text = this._arrayArg(args[i]);
            if ($text) {
                xargs.push($text);
                width = Math.max(width, $text.width);
                height = Math.max(height, $text.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $number = this._arrayArg(args[i]);
            if ($number) {
                xargs.push($number);
                width = Math.max(width, $number.width);
                height = Math.max(height, $number.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (text, number) {
        var out = '';
        while (number-- > 0) {
            out += text;
        }
        return out;
    });

    defineBuiltinFunction('search', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $substring = args[i++];
                if ($substring instanceof CalcError)
                    return $substring;
                if (!(typeof ($substring = this.force($substring)) == 'string' || typeof $substring == 'boolean' || typeof $substring == 'number' ? ($substring += '', true) : $substring === undefined ? ($substring = '', true) : false)) {
                    if ($substring instanceof CalcError)
                        return $substring;
                    return new CalcError(err);
                }
                xargs.push($substring);
            }
            {
                var $string = args[i++];
                if ($string instanceof CalcError)
                    return $string;
                if (!(typeof ($string = this.force($string)) == 'string' || typeof $string == 'boolean' || typeof $string == 'number' ? ($string += '', true) : $string === undefined ? ($string = '', true) : false)) {
                    if ($string instanceof CalcError)
                        return $string;
                    return new CalcError(err);
                }
                xargs.push($string);
            }
            {
                var $start = args[i++];
                if ($start instanceof CalcError)
                    return $start;
                if (!((typeof ($start = this.force($start)) == 'number' || (typeof $start == 'boolean' ? ($start = +$start, true) : false) || (typeof $start == 'string' && !/^(?:=|true|false)/i.test($start) ? (tmp = calc.parse(0, 0, 0, $start), /^date|number|percent$/.test(tmp.type) ? ($start = +tmp.value, true) : false) : false)) && (($start |= 0) > 0 ? true : (err = 'NUM', false)) || ($start == null ? ($start = 1, true) : false))) {
                    if ($start instanceof CalcError)
                        return $start;
                    return new CalcError(err);
                }
                xargs.push($start);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $substring = this._arrayArg(args[i]);
            if ($substring) {
                xargs.push($substring);
                width = Math.max(width, $substring.width);
                height = Math.max(height, $substring.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $string = this._arrayArg(args[i]);
            if ($string) {
                xargs.push($string);
                width = Math.max(width, $string.width);
                height = Math.max(height, $string.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $start = this._arrayArg(args[i]);
            if ($start) {
                xargs.push($start);
                width = Math.max(width, $start.width);
                height = Math.max(height, $start.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (substring, string, start) {
        var pos = string.toLowerCase().indexOf(substring.toLowerCase(), start - 1);
        return pos < 0 ? new CalcError('VALUE') : pos + 1;
    });

    defineBuiltinFunction('substitute', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $text = args[i++];
                if ($text instanceof CalcError)
                    return $text;
                if (!(typeof ($text = this.force($text)) == 'string' || typeof $text == 'boolean' || typeof $text == 'number' ? ($text += '', true) : $text === undefined ? ($text = '', true) : false)) {
                    if ($text instanceof CalcError)
                        return $text;
                    return new CalcError(err);
                }
                xargs.push($text);
            }
            {
                var $oldText = args[i++];
                if ($oldText instanceof CalcError)
                    return $oldText;
                if (!(typeof ($oldText = this.force($oldText)) == 'string' || typeof $oldText == 'boolean' || typeof $oldText == 'number' ? ($oldText += '', true) : $oldText === undefined ? ($oldText = '', true) : false)) {
                    if ($oldText instanceof CalcError)
                        return $oldText;
                    return new CalcError(err);
                }
                xargs.push($oldText);
            }
            {
                var $newText = args[i++];
                if ($newText instanceof CalcError)
                    return $newText;
                if (!(typeof ($newText = this.force($newText)) == 'string' || typeof $newText == 'boolean' || typeof $newText == 'number' ? ($newText += '', true) : $newText === undefined ? ($newText = '', true) : false)) {
                    if ($newText instanceof CalcError)
                        return $newText;
                    return new CalcError(err);
                }
                xargs.push($newText);
            }
            {
                var $nth = args[i++];
                if ($nth instanceof CalcError)
                    return $nth;
                if (!((typeof ($nth = this.force($nth)) == 'number' || (typeof $nth == 'boolean' ? ($nth = +$nth, true) : false) || (typeof $nth == 'string' && !/^(?:=|true|false)/i.test($nth) ? (tmp = calc.parse(0, 0, 0, $nth), /^date|number|percent$/.test(tmp.type) ? ($nth = +tmp.value, true) : false) : false)) && (($nth |= 0) > 0 ? true : (err = 'NUM', false)) || $nth == null)) {
                    if ($nth instanceof CalcError)
                        return $nth;
                    return new CalcError(err);
                }
                xargs.push($nth);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $text = this._arrayArg(args[i]);
            if ($text) {
                xargs.push($text);
                width = Math.max(width, $text.width);
                height = Math.max(height, $text.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $oldText = this._arrayArg(args[i]);
            if ($oldText) {
                xargs.push($oldText);
                width = Math.max(width, $oldText.width);
                height = Math.max(height, $oldText.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $newText = this._arrayArg(args[i]);
            if ($newText) {
                xargs.push($newText);
                width = Math.max(width, $newText.width);
                height = Math.max(height, $newText.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $nth = this._arrayArg(args[i]);
            if ($nth) {
                xargs.push($nth);
                width = Math.max(width, $nth.width);
                height = Math.max(height, $nth.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (text, oldText, newText, nth) {
        if (oldText === newText) {
            return text;
        }
        var a = text.split(oldText);
        if (nth == null) {
            return a.join(newText);
        }
        text = '';
        nth--;
        for (var i = 0; i < a.length; ++i) {
            text += a[i];
            if (i < a.length - 1) {
                if (i === nth) {
                    text += newText;
                } else {
                    text += oldText;
                }
            }
        }
        return text;
    });

    defineBuiltinFunction('t', false, function () {
        function check(args) {
            var xargs = [], i = 0, err = 'VALUE';
            {
                var $value = args[i++];
                if ($value instanceof CalcError)
                    return $value;
                if (!(($value = this.force($value)) != null && i <= args.length)) {
                    if ($value instanceof CalcError)
                        return $value;
                    return new CalcError(err);
                }
                xargs.push($value);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $value = this._arrayArg(args[i]);
            if ($value) {
                xargs.push($value);
                width = Math.max(width, $value.width);
                height = Math.max(height, $value.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (value) {
        return typeof value == 'string' ? value : '';
    });

    defineBuiltinFunction('text', false, function () {
        function check(args) {
            var xargs = [], i = 0, err = 'VALUE';
            {
                var $value = args[i++];
                if ($value instanceof CalcError)
                    return $value;
                if (!(($value = this.force($value)) != null && i <= args.length)) {
                    if ($value instanceof CalcError)
                        return $value;
                    return new CalcError(err);
                }
                xargs.push($value);
            }
            {
                var $format = args[i++];
                if ($format instanceof CalcError)
                    return $format;
                if (!(typeof ($format = this.force($format)) == 'string' || typeof $format == 'boolean' || typeof $format == 'number' ? ($format += '', true) : $format === undefined ? ($format = '', true) : false)) {
                    if ($format instanceof CalcError)
                        return $format;
                    return new CalcError(err);
                }
                xargs.push($format);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $value = this._arrayArg(args[i]);
            if ($value) {
                xargs.push($value);
                width = Math.max(width, $value.width);
                height = Math.max(height, $value.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $format = this._arrayArg(args[i]);
            if ($format) {
                xargs.push($format);
                width = Math.max(width, $format.width);
                height = Math.max(height, $format.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (value, format) {
        return formatting.text(value, format);
    });

    defineBuiltinFunction('value', false, function () {
        function check(args) {
            var xargs = [], i = 0, err = 'VALUE';
            {
                var $value = args[i++];
                if ($value instanceof CalcError)
                    return $value;
                if (!(($value = this.force($value)) != null && i <= args.length)) {
                    if ($value instanceof CalcError)
                        return $value;
                    return new CalcError(err);
                }
                xargs.push($value);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $value = this._arrayArg(args[i]);
            if ($value) {
                xargs.push($value);
                width = Math.max(width, $value.width);
                height = Math.max(height, $value.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (value) {
        if (typeof value == 'number') {
            return value;
        }
        if (typeof value == 'boolean') {
            return +value;
        }
        value = (value + '').replace(/[$€,]/g, '');
        value = parseFloat(value);
        return isNaN(value) ? new CalcError('VALUE') : value;
    });

    function Hyperlink(link, text) {
        this.link = link;
        this.text = text;
    }
    Hyperlink.prototype.toString = function() {
        return this.text;
    };

    defineBuiltinFunction('hyperlink', false, function () {
        function check(args) {
            var xargs = [], i = 0, err = 'VALUE';
            {
                var $link = args[i++];
                if ($link instanceof CalcError)
                    return $link;
                if (!(typeof ($link = this.force($link)) == 'string' || typeof $link == 'boolean' || typeof $link == 'number' ? ($link += '', true) : $link === undefined ? ($link = '', true) : false)) {
                    if ($link instanceof CalcError)
                        return $link;
                    return new CalcError(err);
                }
                xargs.push($link);
            }
            {
                var $text = args[i++];
                if ($text instanceof CalcError)
                    return $text;
                if (!((typeof ($text = this.force($text)) == 'string' || typeof $text == 'boolean' || typeof $text == 'number' ? ($text += '', true) : $text === undefined ? ($text = '', true) : false) || ($text == null ? ($text = $link, true) : false))) {
                    if ($text instanceof CalcError)
                        return $text;
                    return new CalcError(err);
                }
                xargs.push($text);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $link = this._arrayArg(args[i]);
            if ($link) {
                xargs.push($link);
                width = Math.max(width, $link.width);
                height = Math.max(height, $link.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $text = this._arrayArg(args[i]);
            if ($text) {
                xargs.push($text);
                width = Math.max(width, $text.width);
                height = Math.max(height, $text.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (link, text) {
        return new Hyperlink(link, text);
    });

    //// other misc functions

    defineBuiltinFunction('iferror', false, function () {
        function check(args) {
            var xargs = [], i = 0, err = 'VALUE';
            {
                var $value = args[i++];
                if (!($value = this.force($value), i <= args.length)) {
                    return new CalcError(err);
                }
                xargs.push($value);
            }
            {
                var $value_if_error = args[i++];
                if (!(($value_if_error = this.force($value_if_error)) != null && i <= args.length)) {
                    return new CalcError(err);
                }
                xargs.push($value_if_error);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        function arrayArgs(args) {
            var xargs = [], width = 0, height = 0, arrays = [], i = 0;
            var $value = this._arrayArg(args[i]);
            if ($value) {
                xargs.push($value);
                width = Math.max(width, $value.width);
                height = Math.max(height, $value.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            var $value_if_error = this._arrayArg(args[i]);
            if ($value_if_error) {
                xargs.push($value_if_error);
                width = Math.max(width, $value_if_error.width);
                height = Math.max(height, $value_if_error.height);
                arrays.push(true);
            } else {
                xargs.push(args[i]);
                arrays.push(false);
            }
            i++;
            return {
                args: xargs,
                width: width,
                height: height,
                arrays: arrays
            };
        }
        return {
            check: check,
            resolve: resolve,
            arrayArgs: arrayArgs
        };
    }(), function (value, valueIfError) {
        return value instanceof CalcError ? valueIfError : value;
    });

    //// utils

    var parseCriteria = (function(){
        var RXCACHE = Object.create(null);

        function makeComparator(cmp, x) {
            if (typeof x == "string") {
                var num = parseFloat(x);
                if (!isNaN(num) && num == x) {
                    x = num;
                }
            }
            return function(a) {
                var b = x;
                if (typeof a == "string" && typeof b == "string") {
                    a = a.toLowerCase();
                    b = b.toLowerCase();
                }
                return cmp(a, b);
            };
        }

        function lc(a) {
            var num, str;
            if (typeof a == "string") {
                a = a.toLowerCase();
            }
            if (/^[0-9.]+%$/.test(a)) {
                str = a.substr(0, a.length - 1);
                num = parseFloat(str);
                if (!isNaN(num) && num == str) {
                    a = num / 100;
                }
            } else if (/^[0-9.]+$/.test(a)) {
                num = parseFloat(a);
                if (!isNaN(num) && num == a) {
                    a = num;
                }
            }
            return a;
        }

        function compLT(a, b) { return lc(a) < lc(b); }
        function compLTE(a, b) { return lc(a) <= lc(b); }
        function compGT(a, b) { return lc(a) > lc(b); }
        function compGTE(a, b) { return lc(a) >= lc(b); }
        function compNE(a, b) { return !compEQ(a, b); }
        function compEQ(a, b) {
            if (b instanceof RegExp) {
                return b.test(a);
            }
            if (typeof a == "string" || typeof b == "string") {
                // if either one is string, make sure both are strings
                a = String(a);
                b = String(b);
            }
            return lc(a) == lc(b);
        }

        return function(cmp) {
            if (typeof cmp == "function") {
                return cmp;
            }
            var m;
            if ((m = /^=(.*)$/.exec(cmp))) {
                return makeComparator(compEQ, m[1]);
            }
            if ((m = /^<>(.*)$/.exec(cmp))) {
                return makeComparator(compNE, m[1]);
            }
            if ((m = /^<=(.*)$/.exec(cmp))) {
                return makeComparator(compLTE, m[1]);
            }
            if ((m = /^<(.*)$/.exec(cmp))) {
                return makeComparator(compLT, m[1]);
            }
            if ((m = /^>=(.*)$/.exec(cmp))) {
                return makeComparator(compGTE, m[1]);
            }
            if ((m = /^>(.*)$/.exec(cmp))) {
                return makeComparator(compGT, m[1]);
            }
            if (/[?*]/.exec(cmp)) {
                // has wildchars
                var rx = RXCACHE[cmp];
                if (!rx) {
                    rx = cmp.replace(/(~\?|~\*|[\]({\+\.\|\^\$\\})\[]|[?*])/g, function(s){
                        switch (s) {
                        case "~?" : return "\\?";
                        case "~*" : return "\\*";
                        case "?" : return ".";
                        case "*" : return ".*";
                        default : return "\\" + s;
                        }
                    });
                    rx = RXCACHE[cmp] = new RegExp("^" + rx + "$", "i");
                }
                return makeComparator(compEQ, rx);
            }
            return makeComparator(compEQ, cmp);
        };
    })();

    function numericPredicate(val) {
        return typeof val == "number"
            || typeof val == "boolean"
            || val == null
            || val === "";
    }

    function ascending(a, b) {
        return a === b ? 0 : a < b ? -1 : 1;
    }

    function descending(a, b) {
        return a === b ? 0 : a < b ? 1 : -1;
    }

    defineBuiltinFunction('ERF', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $lower_limit = args[i++];
                if ($lower_limit instanceof CalcError)
                    return $lower_limit;
                if (!((typeof ($lower_limit = this.force($lower_limit)) == 'number' ? ($lower_limit = limitPrecision($lower_limit), true) : false) || (typeof $lower_limit == 'boolean' ? ($lower_limit = +$lower_limit, true) : false) || (typeof $lower_limit == 'string' && !/^(?:=|true|false)/i.test($lower_limit) ? (tmp = calc.parse(0, 0, 0, $lower_limit), /^date|number|percent$/.test(tmp.type) ? ($lower_limit = +tmp.value, true) : false) : false))) {
                    if ($lower_limit instanceof CalcError)
                        return $lower_limit;
                    return new CalcError(err);
                }
                xargs.push($lower_limit);
            }
            {
                var $upper_limit = args[i++];
                if ($upper_limit instanceof CalcError)
                    return $upper_limit;
                if (!((typeof ($upper_limit = this.force($upper_limit)) == 'number' ? ($upper_limit = limitPrecision($upper_limit), true) : false) || (typeof $upper_limit == 'boolean' ? ($upper_limit = +$upper_limit, true) : false) || (typeof $upper_limit == 'string' && !/^(?:=|true|false)/i.test($upper_limit) ? (tmp = calc.parse(0, 0, 0, $upper_limit), /^date|number|percent$/.test(tmp.type) ? ($upper_limit = +tmp.value, true) : false) : false) || $upper_limit == null)) {
                    if ($upper_limit instanceof CalcError)
                        return $upper_limit;
                    return new CalcError(err);
                }
                xargs.push($upper_limit);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (ll, ul) {
        if (ul == null) {
            return ERF(ll);
        }
        return ERF(ul) - ERF(ll);
    });

    defineBuiltinFunction('ERFC', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $x = args[i++];
                if ($x instanceof CalcError)
                    return $x;
                if (!((typeof ($x = this.force($x)) == 'number' ? ($x = limitPrecision($x), true) : false) || (typeof $x == 'boolean' ? ($x = +$x, true) : false) || (typeof $x == 'string' && !/^(?:=|true|false)/i.test($x) ? (tmp = calc.parse(0, 0, 0, $x), /^date|number|percent$/.test(tmp.type) ? ($x = +tmp.value, true) : false) : false))) {
                    if ($x instanceof CalcError)
                        return $x;
                    return new CalcError(err);
                }
                xargs.push($x);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), ERFC);

    defineBuiltinFunction('GAMMALN', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $x = args[i++];
                if ($x instanceof CalcError)
                    return $x;
                if (!(((typeof ($x = this.force($x)) == 'number' ? ($x = limitPrecision($x), true) : false) || (typeof $x == 'boolean' ? ($x = +$x, true) : false) || (typeof $x == 'string' && !/^(?:=|true|false)/i.test($x) ? (tmp = calc.parse(0, 0, 0, $x), /^date|number|percent$/.test(tmp.type) ? ($x = +tmp.value, true) : false) : false)) && ($x > 0 ? true : (err = 'NUM', false)))) {
                    if ($x instanceof CalcError)
                        return $x;
                    return new CalcError(err);
                }
                xargs.push($x);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), GAMMALN);

    defineBuiltinFunction('GAMMA', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $x = args[i++];
                if ($x instanceof CalcError)
                    return $x;
                if (!((typeof ($x = this.force($x)) == 'number' ? ($x = limitPrecision($x), true) : false) || (typeof $x == 'boolean' ? ($x = +$x, true) : false) || (typeof $x == 'string' && !/^(?:=|true|false)/i.test($x) ? (tmp = calc.parse(0, 0, 0, $x), /^date|number|percent$/.test(tmp.type) ? ($x = +tmp.value, true) : false) : false))) {
                    if ($x instanceof CalcError)
                        return $x;
                    return new CalcError(err);
                }
                xargs.push($x);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), GAMMA);

    defineBuiltinFunction('GAMMA.DIST', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $x = args[i++];
                if ($x instanceof CalcError)
                    return $x;
                if (!(((typeof ($x = this.force($x)) == 'number' ? ($x = limitPrecision($x), true) : false) || (typeof $x == 'boolean' ? ($x = +$x, true) : false) || (typeof $x == 'string' && !/^(?:=|true|false)/i.test($x) ? (tmp = calc.parse(0, 0, 0, $x), /^date|number|percent$/.test(tmp.type) ? ($x = +tmp.value, true) : false) : false)) && ($x >= 0 ? true : (err = 'NUM', false)))) {
                    if ($x instanceof CalcError)
                        return $x;
                    return new CalcError(err);
                }
                xargs.push($x);
            }
            {
                var $alpha = args[i++];
                if ($alpha instanceof CalcError)
                    return $alpha;
                if (!(((typeof ($alpha = this.force($alpha)) == 'number' ? ($alpha = limitPrecision($alpha), true) : false) || (typeof $alpha == 'boolean' ? ($alpha = +$alpha, true) : false) || (typeof $alpha == 'string' && !/^(?:=|true|false)/i.test($alpha) ? (tmp = calc.parse(0, 0, 0, $alpha), /^date|number|percent$/.test(tmp.type) ? ($alpha = +tmp.value, true) : false) : false)) && ($alpha > 0 ? true : (err = 'NUM', false)))) {
                    if ($alpha instanceof CalcError)
                        return $alpha;
                    return new CalcError(err);
                }
                xargs.push($alpha);
            }
            {
                var $beta = args[i++];
                if ($beta instanceof CalcError)
                    return $beta;
                if (!(((typeof ($beta = this.force($beta)) == 'number' ? ($beta = limitPrecision($beta), true) : false) || (typeof $beta == 'boolean' ? ($beta = +$beta, true) : false) || (typeof $beta == 'string' && !/^(?:=|true|false)/i.test($beta) ? (tmp = calc.parse(0, 0, 0, $beta), /^date|number|percent$/.test(tmp.type) ? ($beta = +tmp.value, true) : false) : false)) && ($beta > 0 ? true : (err = 'NUM', false)))) {
                    if ($beta instanceof CalcError)
                        return $beta;
                    return new CalcError(err);
                }
                xargs.push($beta);
            }
            {
                var $cumulative = args[i++];
                if ($cumulative instanceof CalcError)
                    return $cumulative;
                if (!(typeof ($cumulative = this.force($cumulative)) == 'boolean' || (typeof $cumulative == 'number' ? ($cumulative = !!$cumulative, true) : false))) {
                    if ($cumulative instanceof CalcError)
                        return $cumulative;
                    return new CalcError(err);
                }
                xargs.push($cumulative);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), GAMMA_DIST);

    defineBuiltinFunction('GAMMA.INV', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $p = args[i++];
                if ($p instanceof CalcError)
                    return $p;
                if (!(((typeof ($p = this.force($p)) == 'number' ? ($p = limitPrecision($p), true) : false) || (typeof $p == 'boolean' ? ($p = +$p, true) : false) || (typeof $p == 'string' && !/^(?:=|true|false)/i.test($p) ? (tmp = calc.parse(0, 0, 0, $p), /^date|number|percent$/.test(tmp.type) ? ($p = +tmp.value, true) : false) : false)) && ($p >= 0 && $p <= 1 ? true : (err = 'NUM', false)))) {
                    if ($p instanceof CalcError)
                        return $p;
                    return new CalcError(err);
                }
                xargs.push($p);
            }
            {
                var $alpha = args[i++];
                if ($alpha instanceof CalcError)
                    return $alpha;
                if (!(((typeof ($alpha = this.force($alpha)) == 'number' ? ($alpha = limitPrecision($alpha), true) : false) || (typeof $alpha == 'boolean' ? ($alpha = +$alpha, true) : false) || (typeof $alpha == 'string' && !/^(?:=|true|false)/i.test($alpha) ? (tmp = calc.parse(0, 0, 0, $alpha), /^date|number|percent$/.test(tmp.type) ? ($alpha = +tmp.value, true) : false) : false)) && ($alpha > 0 ? true : (err = 'NUM', false)))) {
                    if ($alpha instanceof CalcError)
                        return $alpha;
                    return new CalcError(err);
                }
                xargs.push($alpha);
            }
            {
                var $beta = args[i++];
                if ($beta instanceof CalcError)
                    return $beta;
                if (!(((typeof ($beta = this.force($beta)) == 'number' ? ($beta = limitPrecision($beta), true) : false) || (typeof $beta == 'boolean' ? ($beta = +$beta, true) : false) || (typeof $beta == 'string' && !/^(?:=|true|false)/i.test($beta) ? (tmp = calc.parse(0, 0, 0, $beta), /^date|number|percent$/.test(tmp.type) ? ($beta = +tmp.value, true) : false) : false)) && ($beta > 0 ? true : (err = 'NUM', false)))) {
                    if ($beta instanceof CalcError)
                        return $beta;
                    return new CalcError(err);
                }
                xargs.push($beta);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), GAMMA_INV);

    defineBuiltinFunction('NORM.S.DIST', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $z = args[i++];
                if ($z instanceof CalcError)
                    return $z;
                if (!((typeof ($z = this.force($z)) == 'number' ? ($z = limitPrecision($z), true) : false) || (typeof $z == 'boolean' ? ($z = +$z, true) : false) || (typeof $z == 'string' && !/^(?:=|true|false)/i.test($z) ? (tmp = calc.parse(0, 0, 0, $z), /^date|number|percent$/.test(tmp.type) ? ($z = +tmp.value, true) : false) : false))) {
                    if ($z instanceof CalcError)
                        return $z;
                    return new CalcError(err);
                }
                xargs.push($z);
            }
            {
                var $cumulative = args[i++];
                if ($cumulative instanceof CalcError)
                    return $cumulative;
                if (!(typeof ($cumulative = this.force($cumulative)) == 'boolean' || (typeof $cumulative == 'number' ? ($cumulative = !!$cumulative, true) : false))) {
                    if ($cumulative instanceof CalcError)
                        return $cumulative;
                    return new CalcError(err);
                }
                xargs.push($cumulative);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), NORM_S_DIST);

    defineBuiltinFunction('NORM.S.INV', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $p = args[i++];
                if ($p instanceof CalcError)
                    return $p;
                if (!(((typeof ($p = this.force($p)) == 'number' ? ($p = limitPrecision($p), true) : false) || (typeof $p == 'boolean' ? ($p = +$p, true) : false) || (typeof $p == 'string' && !/^(?:=|true|false)/i.test($p) ? (tmp = calc.parse(0, 0, 0, $p), /^date|number|percent$/.test(tmp.type) ? ($p = +tmp.value, true) : false) : false)) && ($p >= 0 && $p <= 1 ? true : (err = 'NUM', false)))) {
                    if ($p instanceof CalcError)
                        return $p;
                    return new CalcError(err);
                }
                xargs.push($p);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), NORM_S_INV);

    defineBuiltinFunction('NORM.DIST', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $x = args[i++];
                if ($x instanceof CalcError)
                    return $x;
                if (!((typeof ($x = this.force($x)) == 'number' ? ($x = limitPrecision($x), true) : false) || (typeof $x == 'boolean' ? ($x = +$x, true) : false) || (typeof $x == 'string' && !/^(?:=|true|false)/i.test($x) ? (tmp = calc.parse(0, 0, 0, $x), /^date|number|percent$/.test(tmp.type) ? ($x = +tmp.value, true) : false) : false))) {
                    if ($x instanceof CalcError)
                        return $x;
                    return new CalcError(err);
                }
                xargs.push($x);
            }
            {
                var $mean = args[i++];
                if ($mean instanceof CalcError)
                    return $mean;
                if (!((typeof ($mean = this.force($mean)) == 'number' ? ($mean = limitPrecision($mean), true) : false) || (typeof $mean == 'boolean' ? ($mean = +$mean, true) : false) || (typeof $mean == 'string' && !/^(?:=|true|false)/i.test($mean) ? (tmp = calc.parse(0, 0, 0, $mean), /^date|number|percent$/.test(tmp.type) ? ($mean = +tmp.value, true) : false) : false))) {
                    if ($mean instanceof CalcError)
                        return $mean;
                    return new CalcError(err);
                }
                xargs.push($mean);
            }
            {
                var $stddev = args[i++];
                if ($stddev instanceof CalcError)
                    return $stddev;
                if (!(((typeof ($stddev = this.force($stddev)) == 'number' ? ($stddev = limitPrecision($stddev), true) : false) || (typeof $stddev == 'boolean' ? ($stddev = +$stddev, true) : false) || (typeof $stddev == 'string' && !/^(?:=|true|false)/i.test($stddev) ? (tmp = calc.parse(0, 0, 0, $stddev), /^date|number|percent$/.test(tmp.type) ? ($stddev = +tmp.value, true) : false) : false)) && ($stddev > 0 ? true : (err = 'NUM', false)))) {
                    if ($stddev instanceof CalcError)
                        return $stddev;
                    return new CalcError(err);
                }
                xargs.push($stddev);
            }
            {
                var $cumulative = args[i++];
                if ($cumulative instanceof CalcError)
                    return $cumulative;
                if (!(typeof ($cumulative = this.force($cumulative)) == 'boolean' || (typeof $cumulative == 'number' ? ($cumulative = !!$cumulative, true) : false))) {
                    if ($cumulative instanceof CalcError)
                        return $cumulative;
                    return new CalcError(err);
                }
                xargs.push($cumulative);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), NORM_DIST);

    defineBuiltinFunction('NORM.INV', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $p = args[i++];
                if ($p instanceof CalcError)
                    return $p;
                if (!(((typeof ($p = this.force($p)) == 'number' ? ($p = limitPrecision($p), true) : false) || (typeof $p == 'boolean' ? ($p = +$p, true) : false) || (typeof $p == 'string' && !/^(?:=|true|false)/i.test($p) ? (tmp = calc.parse(0, 0, 0, $p), /^date|number|percent$/.test(tmp.type) ? ($p = +tmp.value, true) : false) : false)) && ($p >= 0 && $p <= 1 ? true : (err = 'NUM', false)))) {
                    if ($p instanceof CalcError)
                        return $p;
                    return new CalcError(err);
                }
                xargs.push($p);
            }
            {
                var $mean = args[i++];
                if ($mean instanceof CalcError)
                    return $mean;
                if (!((typeof ($mean = this.force($mean)) == 'number' ? ($mean = limitPrecision($mean), true) : false) || (typeof $mean == 'boolean' ? ($mean = +$mean, true) : false) || (typeof $mean == 'string' && !/^(?:=|true|false)/i.test($mean) ? (tmp = calc.parse(0, 0, 0, $mean), /^date|number|percent$/.test(tmp.type) ? ($mean = +tmp.value, true) : false) : false))) {
                    if ($mean instanceof CalcError)
                        return $mean;
                    return new CalcError(err);
                }
                xargs.push($mean);
            }
            {
                var $stddev = args[i++];
                if ($stddev instanceof CalcError)
                    return $stddev;
                if (!(((typeof ($stddev = this.force($stddev)) == 'number' ? ($stddev = limitPrecision($stddev), true) : false) || (typeof $stddev == 'boolean' ? ($stddev = +$stddev, true) : false) || (typeof $stddev == 'string' && !/^(?:=|true|false)/i.test($stddev) ? (tmp = calc.parse(0, 0, 0, $stddev), /^date|number|percent$/.test(tmp.type) ? ($stddev = +tmp.value, true) : false) : false)) && ($stddev > 0 ? true : (err = 'NUM', false)))) {
                    if ($stddev instanceof CalcError)
                        return $stddev;
                    return new CalcError(err);
                }
                xargs.push($stddev);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), NORM_INV);

    defineBuiltinFunction('BETADIST', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $x = args[i++];
                if ($x instanceof CalcError)
                    return $x;
                if (!((typeof ($x = this.force($x)) == 'number' ? ($x = limitPrecision($x), true) : false) || (typeof $x == 'boolean' ? ($x = +$x, true) : false) || (typeof $x == 'string' && !/^(?:=|true|false)/i.test($x) ? (tmp = calc.parse(0, 0, 0, $x), /^date|number|percent$/.test(tmp.type) ? ($x = +tmp.value, true) : false) : false))) {
                    if ($x instanceof CalcError)
                        return $x;
                    return new CalcError(err);
                }
                xargs.push($x);
            }
            {
                var $alpha = args[i++];
                if ($alpha instanceof CalcError)
                    return $alpha;
                if (!(((typeof ($alpha = this.force($alpha)) == 'number' ? ($alpha = limitPrecision($alpha), true) : false) || (typeof $alpha == 'boolean' ? ($alpha = +$alpha, true) : false) || (typeof $alpha == 'string' && !/^(?:=|true|false)/i.test($alpha) ? (tmp = calc.parse(0, 0, 0, $alpha), /^date|number|percent$/.test(tmp.type) ? ($alpha = +tmp.value, true) : false) : false)) && ($alpha > 0 ? true : (err = 'NUM', false)))) {
                    if ($alpha instanceof CalcError)
                        return $alpha;
                    return new CalcError(err);
                }
                xargs.push($alpha);
            }
            {
                var $beta = args[i++];
                if ($beta instanceof CalcError)
                    return $beta;
                if (!(((typeof ($beta = this.force($beta)) == 'number' ? ($beta = limitPrecision($beta), true) : false) || (typeof $beta == 'boolean' ? ($beta = +$beta, true) : false) || (typeof $beta == 'string' && !/^(?:=|true|false)/i.test($beta) ? (tmp = calc.parse(0, 0, 0, $beta), /^date|number|percent$/.test(tmp.type) ? ($beta = +tmp.value, true) : false) : false)) && ($beta > 0 ? true : (err = 'NUM', false)))) {
                    if ($beta instanceof CalcError)
                        return $beta;
                    return new CalcError(err);
                }
                xargs.push($beta);
            }
            {
                var $A = args[i++];
                if ($A instanceof CalcError)
                    return $A;
                if (!((typeof ($A = this.force($A)) == 'number' ? ($A = limitPrecision($A), true) : false) || (typeof $A == 'boolean' ? ($A = +$A, true) : false) || (typeof $A == 'string' && !/^(?:=|true|false)/i.test($A) ? (tmp = calc.parse(0, 0, 0, $A), /^date|number|percent$/.test(tmp.type) ? ($A = +tmp.value, true) : false) : false) || ($A == null ? ($A = 0, true) : false))) {
                    if ($A instanceof CalcError)
                        return $A;
                    return new CalcError(err);
                }
                xargs.push($A);
            }
            {
                var $B = args[i++];
                if ($B instanceof CalcError)
                    return $B;
                if (!((typeof ($B = this.force($B)) == 'number' ? ($B = limitPrecision($B), true) : false) || (typeof $B == 'boolean' ? ($B = +$B, true) : false) || (typeof $B == 'string' && !/^(?:=|true|false)/i.test($B) ? (tmp = calc.parse(0, 0, 0, $B), /^date|number|percent$/.test(tmp.type) ? ($B = +tmp.value, true) : false) : false) || ($B == null ? ($B = 1, true) : false))) {
                    if ($B instanceof CalcError)
                        return $B;
                    return new CalcError(err);
                }
                xargs.push($B);
            }
            {
                if (!($x >= $A ? true : (err = 'NUM', false)))
                    return new CalcError(err);
            }
            {
                if (!($x <= $B ? true : (err = 'NUM', false)))
                    return new CalcError(err);
            }
            {
                if (!($A < $B ? true : (err = 'NUM', false)))
                    return new CalcError(err);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), BETADIST);

    defineBuiltinFunction('BETA.DIST', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $x = args[i++];
                if ($x instanceof CalcError)
                    return $x;
                if (!((typeof ($x = this.force($x)) == 'number' ? ($x = limitPrecision($x), true) : false) || (typeof $x == 'boolean' ? ($x = +$x, true) : false) || (typeof $x == 'string' && !/^(?:=|true|false)/i.test($x) ? (tmp = calc.parse(0, 0, 0, $x), /^date|number|percent$/.test(tmp.type) ? ($x = +tmp.value, true) : false) : false))) {
                    if ($x instanceof CalcError)
                        return $x;
                    return new CalcError(err);
                }
                xargs.push($x);
            }
            {
                var $alpha = args[i++];
                if ($alpha instanceof CalcError)
                    return $alpha;
                if (!(((typeof ($alpha = this.force($alpha)) == 'number' ? ($alpha = limitPrecision($alpha), true) : false) || (typeof $alpha == 'boolean' ? ($alpha = +$alpha, true) : false) || (typeof $alpha == 'string' && !/^(?:=|true|false)/i.test($alpha) ? (tmp = calc.parse(0, 0, 0, $alpha), /^date|number|percent$/.test(tmp.type) ? ($alpha = +tmp.value, true) : false) : false)) && ($alpha > 0 ? true : (err = 'NUM', false)))) {
                    if ($alpha instanceof CalcError)
                        return $alpha;
                    return new CalcError(err);
                }
                xargs.push($alpha);
            }
            {
                var $beta = args[i++];
                if ($beta instanceof CalcError)
                    return $beta;
                if (!(((typeof ($beta = this.force($beta)) == 'number' ? ($beta = limitPrecision($beta), true) : false) || (typeof $beta == 'boolean' ? ($beta = +$beta, true) : false) || (typeof $beta == 'string' && !/^(?:=|true|false)/i.test($beta) ? (tmp = calc.parse(0, 0, 0, $beta), /^date|number|percent$/.test(tmp.type) ? ($beta = +tmp.value, true) : false) : false)) && ($beta > 0 ? true : (err = 'NUM', false)))) {
                    if ($beta instanceof CalcError)
                        return $beta;
                    return new CalcError(err);
                }
                xargs.push($beta);
            }
            {
                var $cumulative = args[i++];
                if ($cumulative instanceof CalcError)
                    return $cumulative;
                if (!(typeof ($cumulative = this.force($cumulative)) == 'boolean' || (typeof $cumulative == 'number' ? ($cumulative = !!$cumulative, true) : false))) {
                    if ($cumulative instanceof CalcError)
                        return $cumulative;
                    return new CalcError(err);
                }
                xargs.push($cumulative);
            }
            {
                var $A = args[i++];
                if ($A instanceof CalcError)
                    return $A;
                if (!((typeof ($A = this.force($A)) == 'number' ? ($A = limitPrecision($A), true) : false) || (typeof $A == 'boolean' ? ($A = +$A, true) : false) || (typeof $A == 'string' && !/^(?:=|true|false)/i.test($A) ? (tmp = calc.parse(0, 0, 0, $A), /^date|number|percent$/.test(tmp.type) ? ($A = +tmp.value, true) : false) : false) || ($A == null ? ($A = 0, true) : false))) {
                    if ($A instanceof CalcError)
                        return $A;
                    return new CalcError(err);
                }
                xargs.push($A);
            }
            {
                var $B = args[i++];
                if ($B instanceof CalcError)
                    return $B;
                if (!((typeof ($B = this.force($B)) == 'number' ? ($B = limitPrecision($B), true) : false) || (typeof $B == 'boolean' ? ($B = +$B, true) : false) || (typeof $B == 'string' && !/^(?:=|true|false)/i.test($B) ? (tmp = calc.parse(0, 0, 0, $B), /^date|number|percent$/.test(tmp.type) ? ($B = +tmp.value, true) : false) : false) || ($B == null ? ($B = 1, true) : false))) {
                    if ($B instanceof CalcError)
                        return $B;
                    return new CalcError(err);
                }
                xargs.push($B);
            }
            {
                if (!($x >= $A ? true : (err = 'NUM', false)))
                    return new CalcError(err);
            }
            {
                if (!($x <= $B ? true : (err = 'NUM', false)))
                    return new CalcError(err);
            }
            {
                if (!($A < $B ? true : (err = 'NUM', false)))
                    return new CalcError(err);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), BETA_DIST);

    defineBuiltinFunction('BETA.INV', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $p = args[i++];
                if ($p instanceof CalcError)
                    return $p;
                if (!(((typeof ($p = this.force($p)) == 'number' ? ($p = limitPrecision($p), true) : false) || (typeof $p == 'boolean' ? ($p = +$p, true) : false) || (typeof $p == 'string' && !/^(?:=|true|false)/i.test($p) ? (tmp = calc.parse(0, 0, 0, $p), /^date|number|percent$/.test(tmp.type) ? ($p = +tmp.value, true) : false) : false)) && ($p >= 0 && $p <= 1 ? true : (err = 'NUM', false)))) {
                    if ($p instanceof CalcError)
                        return $p;
                    return new CalcError(err);
                }
                xargs.push($p);
            }
            {
                var $alpha = args[i++];
                if ($alpha instanceof CalcError)
                    return $alpha;
                if (!(((typeof ($alpha = this.force($alpha)) == 'number' ? ($alpha = limitPrecision($alpha), true) : false) || (typeof $alpha == 'boolean' ? ($alpha = +$alpha, true) : false) || (typeof $alpha == 'string' && !/^(?:=|true|false)/i.test($alpha) ? (tmp = calc.parse(0, 0, 0, $alpha), /^date|number|percent$/.test(tmp.type) ? ($alpha = +tmp.value, true) : false) : false)) && ($alpha > 0 ? true : (err = 'NUM', false)))) {
                    if ($alpha instanceof CalcError)
                        return $alpha;
                    return new CalcError(err);
                }
                xargs.push($alpha);
            }
            {
                var $beta = args[i++];
                if ($beta instanceof CalcError)
                    return $beta;
                if (!(((typeof ($beta = this.force($beta)) == 'number' ? ($beta = limitPrecision($beta), true) : false) || (typeof $beta == 'boolean' ? ($beta = +$beta, true) : false) || (typeof $beta == 'string' && !/^(?:=|true|false)/i.test($beta) ? (tmp = calc.parse(0, 0, 0, $beta), /^date|number|percent$/.test(tmp.type) ? ($beta = +tmp.value, true) : false) : false)) && ($beta > 0 ? true : (err = 'NUM', false)))) {
                    if ($beta instanceof CalcError)
                        return $beta;
                    return new CalcError(err);
                }
                xargs.push($beta);
            }
            {
                var $A = args[i++];
                if ($A instanceof CalcError)
                    return $A;
                if (!((typeof ($A = this.force($A)) == 'number' ? ($A = limitPrecision($A), true) : false) || (typeof $A == 'boolean' ? ($A = +$A, true) : false) || (typeof $A == 'string' && !/^(?:=|true|false)/i.test($A) ? (tmp = calc.parse(0, 0, 0, $A), /^date|number|percent$/.test(tmp.type) ? ($A = +tmp.value, true) : false) : false) || ($A == null ? ($A = 0, true) : false))) {
                    if ($A instanceof CalcError)
                        return $A;
                    return new CalcError(err);
                }
                xargs.push($A);
            }
            {
                var $B = args[i++];
                if ($B instanceof CalcError)
                    return $B;
                if (!((typeof ($B = this.force($B)) == 'number' ? ($B = limitPrecision($B), true) : false) || (typeof $B == 'boolean' ? ($B = +$B, true) : false) || (typeof $B == 'string' && !/^(?:=|true|false)/i.test($B) ? (tmp = calc.parse(0, 0, 0, $B), /^date|number|percent$/.test(tmp.type) ? ($B = +tmp.value, true) : false) : false) || ($B == null ? ($B = 1, true) : false))) {
                    if ($B instanceof CalcError)
                        return $B;
                    return new CalcError(err);
                }
                xargs.push($B);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), BETA_INV);

    defineBuiltinFunction('CHISQ.DIST', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $x = args[i++];
                if ($x instanceof CalcError)
                    return $x;
                if (!(((typeof ($x = this.force($x)) == 'number' ? ($x = limitPrecision($x), true) : false) || (typeof $x == 'boolean' ? ($x = +$x, true) : false) || (typeof $x == 'string' && !/^(?:=|true|false)/i.test($x) ? (tmp = calc.parse(0, 0, 0, $x), /^date|number|percent$/.test(tmp.type) ? ($x = +tmp.value, true) : false) : false)) && ($x >= 0 ? true : (err = 'NUM', false)))) {
                    if ($x instanceof CalcError)
                        return $x;
                    return new CalcError(err);
                }
                xargs.push($x);
            }
            {
                var $deg_freedom = args[i++];
                if ($deg_freedom instanceof CalcError)
                    return $deg_freedom;
                if (!((typeof ($deg_freedom = this.force($deg_freedom)) == 'number' || (typeof $deg_freedom == 'boolean' ? ($deg_freedom = +$deg_freedom, true) : false) || (typeof $deg_freedom == 'string' && !/^(?:=|true|false)/i.test($deg_freedom) ? (tmp = calc.parse(0, 0, 0, $deg_freedom), /^date|number|percent$/.test(tmp.type) ? ($deg_freedom = +tmp.value, true) : false) : false)) && (($deg_freedom |= 0) > 0 ? true : (err = 'NUM', false)))) {
                    if ($deg_freedom instanceof CalcError)
                        return $deg_freedom;
                    return new CalcError(err);
                }
                xargs.push($deg_freedom);
            }
            {
                var $cumulative = args[i++];
                if ($cumulative instanceof CalcError)
                    return $cumulative;
                if (!(typeof ($cumulative = this.force($cumulative)) == 'boolean' || (typeof $cumulative == 'number' ? ($cumulative = !!$cumulative, true) : false))) {
                    if ($cumulative instanceof CalcError)
                        return $cumulative;
                    return new CalcError(err);
                }
                xargs.push($cumulative);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), chisq_left);

    defineBuiltinFunction('CHISQ.DIST.RT', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $x = args[i++];
                if ($x instanceof CalcError)
                    return $x;
                if (!(((typeof ($x = this.force($x)) == 'number' ? ($x = limitPrecision($x), true) : false) || (typeof $x == 'boolean' ? ($x = +$x, true) : false) || (typeof $x == 'string' && !/^(?:=|true|false)/i.test($x) ? (tmp = calc.parse(0, 0, 0, $x), /^date|number|percent$/.test(tmp.type) ? ($x = +tmp.value, true) : false) : false)) && ($x >= 0 ? true : (err = 'NUM', false)))) {
                    if ($x instanceof CalcError)
                        return $x;
                    return new CalcError(err);
                }
                xargs.push($x);
            }
            {
                var $deg_freedom = args[i++];
                if ($deg_freedom instanceof CalcError)
                    return $deg_freedom;
                if (!((typeof ($deg_freedom = this.force($deg_freedom)) == 'number' || (typeof $deg_freedom == 'boolean' ? ($deg_freedom = +$deg_freedom, true) : false) || (typeof $deg_freedom == 'string' && !/^(?:=|true|false)/i.test($deg_freedom) ? (tmp = calc.parse(0, 0, 0, $deg_freedom), /^date|number|percent$/.test(tmp.type) ? ($deg_freedom = +tmp.value, true) : false) : false)) && (($deg_freedom |= 0) > 0 ? true : (err = 'NUM', false)))) {
                    if ($deg_freedom instanceof CalcError)
                        return $deg_freedom;
                    return new CalcError(err);
                }
                xargs.push($deg_freedom);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), chisq_right);

    defineBuiltinFunction('CHISQ.INV', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $p = args[i++];
                if ($p instanceof CalcError)
                    return $p;
                if (!(((typeof ($p = this.force($p)) == 'number' ? ($p = limitPrecision($p), true) : false) || (typeof $p == 'boolean' ? ($p = +$p, true) : false) || (typeof $p == 'string' && !/^(?:=|true|false)/i.test($p) ? (tmp = calc.parse(0, 0, 0, $p), /^date|number|percent$/.test(tmp.type) ? ($p = +tmp.value, true) : false) : false)) && ($p >= 0 && $p <= 1 ? true : (err = 'NUM', false)))) {
                    if ($p instanceof CalcError)
                        return $p;
                    return new CalcError(err);
                }
                xargs.push($p);
            }
            {
                var $deg_freedom = args[i++];
                if ($deg_freedom instanceof CalcError)
                    return $deg_freedom;
                if (!((typeof ($deg_freedom = this.force($deg_freedom)) == 'number' || (typeof $deg_freedom == 'boolean' ? ($deg_freedom = +$deg_freedom, true) : false) || (typeof $deg_freedom == 'string' && !/^(?:=|true|false)/i.test($deg_freedom) ? (tmp = calc.parse(0, 0, 0, $deg_freedom), /^date|number|percent$/.test(tmp.type) ? ($deg_freedom = +tmp.value, true) : false) : false)) && (($deg_freedom |= 0) > 0 ? true : (err = 'NUM', false)))) {
                    if ($deg_freedom instanceof CalcError)
                        return $deg_freedom;
                    return new CalcError(err);
                }
                xargs.push($deg_freedom);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), chisq_left_inv);

    defineBuiltinFunction('CHISQ.INV.RT', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $p = args[i++];
                if ($p instanceof CalcError)
                    return $p;
                if (!(((typeof ($p = this.force($p)) == 'number' ? ($p = limitPrecision($p), true) : false) || (typeof $p == 'boolean' ? ($p = +$p, true) : false) || (typeof $p == 'string' && !/^(?:=|true|false)/i.test($p) ? (tmp = calc.parse(0, 0, 0, $p), /^date|number|percent$/.test(tmp.type) ? ($p = +tmp.value, true) : false) : false)) && ($p >= 0 && $p <= 1 ? true : (err = 'NUM', false)))) {
                    if ($p instanceof CalcError)
                        return $p;
                    return new CalcError(err);
                }
                xargs.push($p);
            }
            {
                var $deg_freedom = args[i++];
                if ($deg_freedom instanceof CalcError)
                    return $deg_freedom;
                if (!((typeof ($deg_freedom = this.force($deg_freedom)) == 'number' || (typeof $deg_freedom == 'boolean' ? ($deg_freedom = +$deg_freedom, true) : false) || (typeof $deg_freedom == 'string' && !/^(?:=|true|false)/i.test($deg_freedom) ? (tmp = calc.parse(0, 0, 0, $deg_freedom), /^date|number|percent$/.test(tmp.type) ? ($deg_freedom = +tmp.value, true) : false) : false)) && (($deg_freedom |= 0) > 0 ? true : (err = 'NUM', false)))) {
                    if ($deg_freedom instanceof CalcError)
                        return $deg_freedom;
                    return new CalcError(err);
                }
                xargs.push($deg_freedom);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), chisq_right_inv);

    defineBuiltinFunction('CHISQ.TEST', false, function () {
        function check(args) {
            var xargs = [], i = 0, m, err = 'VALUE';
            {
                var $actual_range = args[i++];
                if ($actual_range instanceof CalcError)
                    return $actual_range;
                if (!((m = this.asMatrix($actual_range)) ? $actual_range = m : false)) {
                    if ($actual_range instanceof CalcError)
                        return $actual_range;
                    return new CalcError(err);
                }
                xargs.push($actual_range);
            }
            {
                var $expected_range = args[i++];
                if ($expected_range instanceof CalcError)
                    return $expected_range;
                if (!((m = this.asMatrix($expected_range)) ? $expected_range = m : false)) {
                    if ($expected_range instanceof CalcError)
                        return $expected_range;
                    return new CalcError(err);
                }
                xargs.push($expected_range);
            }
            {
                if (!($actual_range.width == $expected_range.width ? true : (err = 'N/A', false)))
                    return new CalcError(err);
            }
            {
                if (!($actual_range.height == $expected_range.height ? true : (err = 'N/A', false)))
                    return new CalcError(err);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), function (ac, ex) {
        return chisq_test(ac.data, ex.data);
    });

    defineBuiltinFunction('EXPON.DIST', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $x = args[i++];
                if ($x instanceof CalcError)
                    return $x;
                if (!(((typeof ($x = this.force($x)) == 'number' ? ($x = limitPrecision($x), true) : false) || (typeof $x == 'boolean' ? ($x = +$x, true) : false) || (typeof $x == 'string' && !/^(?:=|true|false)/i.test($x) ? (tmp = calc.parse(0, 0, 0, $x), /^date|number|percent$/.test(tmp.type) ? ($x = +tmp.value, true) : false) : false)) && ($x >= 0 ? true : (err = 'NUM', false)))) {
                    if ($x instanceof CalcError)
                        return $x;
                    return new CalcError(err);
                }
                xargs.push($x);
            }
            {
                var $lambda = args[i++];
                if ($lambda instanceof CalcError)
                    return $lambda;
                if (!(((typeof ($lambda = this.force($lambda)) == 'number' ? ($lambda = limitPrecision($lambda), true) : false) || (typeof $lambda == 'boolean' ? ($lambda = +$lambda, true) : false) || (typeof $lambda == 'string' && !/^(?:=|true|false)/i.test($lambda) ? (tmp = calc.parse(0, 0, 0, $lambda), /^date|number|percent$/.test(tmp.type) ? ($lambda = +tmp.value, true) : false) : false)) && ($lambda > 0 ? true : (err = 'NUM', false)))) {
                    if ($lambda instanceof CalcError)
                        return $lambda;
                    return new CalcError(err);
                }
                xargs.push($lambda);
            }
            {
                var $cumulative = args[i++];
                if ($cumulative instanceof CalcError)
                    return $cumulative;
                if (!(typeof ($cumulative = this.force($cumulative)) == 'boolean' || (typeof $cumulative == 'number' ? ($cumulative = !!$cumulative, true) : false))) {
                    if ($cumulative instanceof CalcError)
                        return $cumulative;
                    return new CalcError(err);
                }
                xargs.push($cumulative);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), expon);

    defineBuiltinFunction('POISSON.DIST', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $x = args[i++];
                if ($x instanceof CalcError)
                    return $x;
                if (!((typeof ($x = this.force($x)) == 'number' || (typeof $x == 'boolean' ? ($x = +$x, true) : false) || (typeof $x == 'string' && !/^(?:=|true|false)/i.test($x) ? (tmp = calc.parse(0, 0, 0, $x), /^date|number|percent$/.test(tmp.type) ? ($x = +tmp.value, true) : false) : false)) && (($x |= 0) >= 0 ? true : (err = 'NUM', false)))) {
                    if ($x instanceof CalcError)
                        return $x;
                    return new CalcError(err);
                }
                xargs.push($x);
            }
            {
                var $mean = args[i++];
                if ($mean instanceof CalcError)
                    return $mean;
                if (!(((typeof ($mean = this.force($mean)) == 'number' ? ($mean = limitPrecision($mean), true) : false) || (typeof $mean == 'boolean' ? ($mean = +$mean, true) : false) || (typeof $mean == 'string' && !/^(?:=|true|false)/i.test($mean) ? (tmp = calc.parse(0, 0, 0, $mean), /^date|number|percent$/.test(tmp.type) ? ($mean = +tmp.value, true) : false) : false)) && ($mean >= 0 ? true : (err = 'NUM', false)))) {
                    if ($mean instanceof CalcError)
                        return $mean;
                    return new CalcError(err);
                }
                xargs.push($mean);
            }
            {
                var $cumulative = args[i++];
                if ($cumulative instanceof CalcError)
                    return $cumulative;
                if (!(typeof ($cumulative = this.force($cumulative)) == 'boolean' || (typeof $cumulative == 'number' ? ($cumulative = !!$cumulative, true) : false))) {
                    if ($cumulative instanceof CalcError)
                        return $cumulative;
                    return new CalcError(err);
                }
                xargs.push($cumulative);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), poisson);

    defineBuiltinFunction('F.DIST', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $x = args[i++];
                if ($x instanceof CalcError)
                    return $x;
                if (!(((typeof ($x = this.force($x)) == 'number' ? ($x = limitPrecision($x), true) : false) || (typeof $x == 'boolean' ? ($x = +$x, true) : false) || (typeof $x == 'string' && !/^(?:=|true|false)/i.test($x) ? (tmp = calc.parse(0, 0, 0, $x), /^date|number|percent$/.test(tmp.type) ? ($x = +tmp.value, true) : false) : false)) && ($x >= 0 ? true : (err = 'NUM', false)))) {
                    if ($x instanceof CalcError)
                        return $x;
                    return new CalcError(err);
                }
                xargs.push($x);
            }
            {
                var $deg_freedom1 = args[i++];
                if ($deg_freedom1 instanceof CalcError)
                    return $deg_freedom1;
                if (!((typeof ($deg_freedom1 = this.force($deg_freedom1)) == 'number' || (typeof $deg_freedom1 == 'boolean' ? ($deg_freedom1 = +$deg_freedom1, true) : false) || (typeof $deg_freedom1 == 'string' && !/^(?:=|true|false)/i.test($deg_freedom1) ? (tmp = calc.parse(0, 0, 0, $deg_freedom1), /^date|number|percent$/.test(tmp.type) ? ($deg_freedom1 = +tmp.value, true) : false) : false)) && (($deg_freedom1 |= 0) > 0 ? true : (err = 'NUM', false)))) {
                    if ($deg_freedom1 instanceof CalcError)
                        return $deg_freedom1;
                    return new CalcError(err);
                }
                xargs.push($deg_freedom1);
            }
            {
                var $deg_freedom2 = args[i++];
                if ($deg_freedom2 instanceof CalcError)
                    return $deg_freedom2;
                if (!((typeof ($deg_freedom2 = this.force($deg_freedom2)) == 'number' || (typeof $deg_freedom2 == 'boolean' ? ($deg_freedom2 = +$deg_freedom2, true) : false) || (typeof $deg_freedom2 == 'string' && !/^(?:=|true|false)/i.test($deg_freedom2) ? (tmp = calc.parse(0, 0, 0, $deg_freedom2), /^date|number|percent$/.test(tmp.type) ? ($deg_freedom2 = +tmp.value, true) : false) : false)) && (($deg_freedom2 |= 0) > 0 ? true : (err = 'NUM', false)))) {
                    if ($deg_freedom2 instanceof CalcError)
                        return $deg_freedom2;
                    return new CalcError(err);
                }
                xargs.push($deg_freedom2);
            }
            {
                var $cumulative = args[i++];
                if ($cumulative instanceof CalcError)
                    return $cumulative;
                if (!(typeof ($cumulative = this.force($cumulative)) == 'boolean' || (typeof $cumulative == 'number' ? ($cumulative = !!$cumulative, true) : false))) {
                    if ($cumulative instanceof CalcError)
                        return $cumulative;
                    return new CalcError(err);
                }
                xargs.push($cumulative);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), Fdist);

    defineBuiltinFunction('F.DIST.RT', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $x = args[i++];
                if ($x instanceof CalcError)
                    return $x;
                if (!(((typeof ($x = this.force($x)) == 'number' ? ($x = limitPrecision($x), true) : false) || (typeof $x == 'boolean' ? ($x = +$x, true) : false) || (typeof $x == 'string' && !/^(?:=|true|false)/i.test($x) ? (tmp = calc.parse(0, 0, 0, $x), /^date|number|percent$/.test(tmp.type) ? ($x = +tmp.value, true) : false) : false)) && ($x >= 0 ? true : (err = 'NUM', false)))) {
                    if ($x instanceof CalcError)
                        return $x;
                    return new CalcError(err);
                }
                xargs.push($x);
            }
            {
                var $deg_freedom1 = args[i++];
                if ($deg_freedom1 instanceof CalcError)
                    return $deg_freedom1;
                if (!((typeof ($deg_freedom1 = this.force($deg_freedom1)) == 'number' || (typeof $deg_freedom1 == 'boolean' ? ($deg_freedom1 = +$deg_freedom1, true) : false) || (typeof $deg_freedom1 == 'string' && !/^(?:=|true|false)/i.test($deg_freedom1) ? (tmp = calc.parse(0, 0, 0, $deg_freedom1), /^date|number|percent$/.test(tmp.type) ? ($deg_freedom1 = +tmp.value, true) : false) : false)) && (($deg_freedom1 |= 0) > 0 ? true : (err = 'NUM', false)))) {
                    if ($deg_freedom1 instanceof CalcError)
                        return $deg_freedom1;
                    return new CalcError(err);
                }
                xargs.push($deg_freedom1);
            }
            {
                var $deg_freedom2 = args[i++];
                if ($deg_freedom2 instanceof CalcError)
                    return $deg_freedom2;
                if (!((typeof ($deg_freedom2 = this.force($deg_freedom2)) == 'number' || (typeof $deg_freedom2 == 'boolean' ? ($deg_freedom2 = +$deg_freedom2, true) : false) || (typeof $deg_freedom2 == 'string' && !/^(?:=|true|false)/i.test($deg_freedom2) ? (tmp = calc.parse(0, 0, 0, $deg_freedom2), /^date|number|percent$/.test(tmp.type) ? ($deg_freedom2 = +tmp.value, true) : false) : false)) && (($deg_freedom2 |= 0) > 0 ? true : (err = 'NUM', false)))) {
                    if ($deg_freedom2 instanceof CalcError)
                        return $deg_freedom2;
                    return new CalcError(err);
                }
                xargs.push($deg_freedom2);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), Fdist_right);

    defineBuiltinFunction('F.INV', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $p = args[i++];
                if ($p instanceof CalcError)
                    return $p;
                if (!(((typeof ($p = this.force($p)) == 'number' ? ($p = limitPrecision($p), true) : false) || (typeof $p == 'boolean' ? ($p = +$p, true) : false) || (typeof $p == 'string' && !/^(?:=|true|false)/i.test($p) ? (tmp = calc.parse(0, 0, 0, $p), /^date|number|percent$/.test(tmp.type) ? ($p = +tmp.value, true) : false) : false)) && ($p >= 0 && $p <= 1 ? true : (err = 'NUM', false)))) {
                    if ($p instanceof CalcError)
                        return $p;
                    return new CalcError(err);
                }
                xargs.push($p);
            }
            {
                var $deg_freedom1 = args[i++];
                if ($deg_freedom1 instanceof CalcError)
                    return $deg_freedom1;
                if (!((typeof ($deg_freedom1 = this.force($deg_freedom1)) == 'number' || (typeof $deg_freedom1 == 'boolean' ? ($deg_freedom1 = +$deg_freedom1, true) : false) || (typeof $deg_freedom1 == 'string' && !/^(?:=|true|false)/i.test($deg_freedom1) ? (tmp = calc.parse(0, 0, 0, $deg_freedom1), /^date|number|percent$/.test(tmp.type) ? ($deg_freedom1 = +tmp.value, true) : false) : false)) && (($deg_freedom1 |= 0) > 0 ? true : (err = 'NUM', false)))) {
                    if ($deg_freedom1 instanceof CalcError)
                        return $deg_freedom1;
                    return new CalcError(err);
                }
                xargs.push($deg_freedom1);
            }
            {
                var $deg_freedom2 = args[i++];
                if ($deg_freedom2 instanceof CalcError)
                    return $deg_freedom2;
                if (!((typeof ($deg_freedom2 = this.force($deg_freedom2)) == 'number' || (typeof $deg_freedom2 == 'boolean' ? ($deg_freedom2 = +$deg_freedom2, true) : false) || (typeof $deg_freedom2 == 'string' && !/^(?:=|true|false)/i.test($deg_freedom2) ? (tmp = calc.parse(0, 0, 0, $deg_freedom2), /^date|number|percent$/.test(tmp.type) ? ($deg_freedom2 = +tmp.value, true) : false) : false)) && (($deg_freedom2 |= 0) > 0 ? true : (err = 'NUM', false)))) {
                    if ($deg_freedom2 instanceof CalcError)
                        return $deg_freedom2;
                    return new CalcError(err);
                }
                xargs.push($deg_freedom2);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), Finv);

    defineBuiltinFunction('F.INV.RT', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $p = args[i++];
                if ($p instanceof CalcError)
                    return $p;
                if (!(((typeof ($p = this.force($p)) == 'number' ? ($p = limitPrecision($p), true) : false) || (typeof $p == 'boolean' ? ($p = +$p, true) : false) || (typeof $p == 'string' && !/^(?:=|true|false)/i.test($p) ? (tmp = calc.parse(0, 0, 0, $p), /^date|number|percent$/.test(tmp.type) ? ($p = +tmp.value, true) : false) : false)) && ($p >= 0 && $p <= 1 ? true : (err = 'NUM', false)))) {
                    if ($p instanceof CalcError)
                        return $p;
                    return new CalcError(err);
                }
                xargs.push($p);
            }
            {
                var $deg_freedom1 = args[i++];
                if ($deg_freedom1 instanceof CalcError)
                    return $deg_freedom1;
                if (!((typeof ($deg_freedom1 = this.force($deg_freedom1)) == 'number' || (typeof $deg_freedom1 == 'boolean' ? ($deg_freedom1 = +$deg_freedom1, true) : false) || (typeof $deg_freedom1 == 'string' && !/^(?:=|true|false)/i.test($deg_freedom1) ? (tmp = calc.parse(0, 0, 0, $deg_freedom1), /^date|number|percent$/.test(tmp.type) ? ($deg_freedom1 = +tmp.value, true) : false) : false)) && (($deg_freedom1 |= 0) > 0 ? true : (err = 'NUM', false)))) {
                    if ($deg_freedom1 instanceof CalcError)
                        return $deg_freedom1;
                    return new CalcError(err);
                }
                xargs.push($deg_freedom1);
            }
            {
                var $deg_freedom2 = args[i++];
                if ($deg_freedom2 instanceof CalcError)
                    return $deg_freedom2;
                if (!((typeof ($deg_freedom2 = this.force($deg_freedom2)) == 'number' || (typeof $deg_freedom2 == 'boolean' ? ($deg_freedom2 = +$deg_freedom2, true) : false) || (typeof $deg_freedom2 == 'string' && !/^(?:=|true|false)/i.test($deg_freedom2) ? (tmp = calc.parse(0, 0, 0, $deg_freedom2), /^date|number|percent$/.test(tmp.type) ? ($deg_freedom2 = +tmp.value, true) : false) : false)) && (($deg_freedom2 |= 0) > 0 ? true : (err = 'NUM', false)))) {
                    if ($deg_freedom2 instanceof CalcError)
                        return $deg_freedom2;
                    return new CalcError(err);
                }
                xargs.push($deg_freedom2);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), Finv_right);

    defineBuiltinFunction('F.TEST', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                try {
                    var $array1 = this.cellValues(args.slice(i, i + 1)).reduce(function (ret, $array1) {
                        if ($array1 instanceof CalcError)
                            throw $array1;
                        if ((typeof $array1 == 'number' ? ($array1 = limitPrecision($array1), true) : false) || (typeof $array1 == 'boolean' ? ($array1 = +$array1, true) : false) || (typeof $array1 == 'string' && !/^(?:=|true|false)/i.test($array1) ? (tmp = calc.parse(0, 0, 0, $array1), /^date|number|percent$/.test(tmp.type) ? ($array1 = +tmp.value, true) : false) : false))
                            ret.push($array1);
                        return ret;
                    }.bind(this), []);
                    i += 1;
                    xargs.push($array1);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            {
                try {
                    var $array2 = this.cellValues(args.slice(i, i + 1)).reduce(function (ret, $array2) {
                        if ($array2 instanceof CalcError)
                            throw $array2;
                        if ((typeof $array2 == 'number' ? ($array2 = limitPrecision($array2), true) : false) || (typeof $array2 == 'boolean' ? ($array2 = +$array2, true) : false) || (typeof $array2 == 'string' && !/^(?:=|true|false)/i.test($array2) ? (tmp = calc.parse(0, 0, 0, $array2), /^date|number|percent$/.test(tmp.type) ? ($array2 = +tmp.value, true) : false) : false))
                            ret.push($array2);
                        return ret;
                    }.bind(this), []);
                    i += 1;
                    xargs.push($array2);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            {
                if (!($array1.length >= 2 ? true : (err = 'DIV/0', false)))
                    return new CalcError(err);
            }
            {
                if (!($array2.length >= 2 ? true : (err = 'DIV/0', false)))
                    return new CalcError(err);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args.slice(i));
            toResolve.push(args.slice(i));
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), Ftest);

    defineBuiltinFunction('FISHER', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $x = args[i++];
                if ($x instanceof CalcError)
                    return $x;
                if (!(((typeof ($x = this.force($x)) == 'number' ? ($x = limitPrecision($x), true) : false) || (typeof $x == 'boolean' ? ($x = +$x, true) : false) || (typeof $x == 'string' && !/^(?:=|true|false)/i.test($x) ? (tmp = calc.parse(0, 0, 0, $x), /^date|number|percent$/.test(tmp.type) ? ($x = +tmp.value, true) : false) : false)) && ($x > -1 && $x < 1 ? true : (err = 'NUM', false)))) {
                    if ($x instanceof CalcError)
                        return $x;
                    return new CalcError(err);
                }
                xargs.push($x);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), fisher);

    defineBuiltinFunction('FISHERINV', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $y = args[i++];
                if ($y instanceof CalcError)
                    return $y;
                if (!((typeof ($y = this.force($y)) == 'number' ? ($y = limitPrecision($y), true) : false) || (typeof $y == 'boolean' ? ($y = +$y, true) : false) || (typeof $y == 'string' && !/^(?:=|true|false)/i.test($y) ? (tmp = calc.parse(0, 0, 0, $y), /^date|number|percent$/.test(tmp.type) ? ($y = +tmp.value, true) : false) : false))) {
                    if ($y instanceof CalcError)
                        return $y;
                    return new CalcError(err);
                }
                xargs.push($y);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), fisherinv);

    defineBuiltinFunction('T.DIST', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $x = args[i++];
                if ($x instanceof CalcError)
                    return $x;
                if (!((typeof ($x = this.force($x)) == 'number' ? ($x = limitPrecision($x), true) : false) || (typeof $x == 'boolean' ? ($x = +$x, true) : false) || (typeof $x == 'string' && !/^(?:=|true|false)/i.test($x) ? (tmp = calc.parse(0, 0, 0, $x), /^date|number|percent$/.test(tmp.type) ? ($x = +tmp.value, true) : false) : false))) {
                    if ($x instanceof CalcError)
                        return $x;
                    return new CalcError(err);
                }
                xargs.push($x);
            }
            {
                var $deg_freedom = args[i++];
                if ($deg_freedom instanceof CalcError)
                    return $deg_freedom;
                if (!((typeof ($deg_freedom = this.force($deg_freedom)) == 'number' || (typeof $deg_freedom == 'boolean' ? ($deg_freedom = +$deg_freedom, true) : false) || (typeof $deg_freedom == 'string' && !/^(?:=|true|false)/i.test($deg_freedom) ? (tmp = calc.parse(0, 0, 0, $deg_freedom), /^date|number|percent$/.test(tmp.type) ? ($deg_freedom = +tmp.value, true) : false) : false)) && (($deg_freedom |= 0) > 0 ? true : (err = 'NUM', false)))) {
                    if ($deg_freedom instanceof CalcError)
                        return $deg_freedom;
                    return new CalcError(err);
                }
                xargs.push($deg_freedom);
            }
            {
                var $cumulative = args[i++];
                if ($cumulative instanceof CalcError)
                    return $cumulative;
                if (!(typeof ($cumulative = this.force($cumulative)) == 'boolean' || (typeof $cumulative == 'number' ? ($cumulative = !!$cumulative, true) : false))) {
                    if ($cumulative instanceof CalcError)
                        return $cumulative;
                    return new CalcError(err);
                }
                xargs.push($cumulative);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), Tdist);

    defineBuiltinFunction('T.DIST.RT', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $x = args[i++];
                if ($x instanceof CalcError)
                    return $x;
                if (!((typeof ($x = this.force($x)) == 'number' ? ($x = limitPrecision($x), true) : false) || (typeof $x == 'boolean' ? ($x = +$x, true) : false) || (typeof $x == 'string' && !/^(?:=|true|false)/i.test($x) ? (tmp = calc.parse(0, 0, 0, $x), /^date|number|percent$/.test(tmp.type) ? ($x = +tmp.value, true) : false) : false))) {
                    if ($x instanceof CalcError)
                        return $x;
                    return new CalcError(err);
                }
                xargs.push($x);
            }
            {
                var $deg_freedom = args[i++];
                if ($deg_freedom instanceof CalcError)
                    return $deg_freedom;
                if (!((typeof ($deg_freedom = this.force($deg_freedom)) == 'number' || (typeof $deg_freedom == 'boolean' ? ($deg_freedom = +$deg_freedom, true) : false) || (typeof $deg_freedom == 'string' && !/^(?:=|true|false)/i.test($deg_freedom) ? (tmp = calc.parse(0, 0, 0, $deg_freedom), /^date|number|percent$/.test(tmp.type) ? ($deg_freedom = +tmp.value, true) : false) : false)) && (($deg_freedom |= 0) > 0 ? true : (err = 'NUM', false)))) {
                    if ($deg_freedom instanceof CalcError)
                        return $deg_freedom;
                    return new CalcError(err);
                }
                xargs.push($deg_freedom);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), Tdist_right);

    defineBuiltinFunction('T.DIST.2T', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $x = args[i++];
                if ($x instanceof CalcError)
                    return $x;
                if (!(((typeof ($x = this.force($x)) == 'number' ? ($x = limitPrecision($x), true) : false) || (typeof $x == 'boolean' ? ($x = +$x, true) : false) || (typeof $x == 'string' && !/^(?:=|true|false)/i.test($x) ? (tmp = calc.parse(0, 0, 0, $x), /^date|number|percent$/.test(tmp.type) ? ($x = +tmp.value, true) : false) : false)) && ($x >= 0 ? true : (err = 'NUM', false)))) {
                    if ($x instanceof CalcError)
                        return $x;
                    return new CalcError(err);
                }
                xargs.push($x);
            }
            {
                var $deg_freedom = args[i++];
                if ($deg_freedom instanceof CalcError)
                    return $deg_freedom;
                if (!((typeof ($deg_freedom = this.force($deg_freedom)) == 'number' || (typeof $deg_freedom == 'boolean' ? ($deg_freedom = +$deg_freedom, true) : false) || (typeof $deg_freedom == 'string' && !/^(?:=|true|false)/i.test($deg_freedom) ? (tmp = calc.parse(0, 0, 0, $deg_freedom), /^date|number|percent$/.test(tmp.type) ? ($deg_freedom = +tmp.value, true) : false) : false)) && (($deg_freedom |= 0) > 0 ? true : (err = 'NUM', false)))) {
                    if ($deg_freedom instanceof CalcError)
                        return $deg_freedom;
                    return new CalcError(err);
                }
                xargs.push($deg_freedom);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), Tdist_2tail);

    defineBuiltinFunction('T.INV', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $p = args[i++];
                if ($p instanceof CalcError)
                    return $p;
                if (!(((typeof ($p = this.force($p)) == 'number' ? ($p = limitPrecision($p), true) : false) || (typeof $p == 'boolean' ? ($p = +$p, true) : false) || (typeof $p == 'string' && !/^(?:=|true|false)/i.test($p) ? (tmp = calc.parse(0, 0, 0, $p), /^date|number|percent$/.test(tmp.type) ? ($p = +tmp.value, true) : false) : false)) && ($p > 0 && $p <= 1 ? true : (err = 'NUM', false)))) {
                    if ($p instanceof CalcError)
                        return $p;
                    return new CalcError(err);
                }
                xargs.push($p);
            }
            {
                var $deg_freedom = args[i++];
                if ($deg_freedom instanceof CalcError)
                    return $deg_freedom;
                if (!((typeof ($deg_freedom = this.force($deg_freedom)) == 'number' || (typeof $deg_freedom == 'boolean' ? ($deg_freedom = +$deg_freedom, true) : false) || (typeof $deg_freedom == 'string' && !/^(?:=|true|false)/i.test($deg_freedom) ? (tmp = calc.parse(0, 0, 0, $deg_freedom), /^date|number|percent$/.test(tmp.type) ? ($deg_freedom = +tmp.value, true) : false) : false)) && (($deg_freedom |= 0) > 0 ? true : (err = 'NUM', false)))) {
                    if ($deg_freedom instanceof CalcError)
                        return $deg_freedom;
                    return new CalcError(err);
                }
                xargs.push($deg_freedom);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), Tdist_inv);

    defineBuiltinFunction('T.INV.2T', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $p = args[i++];
                if ($p instanceof CalcError)
                    return $p;
                if (!(((typeof ($p = this.force($p)) == 'number' ? ($p = limitPrecision($p), true) : false) || (typeof $p == 'boolean' ? ($p = +$p, true) : false) || (typeof $p == 'string' && !/^(?:=|true|false)/i.test($p) ? (tmp = calc.parse(0, 0, 0, $p), /^date|number|percent$/.test(tmp.type) ? ($p = +tmp.value, true) : false) : false)) && ($p > 0 && $p <= 1 ? true : (err = 'NUM', false)))) {
                    if ($p instanceof CalcError)
                        return $p;
                    return new CalcError(err);
                }
                xargs.push($p);
            }
            {
                var $deg_freedom = args[i++];
                if ($deg_freedom instanceof CalcError)
                    return $deg_freedom;
                if (!((typeof ($deg_freedom = this.force($deg_freedom)) == 'number' || (typeof $deg_freedom == 'boolean' ? ($deg_freedom = +$deg_freedom, true) : false) || (typeof $deg_freedom == 'string' && !/^(?:=|true|false)/i.test($deg_freedom) ? (tmp = calc.parse(0, 0, 0, $deg_freedom), /^date|number|percent$/.test(tmp.type) ? ($deg_freedom = +tmp.value, true) : false) : false)) && (($deg_freedom |= 0) > 0 ? true : (err = 'NUM', false)))) {
                    if ($deg_freedom instanceof CalcError)
                        return $deg_freedom;
                    return new CalcError(err);
                }
                xargs.push($deg_freedom);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), Tdist_2tail_inv);

    defineBuiltinFunction('T.TEST', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                try {
                    var $array1 = this.cellValues(args.slice(i, i + 1)).reduce(function (ret, $array1) {
                        if ($array1 instanceof CalcError)
                            throw $array1;
                        if ((typeof $array1 == 'number' ? ($array1 = limitPrecision($array1), true) : false) || (typeof $array1 == 'boolean' ? ($array1 = +$array1, true) : false) || (typeof $array1 == 'string' && !/^(?:=|true|false)/i.test($array1) ? (tmp = calc.parse(0, 0, 0, $array1), /^date|number|percent$/.test(tmp.type) ? ($array1 = +tmp.value, true) : false) : false))
                            ret.push($array1);
                        return ret;
                    }.bind(this), []);
                    i += 1;
                    xargs.push($array1);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            {
                try {
                    var $array2 = this.cellValues(args.slice(i, i + 1)).reduce(function (ret, $array2) {
                        if ($array2 instanceof CalcError)
                            throw $array2;
                        if ((typeof $array2 == 'number' ? ($array2 = limitPrecision($array2), true) : false) || (typeof $array2 == 'boolean' ? ($array2 = +$array2, true) : false) || (typeof $array2 == 'string' && !/^(?:=|true|false)/i.test($array2) ? (tmp = calc.parse(0, 0, 0, $array2), /^date|number|percent$/.test(tmp.type) ? ($array2 = +tmp.value, true) : false) : false))
                            ret.push($array2);
                        return ret;
                    }.bind(this), []);
                    i += 1;
                    xargs.push($array2);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            {
                var $tails = args[i++];
                if ($tails instanceof CalcError)
                    return $tails;
                if (!((typeof ($tails = this.force($tails)) == 'number' || (typeof $tails == 'boolean' ? ($tails = +$tails, true) : false) || (typeof $tails == 'string' && !/^(?:=|true|false)/i.test($tails) ? (tmp = calc.parse(0, 0, 0, $tails), /^date|number|percent$/.test(tmp.type) ? ($tails = +tmp.value, true) : false) : false)) && ($tails |= 0, true) && ($tails === 1 || $tails === 2))) {
                    if ($tails instanceof CalcError)
                        return $tails;
                    return new CalcError(err);
                }
                xargs.push($tails);
            }
            {
                var $type = args[i++];
                if ($type instanceof CalcError)
                    return $type;
                if (!((typeof ($type = this.force($type)) == 'number' || (typeof $type == 'boolean' ? ($type = +$type, true) : false) || (typeof $type == 'string' && !/^(?:=|true|false)/i.test($type) ? (tmp = calc.parse(0, 0, 0, $type), /^date|number|percent$/.test(tmp.type) ? ($type = +tmp.value, true) : false) : false)) && ($type |= 0, true) && ($type === 1 || $type === 2 || $type === 3))) {
                    if ($type instanceof CalcError)
                        return $type;
                    return new CalcError(err);
                }
                xargs.push($type);
            }
            {
                if (!($type != 1 || $array1.length == $array2.length ? true : (err = 'N/A', false)))
                    return new CalcError(err);
            }
            {
                if (!($array1.length >= 2 ? true : (err = 'DIV/0', false)))
                    return new CalcError(err);
            }
            {
                if (!($array2.length >= 2 ? true : (err = 'DIV/0', false)))
                    return new CalcError(err);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args.slice(i));
            toResolve.push(args.slice(i));
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), Tdist_test);

    defineBuiltinFunction('CONFIDENCE.T', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $alpha = args[i++];
                if ($alpha instanceof CalcError)
                    return $alpha;
                if (!(((typeof ($alpha = this.force($alpha)) == 'number' ? ($alpha = limitPrecision($alpha), true) : false) || (typeof $alpha == 'boolean' ? ($alpha = +$alpha, true) : false) || (typeof $alpha == 'string' && !/^(?:=|true|false)/i.test($alpha) ? (tmp = calc.parse(0, 0, 0, $alpha), /^date|number|percent$/.test(tmp.type) ? ($alpha = +tmp.value, true) : false) : false)) && ($alpha > 0 && $alpha < 1 ? true : (err = 'NUM', false)))) {
                    if ($alpha instanceof CalcError)
                        return $alpha;
                    return new CalcError(err);
                }
                xargs.push($alpha);
            }
            {
                var $standard_dev = args[i++];
                if ($standard_dev instanceof CalcError)
                    return $standard_dev;
                if (!(((typeof ($standard_dev = this.force($standard_dev)) == 'number' ? ($standard_dev = limitPrecision($standard_dev), true) : false) || (typeof $standard_dev == 'boolean' ? ($standard_dev = +$standard_dev, true) : false) || (typeof $standard_dev == 'string' && !/^(?:=|true|false)/i.test($standard_dev) ? (tmp = calc.parse(0, 0, 0, $standard_dev), /^date|number|percent$/.test(tmp.type) ? ($standard_dev = +tmp.value, true) : false) : false)) && ($standard_dev > 0 ? true : (err = 'NUM', false)))) {
                    if ($standard_dev instanceof CalcError)
                        return $standard_dev;
                    return new CalcError(err);
                }
                xargs.push($standard_dev);
            }
            {
                var $size = args[i++];
                if ($size instanceof CalcError)
                    return $size;
                if (!((typeof ($size = this.force($size)) == 'number' || (typeof $size == 'boolean' ? ($size = +$size, true) : false) || (typeof $size == 'string' && !/^(?:=|true|false)/i.test($size) ? (tmp = calc.parse(0, 0, 0, $size), /^date|number|percent$/.test(tmp.type) ? ($size = +tmp.value, true) : false) : false)) && (($size |= 0) > 0 ? true : (err = 'NUM', false)) && ($size != 1 ? true : (err = 'DIV/0', false)))) {
                    if ($size instanceof CalcError)
                        return $size;
                    return new CalcError(err);
                }
                xargs.push($size);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), confidence_t);

    defineBuiltinFunction('CONFIDENCE.NORM', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $alpha = args[i++];
                if ($alpha instanceof CalcError)
                    return $alpha;
                if (!(((typeof ($alpha = this.force($alpha)) == 'number' ? ($alpha = limitPrecision($alpha), true) : false) || (typeof $alpha == 'boolean' ? ($alpha = +$alpha, true) : false) || (typeof $alpha == 'string' && !/^(?:=|true|false)/i.test($alpha) ? (tmp = calc.parse(0, 0, 0, $alpha), /^date|number|percent$/.test(tmp.type) ? ($alpha = +tmp.value, true) : false) : false)) && ($alpha > 0 && $alpha < 1 ? true : (err = 'NUM', false)))) {
                    if ($alpha instanceof CalcError)
                        return $alpha;
                    return new CalcError(err);
                }
                xargs.push($alpha);
            }
            {
                var $standard_dev = args[i++];
                if ($standard_dev instanceof CalcError)
                    return $standard_dev;
                if (!(((typeof ($standard_dev = this.force($standard_dev)) == 'number' ? ($standard_dev = limitPrecision($standard_dev), true) : false) || (typeof $standard_dev == 'boolean' ? ($standard_dev = +$standard_dev, true) : false) || (typeof $standard_dev == 'string' && !/^(?:=|true|false)/i.test($standard_dev) ? (tmp = calc.parse(0, 0, 0, $standard_dev), /^date|number|percent$/.test(tmp.type) ? ($standard_dev = +tmp.value, true) : false) : false)) && ($standard_dev > 0 ? true : (err = 'NUM', false)))) {
                    if ($standard_dev instanceof CalcError)
                        return $standard_dev;
                    return new CalcError(err);
                }
                xargs.push($standard_dev);
            }
            {
                var $size = args[i++];
                if ($size instanceof CalcError)
                    return $size;
                if (!((typeof ($size = this.force($size)) == 'number' || (typeof $size == 'boolean' ? ($size = +$size, true) : false) || (typeof $size == 'string' && !/^(?:=|true|false)/i.test($size) ? (tmp = calc.parse(0, 0, 0, $size), /^date|number|percent$/.test(tmp.type) ? ($size = +tmp.value, true) : false) : false)) && (($size |= 0) > 0 ? true : (err = 'NUM', false)))) {
                    if ($size instanceof CalcError)
                        return $size;
                    return new CalcError(err);
                }
                xargs.push($size);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), confidence_norm);

    defineBuiltinFunction('GAUSS', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $z = args[i++];
                if ($z instanceof CalcError)
                    return $z;
                if (!((typeof ($z = this.force($z)) == 'number' ? ($z = limitPrecision($z), true) : false) || (typeof $z == 'boolean' ? ($z = +$z, true) : false) || (typeof $z == 'string' && !/^(?:=|true|false)/i.test($z) ? (tmp = calc.parse(0, 0, 0, $z), /^date|number|percent$/.test(tmp.type) ? ($z = +tmp.value, true) : false) : false))) {
                    if ($z instanceof CalcError)
                        return $z;
                    return new CalcError(err);
                }
                xargs.push($z);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), gauss);

    defineBuiltinFunction('PHI', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $x = args[i++];
                if ($x instanceof CalcError)
                    return $x;
                if (!((typeof ($x = this.force($x)) == 'number' ? ($x = limitPrecision($x), true) : false) || (typeof $x == 'boolean' ? ($x = +$x, true) : false) || (typeof $x == 'string' && !/^(?:=|true|false)/i.test($x) ? (tmp = calc.parse(0, 0, 0, $x), /^date|number|percent$/.test(tmp.type) ? ($x = +tmp.value, true) : false) : false))) {
                    if ($x instanceof CalcError)
                        return $x;
                    return new CalcError(err);
                }
                xargs.push($x);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), phi);

    defineBuiltinFunction('LOGNORM.DIST', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $x = args[i++];
                if ($x instanceof CalcError)
                    return $x;
                if (!(((typeof ($x = this.force($x)) == 'number' ? ($x = limitPrecision($x), true) : false) || (typeof $x == 'boolean' ? ($x = +$x, true) : false) || (typeof $x == 'string' && !/^(?:=|true|false)/i.test($x) ? (tmp = calc.parse(0, 0, 0, $x), /^date|number|percent$/.test(tmp.type) ? ($x = +tmp.value, true) : false) : false)) && ($x > 0 ? true : (err = 'NUM', false)))) {
                    if ($x instanceof CalcError)
                        return $x;
                    return new CalcError(err);
                }
                xargs.push($x);
            }
            {
                var $mean = args[i++];
                if ($mean instanceof CalcError)
                    return $mean;
                if (!((typeof ($mean = this.force($mean)) == 'number' ? ($mean = limitPrecision($mean), true) : false) || (typeof $mean == 'boolean' ? ($mean = +$mean, true) : false) || (typeof $mean == 'string' && !/^(?:=|true|false)/i.test($mean) ? (tmp = calc.parse(0, 0, 0, $mean), /^date|number|percent$/.test(tmp.type) ? ($mean = +tmp.value, true) : false) : false))) {
                    if ($mean instanceof CalcError)
                        return $mean;
                    return new CalcError(err);
                }
                xargs.push($mean);
            }
            {
                var $standard_dev = args[i++];
                if ($standard_dev instanceof CalcError)
                    return $standard_dev;
                if (!(((typeof ($standard_dev = this.force($standard_dev)) == 'number' ? ($standard_dev = limitPrecision($standard_dev), true) : false) || (typeof $standard_dev == 'boolean' ? ($standard_dev = +$standard_dev, true) : false) || (typeof $standard_dev == 'string' && !/^(?:=|true|false)/i.test($standard_dev) ? (tmp = calc.parse(0, 0, 0, $standard_dev), /^date|number|percent$/.test(tmp.type) ? ($standard_dev = +tmp.value, true) : false) : false)) && ($standard_dev > 0 ? true : (err = 'NUM', false)))) {
                    if ($standard_dev instanceof CalcError)
                        return $standard_dev;
                    return new CalcError(err);
                }
                xargs.push($standard_dev);
            }
            {
                var $cumulative = args[i++];
                if ($cumulative instanceof CalcError)
                    return $cumulative;
                if (!(typeof ($cumulative = this.force($cumulative)) == 'boolean' || (typeof $cumulative == 'number' ? ($cumulative = !!$cumulative, true) : false))) {
                    if ($cumulative instanceof CalcError)
                        return $cumulative;
                    return new CalcError(err);
                }
                xargs.push($cumulative);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), lognorm_dist);

    defineBuiltinFunction('LOGNORM.INV', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $probability = args[i++];
                if ($probability instanceof CalcError)
                    return $probability;
                if (!(((typeof ($probability = this.force($probability)) == 'number' ? ($probability = limitPrecision($probability), true) : false) || (typeof $probability == 'boolean' ? ($probability = +$probability, true) : false) || (typeof $probability == 'string' && !/^(?:=|true|false)/i.test($probability) ? (tmp = calc.parse(0, 0, 0, $probability), /^date|number|percent$/.test(tmp.type) ? ($probability = +tmp.value, true) : false) : false)) && ($probability > 0 && $probability < 1 ? true : (err = 'NUM', false)))) {
                    if ($probability instanceof CalcError)
                        return $probability;
                    return new CalcError(err);
                }
                xargs.push($probability);
            }
            {
                var $mean = args[i++];
                if ($mean instanceof CalcError)
                    return $mean;
                if (!((typeof ($mean = this.force($mean)) == 'number' ? ($mean = limitPrecision($mean), true) : false) || (typeof $mean == 'boolean' ? ($mean = +$mean, true) : false) || (typeof $mean == 'string' && !/^(?:=|true|false)/i.test($mean) ? (tmp = calc.parse(0, 0, 0, $mean), /^date|number|percent$/.test(tmp.type) ? ($mean = +tmp.value, true) : false) : false))) {
                    if ($mean instanceof CalcError)
                        return $mean;
                    return new CalcError(err);
                }
                xargs.push($mean);
            }
            {
                var $standard_dev = args[i++];
                if ($standard_dev instanceof CalcError)
                    return $standard_dev;
                if (!(((typeof ($standard_dev = this.force($standard_dev)) == 'number' ? ($standard_dev = limitPrecision($standard_dev), true) : false) || (typeof $standard_dev == 'boolean' ? ($standard_dev = +$standard_dev, true) : false) || (typeof $standard_dev == 'string' && !/^(?:=|true|false)/i.test($standard_dev) ? (tmp = calc.parse(0, 0, 0, $standard_dev), /^date|number|percent$/.test(tmp.type) ? ($standard_dev = +tmp.value, true) : false) : false)) && ($standard_dev > 0 ? true : (err = 'NUM', false)))) {
                    if ($standard_dev instanceof CalcError)
                        return $standard_dev;
                    return new CalcError(err);
                }
                xargs.push($standard_dev);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), lognorm_inv);

    defineBuiltinFunction('PROB', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                try {
                    var $x_range = this.cellValues(args.slice(i, i + 1)).reduce(function (ret, $x_range) {
                        if ($x_range instanceof CalcError)
                            throw $x_range;
                        if ((typeof $x_range == 'number' ? ($x_range = limitPrecision($x_range), true) : false) || (typeof $x_range == 'boolean' ? ($x_range = +$x_range, true) : false) || (typeof $x_range == 'string' && !/^(?:=|true|false)/i.test($x_range) ? (tmp = calc.parse(0, 0, 0, $x_range), /^date|number|percent$/.test(tmp.type) ? ($x_range = +tmp.value, true) : false) : false))
                            ret.push($x_range);
                        return ret;
                    }.bind(this), []);
                    i += 1;
                    xargs.push($x_range);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            {
                try {
                    var $prob_range = this.cellValues(args.slice(i, i + 1)).reduce(function (ret, $prob_range) {
                        if ($prob_range instanceof CalcError)
                            throw $prob_range;
                        if ((typeof $prob_range == 'number' ? ($prob_range = limitPrecision($prob_range), true) : false) || (typeof $prob_range == 'boolean' ? ($prob_range = +$prob_range, true) : false) || (typeof $prob_range == 'string' && !/^(?:=|true|false)/i.test($prob_range) ? (tmp = calc.parse(0, 0, 0, $prob_range), /^date|number|percent$/.test(tmp.type) ? ($prob_range = +tmp.value, true) : false) : false))
                            ret.push($prob_range);
                        return ret;
                    }.bind(this), []);
                    i += 1;
                    xargs.push($prob_range);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            {
                var $lower_limit = args[i++];
                if ($lower_limit instanceof CalcError)
                    return $lower_limit;
                if (!((typeof ($lower_limit = this.force($lower_limit)) == 'number' ? ($lower_limit = limitPrecision($lower_limit), true) : false) || (typeof $lower_limit == 'boolean' ? ($lower_limit = +$lower_limit, true) : false) || (typeof $lower_limit == 'string' && !/^(?:=|true|false)/i.test($lower_limit) ? (tmp = calc.parse(0, 0, 0, $lower_limit), /^date|number|percent$/.test(tmp.type) ? ($lower_limit = +tmp.value, true) : false) : false))) {
                    if ($lower_limit instanceof CalcError)
                        return $lower_limit;
                    return new CalcError(err);
                }
                xargs.push($lower_limit);
            }
            {
                var $upper_limit = args[i++];
                if ($upper_limit instanceof CalcError)
                    return $upper_limit;
                if (!((typeof ($upper_limit = this.force($upper_limit)) == 'number' ? ($upper_limit = limitPrecision($upper_limit), true) : false) || (typeof $upper_limit == 'boolean' ? ($upper_limit = +$upper_limit, true) : false) || (typeof $upper_limit == 'string' && !/^(?:=|true|false)/i.test($upper_limit) ? (tmp = calc.parse(0, 0, 0, $upper_limit), /^date|number|percent$/.test(tmp.type) ? ($upper_limit = +tmp.value, true) : false) : false) || ($upper_limit == null ? ($upper_limit = $lower_limit, true) : false))) {
                    if ($upper_limit instanceof CalcError)
                        return $upper_limit;
                    return new CalcError(err);
                }
                xargs.push($upper_limit);
            }
            {
                if (!($prob_range.length == $x_range.length ? true : (err = 'N/A', false)))
                    return new CalcError(err);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args.slice(i));
            toResolve.push(args.slice(i));
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), prob);

    defineBuiltinFunction('SLOPE', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                try {
                    var $known_y = this.cellValues(args.slice(i, i + 1)).reduce(function (ret, $known_y) {
                        if ($known_y instanceof CalcError)
                            throw $known_y;
                        if ((typeof $known_y == 'number' ? ($known_y = limitPrecision($known_y), true) : false) || (typeof $known_y == 'boolean' ? ($known_y = +$known_y, true) : false) || (typeof $known_y == 'string' && !/^(?:=|true|false)/i.test($known_y) ? (tmp = calc.parse(0, 0, 0, $known_y), /^date|number|percent$/.test(tmp.type) ? ($known_y = +tmp.value, true) : false) : false))
                            ret.push($known_y);
                        return ret;
                    }.bind(this), []);
                    i += 1;
                    xargs.push($known_y);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            {
                try {
                    var $known_x = this.cellValues(args.slice(i, i + 1)).reduce(function (ret, $known_x) {
                        if ($known_x instanceof CalcError)
                            throw $known_x;
                        if ((typeof $known_x == 'number' ? ($known_x = limitPrecision($known_x), true) : false) || (typeof $known_x == 'boolean' ? ($known_x = +$known_x, true) : false) || (typeof $known_x == 'string' && !/^(?:=|true|false)/i.test($known_x) ? (tmp = calc.parse(0, 0, 0, $known_x), /^date|number|percent$/.test(tmp.type) ? ($known_x = +tmp.value, true) : false) : false))
                            ret.push($known_x);
                        return ret;
                    }.bind(this), []);
                    i += 1;
                    xargs.push($known_x);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            {
                if (!($known_x.length == $known_y.length ? true : (err = 'N/A', false)))
                    return new CalcError(err);
            }
            {
                if (!($known_x.length > 0 && $known_y.length > 0 ? true : (err = 'N/A', false)))
                    return new CalcError(err);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args.slice(i));
            toResolve.push(args.slice(i));
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), slope);

    defineBuiltinFunction('INTERCEPT', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                try {
                    var $known_y = this.cellValues(args.slice(i, i + 1)).reduce(function (ret, $known_y) {
                        if ($known_y instanceof CalcError)
                            throw $known_y;
                        if ((typeof $known_y == 'number' ? ($known_y = limitPrecision($known_y), true) : false) || (typeof $known_y == 'boolean' ? ($known_y = +$known_y, true) : false) || (typeof $known_y == 'string' && !/^(?:=|true|false)/i.test($known_y) ? (tmp = calc.parse(0, 0, 0, $known_y), /^date|number|percent$/.test(tmp.type) ? ($known_y = +tmp.value, true) : false) : false))
                            ret.push($known_y);
                        return ret;
                    }.bind(this), []);
                    i += 1;
                    xargs.push($known_y);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            {
                try {
                    var $known_x = this.cellValues(args.slice(i, i + 1)).reduce(function (ret, $known_x) {
                        if ($known_x instanceof CalcError)
                            throw $known_x;
                        if ((typeof $known_x == 'number' ? ($known_x = limitPrecision($known_x), true) : false) || (typeof $known_x == 'boolean' ? ($known_x = +$known_x, true) : false) || (typeof $known_x == 'string' && !/^(?:=|true|false)/i.test($known_x) ? (tmp = calc.parse(0, 0, 0, $known_x), /^date|number|percent$/.test(tmp.type) ? ($known_x = +tmp.value, true) : false) : false))
                            ret.push($known_x);
                        return ret;
                    }.bind(this), []);
                    i += 1;
                    xargs.push($known_x);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            {
                if (!($known_x.length == $known_y.length ? true : (err = 'N/A', false)))
                    return new CalcError(err);
            }
            {
                if (!($known_x.length > 0 && $known_y.length > 0 ? true : (err = 'N/A', false)))
                    return new CalcError(err);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args.slice(i));
            toResolve.push(args.slice(i));
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), intercept);

    defineBuiltinFunction('PEARSON', false, function () {
        function check(args) {
            var xargs = [], i = 0, err = 'VALUE';
            {
                try {
                    var $array1 = this.cellValues(args.slice(i, i + 1), true).reduce(function (ret, $array1) {
                        if ($array1 instanceof CalcError)
                            throw $array1;
                        if (i <= args.length)
                            ret.push($array1);
                        return ret;
                    }.bind(this), []);
                    i += 1;
                    xargs.push($array1);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            {
                try {
                    var $array2 = this.cellValues(args.slice(i, i + 1), true).reduce(function (ret, $array2) {
                        if ($array2 instanceof CalcError)
                            throw $array2;
                        if (i <= args.length)
                            ret.push($array2);
                        return ret;
                    }.bind(this), []);
                    i += 1;
                    xargs.push($array2);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            {
                if (!($array2.length == $array1.length ? true : (err = 'N/A', false)))
                    return new CalcError(err);
            }
            {
                if (!($array2.length > 0 && $array1.length > 0 ? true : (err = 'N/A', false)))
                    return new CalcError(err);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args.slice(i));
            toResolve.push(args.slice(i));
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), pearson);

    defineBuiltinFunction('RSQ', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                try {
                    var $known_y = this.cellValues(args.slice(i, i + 1)).reduce(function (ret, $known_y) {
                        if ($known_y instanceof CalcError)
                            throw $known_y;
                        if ((typeof $known_y == 'number' ? ($known_y = limitPrecision($known_y), true) : false) || (typeof $known_y == 'boolean' ? ($known_y = +$known_y, true) : false) || (typeof $known_y == 'string' && !/^(?:=|true|false)/i.test($known_y) ? (tmp = calc.parse(0, 0, 0, $known_y), /^date|number|percent$/.test(tmp.type) ? ($known_y = +tmp.value, true) : false) : false))
                            ret.push($known_y);
                        return ret;
                    }.bind(this), []);
                    i += 1;
                    xargs.push($known_y);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            {
                try {
                    var $known_x = this.cellValues(args.slice(i, i + 1)).reduce(function (ret, $known_x) {
                        if ($known_x instanceof CalcError)
                            throw $known_x;
                        if ((typeof $known_x == 'number' ? ($known_x = limitPrecision($known_x), true) : false) || (typeof $known_x == 'boolean' ? ($known_x = +$known_x, true) : false) || (typeof $known_x == 'string' && !/^(?:=|true|false)/i.test($known_x) ? (tmp = calc.parse(0, 0, 0, $known_x), /^date|number|percent$/.test(tmp.type) ? ($known_x = +tmp.value, true) : false) : false))
                            ret.push($known_x);
                        return ret;
                    }.bind(this), []);
                    i += 1;
                    xargs.push($known_x);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            {
                if (!($known_x.length == $known_y.length ? true : (err = 'N/A', false)))
                    return new CalcError(err);
            }
            {
                if (!($known_x.length > 0 && $known_y.length > 0 ? true : (err = 'N/A', false)))
                    return new CalcError(err);
            }
            {
                if (!($known_x.length != 1 && $known_y.length != 1 ? true : (err = 'N/A', false)))
                    return new CalcError(err);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args.slice(i));
            toResolve.push(args.slice(i));
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), rsq);

    defineBuiltinFunction('STEYX', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                try {
                    var $known_y = this.cellValues(args.slice(i, i + 1)).reduce(function (ret, $known_y) {
                        if ($known_y instanceof CalcError)
                            throw $known_y;
                        if ((typeof $known_y == 'number' ? ($known_y = limitPrecision($known_y), true) : false) || (typeof $known_y == 'boolean' ? ($known_y = +$known_y, true) : false) || (typeof $known_y == 'string' && !/^(?:=|true|false)/i.test($known_y) ? (tmp = calc.parse(0, 0, 0, $known_y), /^date|number|percent$/.test(tmp.type) ? ($known_y = +tmp.value, true) : false) : false))
                            ret.push($known_y);
                        return ret;
                    }.bind(this), []);
                    i += 1;
                    xargs.push($known_y);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            {
                try {
                    var $known_x = this.cellValues(args.slice(i, i + 1)).reduce(function (ret, $known_x) {
                        if ($known_x instanceof CalcError)
                            throw $known_x;
                        if ((typeof $known_x == 'number' ? ($known_x = limitPrecision($known_x), true) : false) || (typeof $known_x == 'boolean' ? ($known_x = +$known_x, true) : false) || (typeof $known_x == 'string' && !/^(?:=|true|false)/i.test($known_x) ? (tmp = calc.parse(0, 0, 0, $known_x), /^date|number|percent$/.test(tmp.type) ? ($known_x = +tmp.value, true) : false) : false))
                            ret.push($known_x);
                        return ret;
                    }.bind(this), []);
                    i += 1;
                    xargs.push($known_x);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            {
                if (!($known_x.length == $known_y.length ? true : (err = 'N/A', false)))
                    return new CalcError(err);
            }
            {
                if (!($known_x.length >= 3 && $known_y.length >= 3 ? true : (err = 'DIV/0', false)))
                    return new CalcError(err);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args.slice(i));
            toResolve.push(args.slice(i));
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), steyx);

    defineBuiltinFunction('FORECAST', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $x = args[i++];
                if ($x instanceof CalcError)
                    return $x;
                if (!((typeof ($x = this.force($x)) == 'number' ? ($x = limitPrecision($x), true) : false) || (typeof $x == 'boolean' ? ($x = +$x, true) : false) || (typeof $x == 'string' && !/^(?:=|true|false)/i.test($x) ? (tmp = calc.parse(0, 0, 0, $x), /^date|number|percent$/.test(tmp.type) ? ($x = +tmp.value, true) : false) : false))) {
                    if ($x instanceof CalcError)
                        return $x;
                    return new CalcError(err);
                }
                xargs.push($x);
            }
            {
                try {
                    var $known_y = this.cellValues(args.slice(i, i + 1)).reduce(function (ret, $known_y) {
                        if ($known_y instanceof CalcError)
                            throw $known_y;
                        if ((typeof $known_y == 'number' ? ($known_y = limitPrecision($known_y), true) : false) || (typeof $known_y == 'boolean' ? ($known_y = +$known_y, true) : false) || (typeof $known_y == 'string' && !/^(?:=|true|false)/i.test($known_y) ? (tmp = calc.parse(0, 0, 0, $known_y), /^date|number|percent$/.test(tmp.type) ? ($known_y = +tmp.value, true) : false) : false))
                            ret.push($known_y);
                        return ret;
                    }.bind(this), []);
                    i += 1;
                    xargs.push($known_y);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            {
                try {
                    var $known_x = this.cellValues(args.slice(i, i + 1)).reduce(function (ret, $known_x) {
                        if ($known_x instanceof CalcError)
                            throw $known_x;
                        if ((typeof $known_x == 'number' ? ($known_x = limitPrecision($known_x), true) : false) || (typeof $known_x == 'boolean' ? ($known_x = +$known_x, true) : false) || (typeof $known_x == 'string' && !/^(?:=|true|false)/i.test($known_x) ? (tmp = calc.parse(0, 0, 0, $known_x), /^date|number|percent$/.test(tmp.type) ? ($known_x = +tmp.value, true) : false) : false))
                            ret.push($known_x);
                        return ret;
                    }.bind(this), []);
                    i += 1;
                    xargs.push($known_x);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            {
                if (!($known_x.length == $known_y.length ? true : (err = 'N/A', false)))
                    return new CalcError(err);
            }
            {
                if (!($known_x.length > 0 && $known_y.length > 0 ? true : (err = 'N/A', false)))
                    return new CalcError(err);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args.slice(i));
            toResolve.push(args.slice(i));
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), forecast);

    defineBuiltinFunction('LINEST', false, function () {
        function check(args) {
            var xargs = [], i = 0, m, err = 'VALUE';
            {
                var $known_y = args[i++];
                if ($known_y instanceof CalcError)
                    return $known_y;
                if (!((m = this.asMatrix($known_y)) ? $known_y = m : false)) {
                    if ($known_y instanceof CalcError)
                        return $known_y;
                    return new CalcError(err);
                }
                xargs.push($known_y);
            }
            {
                var $known_x = args[i++];
                if ($known_x instanceof CalcError)
                    return $known_x;
                if (!(((m = this.asMatrix($known_x)) ? $known_x = m : false) || $known_x == null)) {
                    if ($known_x instanceof CalcError)
                        return $known_x;
                    return new CalcError(err);
                }
                xargs.push($known_x);
            }
            {
                var $const = args[i++];
                if ($const instanceof CalcError)
                    return $const;
                if (!(typeof ($const = this.force($const)) == 'boolean' || (typeof $const == 'number' ? ($const = !!$const, true) : false) || ($const == null ? ($const = true, true) : false))) {
                    if ($const instanceof CalcError)
                        return $const;
                    return new CalcError(err);
                }
                xargs.push($const);
            }
            {
                var $stats = args[i++];
                if ($stats instanceof CalcError)
                    return $stats;
                if (!(typeof ($stats = this.force($stats)) == 'boolean' || (typeof $stats == 'number' ? ($stats = !!$stats, true) : false) || ($stats == null ? ($stats = false, true) : false))) {
                    if ($stats instanceof CalcError)
                        return $stats;
                    return new CalcError(err);
                }
                xargs.push($stats);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), linest);

    defineBuiltinFunction('LOGEST', false, function () {
        function check(args) {
            var xargs = [], i = 0, m, err = 'VALUE';
            {
                var $known_y = args[i++];
                if ($known_y instanceof CalcError)
                    return $known_y;
                if (!((m = this.asMatrix($known_y)) ? $known_y = m : false)) {
                    if ($known_y instanceof CalcError)
                        return $known_y;
                    return new CalcError(err);
                }
                xargs.push($known_y);
            }
            {
                var $known_x = args[i++];
                if ($known_x instanceof CalcError)
                    return $known_x;
                if (!(((m = this.asMatrix($known_x)) ? $known_x = m : false) || $known_x == null)) {
                    if ($known_x instanceof CalcError)
                        return $known_x;
                    return new CalcError(err);
                }
                xargs.push($known_x);
            }
            {
                var $const = args[i++];
                if ($const instanceof CalcError)
                    return $const;
                if (!(typeof ($const = this.force($const)) == 'boolean' || (typeof $const == 'number' ? ($const = !!$const, true) : false) || ($const == null ? ($const = true, true) : false))) {
                    if ($const instanceof CalcError)
                        return $const;
                    return new CalcError(err);
                }
                xargs.push($const);
            }
            {
                var $stats = args[i++];
                if ($stats instanceof CalcError)
                    return $stats;
                if (!(typeof ($stats = this.force($stats)) == 'boolean' || (typeof $stats == 'number' ? ($stats = !!$stats, true) : false) || ($stats == null ? ($stats = false, true) : false))) {
                    if ($stats instanceof CalcError)
                        return $stats;
                    return new CalcError(err);
                }
                xargs.push($stats);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), logest);

    defineBuiltinFunction('TREND', false, function () {
        function check(args) {
            var xargs = [], i = 0, m, err = 'VALUE';
            {
                var $known_y = args[i++];
                if ($known_y instanceof CalcError)
                    return $known_y;
                if (!((m = this.asMatrix($known_y)) ? $known_y = m : false)) {
                    if ($known_y instanceof CalcError)
                        return $known_y;
                    return new CalcError(err);
                }
                xargs.push($known_y);
            }
            {
                var $known_x = args[i++];
                if ($known_x instanceof CalcError)
                    return $known_x;
                if (!(((m = this.asMatrix($known_x)) ? $known_x = m : false) || $known_x == null)) {
                    if ($known_x instanceof CalcError)
                        return $known_x;
                    return new CalcError(err);
                }
                xargs.push($known_x);
            }
            {
                var $new_x = args[i++];
                if ($new_x instanceof CalcError)
                    return $new_x;
                if (!(((m = this.asMatrix($new_x)) ? $new_x = m : false) || $new_x == null)) {
                    if ($new_x instanceof CalcError)
                        return $new_x;
                    return new CalcError(err);
                }
                xargs.push($new_x);
            }
            {
                var $const = args[i++];
                if ($const instanceof CalcError)
                    return $const;
                if (!(typeof ($const = this.force($const)) == 'boolean' || (typeof $const == 'number' ? ($const = !!$const, true) : false) || ($const == null ? ($const = true, true) : false))) {
                    if ($const instanceof CalcError)
                        return $const;
                    return new CalcError(err);
                }
                xargs.push($const);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), trend);

    defineBuiltinFunction('GROWTH', false, function () {
        function check(args) {
            var xargs = [], i = 0, m, err = 'VALUE';
            {
                var $known_y = args[i++];
                if ($known_y instanceof CalcError)
                    return $known_y;
                if (!((m = this.asMatrix($known_y)) ? $known_y = m : false)) {
                    if ($known_y instanceof CalcError)
                        return $known_y;
                    return new CalcError(err);
                }
                xargs.push($known_y);
            }
            {
                var $known_x = args[i++];
                if ($known_x instanceof CalcError)
                    return $known_x;
                if (!(((m = this.asMatrix($known_x)) ? $known_x = m : false) || $known_x == null)) {
                    if ($known_x instanceof CalcError)
                        return $known_x;
                    return new CalcError(err);
                }
                xargs.push($known_x);
            }
            {
                var $new_x = args[i++];
                if ($new_x instanceof CalcError)
                    return $new_x;
                if (!(((m = this.asMatrix($new_x)) ? $new_x = m : false) || $new_x == null)) {
                    if ($new_x instanceof CalcError)
                        return $new_x;
                    return new CalcError(err);
                }
                xargs.push($new_x);
            }
            {
                var $const = args[i++];
                if ($const instanceof CalcError)
                    return $const;
                if (!(typeof ($const = this.force($const)) == 'boolean' || (typeof $const == 'number' ? ($const = !!$const, true) : false) || ($const == null ? ($const = true, true) : false))) {
                    if ($const instanceof CalcError)
                        return $const;
                    return new CalcError(err);
                }
                xargs.push($const);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), growth);

    defineBuiltinFunction('FV', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $rate = args[i++];
                if ($rate instanceof CalcError)
                    return $rate;
                if (!((typeof ($rate = this.force($rate)) == 'number' ? ($rate = limitPrecision($rate), true) : false) || (typeof $rate == 'boolean' ? ($rate = +$rate, true) : false) || (typeof $rate == 'string' && !/^(?:=|true|false)/i.test($rate) ? (tmp = calc.parse(0, 0, 0, $rate), /^date|number|percent$/.test(tmp.type) ? ($rate = +tmp.value, true) : false) : false))) {
                    if ($rate instanceof CalcError)
                        return $rate;
                    return new CalcError(err);
                }
                xargs.push($rate);
            }
            {
                var $nper = args[i++];
                if ($nper instanceof CalcError)
                    return $nper;
                if (!((typeof ($nper = this.force($nper)) == 'number' ? ($nper = limitPrecision($nper), true) : false) || (typeof $nper == 'boolean' ? ($nper = +$nper, true) : false) || (typeof $nper == 'string' && !/^(?:=|true|false)/i.test($nper) ? (tmp = calc.parse(0, 0, 0, $nper), /^date|number|percent$/.test(tmp.type) ? ($nper = +tmp.value, true) : false) : false))) {
                    if ($nper instanceof CalcError)
                        return $nper;
                    return new CalcError(err);
                }
                xargs.push($nper);
            }
            {
                var $pmt = args[i++];
                if ($pmt instanceof CalcError)
                    return $pmt;
                if (!((typeof ($pmt = this.force($pmt)) == 'number' ? ($pmt = limitPrecision($pmt), true) : false) || (typeof $pmt == 'boolean' ? ($pmt = +$pmt, true) : false) || (typeof $pmt == 'string' && !/^(?:=|true|false)/i.test($pmt) ? (tmp = calc.parse(0, 0, 0, $pmt), /^date|number|percent$/.test(tmp.type) ? ($pmt = +tmp.value, true) : false) : false) || ($pmt == null ? ($pmt = 0, true) : false))) {
                    if ($pmt instanceof CalcError)
                        return $pmt;
                    return new CalcError(err);
                }
                xargs.push($pmt);
            }
            {
                var $pv = args[i++];
                if ($pv instanceof CalcError)
                    return $pv;
                if (!((typeof ($pv = this.force($pv)) == 'number' ? ($pv = limitPrecision($pv), true) : false) || (typeof $pv == 'boolean' ? ($pv = +$pv, true) : false) || (typeof $pv == 'string' && !/^(?:=|true|false)/i.test($pv) ? (tmp = calc.parse(0, 0, 0, $pv), /^date|number|percent$/.test(tmp.type) ? ($pv = +tmp.value, true) : false) : false) || ($pv == null ? ($pv = 0, true) : false))) {
                    if ($pv instanceof CalcError)
                        return $pv;
                    return new CalcError(err);
                }
                xargs.push($pv);
            }
            {
                var $type = args[i++];
                if ($type instanceof CalcError)
                    return $type;
                if (!(($type = this.force($type)) === 0 || $type === 1 || ($type == null ? ($type = 0, true) : false))) {
                    if ($type instanceof CalcError)
                        return $type;
                    return new CalcError(err);
                }
                xargs.push($type);
            }
            {
                if (!($pmt || $pv ? true : (err = 'N/A', false)))
                    return new CalcError(err);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), FV);

    defineBuiltinFunction('PV', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $rate = args[i++];
                if ($rate instanceof CalcError)
                    return $rate;
                if (!((typeof ($rate = this.force($rate)) == 'number' ? ($rate = limitPrecision($rate), true) : false) || (typeof $rate == 'boolean' ? ($rate = +$rate, true) : false) || (typeof $rate == 'string' && !/^(?:=|true|false)/i.test($rate) ? (tmp = calc.parse(0, 0, 0, $rate), /^date|number|percent$/.test(tmp.type) ? ($rate = +tmp.value, true) : false) : false))) {
                    if ($rate instanceof CalcError)
                        return $rate;
                    return new CalcError(err);
                }
                xargs.push($rate);
            }
            {
                var $nper = args[i++];
                if ($nper instanceof CalcError)
                    return $nper;
                if (!((typeof ($nper = this.force($nper)) == 'number' ? ($nper = limitPrecision($nper), true) : false) || (typeof $nper == 'boolean' ? ($nper = +$nper, true) : false) || (typeof $nper == 'string' && !/^(?:=|true|false)/i.test($nper) ? (tmp = calc.parse(0, 0, 0, $nper), /^date|number|percent$/.test(tmp.type) ? ($nper = +tmp.value, true) : false) : false))) {
                    if ($nper instanceof CalcError)
                        return $nper;
                    return new CalcError(err);
                }
                xargs.push($nper);
            }
            {
                var $pmt = args[i++];
                if ($pmt instanceof CalcError)
                    return $pmt;
                if (!((typeof ($pmt = this.force($pmt)) == 'number' ? ($pmt = limitPrecision($pmt), true) : false) || (typeof $pmt == 'boolean' ? ($pmt = +$pmt, true) : false) || (typeof $pmt == 'string' && !/^(?:=|true|false)/i.test($pmt) ? (tmp = calc.parse(0, 0, 0, $pmt), /^date|number|percent$/.test(tmp.type) ? ($pmt = +tmp.value, true) : false) : false) || ($pmt == null ? ($pmt = 0, true) : false))) {
                    if ($pmt instanceof CalcError)
                        return $pmt;
                    return new CalcError(err);
                }
                xargs.push($pmt);
            }
            {
                var $fv = args[i++];
                if ($fv instanceof CalcError)
                    return $fv;
                if (!((typeof ($fv = this.force($fv)) == 'number' ? ($fv = limitPrecision($fv), true) : false) || (typeof $fv == 'boolean' ? ($fv = +$fv, true) : false) || (typeof $fv == 'string' && !/^(?:=|true|false)/i.test($fv) ? (tmp = calc.parse(0, 0, 0, $fv), /^date|number|percent$/.test(tmp.type) ? ($fv = +tmp.value, true) : false) : false) || ($fv == null ? ($fv = 0, true) : false))) {
                    if ($fv instanceof CalcError)
                        return $fv;
                    return new CalcError(err);
                }
                xargs.push($fv);
            }
            {
                var $type = args[i++];
                if ($type instanceof CalcError)
                    return $type;
                if (!(($type = this.force($type)) === 0 || $type === 1 || ($type == null ? ($type = 0, true) : false))) {
                    if ($type instanceof CalcError)
                        return $type;
                    return new CalcError(err);
                }
                xargs.push($type);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), PV);

    defineBuiltinFunction('PMT', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $rate = args[i++];
                if ($rate instanceof CalcError)
                    return $rate;
                if (!((typeof ($rate = this.force($rate)) == 'number' ? ($rate = limitPrecision($rate), true) : false) || (typeof $rate == 'boolean' ? ($rate = +$rate, true) : false) || (typeof $rate == 'string' && !/^(?:=|true|false)/i.test($rate) ? (tmp = calc.parse(0, 0, 0, $rate), /^date|number|percent$/.test(tmp.type) ? ($rate = +tmp.value, true) : false) : false))) {
                    if ($rate instanceof CalcError)
                        return $rate;
                    return new CalcError(err);
                }
                xargs.push($rate);
            }
            {
                var $nper = args[i++];
                if ($nper instanceof CalcError)
                    return $nper;
                if (!((typeof ($nper = this.force($nper)) == 'number' ? ($nper = limitPrecision($nper), true) : false) || (typeof $nper == 'boolean' ? ($nper = +$nper, true) : false) || (typeof $nper == 'string' && !/^(?:=|true|false)/i.test($nper) ? (tmp = calc.parse(0, 0, 0, $nper), /^date|number|percent$/.test(tmp.type) ? ($nper = +tmp.value, true) : false) : false))) {
                    if ($nper instanceof CalcError)
                        return $nper;
                    return new CalcError(err);
                }
                xargs.push($nper);
            }
            {
                var $pmt = args[i++];
                if ($pmt instanceof CalcError)
                    return $pmt;
                if (!((typeof ($pmt = this.force($pmt)) == 'number' ? ($pmt = limitPrecision($pmt), true) : false) || (typeof $pmt == 'boolean' ? ($pmt = +$pmt, true) : false) || (typeof $pmt == 'string' && !/^(?:=|true|false)/i.test($pmt) ? (tmp = calc.parse(0, 0, 0, $pmt), /^date|number|percent$/.test(tmp.type) ? ($pmt = +tmp.value, true) : false) : false))) {
                    if ($pmt instanceof CalcError)
                        return $pmt;
                    return new CalcError(err);
                }
                xargs.push($pmt);
            }
            {
                var $fv = args[i++];
                if ($fv instanceof CalcError)
                    return $fv;
                if (!((typeof ($fv = this.force($fv)) == 'number' ? ($fv = limitPrecision($fv), true) : false) || (typeof $fv == 'boolean' ? ($fv = +$fv, true) : false) || (typeof $fv == 'string' && !/^(?:=|true|false)/i.test($fv) ? (tmp = calc.parse(0, 0, 0, $fv), /^date|number|percent$/.test(tmp.type) ? ($fv = +tmp.value, true) : false) : false) || ($fv == null ? ($fv = 0, true) : false))) {
                    if ($fv instanceof CalcError)
                        return $fv;
                    return new CalcError(err);
                }
                xargs.push($fv);
            }
            {
                var $type = args[i++];
                if ($type instanceof CalcError)
                    return $type;
                if (!(($type = this.force($type)) === 0 || $type === 1 || ($type == null ? ($type = 0, true) : false))) {
                    if ($type instanceof CalcError)
                        return $type;
                    return new CalcError(err);
                }
                xargs.push($type);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), PMT);

    defineBuiltinFunction('NPER', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $rate = args[i++];
                if ($rate instanceof CalcError)
                    return $rate;
                if (!((typeof ($rate = this.force($rate)) == 'number' ? ($rate = limitPrecision($rate), true) : false) || (typeof $rate == 'boolean' ? ($rate = +$rate, true) : false) || (typeof $rate == 'string' && !/^(?:=|true|false)/i.test($rate) ? (tmp = calc.parse(0, 0, 0, $rate), /^date|number|percent$/.test(tmp.type) ? ($rate = +tmp.value, true) : false) : false))) {
                    if ($rate instanceof CalcError)
                        return $rate;
                    return new CalcError(err);
                }
                xargs.push($rate);
            }
            {
                var $pmt = args[i++];
                if ($pmt instanceof CalcError)
                    return $pmt;
                if (!((typeof ($pmt = this.force($pmt)) == 'number' ? ($pmt = limitPrecision($pmt), true) : false) || (typeof $pmt == 'boolean' ? ($pmt = +$pmt, true) : false) || (typeof $pmt == 'string' && !/^(?:=|true|false)/i.test($pmt) ? (tmp = calc.parse(0, 0, 0, $pmt), /^date|number|percent$/.test(tmp.type) ? ($pmt = +tmp.value, true) : false) : false))) {
                    if ($pmt instanceof CalcError)
                        return $pmt;
                    return new CalcError(err);
                }
                xargs.push($pmt);
            }
            {
                var $pv = args[i++];
                if ($pv instanceof CalcError)
                    return $pv;
                if (!((typeof ($pv = this.force($pv)) == 'number' ? ($pv = limitPrecision($pv), true) : false) || (typeof $pv == 'boolean' ? ($pv = +$pv, true) : false) || (typeof $pv == 'string' && !/^(?:=|true|false)/i.test($pv) ? (tmp = calc.parse(0, 0, 0, $pv), /^date|number|percent$/.test(tmp.type) ? ($pv = +tmp.value, true) : false) : false))) {
                    if ($pv instanceof CalcError)
                        return $pv;
                    return new CalcError(err);
                }
                xargs.push($pv);
            }
            {
                var $fv = args[i++];
                if ($fv instanceof CalcError)
                    return $fv;
                if (!((typeof ($fv = this.force($fv)) == 'number' ? ($fv = limitPrecision($fv), true) : false) || (typeof $fv == 'boolean' ? ($fv = +$fv, true) : false) || (typeof $fv == 'string' && !/^(?:=|true|false)/i.test($fv) ? (tmp = calc.parse(0, 0, 0, $fv), /^date|number|percent$/.test(tmp.type) ? ($fv = +tmp.value, true) : false) : false) || ($fv == null ? ($fv = 0, true) : false))) {
                    if ($fv instanceof CalcError)
                        return $fv;
                    return new CalcError(err);
                }
                xargs.push($fv);
            }
            {
                var $type = args[i++];
                if ($type instanceof CalcError)
                    return $type;
                if (!(($type = this.force($type)) === 0 || $type === 1 || ($type == null ? ($type = 0, true) : false))) {
                    if ($type instanceof CalcError)
                        return $type;
                    return new CalcError(err);
                }
                xargs.push($type);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), NPER);

    defineBuiltinFunction('RATE', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $nper = args[i++];
                if ($nper instanceof CalcError)
                    return $nper;
                if (!((typeof ($nper = this.force($nper)) == 'number' ? ($nper = limitPrecision($nper), true) : false) || (typeof $nper == 'boolean' ? ($nper = +$nper, true) : false) || (typeof $nper == 'string' && !/^(?:=|true|false)/i.test($nper) ? (tmp = calc.parse(0, 0, 0, $nper), /^date|number|percent$/.test(tmp.type) ? ($nper = +tmp.value, true) : false) : false))) {
                    if ($nper instanceof CalcError)
                        return $nper;
                    return new CalcError(err);
                }
                xargs.push($nper);
            }
            {
                var $pmt = args[i++];
                if ($pmt instanceof CalcError)
                    return $pmt;
                if (!((typeof ($pmt = this.force($pmt)) == 'number' ? ($pmt = limitPrecision($pmt), true) : false) || (typeof $pmt == 'boolean' ? ($pmt = +$pmt, true) : false) || (typeof $pmt == 'string' && !/^(?:=|true|false)/i.test($pmt) ? (tmp = calc.parse(0, 0, 0, $pmt), /^date|number|percent$/.test(tmp.type) ? ($pmt = +tmp.value, true) : false) : false) || ($pmt == null ? ($pmt = 0, true) : false))) {
                    if ($pmt instanceof CalcError)
                        return $pmt;
                    return new CalcError(err);
                }
                xargs.push($pmt);
            }
            {
                var $pv = args[i++];
                if ($pv instanceof CalcError)
                    return $pv;
                if (!((typeof ($pv = this.force($pv)) == 'number' ? ($pv = limitPrecision($pv), true) : false) || (typeof $pv == 'boolean' ? ($pv = +$pv, true) : false) || (typeof $pv == 'string' && !/^(?:=|true|false)/i.test($pv) ? (tmp = calc.parse(0, 0, 0, $pv), /^date|number|percent$/.test(tmp.type) ? ($pv = +tmp.value, true) : false) : false))) {
                    if ($pv instanceof CalcError)
                        return $pv;
                    return new CalcError(err);
                }
                xargs.push($pv);
            }
            {
                var $fv = args[i++];
                if ($fv instanceof CalcError)
                    return $fv;
                if (!((typeof ($fv = this.force($fv)) == 'number' ? ($fv = limitPrecision($fv), true) : false) || (typeof $fv == 'boolean' ? ($fv = +$fv, true) : false) || (typeof $fv == 'string' && !/^(?:=|true|false)/i.test($fv) ? (tmp = calc.parse(0, 0, 0, $fv), /^date|number|percent$/.test(tmp.type) ? ($fv = +tmp.value, true) : false) : false) || ($fv == null ? ($fv = 0, true) : false))) {
                    if ($fv instanceof CalcError)
                        return $fv;
                    return new CalcError(err);
                }
                xargs.push($fv);
            }
            {
                var $type = args[i++];
                if ($type instanceof CalcError)
                    return $type;
                if (!(($type = this.force($type)) === 0 || $type === 1 || ($type == null ? ($type = 0, true) : false))) {
                    if ($type instanceof CalcError)
                        return $type;
                    return new CalcError(err);
                }
                xargs.push($type);
            }
            {
                var $guess = args[i++];
                if ($guess instanceof CalcError)
                    return $guess;
                if (!(((typeof ($guess = this.force($guess)) == 'number' ? ($guess = limitPrecision($guess), true) : false) || (typeof $guess == 'boolean' ? ($guess = +$guess, true) : false) || (typeof $guess == 'string' && !/^(?:=|true|false)/i.test($guess) ? (tmp = calc.parse(0, 0, 0, $guess), /^date|number|percent$/.test(tmp.type) ? ($guess = +tmp.value, true) : false) : false)) && ($guess > 0 ? true : (err = 'NUM', false)) || ($guess == null ? ($guess = 0.01, true) : false))) {
                    if ($guess instanceof CalcError)
                        return $guess;
                    return new CalcError(err);
                }
                xargs.push($guess);
            }
            {
                if (!($pmt || $fv ? true : (err = 'N/A', false)))
                    return new CalcError(err);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), RATE);

    defineBuiltinFunction('IPMT', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $rate = args[i++];
                if ($rate instanceof CalcError)
                    return $rate;
                if (!((typeof ($rate = this.force($rate)) == 'number' ? ($rate = limitPrecision($rate), true) : false) || (typeof $rate == 'boolean' ? ($rate = +$rate, true) : false) || (typeof $rate == 'string' && !/^(?:=|true|false)/i.test($rate) ? (tmp = calc.parse(0, 0, 0, $rate), /^date|number|percent$/.test(tmp.type) ? ($rate = +tmp.value, true) : false) : false))) {
                    if ($rate instanceof CalcError)
                        return $rate;
                    return new CalcError(err);
                }
                xargs.push($rate);
            }
            {
                var $per = args[i++];
                if ($per instanceof CalcError)
                    return $per;
                if (!(((typeof ($per = this.force($per)) == 'number' ? ($per = limitPrecision($per), true) : false) || (typeof $per == 'boolean' ? ($per = +$per, true) : false) || (typeof $per == 'string' && !/^(?:=|true|false)/i.test($per) ? (tmp = calc.parse(0, 0, 0, $per), /^date|number|percent$/.test(tmp.type) ? ($per = +tmp.value, true) : false) : false)) && ($per > 0 ? true : (err = 'NUM', false)))) {
                    if ($per instanceof CalcError)
                        return $per;
                    return new CalcError(err);
                }
                xargs.push($per);
            }
            {
                var $nper = args[i++];
                if ($nper instanceof CalcError)
                    return $nper;
                if (!(((typeof ($nper = this.force($nper)) == 'number' ? ($nper = limitPrecision($nper), true) : false) || (typeof $nper == 'boolean' ? ($nper = +$nper, true) : false) || (typeof $nper == 'string' && !/^(?:=|true|false)/i.test($nper) ? (tmp = calc.parse(0, 0, 0, $nper), /^date|number|percent$/.test(tmp.type) ? ($nper = +tmp.value, true) : false) : false)) && ($nper > 0 ? true : (err = 'NUM', false)))) {
                    if ($nper instanceof CalcError)
                        return $nper;
                    return new CalcError(err);
                }
                xargs.push($nper);
            }
            {
                var $pv = args[i++];
                if ($pv instanceof CalcError)
                    return $pv;
                if (!((typeof ($pv = this.force($pv)) == 'number' ? ($pv = limitPrecision($pv), true) : false) || (typeof $pv == 'boolean' ? ($pv = +$pv, true) : false) || (typeof $pv == 'string' && !/^(?:=|true|false)/i.test($pv) ? (tmp = calc.parse(0, 0, 0, $pv), /^date|number|percent$/.test(tmp.type) ? ($pv = +tmp.value, true) : false) : false))) {
                    if ($pv instanceof CalcError)
                        return $pv;
                    return new CalcError(err);
                }
                xargs.push($pv);
            }
            {
                var $fv = args[i++];
                if ($fv instanceof CalcError)
                    return $fv;
                if (!((typeof ($fv = this.force($fv)) == 'number' ? ($fv = limitPrecision($fv), true) : false) || (typeof $fv == 'boolean' ? ($fv = +$fv, true) : false) || (typeof $fv == 'string' && !/^(?:=|true|false)/i.test($fv) ? (tmp = calc.parse(0, 0, 0, $fv), /^date|number|percent$/.test(tmp.type) ? ($fv = +tmp.value, true) : false) : false) || ($fv == null ? ($fv = 0, true) : false))) {
                    if ($fv instanceof CalcError)
                        return $fv;
                    return new CalcError(err);
                }
                xargs.push($fv);
            }
            {
                var $type = args[i++];
                if ($type instanceof CalcError)
                    return $type;
                if (!(($type = this.force($type)) === 0 || $type === 1 || ($type == null ? ($type = 0, true) : false))) {
                    if ($type instanceof CalcError)
                        return $type;
                    return new CalcError(err);
                }
                xargs.push($type);
            }
            {
                if (!($per >= 1 && $per <= $nper ? true : (err = 'N/A', false)))
                    return new CalcError(err);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), IPMT);

    defineBuiltinFunction('PPMT', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $rate = args[i++];
                if ($rate instanceof CalcError)
                    return $rate;
                if (!((typeof ($rate = this.force($rate)) == 'number' ? ($rate = limitPrecision($rate), true) : false) || (typeof $rate == 'boolean' ? ($rate = +$rate, true) : false) || (typeof $rate == 'string' && !/^(?:=|true|false)/i.test($rate) ? (tmp = calc.parse(0, 0, 0, $rate), /^date|number|percent$/.test(tmp.type) ? ($rate = +tmp.value, true) : false) : false))) {
                    if ($rate instanceof CalcError)
                        return $rate;
                    return new CalcError(err);
                }
                xargs.push($rate);
            }
            {
                var $per = args[i++];
                if ($per instanceof CalcError)
                    return $per;
                if (!(((typeof ($per = this.force($per)) == 'number' ? ($per = limitPrecision($per), true) : false) || (typeof $per == 'boolean' ? ($per = +$per, true) : false) || (typeof $per == 'string' && !/^(?:=|true|false)/i.test($per) ? (tmp = calc.parse(0, 0, 0, $per), /^date|number|percent$/.test(tmp.type) ? ($per = +tmp.value, true) : false) : false)) && ($per > 0 ? true : (err = 'NUM', false)))) {
                    if ($per instanceof CalcError)
                        return $per;
                    return new CalcError(err);
                }
                xargs.push($per);
            }
            {
                var $nper = args[i++];
                if ($nper instanceof CalcError)
                    return $nper;
                if (!(((typeof ($nper = this.force($nper)) == 'number' ? ($nper = limitPrecision($nper), true) : false) || (typeof $nper == 'boolean' ? ($nper = +$nper, true) : false) || (typeof $nper == 'string' && !/^(?:=|true|false)/i.test($nper) ? (tmp = calc.parse(0, 0, 0, $nper), /^date|number|percent$/.test(tmp.type) ? ($nper = +tmp.value, true) : false) : false)) && ($nper > 0 ? true : (err = 'NUM', false)))) {
                    if ($nper instanceof CalcError)
                        return $nper;
                    return new CalcError(err);
                }
                xargs.push($nper);
            }
            {
                var $pv = args[i++];
                if ($pv instanceof CalcError)
                    return $pv;
                if (!((typeof ($pv = this.force($pv)) == 'number' ? ($pv = limitPrecision($pv), true) : false) || (typeof $pv == 'boolean' ? ($pv = +$pv, true) : false) || (typeof $pv == 'string' && !/^(?:=|true|false)/i.test($pv) ? (tmp = calc.parse(0, 0, 0, $pv), /^date|number|percent$/.test(tmp.type) ? ($pv = +tmp.value, true) : false) : false))) {
                    if ($pv instanceof CalcError)
                        return $pv;
                    return new CalcError(err);
                }
                xargs.push($pv);
            }
            {
                var $fv = args[i++];
                if ($fv instanceof CalcError)
                    return $fv;
                if (!((typeof ($fv = this.force($fv)) == 'number' ? ($fv = limitPrecision($fv), true) : false) || (typeof $fv == 'boolean' ? ($fv = +$fv, true) : false) || (typeof $fv == 'string' && !/^(?:=|true|false)/i.test($fv) ? (tmp = calc.parse(0, 0, 0, $fv), /^date|number|percent$/.test(tmp.type) ? ($fv = +tmp.value, true) : false) : false) || ($fv == null ? ($fv = 0, true) : false))) {
                    if ($fv instanceof CalcError)
                        return $fv;
                    return new CalcError(err);
                }
                xargs.push($fv);
            }
            {
                var $type = args[i++];
                if ($type instanceof CalcError)
                    return $type;
                if (!(($type = this.force($type)) === 0 || $type === 1 || ($type == null ? ($type = 0, true) : false))) {
                    if ($type instanceof CalcError)
                        return $type;
                    return new CalcError(err);
                }
                xargs.push($type);
            }
            {
                if (!($per >= 1 && $per <= $nper ? true : (err = 'N/A', false)))
                    return new CalcError(err);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), PPMT);

    defineBuiltinFunction('CUMPRINC', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $rate = args[i++];
                if ($rate instanceof CalcError)
                    return $rate;
                if (!(((typeof ($rate = this.force($rate)) == 'number' ? ($rate = limitPrecision($rate), true) : false) || (typeof $rate == 'boolean' ? ($rate = +$rate, true) : false) || (typeof $rate == 'string' && !/^(?:=|true|false)/i.test($rate) ? (tmp = calc.parse(0, 0, 0, $rate), /^date|number|percent$/.test(tmp.type) ? ($rate = +tmp.value, true) : false) : false)) && ($rate > 0 ? true : (err = 'NUM', false)))) {
                    if ($rate instanceof CalcError)
                        return $rate;
                    return new CalcError(err);
                }
                xargs.push($rate);
            }
            {
                var $nper = args[i++];
                if ($nper instanceof CalcError)
                    return $nper;
                if (!(((typeof ($nper = this.force($nper)) == 'number' ? ($nper = limitPrecision($nper), true) : false) || (typeof $nper == 'boolean' ? ($nper = +$nper, true) : false) || (typeof $nper == 'string' && !/^(?:=|true|false)/i.test($nper) ? (tmp = calc.parse(0, 0, 0, $nper), /^date|number|percent$/.test(tmp.type) ? ($nper = +tmp.value, true) : false) : false)) && ($nper > 0 ? true : (err = 'NUM', false)))) {
                    if ($nper instanceof CalcError)
                        return $nper;
                    return new CalcError(err);
                }
                xargs.push($nper);
            }
            {
                var $pv = args[i++];
                if ($pv instanceof CalcError)
                    return $pv;
                if (!(((typeof ($pv = this.force($pv)) == 'number' ? ($pv = limitPrecision($pv), true) : false) || (typeof $pv == 'boolean' ? ($pv = +$pv, true) : false) || (typeof $pv == 'string' && !/^(?:=|true|false)/i.test($pv) ? (tmp = calc.parse(0, 0, 0, $pv), /^date|number|percent$/.test(tmp.type) ? ($pv = +tmp.value, true) : false) : false)) && ($pv > 0 ? true : (err = 'NUM', false)))) {
                    if ($pv instanceof CalcError)
                        return $pv;
                    return new CalcError(err);
                }
                xargs.push($pv);
            }
            {
                var $start_period = args[i++];
                if ($start_period instanceof CalcError)
                    return $start_period;
                if (!(((typeof ($start_period = this.force($start_period)) == 'number' ? ($start_period = limitPrecision($start_period), true) : false) || (typeof $start_period == 'boolean' ? ($start_period = +$start_period, true) : false) || (typeof $start_period == 'string' && !/^(?:=|true|false)/i.test($start_period) ? (tmp = calc.parse(0, 0, 0, $start_period), /^date|number|percent$/.test(tmp.type) ? ($start_period = +tmp.value, true) : false) : false)) && ($start_period > 0 ? true : (err = 'NUM', false)))) {
                    if ($start_period instanceof CalcError)
                        return $start_period;
                    return new CalcError(err);
                }
                xargs.push($start_period);
            }
            {
                var $end_period = args[i++];
                if ($end_period instanceof CalcError)
                    return $end_period;
                if (!(((typeof ($end_period = this.force($end_period)) == 'number' ? ($end_period = limitPrecision($end_period), true) : false) || (typeof $end_period == 'boolean' ? ($end_period = +$end_period, true) : false) || (typeof $end_period == 'string' && !/^(?:=|true|false)/i.test($end_period) ? (tmp = calc.parse(0, 0, 0, $end_period), /^date|number|percent$/.test(tmp.type) ? ($end_period = +tmp.value, true) : false) : false)) && ($end_period > 0 ? true : (err = 'NUM', false)))) {
                    if ($end_period instanceof CalcError)
                        return $end_period;
                    return new CalcError(err);
                }
                xargs.push($end_period);
            }
            {
                var $type = args[i++];
                if ($type instanceof CalcError)
                    return $type;
                if (!(($type = this.force($type)) === 0 || $type === 1 || ($type == null ? ($type = 0, true) : false))) {
                    if ($type instanceof CalcError)
                        return $type;
                    return new CalcError(err);
                }
                xargs.push($type);
            }
            {
                if (!($end_period >= $start_period ? true : (err = 'NUM', false)))
                    return new CalcError(err);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), CUMPRINC);

    defineBuiltinFunction('CUMIPMT', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $rate = args[i++];
                if ($rate instanceof CalcError)
                    return $rate;
                if (!(((typeof ($rate = this.force($rate)) == 'number' ? ($rate = limitPrecision($rate), true) : false) || (typeof $rate == 'boolean' ? ($rate = +$rate, true) : false) || (typeof $rate == 'string' && !/^(?:=|true|false)/i.test($rate) ? (tmp = calc.parse(0, 0, 0, $rate), /^date|number|percent$/.test(tmp.type) ? ($rate = +tmp.value, true) : false) : false)) && ($rate > 0 ? true : (err = 'NUM', false)))) {
                    if ($rate instanceof CalcError)
                        return $rate;
                    return new CalcError(err);
                }
                xargs.push($rate);
            }
            {
                var $nper = args[i++];
                if ($nper instanceof CalcError)
                    return $nper;
                if (!(((typeof ($nper = this.force($nper)) == 'number' ? ($nper = limitPrecision($nper), true) : false) || (typeof $nper == 'boolean' ? ($nper = +$nper, true) : false) || (typeof $nper == 'string' && !/^(?:=|true|false)/i.test($nper) ? (tmp = calc.parse(0, 0, 0, $nper), /^date|number|percent$/.test(tmp.type) ? ($nper = +tmp.value, true) : false) : false)) && ($nper > 0 ? true : (err = 'NUM', false)))) {
                    if ($nper instanceof CalcError)
                        return $nper;
                    return new CalcError(err);
                }
                xargs.push($nper);
            }
            {
                var $pv = args[i++];
                if ($pv instanceof CalcError)
                    return $pv;
                if (!(((typeof ($pv = this.force($pv)) == 'number' ? ($pv = limitPrecision($pv), true) : false) || (typeof $pv == 'boolean' ? ($pv = +$pv, true) : false) || (typeof $pv == 'string' && !/^(?:=|true|false)/i.test($pv) ? (tmp = calc.parse(0, 0, 0, $pv), /^date|number|percent$/.test(tmp.type) ? ($pv = +tmp.value, true) : false) : false)) && ($pv > 0 ? true : (err = 'NUM', false)))) {
                    if ($pv instanceof CalcError)
                        return $pv;
                    return new CalcError(err);
                }
                xargs.push($pv);
            }
            {
                var $start_period = args[i++];
                if ($start_period instanceof CalcError)
                    return $start_period;
                if (!(((typeof ($start_period = this.force($start_period)) == 'number' ? ($start_period = limitPrecision($start_period), true) : false) || (typeof $start_period == 'boolean' ? ($start_period = +$start_period, true) : false) || (typeof $start_period == 'string' && !/^(?:=|true|false)/i.test($start_period) ? (tmp = calc.parse(0, 0, 0, $start_period), /^date|number|percent$/.test(tmp.type) ? ($start_period = +tmp.value, true) : false) : false)) && ($start_period > 0 ? true : (err = 'NUM', false)))) {
                    if ($start_period instanceof CalcError)
                        return $start_period;
                    return new CalcError(err);
                }
                xargs.push($start_period);
            }
            {
                var $end_period = args[i++];
                if ($end_period instanceof CalcError)
                    return $end_period;
                if (!(((typeof ($end_period = this.force($end_period)) == 'number' ? ($end_period = limitPrecision($end_period), true) : false) || (typeof $end_period == 'boolean' ? ($end_period = +$end_period, true) : false) || (typeof $end_period == 'string' && !/^(?:=|true|false)/i.test($end_period) ? (tmp = calc.parse(0, 0, 0, $end_period), /^date|number|percent$/.test(tmp.type) ? ($end_period = +tmp.value, true) : false) : false)) && ($end_period > 0 ? true : (err = 'NUM', false)))) {
                    if ($end_period instanceof CalcError)
                        return $end_period;
                    return new CalcError(err);
                }
                xargs.push($end_period);
            }
            {
                var $type = args[i++];
                if ($type instanceof CalcError)
                    return $type;
                if (!(($type = this.force($type)) === 0 || $type === 1 || ($type == null ? ($type = 0, true) : false))) {
                    if ($type instanceof CalcError)
                        return $type;
                    return new CalcError(err);
                }
                xargs.push($type);
            }
            {
                if (!($end_period >= $start_period ? true : (err = 'NUM', false)))
                    return new CalcError(err);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), CUMIPMT);

    defineBuiltinFunction('NPV', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $rate = args[i++];
                if ($rate instanceof CalcError)
                    return $rate;
                if (!((typeof ($rate = this.force($rate)) == 'number' ? ($rate = limitPrecision($rate), true) : false) || (typeof $rate == 'boolean' ? ($rate = +$rate, true) : false) || (typeof $rate == 'string' && !/^(?:=|true|false)/i.test($rate) ? (tmp = calc.parse(0, 0, 0, $rate), /^date|number|percent$/.test(tmp.type) ? ($rate = +tmp.value, true) : false) : false))) {
                    if ($rate instanceof CalcError)
                        return $rate;
                    return new CalcError(err);
                }
                xargs.push($rate);
            }
            {
                try {
                    var $values = this.cellValues(args.slice(i)).reduce(function (ret, $values) {
                        if ($values instanceof CalcError)
                            throw $values;
                        if ((typeof $values == 'number' ? ($values = limitPrecision($values), true) : false) || (typeof $values == 'boolean' ? ($values = +$values, true) : false) || (typeof $values == 'string' && !/^(?:=|true|false)/i.test($values) ? (tmp = calc.parse(0, 0, 0, $values), /^date|number|percent$/.test(tmp.type) ? ($values = +tmp.value, true) : false) : false))
                            ret.push($values);
                        return ret;
                    }.bind(this), []);
                    i = args.length;
                    xargs.push($values);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            {
                if (!($values.length > 0 ? true : (err = 'N/A', false)))
                    return new CalcError(err);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args.slice(i));
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), NPV);

    defineBuiltinFunction('IRR', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                try {
                    var $values = this.cellValues(args.slice(i, i + 1)).reduce(function (ret, $values) {
                        if ($values instanceof CalcError)
                            throw $values;
                        if ((typeof $values == 'number' ? ($values = limitPrecision($values), true) : false) || (typeof $values == 'boolean' ? ($values = +$values, true) : false) || (typeof $values == 'string' && !/^(?:=|true|false)/i.test($values) ? (tmp = calc.parse(0, 0, 0, $values), /^date|number|percent$/.test(tmp.type) ? ($values = +tmp.value, true) : false) : false))
                            ret.push($values);
                        return ret;
                    }.bind(this), []);
                    i += 1;
                    xargs.push($values);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            {
                var $guess = args[i++];
                if ($guess instanceof CalcError)
                    return $guess;
                if (!((typeof ($guess = this.force($guess)) == 'number' ? ($guess = limitPrecision($guess), true) : false) || (typeof $guess == 'boolean' ? ($guess = +$guess, true) : false) || (typeof $guess == 'string' && !/^(?:=|true|false)/i.test($guess) ? (tmp = calc.parse(0, 0, 0, $guess), /^date|number|percent$/.test(tmp.type) ? ($guess = +tmp.value, true) : false) : false) || ($guess == null ? ($guess = 0.1, true) : false))) {
                    if ($guess instanceof CalcError)
                        return $guess;
                    return new CalcError(err);
                }
                xargs.push($guess);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args.slice(i));
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), IRR);

    defineBuiltinFunction('EFFECT', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $nominal_rate = args[i++];
                if ($nominal_rate instanceof CalcError)
                    return $nominal_rate;
                if (!(((typeof ($nominal_rate = this.force($nominal_rate)) == 'number' ? ($nominal_rate = limitPrecision($nominal_rate), true) : false) || (typeof $nominal_rate == 'boolean' ? ($nominal_rate = +$nominal_rate, true) : false) || (typeof $nominal_rate == 'string' && !/^(?:=|true|false)/i.test($nominal_rate) ? (tmp = calc.parse(0, 0, 0, $nominal_rate), /^date|number|percent$/.test(tmp.type) ? ($nominal_rate = +tmp.value, true) : false) : false)) && ($nominal_rate > 0 ? true : (err = 'NUM', false)))) {
                    if ($nominal_rate instanceof CalcError)
                        return $nominal_rate;
                    return new CalcError(err);
                }
                xargs.push($nominal_rate);
            }
            {
                var $npery = args[i++];
                if ($npery instanceof CalcError)
                    return $npery;
                if (!((typeof ($npery = this.force($npery)) == 'number' || (typeof $npery == 'boolean' ? ($npery = +$npery, true) : false) || (typeof $npery == 'string' && !/^(?:=|true|false)/i.test($npery) ? (tmp = calc.parse(0, 0, 0, $npery), /^date|number|percent$/.test(tmp.type) ? ($npery = +tmp.value, true) : false) : false)) && (($npery |= 0) > 0 ? true : (err = 'NUM', false)))) {
                    if ($npery instanceof CalcError)
                        return $npery;
                    return new CalcError(err);
                }
                xargs.push($npery);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), EFFECT);

    defineBuiltinFunction('NOMINAL', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $effect_rate = args[i++];
                if ($effect_rate instanceof CalcError)
                    return $effect_rate;
                if (!(((typeof ($effect_rate = this.force($effect_rate)) == 'number' ? ($effect_rate = limitPrecision($effect_rate), true) : false) || (typeof $effect_rate == 'boolean' ? ($effect_rate = +$effect_rate, true) : false) || (typeof $effect_rate == 'string' && !/^(?:=|true|false)/i.test($effect_rate) ? (tmp = calc.parse(0, 0, 0, $effect_rate), /^date|number|percent$/.test(tmp.type) ? ($effect_rate = +tmp.value, true) : false) : false)) && ($effect_rate > 0 ? true : (err = 'NUM', false)))) {
                    if ($effect_rate instanceof CalcError)
                        return $effect_rate;
                    return new CalcError(err);
                }
                xargs.push($effect_rate);
            }
            {
                var $npery = args[i++];
                if ($npery instanceof CalcError)
                    return $npery;
                if (!((typeof ($npery = this.force($npery)) == 'number' || (typeof $npery == 'boolean' ? ($npery = +$npery, true) : false) || (typeof $npery == 'string' && !/^(?:=|true|false)/i.test($npery) ? (tmp = calc.parse(0, 0, 0, $npery), /^date|number|percent$/.test(tmp.type) ? ($npery = +tmp.value, true) : false) : false)) && (($npery |= 0) > 0 ? true : (err = 'NUM', false)))) {
                    if ($npery instanceof CalcError)
                        return $npery;
                    return new CalcError(err);
                }
                xargs.push($npery);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), NOMINAL);

    defineBuiltinFunction('XNPV', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $rate = args[i++];
                if ($rate instanceof CalcError)
                    return $rate;
                if (!((typeof ($rate = this.force($rate)) == 'number' ? ($rate = limitPrecision($rate), true) : false) || (typeof $rate == 'boolean' ? ($rate = +$rate, true) : false) || (typeof $rate == 'string' && !/^(?:=|true|false)/i.test($rate) ? (tmp = calc.parse(0, 0, 0, $rate), /^date|number|percent$/.test(tmp.type) ? ($rate = +tmp.value, true) : false) : false))) {
                    if ($rate instanceof CalcError)
                        return $rate;
                    return new CalcError(err);
                }
                xargs.push($rate);
            }
            {
                try {
                    var $values = this.cellValues(args.slice(i, i + 1)).reduce(function (ret, $values) {
                        if ($values instanceof CalcError)
                            throw $values;
                        if ((typeof $values == 'number' ? ($values = limitPrecision($values), true) : false) || (typeof $values == 'boolean' ? ($values = +$values, true) : false) || (typeof $values == 'string' && !/^(?:=|true|false)/i.test($values) ? (tmp = calc.parse(0, 0, 0, $values), /^date|number|percent$/.test(tmp.type) ? ($values = +tmp.value, true) : false) : false))
                            ret.push($values);
                        return ret;
                    }.bind(this), []);
                    i += 1;
                    xargs.push($values);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            {
                try {
                    var $dates = this.cellValues(args.slice(i, i + 1)).reduce(function (ret, $dates) {
                        if ($dates instanceof CalcError)
                            throw $dates;
                        if ((typeof $dates == 'number' || (typeof $dates == 'boolean' ? ($dates = +$dates, true) : false) || (typeof $dates == 'string' && !/^(?:=|true|false)/i.test($dates) ? (tmp = calc.parse(0, 0, 0, $dates), /^date|number|percent$/.test(tmp.type) ? ($dates = +tmp.value, true) : false) : false)) && ($dates |= 0, true))
                            ret.push($dates);
                        return ret;
                    }.bind(this), []);
                    i += 1;
                    xargs.push($dates);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            {
                if (!($values.length == $dates.length ? true : (err = 'NUM', false)))
                    return new CalcError(err);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args.slice(i));
            toResolve.push(args.slice(i));
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), XNPV);

    defineBuiltinFunction('XIRR', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                try {
                    var $values = this.cellValues(args.slice(i, i + 1)).reduce(function (ret, $values) {
                        if ($values instanceof CalcError)
                            throw $values;
                        if ((typeof $values == 'number' ? ($values = limitPrecision($values), true) : false) || (typeof $values == 'boolean' ? ($values = +$values, true) : false) || (typeof $values == 'string' && !/^(?:=|true|false)/i.test($values) ? (tmp = calc.parse(0, 0, 0, $values), /^date|number|percent$/.test(tmp.type) ? ($values = +tmp.value, true) : false) : false))
                            ret.push($values);
                        return ret;
                    }.bind(this), []);
                    i += 1;
                    xargs.push($values);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            {
                try {
                    var $dates = this.cellValues(args.slice(i, i + 1)).reduce(function (ret, $dates) {
                        if ($dates instanceof CalcError)
                            throw $dates;
                        if ((typeof $dates == 'number' || (typeof $dates == 'boolean' ? ($dates = +$dates, true) : false) || (typeof $dates == 'string' && !/^(?:=|true|false)/i.test($dates) ? (tmp = calc.parse(0, 0, 0, $dates), /^date|number|percent$/.test(tmp.type) ? ($dates = +tmp.value, true) : false) : false)) && ($dates |= 0, true))
                            ret.push($dates);
                        return ret;
                    }.bind(this), []);
                    i += 1;
                    xargs.push($dates);
                } catch (ex) {
                    if (ex instanceof CalcError)
                        return ex;
                    throw ex;
                }
            }
            {
                var $guess = args[i++];
                if ($guess instanceof CalcError)
                    return $guess;
                if (!((typeof ($guess = this.force($guess)) == 'number' ? ($guess = limitPrecision($guess), true) : false) || (typeof $guess == 'boolean' ? ($guess = +$guess, true) : false) || (typeof $guess == 'string' && !/^(?:=|true|false)/i.test($guess) ? (tmp = calc.parse(0, 0, 0, $guess), /^date|number|percent$/.test(tmp.type) ? ($guess = +tmp.value, true) : false) : false) || ($guess == null ? ($guess = 0.1, true) : false))) {
                    if ($guess instanceof CalcError)
                        return $guess;
                    return new CalcError(err);
                }
                xargs.push($guess);
            }
            {
                if (!($values.length == $dates.length ? true : (err = 'NUM', false)))
                    return new CalcError(err);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args.slice(i));
            toResolve.push(args.slice(i));
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), XIRR);

    defineBuiltinFunction('ISPMT', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $rate = args[i++];
                if ($rate instanceof CalcError)
                    return $rate;
                if (!((typeof ($rate = this.force($rate)) == 'number' ? ($rate = limitPrecision($rate), true) : false) || (typeof $rate == 'boolean' ? ($rate = +$rate, true) : false) || (typeof $rate == 'string' && !/^(?:=|true|false)/i.test($rate) ? (tmp = calc.parse(0, 0, 0, $rate), /^date|number|percent$/.test(tmp.type) ? ($rate = +tmp.value, true) : false) : false))) {
                    if ($rate instanceof CalcError)
                        return $rate;
                    return new CalcError(err);
                }
                xargs.push($rate);
            }
            {
                var $per = args[i++];
                if ($per instanceof CalcError)
                    return $per;
                if (!(((typeof ($per = this.force($per)) == 'number' ? ($per = limitPrecision($per), true) : false) || (typeof $per == 'boolean' ? ($per = +$per, true) : false) || (typeof $per == 'string' && !/^(?:=|true|false)/i.test($per) ? (tmp = calc.parse(0, 0, 0, $per), /^date|number|percent$/.test(tmp.type) ? ($per = +tmp.value, true) : false) : false)) && ($per > 0 ? true : (err = 'NUM', false)))) {
                    if ($per instanceof CalcError)
                        return $per;
                    return new CalcError(err);
                }
                xargs.push($per);
            }
            {
                var $nper = args[i++];
                if ($nper instanceof CalcError)
                    return $nper;
                if (!(((typeof ($nper = this.force($nper)) == 'number' ? ($nper = limitPrecision($nper), true) : false) || (typeof $nper == 'boolean' ? ($nper = +$nper, true) : false) || (typeof $nper == 'string' && !/^(?:=|true|false)/i.test($nper) ? (tmp = calc.parse(0, 0, 0, $nper), /^date|number|percent$/.test(tmp.type) ? ($nper = +tmp.value, true) : false) : false)) && ($nper > 0 ? true : (err = 'NUM', false)))) {
                    if ($nper instanceof CalcError)
                        return $nper;
                    return new CalcError(err);
                }
                xargs.push($nper);
            }
            {
                var $pv = args[i++];
                if ($pv instanceof CalcError)
                    return $pv;
                if (!((typeof ($pv = this.force($pv)) == 'number' ? ($pv = limitPrecision($pv), true) : false) || (typeof $pv == 'boolean' ? ($pv = +$pv, true) : false) || (typeof $pv == 'string' && !/^(?:=|true|false)/i.test($pv) ? (tmp = calc.parse(0, 0, 0, $pv), /^date|number|percent$/.test(tmp.type) ? ($pv = +tmp.value, true) : false) : false))) {
                    if ($pv instanceof CalcError)
                        return $pv;
                    return new CalcError(err);
                }
                xargs.push($pv);
            }
            {
                if (!($per >= 1 && $per <= $nper ? true : (err = 'N/A', false)))
                    return new CalcError(err);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), ISPMT);

    defineBuiltinFunction('DB', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $cost = args[i++];
                if ($cost instanceof CalcError)
                    return $cost;
                if (!((typeof ($cost = this.force($cost)) == 'number' ? ($cost = limitPrecision($cost), true) : false) || (typeof $cost == 'boolean' ? ($cost = +$cost, true) : false) || (typeof $cost == 'string' && !/^(?:=|true|false)/i.test($cost) ? (tmp = calc.parse(0, 0, 0, $cost), /^date|number|percent$/.test(tmp.type) ? ($cost = +tmp.value, true) : false) : false))) {
                    if ($cost instanceof CalcError)
                        return $cost;
                    return new CalcError(err);
                }
                xargs.push($cost);
            }
            {
                var $salvage = args[i++];
                if ($salvage instanceof CalcError)
                    return $salvage;
                if (!((typeof ($salvage = this.force($salvage)) == 'number' ? ($salvage = limitPrecision($salvage), true) : false) || (typeof $salvage == 'boolean' ? ($salvage = +$salvage, true) : false) || (typeof $salvage == 'string' && !/^(?:=|true|false)/i.test($salvage) ? (tmp = calc.parse(0, 0, 0, $salvage), /^date|number|percent$/.test(tmp.type) ? ($salvage = +tmp.value, true) : false) : false))) {
                    if ($salvage instanceof CalcError)
                        return $salvage;
                    return new CalcError(err);
                }
                xargs.push($salvage);
            }
            {
                var $life = args[i++];
                if ($life instanceof CalcError)
                    return $life;
                if (!(((typeof ($life = this.force($life)) == 'number' ? ($life = limitPrecision($life), true) : false) || (typeof $life == 'boolean' ? ($life = +$life, true) : false) || (typeof $life == 'string' && !/^(?:=|true|false)/i.test($life) ? (tmp = calc.parse(0, 0, 0, $life), /^date|number|percent$/.test(tmp.type) ? ($life = +tmp.value, true) : false) : false)) && ($life > 0 ? true : (err = 'NUM', false)))) {
                    if ($life instanceof CalcError)
                        return $life;
                    return new CalcError(err);
                }
                xargs.push($life);
            }
            {
                var $period = args[i++];
                if ($period instanceof CalcError)
                    return $period;
                if (!(((typeof ($period = this.force($period)) == 'number' ? ($period = limitPrecision($period), true) : false) || (typeof $period == 'boolean' ? ($period = +$period, true) : false) || (typeof $period == 'string' && !/^(?:=|true|false)/i.test($period) ? (tmp = calc.parse(0, 0, 0, $period), /^date|number|percent$/.test(tmp.type) ? ($period = +tmp.value, true) : false) : false)) && ($period > 0 ? true : (err = 'NUM', false)))) {
                    if ($period instanceof CalcError)
                        return $period;
                    return new CalcError(err);
                }
                xargs.push($period);
            }
            {
                var $month = args[i++];
                if ($month instanceof CalcError)
                    return $month;
                if (!((typeof ($month = this.force($month)) == 'number' ? ($month = limitPrecision($month), true) : false) || (typeof $month == 'boolean' ? ($month = +$month, true) : false) || (typeof $month == 'string' && !/^(?:=|true|false)/i.test($month) ? (tmp = calc.parse(0, 0, 0, $month), /^date|number|percent$/.test(tmp.type) ? ($month = +tmp.value, true) : false) : false) || ($month == null ? ($month = 12, true) : false))) {
                    if ($month instanceof CalcError)
                        return $month;
                    return new CalcError(err);
                }
                xargs.push($month);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), DB);

    defineBuiltinFunction('DDB', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $cost = args[i++];
                if ($cost instanceof CalcError)
                    return $cost;
                if (!((typeof ($cost = this.force($cost)) == 'number' ? ($cost = limitPrecision($cost), true) : false) || (typeof $cost == 'boolean' ? ($cost = +$cost, true) : false) || (typeof $cost == 'string' && !/^(?:=|true|false)/i.test($cost) ? (tmp = calc.parse(0, 0, 0, $cost), /^date|number|percent$/.test(tmp.type) ? ($cost = +tmp.value, true) : false) : false))) {
                    if ($cost instanceof CalcError)
                        return $cost;
                    return new CalcError(err);
                }
                xargs.push($cost);
            }
            {
                var $salvage = args[i++];
                if ($salvage instanceof CalcError)
                    return $salvage;
                if (!((typeof ($salvage = this.force($salvage)) == 'number' ? ($salvage = limitPrecision($salvage), true) : false) || (typeof $salvage == 'boolean' ? ($salvage = +$salvage, true) : false) || (typeof $salvage == 'string' && !/^(?:=|true|false)/i.test($salvage) ? (tmp = calc.parse(0, 0, 0, $salvage), /^date|number|percent$/.test(tmp.type) ? ($salvage = +tmp.value, true) : false) : false))) {
                    if ($salvage instanceof CalcError)
                        return $salvage;
                    return new CalcError(err);
                }
                xargs.push($salvage);
            }
            {
                var $life = args[i++];
                if ($life instanceof CalcError)
                    return $life;
                if (!(((typeof ($life = this.force($life)) == 'number' ? ($life = limitPrecision($life), true) : false) || (typeof $life == 'boolean' ? ($life = +$life, true) : false) || (typeof $life == 'string' && !/^(?:=|true|false)/i.test($life) ? (tmp = calc.parse(0, 0, 0, $life), /^date|number|percent$/.test(tmp.type) ? ($life = +tmp.value, true) : false) : false)) && ($life > 0 ? true : (err = 'NUM', false)))) {
                    if ($life instanceof CalcError)
                        return $life;
                    return new CalcError(err);
                }
                xargs.push($life);
            }
            {
                var $period = args[i++];
                if ($period instanceof CalcError)
                    return $period;
                if (!(((typeof ($period = this.force($period)) == 'number' ? ($period = limitPrecision($period), true) : false) || (typeof $period == 'boolean' ? ($period = +$period, true) : false) || (typeof $period == 'string' && !/^(?:=|true|false)/i.test($period) ? (tmp = calc.parse(0, 0, 0, $period), /^date|number|percent$/.test(tmp.type) ? ($period = +tmp.value, true) : false) : false)) && ($period > 0 ? true : (err = 'NUM', false)))) {
                    if ($period instanceof CalcError)
                        return $period;
                    return new CalcError(err);
                }
                xargs.push($period);
            }
            {
                var $factor = args[i++];
                if ($factor instanceof CalcError)
                    return $factor;
                if (!((typeof ($factor = this.force($factor)) == 'number' ? ($factor = limitPrecision($factor), true) : false) || (typeof $factor == 'boolean' ? ($factor = +$factor, true) : false) || (typeof $factor == 'string' && !/^(?:=|true|false)/i.test($factor) ? (tmp = calc.parse(0, 0, 0, $factor), /^date|number|percent$/.test(tmp.type) ? ($factor = +tmp.value, true) : false) : false) || ($factor == null ? ($factor = 2, true) : false))) {
                    if ($factor instanceof CalcError)
                        return $factor;
                    return new CalcError(err);
                }
                xargs.push($factor);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), DDB);

    defineBuiltinFunction('SLN', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $cost = args[i++];
                if ($cost instanceof CalcError)
                    return $cost;
                if (!((typeof ($cost = this.force($cost)) == 'number' ? ($cost = limitPrecision($cost), true) : false) || (typeof $cost == 'boolean' ? ($cost = +$cost, true) : false) || (typeof $cost == 'string' && !/^(?:=|true|false)/i.test($cost) ? (tmp = calc.parse(0, 0, 0, $cost), /^date|number|percent$/.test(tmp.type) ? ($cost = +tmp.value, true) : false) : false))) {
                    if ($cost instanceof CalcError)
                        return $cost;
                    return new CalcError(err);
                }
                xargs.push($cost);
            }
            {
                var $salvage = args[i++];
                if ($salvage instanceof CalcError)
                    return $salvage;
                if (!((typeof ($salvage = this.force($salvage)) == 'number' ? ($salvage = limitPrecision($salvage), true) : false) || (typeof $salvage == 'boolean' ? ($salvage = +$salvage, true) : false) || (typeof $salvage == 'string' && !/^(?:=|true|false)/i.test($salvage) ? (tmp = calc.parse(0, 0, 0, $salvage), /^date|number|percent$/.test(tmp.type) ? ($salvage = +tmp.value, true) : false) : false))) {
                    if ($salvage instanceof CalcError)
                        return $salvage;
                    return new CalcError(err);
                }
                xargs.push($salvage);
            }
            {
                var $life = args[i++];
                if ($life instanceof CalcError)
                    return $life;
                if (!(((typeof ($life = this.force($life)) == 'number' ? ($life = limitPrecision($life), true) : false) || (typeof $life == 'boolean' ? ($life = +$life, true) : false) || (typeof $life == 'string' && !/^(?:=|true|false)/i.test($life) ? (tmp = calc.parse(0, 0, 0, $life), /^date|number|percent$/.test(tmp.type) ? ($life = +tmp.value, true) : false) : false)) && ($life > 0 ? true : (err = 'NUM', false)))) {
                    if ($life instanceof CalcError)
                        return $life;
                    return new CalcError(err);
                }
                xargs.push($life);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), SLN);

    defineBuiltinFunction('SYD', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $cost = args[i++];
                if ($cost instanceof CalcError)
                    return $cost;
                if (!((typeof ($cost = this.force($cost)) == 'number' ? ($cost = limitPrecision($cost), true) : false) || (typeof $cost == 'boolean' ? ($cost = +$cost, true) : false) || (typeof $cost == 'string' && !/^(?:=|true|false)/i.test($cost) ? (tmp = calc.parse(0, 0, 0, $cost), /^date|number|percent$/.test(tmp.type) ? ($cost = +tmp.value, true) : false) : false))) {
                    if ($cost instanceof CalcError)
                        return $cost;
                    return new CalcError(err);
                }
                xargs.push($cost);
            }
            {
                var $salvage = args[i++];
                if ($salvage instanceof CalcError)
                    return $salvage;
                if (!((typeof ($salvage = this.force($salvage)) == 'number' ? ($salvage = limitPrecision($salvage), true) : false) || (typeof $salvage == 'boolean' ? ($salvage = +$salvage, true) : false) || (typeof $salvage == 'string' && !/^(?:=|true|false)/i.test($salvage) ? (tmp = calc.parse(0, 0, 0, $salvage), /^date|number|percent$/.test(tmp.type) ? ($salvage = +tmp.value, true) : false) : false))) {
                    if ($salvage instanceof CalcError)
                        return $salvage;
                    return new CalcError(err);
                }
                xargs.push($salvage);
            }
            {
                var $life = args[i++];
                if ($life instanceof CalcError)
                    return $life;
                if (!(((typeof ($life = this.force($life)) == 'number' ? ($life = limitPrecision($life), true) : false) || (typeof $life == 'boolean' ? ($life = +$life, true) : false) || (typeof $life == 'string' && !/^(?:=|true|false)/i.test($life) ? (tmp = calc.parse(0, 0, 0, $life), /^date|number|percent$/.test(tmp.type) ? ($life = +tmp.value, true) : false) : false)) && ($life > 0 ? true : (err = 'NUM', false)))) {
                    if ($life instanceof CalcError)
                        return $life;
                    return new CalcError(err);
                }
                xargs.push($life);
            }
            {
                var $per = args[i++];
                if ($per instanceof CalcError)
                    return $per;
                if (!(((typeof ($per = this.force($per)) == 'number' ? ($per = limitPrecision($per), true) : false) || (typeof $per == 'boolean' ? ($per = +$per, true) : false) || (typeof $per == 'string' && !/^(?:=|true|false)/i.test($per) ? (tmp = calc.parse(0, 0, 0, $per), /^date|number|percent$/.test(tmp.type) ? ($per = +tmp.value, true) : false) : false)) && ($per > 0 ? true : (err = 'NUM', false)))) {
                    if ($per instanceof CalcError)
                        return $per;
                    return new CalcError(err);
                }
                xargs.push($per);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), SYD);

    defineBuiltinFunction('VDB', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $cost = args[i++];
                if ($cost instanceof CalcError)
                    return $cost;
                if (!(((typeof ($cost = this.force($cost)) == 'number' ? ($cost = limitPrecision($cost), true) : false) || (typeof $cost == 'boolean' ? ($cost = +$cost, true) : false) || (typeof $cost == 'string' && !/^(?:=|true|false)/i.test($cost) ? (tmp = calc.parse(0, 0, 0, $cost), /^date|number|percent$/.test(tmp.type) ? ($cost = +tmp.value, true) : false) : false)) && ($cost >= 0 ? true : (err = 'NUM', false)))) {
                    if ($cost instanceof CalcError)
                        return $cost;
                    return new CalcError(err);
                }
                xargs.push($cost);
            }
            {
                var $salvage = args[i++];
                if ($salvage instanceof CalcError)
                    return $salvage;
                if (!(((typeof ($salvage = this.force($salvage)) == 'number' ? ($salvage = limitPrecision($salvage), true) : false) || (typeof $salvage == 'boolean' ? ($salvage = +$salvage, true) : false) || (typeof $salvage == 'string' && !/^(?:=|true|false)/i.test($salvage) ? (tmp = calc.parse(0, 0, 0, $salvage), /^date|number|percent$/.test(tmp.type) ? ($salvage = +tmp.value, true) : false) : false)) && ($salvage >= 0 ? true : (err = 'NUM', false)))) {
                    if ($salvage instanceof CalcError)
                        return $salvage;
                    return new CalcError(err);
                }
                xargs.push($salvage);
            }
            {
                var $life = args[i++];
                if ($life instanceof CalcError)
                    return $life;
                if (!(((typeof ($life = this.force($life)) == 'number' ? ($life = limitPrecision($life), true) : false) || (typeof $life == 'boolean' ? ($life = +$life, true) : false) || (typeof $life == 'string' && !/^(?:=|true|false)/i.test($life) ? (tmp = calc.parse(0, 0, 0, $life), /^date|number|percent$/.test(tmp.type) ? ($life = +tmp.value, true) : false) : false)) && ($life > 0 ? true : (err = 'NUM', false)))) {
                    if ($life instanceof CalcError)
                        return $life;
                    return new CalcError(err);
                }
                xargs.push($life);
            }
            {
                var $start_period = args[i++];
                if ($start_period instanceof CalcError)
                    return $start_period;
                if (!(((typeof ($start_period = this.force($start_period)) == 'number' ? ($start_period = limitPrecision($start_period), true) : false) || (typeof $start_period == 'boolean' ? ($start_period = +$start_period, true) : false) || (typeof $start_period == 'string' && !/^(?:=|true|false)/i.test($start_period) ? (tmp = calc.parse(0, 0, 0, $start_period), /^date|number|percent$/.test(tmp.type) ? ($start_period = +tmp.value, true) : false) : false)) && ($start_period >= 0 ? true : (err = 'NUM', false)))) {
                    if ($start_period instanceof CalcError)
                        return $start_period;
                    return new CalcError(err);
                }
                xargs.push($start_period);
            }
            {
                var $end_period = args[i++];
                if ($end_period instanceof CalcError)
                    return $end_period;
                if (!(((typeof ($end_period = this.force($end_period)) == 'number' ? ($end_period = limitPrecision($end_period), true) : false) || (typeof $end_period == 'boolean' ? ($end_period = +$end_period, true) : false) || (typeof $end_period == 'string' && !/^(?:=|true|false)/i.test($end_period) ? (tmp = calc.parse(0, 0, 0, $end_period), /^date|number|percent$/.test(tmp.type) ? ($end_period = +tmp.value, true) : false) : false)) && ($end_period >= 0 ? true : (err = 'NUM', false)))) {
                    if ($end_period instanceof CalcError)
                        return $end_period;
                    return new CalcError(err);
                }
                xargs.push($end_period);
            }
            {
                var $factor = args[i++];
                if ($factor instanceof CalcError)
                    return $factor;
                if (!(((typeof ($factor = this.force($factor)) == 'number' ? ($factor = limitPrecision($factor), true) : false) || (typeof $factor == 'boolean' ? ($factor = +$factor, true) : false) || (typeof $factor == 'string' && !/^(?:=|true|false)/i.test($factor) ? (tmp = calc.parse(0, 0, 0, $factor), /^date|number|percent$/.test(tmp.type) ? ($factor = +tmp.value, true) : false) : false)) && ($factor >= 0 ? true : (err = 'NUM', false)) || ($factor == null ? ($factor = 2, true) : false))) {
                    if ($factor instanceof CalcError)
                        return $factor;
                    return new CalcError(err);
                }
                xargs.push($factor);
            }
            {
                var $no_switch = args[i++];
                if ($no_switch instanceof CalcError)
                    return $no_switch;
                if (!(typeof ($no_switch = this.force($no_switch)) == 'boolean' || (typeof $no_switch == 'number' ? ($no_switch = !!$no_switch, true) : false) || ($no_switch == null ? ($no_switch = false, true) : false))) {
                    if ($no_switch instanceof CalcError)
                        return $no_switch;
                    return new CalcError(err);
                }
                xargs.push($no_switch);
            }
            {
                if (!($end_period >= $start_period ? true : (err = 'NUM', false)))
                    return new CalcError(err);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), VDB);

    defineBuiltinFunction('COUPDAYBS', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $settlement = args[i++];
                if ($settlement instanceof CalcError)
                    return $settlement;
                if (!((typeof ($settlement = this.force($settlement)) == 'number' || (typeof $settlement == 'boolean' ? ($settlement = +$settlement, true) : false) || (typeof $settlement == 'string' && !/^(?:=|true|false)/i.test($settlement) ? (tmp = calc.parse(0, 0, 0, $settlement), /^date|number|percent$/.test(tmp.type) ? ($settlement = +tmp.value, true) : false) : false)) && ($settlement |= 0, true))) {
                    if ($settlement instanceof CalcError)
                        return $settlement;
                    return new CalcError(err);
                }
                xargs.push($settlement);
            }
            {
                var $maturity = args[i++];
                if ($maturity instanceof CalcError)
                    return $maturity;
                if (!((typeof ($maturity = this.force($maturity)) == 'number' || (typeof $maturity == 'boolean' ? ($maturity = +$maturity, true) : false) || (typeof $maturity == 'string' && !/^(?:=|true|false)/i.test($maturity) ? (tmp = calc.parse(0, 0, 0, $maturity), /^date|number|percent$/.test(tmp.type) ? ($maturity = +tmp.value, true) : false) : false)) && ($maturity |= 0, true))) {
                    if ($maturity instanceof CalcError)
                        return $maturity;
                    return new CalcError(err);
                }
                xargs.push($maturity);
            }
            {
                var $frequency = args[i++];
                if ($frequency instanceof CalcError)
                    return $frequency;
                if (!((typeof ($frequency = this.force($frequency)) == 'number' || (typeof $frequency == 'boolean' ? ($frequency = +$frequency, true) : false) || (typeof $frequency == 'string' && !/^(?:=|true|false)/i.test($frequency) ? (tmp = calc.parse(0, 0, 0, $frequency), /^date|number|percent$/.test(tmp.type) ? ($frequency = +tmp.value, true) : false) : false)) && ($frequency |= 0, true) && ($frequency === 1 || $frequency === 2 || $frequency === 4))) {
                    if ($frequency instanceof CalcError)
                        return $frequency;
                    return new CalcError(err);
                }
                xargs.push($frequency);
            }
            {
                var $basis = args[i++];
                if ($basis instanceof CalcError)
                    return $basis;
                if (!((($basis = this.force($basis)) == null ? ($basis = 0, true) : false) || (typeof $basis == 'number' || (typeof $basis == 'boolean' ? ($basis = +$basis, true) : false) || (typeof $basis == 'string' && !/^(?:=|true|false)/i.test($basis) ? (tmp = calc.parse(0, 0, 0, $basis), /^date|number|percent$/.test(tmp.type) ? ($basis = +tmp.value, true) : false) : false)) && ($basis |= 0, true) && ($basis === 0 || $basis === 1 || $basis === 2 || $basis === 3 || $basis === 4))) {
                    if ($basis instanceof CalcError)
                        return $basis;
                    return new CalcError(err);
                }
                xargs.push($basis);
            }
            {
                if (!($settlement < $maturity ? true : (err = 'NUM', false)))
                    return new CalcError(err);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), COUPDAYBS);

    defineBuiltinFunction('COUPDAYS', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $settlement = args[i++];
                if ($settlement instanceof CalcError)
                    return $settlement;
                if (!((typeof ($settlement = this.force($settlement)) == 'number' || (typeof $settlement == 'boolean' ? ($settlement = +$settlement, true) : false) || (typeof $settlement == 'string' && !/^(?:=|true|false)/i.test($settlement) ? (tmp = calc.parse(0, 0, 0, $settlement), /^date|number|percent$/.test(tmp.type) ? ($settlement = +tmp.value, true) : false) : false)) && ($settlement |= 0, true))) {
                    if ($settlement instanceof CalcError)
                        return $settlement;
                    return new CalcError(err);
                }
                xargs.push($settlement);
            }
            {
                var $maturity = args[i++];
                if ($maturity instanceof CalcError)
                    return $maturity;
                if (!((typeof ($maturity = this.force($maturity)) == 'number' || (typeof $maturity == 'boolean' ? ($maturity = +$maturity, true) : false) || (typeof $maturity == 'string' && !/^(?:=|true|false)/i.test($maturity) ? (tmp = calc.parse(0, 0, 0, $maturity), /^date|number|percent$/.test(tmp.type) ? ($maturity = +tmp.value, true) : false) : false)) && ($maturity |= 0, true))) {
                    if ($maturity instanceof CalcError)
                        return $maturity;
                    return new CalcError(err);
                }
                xargs.push($maturity);
            }
            {
                var $frequency = args[i++];
                if ($frequency instanceof CalcError)
                    return $frequency;
                if (!((typeof ($frequency = this.force($frequency)) == 'number' || (typeof $frequency == 'boolean' ? ($frequency = +$frequency, true) : false) || (typeof $frequency == 'string' && !/^(?:=|true|false)/i.test($frequency) ? (tmp = calc.parse(0, 0, 0, $frequency), /^date|number|percent$/.test(tmp.type) ? ($frequency = +tmp.value, true) : false) : false)) && ($frequency |= 0, true) && ($frequency === 1 || $frequency === 2 || $frequency === 4))) {
                    if ($frequency instanceof CalcError)
                        return $frequency;
                    return new CalcError(err);
                }
                xargs.push($frequency);
            }
            {
                var $basis = args[i++];
                if ($basis instanceof CalcError)
                    return $basis;
                if (!((($basis = this.force($basis)) == null ? ($basis = 0, true) : false) || (typeof $basis == 'number' || (typeof $basis == 'boolean' ? ($basis = +$basis, true) : false) || (typeof $basis == 'string' && !/^(?:=|true|false)/i.test($basis) ? (tmp = calc.parse(0, 0, 0, $basis), /^date|number|percent$/.test(tmp.type) ? ($basis = +tmp.value, true) : false) : false)) && ($basis |= 0, true) && ($basis === 0 || $basis === 1 || $basis === 2 || $basis === 3 || $basis === 4))) {
                    if ($basis instanceof CalcError)
                        return $basis;
                    return new CalcError(err);
                }
                xargs.push($basis);
            }
            {
                if (!($settlement < $maturity ? true : (err = 'NUM', false)))
                    return new CalcError(err);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), COUPDAYS);

    defineBuiltinFunction('COUPDAYSNC', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $settlement = args[i++];
                if ($settlement instanceof CalcError)
                    return $settlement;
                if (!((typeof ($settlement = this.force($settlement)) == 'number' || (typeof $settlement == 'boolean' ? ($settlement = +$settlement, true) : false) || (typeof $settlement == 'string' && !/^(?:=|true|false)/i.test($settlement) ? (tmp = calc.parse(0, 0, 0, $settlement), /^date|number|percent$/.test(tmp.type) ? ($settlement = +tmp.value, true) : false) : false)) && ($settlement |= 0, true))) {
                    if ($settlement instanceof CalcError)
                        return $settlement;
                    return new CalcError(err);
                }
                xargs.push($settlement);
            }
            {
                var $maturity = args[i++];
                if ($maturity instanceof CalcError)
                    return $maturity;
                if (!((typeof ($maturity = this.force($maturity)) == 'number' || (typeof $maturity == 'boolean' ? ($maturity = +$maturity, true) : false) || (typeof $maturity == 'string' && !/^(?:=|true|false)/i.test($maturity) ? (tmp = calc.parse(0, 0, 0, $maturity), /^date|number|percent$/.test(tmp.type) ? ($maturity = +tmp.value, true) : false) : false)) && ($maturity |= 0, true))) {
                    if ($maturity instanceof CalcError)
                        return $maturity;
                    return new CalcError(err);
                }
                xargs.push($maturity);
            }
            {
                var $frequency = args[i++];
                if ($frequency instanceof CalcError)
                    return $frequency;
                if (!((typeof ($frequency = this.force($frequency)) == 'number' || (typeof $frequency == 'boolean' ? ($frequency = +$frequency, true) : false) || (typeof $frequency == 'string' && !/^(?:=|true|false)/i.test($frequency) ? (tmp = calc.parse(0, 0, 0, $frequency), /^date|number|percent$/.test(tmp.type) ? ($frequency = +tmp.value, true) : false) : false)) && ($frequency |= 0, true) && ($frequency === 1 || $frequency === 2 || $frequency === 4))) {
                    if ($frequency instanceof CalcError)
                        return $frequency;
                    return new CalcError(err);
                }
                xargs.push($frequency);
            }
            {
                var $basis = args[i++];
                if ($basis instanceof CalcError)
                    return $basis;
                if (!((($basis = this.force($basis)) == null ? ($basis = 0, true) : false) || (typeof $basis == 'number' || (typeof $basis == 'boolean' ? ($basis = +$basis, true) : false) || (typeof $basis == 'string' && !/^(?:=|true|false)/i.test($basis) ? (tmp = calc.parse(0, 0, 0, $basis), /^date|number|percent$/.test(tmp.type) ? ($basis = +tmp.value, true) : false) : false)) && ($basis |= 0, true) && ($basis === 0 || $basis === 1 || $basis === 2 || $basis === 3 || $basis === 4))) {
                    if ($basis instanceof CalcError)
                        return $basis;
                    return new CalcError(err);
                }
                xargs.push($basis);
            }
            {
                if (!($settlement < $maturity ? true : (err = 'NUM', false)))
                    return new CalcError(err);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), COUPDAYSNC);

    defineBuiltinFunction('COUPPCD', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $settlement = args[i++];
                if ($settlement instanceof CalcError)
                    return $settlement;
                if (!((typeof ($settlement = this.force($settlement)) == 'number' || (typeof $settlement == 'boolean' ? ($settlement = +$settlement, true) : false) || (typeof $settlement == 'string' && !/^(?:=|true|false)/i.test($settlement) ? (tmp = calc.parse(0, 0, 0, $settlement), /^date|number|percent$/.test(tmp.type) ? ($settlement = +tmp.value, true) : false) : false)) && ($settlement |= 0, true))) {
                    if ($settlement instanceof CalcError)
                        return $settlement;
                    return new CalcError(err);
                }
                xargs.push($settlement);
            }
            {
                var $maturity = args[i++];
                if ($maturity instanceof CalcError)
                    return $maturity;
                if (!((typeof ($maturity = this.force($maturity)) == 'number' || (typeof $maturity == 'boolean' ? ($maturity = +$maturity, true) : false) || (typeof $maturity == 'string' && !/^(?:=|true|false)/i.test($maturity) ? (tmp = calc.parse(0, 0, 0, $maturity), /^date|number|percent$/.test(tmp.type) ? ($maturity = +tmp.value, true) : false) : false)) && ($maturity |= 0, true))) {
                    if ($maturity instanceof CalcError)
                        return $maturity;
                    return new CalcError(err);
                }
                xargs.push($maturity);
            }
            {
                var $frequency = args[i++];
                if ($frequency instanceof CalcError)
                    return $frequency;
                if (!((typeof ($frequency = this.force($frequency)) == 'number' || (typeof $frequency == 'boolean' ? ($frequency = +$frequency, true) : false) || (typeof $frequency == 'string' && !/^(?:=|true|false)/i.test($frequency) ? (tmp = calc.parse(0, 0, 0, $frequency), /^date|number|percent$/.test(tmp.type) ? ($frequency = +tmp.value, true) : false) : false)) && ($frequency |= 0, true) && ($frequency === 1 || $frequency === 2 || $frequency === 4))) {
                    if ($frequency instanceof CalcError)
                        return $frequency;
                    return new CalcError(err);
                }
                xargs.push($frequency);
            }
            {
                var $basis = args[i++];
                if ($basis instanceof CalcError)
                    return $basis;
                if (!((($basis = this.force($basis)) == null ? ($basis = 0, true) : false) || (typeof $basis == 'number' || (typeof $basis == 'boolean' ? ($basis = +$basis, true) : false) || (typeof $basis == 'string' && !/^(?:=|true|false)/i.test($basis) ? (tmp = calc.parse(0, 0, 0, $basis), /^date|number|percent$/.test(tmp.type) ? ($basis = +tmp.value, true) : false) : false)) && ($basis |= 0, true) && ($basis === 0 || $basis === 1 || $basis === 2 || $basis === 3 || $basis === 4))) {
                    if ($basis instanceof CalcError)
                        return $basis;
                    return new CalcError(err);
                }
                xargs.push($basis);
            }
            {
                if (!($settlement < $maturity ? true : (err = 'NUM', false)))
                    return new CalcError(err);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), COUPPCD);

    defineBuiltinFunction('COUPNCD', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $settlement = args[i++];
                if ($settlement instanceof CalcError)
                    return $settlement;
                if (!((typeof ($settlement = this.force($settlement)) == 'number' || (typeof $settlement == 'boolean' ? ($settlement = +$settlement, true) : false) || (typeof $settlement == 'string' && !/^(?:=|true|false)/i.test($settlement) ? (tmp = calc.parse(0, 0, 0, $settlement), /^date|number|percent$/.test(tmp.type) ? ($settlement = +tmp.value, true) : false) : false)) && ($settlement |= 0, true))) {
                    if ($settlement instanceof CalcError)
                        return $settlement;
                    return new CalcError(err);
                }
                xargs.push($settlement);
            }
            {
                var $maturity = args[i++];
                if ($maturity instanceof CalcError)
                    return $maturity;
                if (!((typeof ($maturity = this.force($maturity)) == 'number' || (typeof $maturity == 'boolean' ? ($maturity = +$maturity, true) : false) || (typeof $maturity == 'string' && !/^(?:=|true|false)/i.test($maturity) ? (tmp = calc.parse(0, 0, 0, $maturity), /^date|number|percent$/.test(tmp.type) ? ($maturity = +tmp.value, true) : false) : false)) && ($maturity |= 0, true))) {
                    if ($maturity instanceof CalcError)
                        return $maturity;
                    return new CalcError(err);
                }
                xargs.push($maturity);
            }
            {
                var $frequency = args[i++];
                if ($frequency instanceof CalcError)
                    return $frequency;
                if (!((typeof ($frequency = this.force($frequency)) == 'number' || (typeof $frequency == 'boolean' ? ($frequency = +$frequency, true) : false) || (typeof $frequency == 'string' && !/^(?:=|true|false)/i.test($frequency) ? (tmp = calc.parse(0, 0, 0, $frequency), /^date|number|percent$/.test(tmp.type) ? ($frequency = +tmp.value, true) : false) : false)) && ($frequency |= 0, true) && ($frequency === 1 || $frequency === 2 || $frequency === 4))) {
                    if ($frequency instanceof CalcError)
                        return $frequency;
                    return new CalcError(err);
                }
                xargs.push($frequency);
            }
            {
                var $basis = args[i++];
                if ($basis instanceof CalcError)
                    return $basis;
                if (!((($basis = this.force($basis)) == null ? ($basis = 0, true) : false) || (typeof $basis == 'number' || (typeof $basis == 'boolean' ? ($basis = +$basis, true) : false) || (typeof $basis == 'string' && !/^(?:=|true|false)/i.test($basis) ? (tmp = calc.parse(0, 0, 0, $basis), /^date|number|percent$/.test(tmp.type) ? ($basis = +tmp.value, true) : false) : false)) && ($basis |= 0, true) && ($basis === 0 || $basis === 1 || $basis === 2 || $basis === 3 || $basis === 4))) {
                    if ($basis instanceof CalcError)
                        return $basis;
                    return new CalcError(err);
                }
                xargs.push($basis);
            }
            {
                if (!($settlement < $maturity ? true : (err = 'NUM', false)))
                    return new CalcError(err);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), COUPNCD);

    defineBuiltinFunction('COUPNUM', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $settlement = args[i++];
                if ($settlement instanceof CalcError)
                    return $settlement;
                if (!((typeof ($settlement = this.force($settlement)) == 'number' || (typeof $settlement == 'boolean' ? ($settlement = +$settlement, true) : false) || (typeof $settlement == 'string' && !/^(?:=|true|false)/i.test($settlement) ? (tmp = calc.parse(0, 0, 0, $settlement), /^date|number|percent$/.test(tmp.type) ? ($settlement = +tmp.value, true) : false) : false)) && ($settlement |= 0, true))) {
                    if ($settlement instanceof CalcError)
                        return $settlement;
                    return new CalcError(err);
                }
                xargs.push($settlement);
            }
            {
                var $maturity = args[i++];
                if ($maturity instanceof CalcError)
                    return $maturity;
                if (!((typeof ($maturity = this.force($maturity)) == 'number' || (typeof $maturity == 'boolean' ? ($maturity = +$maturity, true) : false) || (typeof $maturity == 'string' && !/^(?:=|true|false)/i.test($maturity) ? (tmp = calc.parse(0, 0, 0, $maturity), /^date|number|percent$/.test(tmp.type) ? ($maturity = +tmp.value, true) : false) : false)) && ($maturity |= 0, true))) {
                    if ($maturity instanceof CalcError)
                        return $maturity;
                    return new CalcError(err);
                }
                xargs.push($maturity);
            }
            {
                var $frequency = args[i++];
                if ($frequency instanceof CalcError)
                    return $frequency;
                if (!((typeof ($frequency = this.force($frequency)) == 'number' || (typeof $frequency == 'boolean' ? ($frequency = +$frequency, true) : false) || (typeof $frequency == 'string' && !/^(?:=|true|false)/i.test($frequency) ? (tmp = calc.parse(0, 0, 0, $frequency), /^date|number|percent$/.test(tmp.type) ? ($frequency = +tmp.value, true) : false) : false)) && ($frequency |= 0, true) && ($frequency === 1 || $frequency === 2 || $frequency === 4))) {
                    if ($frequency instanceof CalcError)
                        return $frequency;
                    return new CalcError(err);
                }
                xargs.push($frequency);
            }
            {
                var $basis = args[i++];
                if ($basis instanceof CalcError)
                    return $basis;
                if (!((($basis = this.force($basis)) == null ? ($basis = 0, true) : false) || (typeof $basis == 'number' || (typeof $basis == 'boolean' ? ($basis = +$basis, true) : false) || (typeof $basis == 'string' && !/^(?:=|true|false)/i.test($basis) ? (tmp = calc.parse(0, 0, 0, $basis), /^date|number|percent$/.test(tmp.type) ? ($basis = +tmp.value, true) : false) : false)) && ($basis |= 0, true) && ($basis === 0 || $basis === 1 || $basis === 2 || $basis === 3 || $basis === 4))) {
                    if ($basis instanceof CalcError)
                        return $basis;
                    return new CalcError(err);
                }
                xargs.push($basis);
            }
            {
                if (!($settlement < $maturity ? true : (err = 'NUM', false)))
                    return new CalcError(err);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), COUPNUM);

    defineBuiltinFunction('ACCRINTM', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $issue = args[i++];
                if ($issue instanceof CalcError)
                    return $issue;
                if (!((typeof ($issue = this.force($issue)) == 'number' || (typeof $issue == 'boolean' ? ($issue = +$issue, true) : false) || (typeof $issue == 'string' && !/^(?:=|true|false)/i.test($issue) ? (tmp = calc.parse(0, 0, 0, $issue), /^date|number|percent$/.test(tmp.type) ? ($issue = +tmp.value, true) : false) : false)) && ($issue |= 0, true))) {
                    if ($issue instanceof CalcError)
                        return $issue;
                    return new CalcError(err);
                }
                xargs.push($issue);
            }
            {
                var $settlement = args[i++];
                if ($settlement instanceof CalcError)
                    return $settlement;
                if (!((typeof ($settlement = this.force($settlement)) == 'number' || (typeof $settlement == 'boolean' ? ($settlement = +$settlement, true) : false) || (typeof $settlement == 'string' && !/^(?:=|true|false)/i.test($settlement) ? (tmp = calc.parse(0, 0, 0, $settlement), /^date|number|percent$/.test(tmp.type) ? ($settlement = +tmp.value, true) : false) : false)) && ($settlement |= 0, true))) {
                    if ($settlement instanceof CalcError)
                        return $settlement;
                    return new CalcError(err);
                }
                xargs.push($settlement);
            }
            {
                var $rate = args[i++];
                if ($rate instanceof CalcError)
                    return $rate;
                if (!(((typeof ($rate = this.force($rate)) == 'number' ? ($rate = limitPrecision($rate), true) : false) || (typeof $rate == 'boolean' ? ($rate = +$rate, true) : false) || (typeof $rate == 'string' && !/^(?:=|true|false)/i.test($rate) ? (tmp = calc.parse(0, 0, 0, $rate), /^date|number|percent$/.test(tmp.type) ? ($rate = +tmp.value, true) : false) : false)) && ($rate > 0 ? true : (err = 'NUM', false)))) {
                    if ($rate instanceof CalcError)
                        return $rate;
                    return new CalcError(err);
                }
                xargs.push($rate);
            }
            {
                var $par = args[i++];
                if ($par instanceof CalcError)
                    return $par;
                if (!((($par = this.force($par)) == null ? ($par = 1000, true) : false) || ((typeof $par == 'number' ? ($par = limitPrecision($par), true) : false) || (typeof $par == 'boolean' ? ($par = +$par, true) : false) || (typeof $par == 'string' && !/^(?:=|true|false)/i.test($par) ? (tmp = calc.parse(0, 0, 0, $par), /^date|number|percent$/.test(tmp.type) ? ($par = +tmp.value, true) : false) : false)) && ($par > 0 ? true : (err = 'NUM', false)))) {
                    if ($par instanceof CalcError)
                        return $par;
                    return new CalcError(err);
                }
                xargs.push($par);
            }
            {
                var $basis = args[i++];
                if ($basis instanceof CalcError)
                    return $basis;
                if (!((($basis = this.force($basis)) == null ? ($basis = 0, true) : false) || (typeof $basis == 'number' || (typeof $basis == 'boolean' ? ($basis = +$basis, true) : false) || (typeof $basis == 'string' && !/^(?:=|true|false)/i.test($basis) ? (tmp = calc.parse(0, 0, 0, $basis), /^date|number|percent$/.test(tmp.type) ? ($basis = +tmp.value, true) : false) : false)) && ($basis |= 0, true) && ($basis === 0 || $basis === 1 || $basis === 2 || $basis === 3 || $basis === 4))) {
                    if ($basis instanceof CalcError)
                        return $basis;
                    return new CalcError(err);
                }
                xargs.push($basis);
            }
            {
                if (!($issue < $settlement ? true : (err = 'NUM', false)))
                    return new CalcError(err);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), ACCRINTM);

    defineBuiltinFunction('ACCRINT', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $issue = args[i++];
                if ($issue instanceof CalcError)
                    return $issue;
                if (!((typeof ($issue = this.force($issue)) == 'number' || (typeof $issue == 'boolean' ? ($issue = +$issue, true) : false) || (typeof $issue == 'string' && !/^(?:=|true|false)/i.test($issue) ? (tmp = calc.parse(0, 0, 0, $issue), /^date|number|percent$/.test(tmp.type) ? ($issue = +tmp.value, true) : false) : false)) && ($issue |= 0, true))) {
                    if ($issue instanceof CalcError)
                        return $issue;
                    return new CalcError(err);
                }
                xargs.push($issue);
            }
            {
                var $first_interest = args[i++];
                if ($first_interest instanceof CalcError)
                    return $first_interest;
                if (!((typeof ($first_interest = this.force($first_interest)) == 'number' || (typeof $first_interest == 'boolean' ? ($first_interest = +$first_interest, true) : false) || (typeof $first_interest == 'string' && !/^(?:=|true|false)/i.test($first_interest) ? (tmp = calc.parse(0, 0, 0, $first_interest), /^date|number|percent$/.test(tmp.type) ? ($first_interest = +tmp.value, true) : false) : false)) && ($first_interest |= 0, true))) {
                    if ($first_interest instanceof CalcError)
                        return $first_interest;
                    return new CalcError(err);
                }
                xargs.push($first_interest);
            }
            {
                var $settlement = args[i++];
                if ($settlement instanceof CalcError)
                    return $settlement;
                if (!((typeof ($settlement = this.force($settlement)) == 'number' || (typeof $settlement == 'boolean' ? ($settlement = +$settlement, true) : false) || (typeof $settlement == 'string' && !/^(?:=|true|false)/i.test($settlement) ? (tmp = calc.parse(0, 0, 0, $settlement), /^date|number|percent$/.test(tmp.type) ? ($settlement = +tmp.value, true) : false) : false)) && ($settlement |= 0, true))) {
                    if ($settlement instanceof CalcError)
                        return $settlement;
                    return new CalcError(err);
                }
                xargs.push($settlement);
            }
            {
                var $rate = args[i++];
                if ($rate instanceof CalcError)
                    return $rate;
                if (!(((typeof ($rate = this.force($rate)) == 'number' ? ($rate = limitPrecision($rate), true) : false) || (typeof $rate == 'boolean' ? ($rate = +$rate, true) : false) || (typeof $rate == 'string' && !/^(?:=|true|false)/i.test($rate) ? (tmp = calc.parse(0, 0, 0, $rate), /^date|number|percent$/.test(tmp.type) ? ($rate = +tmp.value, true) : false) : false)) && ($rate > 0 ? true : (err = 'NUM', false)))) {
                    if ($rate instanceof CalcError)
                        return $rate;
                    return new CalcError(err);
                }
                xargs.push($rate);
            }
            {
                var $par = args[i++];
                if ($par instanceof CalcError)
                    return $par;
                if (!((($par = this.force($par)) == null ? ($par = 1000, true) : false) || ((typeof $par == 'number' ? ($par = limitPrecision($par), true) : false) || (typeof $par == 'boolean' ? ($par = +$par, true) : false) || (typeof $par == 'string' && !/^(?:=|true|false)/i.test($par) ? (tmp = calc.parse(0, 0, 0, $par), /^date|number|percent$/.test(tmp.type) ? ($par = +tmp.value, true) : false) : false)) && ($par > 0 ? true : (err = 'NUM', false)))) {
                    if ($par instanceof CalcError)
                        return $par;
                    return new CalcError(err);
                }
                xargs.push($par);
            }
            {
                var $frequency = args[i++];
                if ($frequency instanceof CalcError)
                    return $frequency;
                if (!((typeof ($frequency = this.force($frequency)) == 'number' || (typeof $frequency == 'boolean' ? ($frequency = +$frequency, true) : false) || (typeof $frequency == 'string' && !/^(?:=|true|false)/i.test($frequency) ? (tmp = calc.parse(0, 0, 0, $frequency), /^date|number|percent$/.test(tmp.type) ? ($frequency = +tmp.value, true) : false) : false)) && ($frequency |= 0, true) && ($frequency === 1 || $frequency === 2 || $frequency === 4))) {
                    if ($frequency instanceof CalcError)
                        return $frequency;
                    return new CalcError(err);
                }
                xargs.push($frequency);
            }
            {
                var $basis = args[i++];
                if ($basis instanceof CalcError)
                    return $basis;
                if (!((($basis = this.force($basis)) == null ? ($basis = 0, true) : false) || (typeof $basis == 'number' || (typeof $basis == 'boolean' ? ($basis = +$basis, true) : false) || (typeof $basis == 'string' && !/^(?:=|true|false)/i.test($basis) ? (tmp = calc.parse(0, 0, 0, $basis), /^date|number|percent$/.test(tmp.type) ? ($basis = +tmp.value, true) : false) : false)) && ($basis |= 0, true) && ($basis === 0 || $basis === 1 || $basis === 2 || $basis === 3 || $basis === 4))) {
                    if ($basis instanceof CalcError)
                        return $basis;
                    return new CalcError(err);
                }
                xargs.push($basis);
            }
            {
                var $calc_method = args[i++];
                if ($calc_method instanceof CalcError)
                    return $calc_method;
                if (!(typeof ($calc_method = this.force($calc_method)) == 'boolean' || (typeof $calc_method == 'number' ? ($calc_method = !!$calc_method, true) : false) || ($calc_method == null ? ($calc_method = true, true) : false))) {
                    if ($calc_method instanceof CalcError)
                        return $calc_method;
                    return new CalcError(err);
                }
                xargs.push($calc_method);
            }
            {
                if (!($issue < $settlement ? true : (err = 'NUM', false)))
                    return new CalcError(err);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), ACCRINT);

    defineBuiltinFunction('DISC', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $settlement = args[i++];
                if ($settlement instanceof CalcError)
                    return $settlement;
                if (!((typeof ($settlement = this.force($settlement)) == 'number' || (typeof $settlement == 'boolean' ? ($settlement = +$settlement, true) : false) || (typeof $settlement == 'string' && !/^(?:=|true|false)/i.test($settlement) ? (tmp = calc.parse(0, 0, 0, $settlement), /^date|number|percent$/.test(tmp.type) ? ($settlement = +tmp.value, true) : false) : false)) && ($settlement |= 0, true))) {
                    if ($settlement instanceof CalcError)
                        return $settlement;
                    return new CalcError(err);
                }
                xargs.push($settlement);
            }
            {
                var $maturity = args[i++];
                if ($maturity instanceof CalcError)
                    return $maturity;
                if (!((typeof ($maturity = this.force($maturity)) == 'number' || (typeof $maturity == 'boolean' ? ($maturity = +$maturity, true) : false) || (typeof $maturity == 'string' && !/^(?:=|true|false)/i.test($maturity) ? (tmp = calc.parse(0, 0, 0, $maturity), /^date|number|percent$/.test(tmp.type) ? ($maturity = +tmp.value, true) : false) : false)) && ($maturity |= 0, true))) {
                    if ($maturity instanceof CalcError)
                        return $maturity;
                    return new CalcError(err);
                }
                xargs.push($maturity);
            }
            {
                var $pr = args[i++];
                if ($pr instanceof CalcError)
                    return $pr;
                if (!(((typeof ($pr = this.force($pr)) == 'number' ? ($pr = limitPrecision($pr), true) : false) || (typeof $pr == 'boolean' ? ($pr = +$pr, true) : false) || (typeof $pr == 'string' && !/^(?:=|true|false)/i.test($pr) ? (tmp = calc.parse(0, 0, 0, $pr), /^date|number|percent$/.test(tmp.type) ? ($pr = +tmp.value, true) : false) : false)) && ($pr > 0 ? true : (err = 'NUM', false)))) {
                    if ($pr instanceof CalcError)
                        return $pr;
                    return new CalcError(err);
                }
                xargs.push($pr);
            }
            {
                var $redemption = args[i++];
                if ($redemption instanceof CalcError)
                    return $redemption;
                if (!(((typeof ($redemption = this.force($redemption)) == 'number' ? ($redemption = limitPrecision($redemption), true) : false) || (typeof $redemption == 'boolean' ? ($redemption = +$redemption, true) : false) || (typeof $redemption == 'string' && !/^(?:=|true|false)/i.test($redemption) ? (tmp = calc.parse(0, 0, 0, $redemption), /^date|number|percent$/.test(tmp.type) ? ($redemption = +tmp.value, true) : false) : false)) && ($redemption > 0 ? true : (err = 'NUM', false)))) {
                    if ($redemption instanceof CalcError)
                        return $redemption;
                    return new CalcError(err);
                }
                xargs.push($redemption);
            }
            {
                var $basis = args[i++];
                if ($basis instanceof CalcError)
                    return $basis;
                if (!((($basis = this.force($basis)) == null ? ($basis = 0, true) : false) || (typeof $basis == 'number' || (typeof $basis == 'boolean' ? ($basis = +$basis, true) : false) || (typeof $basis == 'string' && !/^(?:=|true|false)/i.test($basis) ? (tmp = calc.parse(0, 0, 0, $basis), /^date|number|percent$/.test(tmp.type) ? ($basis = +tmp.value, true) : false) : false)) && ($basis |= 0, true) && ($basis === 0 || $basis === 1 || $basis === 2 || $basis === 3 || $basis === 4))) {
                    if ($basis instanceof CalcError)
                        return $basis;
                    return new CalcError(err);
                }
                xargs.push($basis);
            }
            {
                if (!($settlement < $maturity ? true : (err = 'NUM', false)))
                    return new CalcError(err);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), DISC);

    defineBuiltinFunction('INTRATE', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $settlement = args[i++];
                if ($settlement instanceof CalcError)
                    return $settlement;
                if (!((typeof ($settlement = this.force($settlement)) == 'number' || (typeof $settlement == 'boolean' ? ($settlement = +$settlement, true) : false) || (typeof $settlement == 'string' && !/^(?:=|true|false)/i.test($settlement) ? (tmp = calc.parse(0, 0, 0, $settlement), /^date|number|percent$/.test(tmp.type) ? ($settlement = +tmp.value, true) : false) : false)) && ($settlement |= 0, true))) {
                    if ($settlement instanceof CalcError)
                        return $settlement;
                    return new CalcError(err);
                }
                xargs.push($settlement);
            }
            {
                var $maturity = args[i++];
                if ($maturity instanceof CalcError)
                    return $maturity;
                if (!((typeof ($maturity = this.force($maturity)) == 'number' || (typeof $maturity == 'boolean' ? ($maturity = +$maturity, true) : false) || (typeof $maturity == 'string' && !/^(?:=|true|false)/i.test($maturity) ? (tmp = calc.parse(0, 0, 0, $maturity), /^date|number|percent$/.test(tmp.type) ? ($maturity = +tmp.value, true) : false) : false)) && ($maturity |= 0, true))) {
                    if ($maturity instanceof CalcError)
                        return $maturity;
                    return new CalcError(err);
                }
                xargs.push($maturity);
            }
            {
                var $investment = args[i++];
                if ($investment instanceof CalcError)
                    return $investment;
                if (!(((typeof ($investment = this.force($investment)) == 'number' ? ($investment = limitPrecision($investment), true) : false) || (typeof $investment == 'boolean' ? ($investment = +$investment, true) : false) || (typeof $investment == 'string' && !/^(?:=|true|false)/i.test($investment) ? (tmp = calc.parse(0, 0, 0, $investment), /^date|number|percent$/.test(tmp.type) ? ($investment = +tmp.value, true) : false) : false)) && ($investment > 0 ? true : (err = 'NUM', false)))) {
                    if ($investment instanceof CalcError)
                        return $investment;
                    return new CalcError(err);
                }
                xargs.push($investment);
            }
            {
                var $redemption = args[i++];
                if ($redemption instanceof CalcError)
                    return $redemption;
                if (!(((typeof ($redemption = this.force($redemption)) == 'number' ? ($redemption = limitPrecision($redemption), true) : false) || (typeof $redemption == 'boolean' ? ($redemption = +$redemption, true) : false) || (typeof $redemption == 'string' && !/^(?:=|true|false)/i.test($redemption) ? (tmp = calc.parse(0, 0, 0, $redemption), /^date|number|percent$/.test(tmp.type) ? ($redemption = +tmp.value, true) : false) : false)) && ($redemption > 0 ? true : (err = 'NUM', false)))) {
                    if ($redemption instanceof CalcError)
                        return $redemption;
                    return new CalcError(err);
                }
                xargs.push($redemption);
            }
            {
                var $basis = args[i++];
                if ($basis instanceof CalcError)
                    return $basis;
                if (!((($basis = this.force($basis)) == null ? ($basis = 0, true) : false) || (typeof $basis == 'number' || (typeof $basis == 'boolean' ? ($basis = +$basis, true) : false) || (typeof $basis == 'string' && !/^(?:=|true|false)/i.test($basis) ? (tmp = calc.parse(0, 0, 0, $basis), /^date|number|percent$/.test(tmp.type) ? ($basis = +tmp.value, true) : false) : false)) && ($basis |= 0, true) && ($basis === 0 || $basis === 1 || $basis === 2 || $basis === 3 || $basis === 4))) {
                    if ($basis instanceof CalcError)
                        return $basis;
                    return new CalcError(err);
                }
                xargs.push($basis);
            }
            {
                if (!($settlement < $maturity ? true : (err = 'NUM', false)))
                    return new CalcError(err);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), INTRATE);

    defineBuiltinFunction('RECEIVED', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $settlement = args[i++];
                if ($settlement instanceof CalcError)
                    return $settlement;
                if (!((typeof ($settlement = this.force($settlement)) == 'number' || (typeof $settlement == 'boolean' ? ($settlement = +$settlement, true) : false) || (typeof $settlement == 'string' && !/^(?:=|true|false)/i.test($settlement) ? (tmp = calc.parse(0, 0, 0, $settlement), /^date|number|percent$/.test(tmp.type) ? ($settlement = +tmp.value, true) : false) : false)) && ($settlement |= 0, true))) {
                    if ($settlement instanceof CalcError)
                        return $settlement;
                    return new CalcError(err);
                }
                xargs.push($settlement);
            }
            {
                var $maturity = args[i++];
                if ($maturity instanceof CalcError)
                    return $maturity;
                if (!((typeof ($maturity = this.force($maturity)) == 'number' || (typeof $maturity == 'boolean' ? ($maturity = +$maturity, true) : false) || (typeof $maturity == 'string' && !/^(?:=|true|false)/i.test($maturity) ? (tmp = calc.parse(0, 0, 0, $maturity), /^date|number|percent$/.test(tmp.type) ? ($maturity = +tmp.value, true) : false) : false)) && ($maturity |= 0, true))) {
                    if ($maturity instanceof CalcError)
                        return $maturity;
                    return new CalcError(err);
                }
                xargs.push($maturity);
            }
            {
                var $investment = args[i++];
                if ($investment instanceof CalcError)
                    return $investment;
                if (!(((typeof ($investment = this.force($investment)) == 'number' ? ($investment = limitPrecision($investment), true) : false) || (typeof $investment == 'boolean' ? ($investment = +$investment, true) : false) || (typeof $investment == 'string' && !/^(?:=|true|false)/i.test($investment) ? (tmp = calc.parse(0, 0, 0, $investment), /^date|number|percent$/.test(tmp.type) ? ($investment = +tmp.value, true) : false) : false)) && ($investment > 0 ? true : (err = 'NUM', false)))) {
                    if ($investment instanceof CalcError)
                        return $investment;
                    return new CalcError(err);
                }
                xargs.push($investment);
            }
            {
                var $discount = args[i++];
                if ($discount instanceof CalcError)
                    return $discount;
                if (!(((typeof ($discount = this.force($discount)) == 'number' ? ($discount = limitPrecision($discount), true) : false) || (typeof $discount == 'boolean' ? ($discount = +$discount, true) : false) || (typeof $discount == 'string' && !/^(?:=|true|false)/i.test($discount) ? (tmp = calc.parse(0, 0, 0, $discount), /^date|number|percent$/.test(tmp.type) ? ($discount = +tmp.value, true) : false) : false)) && ($discount > 0 ? true : (err = 'NUM', false)))) {
                    if ($discount instanceof CalcError)
                        return $discount;
                    return new CalcError(err);
                }
                xargs.push($discount);
            }
            {
                var $basis = args[i++];
                if ($basis instanceof CalcError)
                    return $basis;
                if (!((($basis = this.force($basis)) == null ? ($basis = 0, true) : false) || (typeof $basis == 'number' || (typeof $basis == 'boolean' ? ($basis = +$basis, true) : false) || (typeof $basis == 'string' && !/^(?:=|true|false)/i.test($basis) ? (tmp = calc.parse(0, 0, 0, $basis), /^date|number|percent$/.test(tmp.type) ? ($basis = +tmp.value, true) : false) : false)) && ($basis |= 0, true) && ($basis === 0 || $basis === 1 || $basis === 2 || $basis === 3 || $basis === 4))) {
                    if ($basis instanceof CalcError)
                        return $basis;
                    return new CalcError(err);
                }
                xargs.push($basis);
            }
            {
                if (!($settlement < $maturity ? true : (err = 'NUM', false)))
                    return new CalcError(err);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), RECEIVED);

    defineBuiltinFunction('PRICE', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $settlement = args[i++];
                if ($settlement instanceof CalcError)
                    return $settlement;
                if (!((typeof ($settlement = this.force($settlement)) == 'number' || (typeof $settlement == 'boolean' ? ($settlement = +$settlement, true) : false) || (typeof $settlement == 'string' && !/^(?:=|true|false)/i.test($settlement) ? (tmp = calc.parse(0, 0, 0, $settlement), /^date|number|percent$/.test(tmp.type) ? ($settlement = +tmp.value, true) : false) : false)) && ($settlement |= 0, true))) {
                    if ($settlement instanceof CalcError)
                        return $settlement;
                    return new CalcError(err);
                }
                xargs.push($settlement);
            }
            {
                var $maturity = args[i++];
                if ($maturity instanceof CalcError)
                    return $maturity;
                if (!((typeof ($maturity = this.force($maturity)) == 'number' || (typeof $maturity == 'boolean' ? ($maturity = +$maturity, true) : false) || (typeof $maturity == 'string' && !/^(?:=|true|false)/i.test($maturity) ? (tmp = calc.parse(0, 0, 0, $maturity), /^date|number|percent$/.test(tmp.type) ? ($maturity = +tmp.value, true) : false) : false)) && ($maturity |= 0, true))) {
                    if ($maturity instanceof CalcError)
                        return $maturity;
                    return new CalcError(err);
                }
                xargs.push($maturity);
            }
            {
                var $rate = args[i++];
                if ($rate instanceof CalcError)
                    return $rate;
                if (!(((typeof ($rate = this.force($rate)) == 'number' ? ($rate = limitPrecision($rate), true) : false) || (typeof $rate == 'boolean' ? ($rate = +$rate, true) : false) || (typeof $rate == 'string' && !/^(?:=|true|false)/i.test($rate) ? (tmp = calc.parse(0, 0, 0, $rate), /^date|number|percent$/.test(tmp.type) ? ($rate = +tmp.value, true) : false) : false)) && ($rate > 0 ? true : (err = 'NUM', false)))) {
                    if ($rate instanceof CalcError)
                        return $rate;
                    return new CalcError(err);
                }
                xargs.push($rate);
            }
            {
                var $yld = args[i++];
                if ($yld instanceof CalcError)
                    return $yld;
                if (!(((typeof ($yld = this.force($yld)) == 'number' ? ($yld = limitPrecision($yld), true) : false) || (typeof $yld == 'boolean' ? ($yld = +$yld, true) : false) || (typeof $yld == 'string' && !/^(?:=|true|false)/i.test($yld) ? (tmp = calc.parse(0, 0, 0, $yld), /^date|number|percent$/.test(tmp.type) ? ($yld = +tmp.value, true) : false) : false)) && ($yld > 0 ? true : (err = 'NUM', false)))) {
                    if ($yld instanceof CalcError)
                        return $yld;
                    return new CalcError(err);
                }
                xargs.push($yld);
            }
            {
                var $redemption = args[i++];
                if ($redemption instanceof CalcError)
                    return $redemption;
                if (!(((typeof ($redemption = this.force($redemption)) == 'number' ? ($redemption = limitPrecision($redemption), true) : false) || (typeof $redemption == 'boolean' ? ($redemption = +$redemption, true) : false) || (typeof $redemption == 'string' && !/^(?:=|true|false)/i.test($redemption) ? (tmp = calc.parse(0, 0, 0, $redemption), /^date|number|percent$/.test(tmp.type) ? ($redemption = +tmp.value, true) : false) : false)) && ($redemption > 0 ? true : (err = 'NUM', false)))) {
                    if ($redemption instanceof CalcError)
                        return $redemption;
                    return new CalcError(err);
                }
                xargs.push($redemption);
            }
            {
                var $frequency = args[i++];
                if ($frequency instanceof CalcError)
                    return $frequency;
                if (!((typeof ($frequency = this.force($frequency)) == 'number' || (typeof $frequency == 'boolean' ? ($frequency = +$frequency, true) : false) || (typeof $frequency == 'string' && !/^(?:=|true|false)/i.test($frequency) ? (tmp = calc.parse(0, 0, 0, $frequency), /^date|number|percent$/.test(tmp.type) ? ($frequency = +tmp.value, true) : false) : false)) && ($frequency |= 0, true) && ($frequency === 1 || $frequency === 2 || $frequency === 4))) {
                    if ($frequency instanceof CalcError)
                        return $frequency;
                    return new CalcError(err);
                }
                xargs.push($frequency);
            }
            {
                var $basis = args[i++];
                if ($basis instanceof CalcError)
                    return $basis;
                if (!((($basis = this.force($basis)) == null ? ($basis = 0, true) : false) || (typeof $basis == 'number' || (typeof $basis == 'boolean' ? ($basis = +$basis, true) : false) || (typeof $basis == 'string' && !/^(?:=|true|false)/i.test($basis) ? (tmp = calc.parse(0, 0, 0, $basis), /^date|number|percent$/.test(tmp.type) ? ($basis = +tmp.value, true) : false) : false)) && ($basis |= 0, true) && ($basis === 0 || $basis === 1 || $basis === 2 || $basis === 3 || $basis === 4))) {
                    if ($basis instanceof CalcError)
                        return $basis;
                    return new CalcError(err);
                }
                xargs.push($basis);
            }
            {
                if (!($settlement < $maturity ? true : (err = 'NUM', false)))
                    return new CalcError(err);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), PRICE);

    defineBuiltinFunction('PRICEDISC', false, function () {
        function check(args) {
            var tmp, xargs = [], i = 0, err = 'VALUE';
            {
                var $settlement = args[i++];
                if ($settlement instanceof CalcError)
                    return $settlement;
                if (!((typeof ($settlement = this.force($settlement)) == 'number' || (typeof $settlement == 'boolean' ? ($settlement = +$settlement, true) : false) || (typeof $settlement == 'string' && !/^(?:=|true|false)/i.test($settlement) ? (tmp = calc.parse(0, 0, 0, $settlement), /^date|number|percent$/.test(tmp.type) ? ($settlement = +tmp.value, true) : false) : false)) && ($settlement |= 0, true))) {
                    if ($settlement instanceof CalcError)
                        return $settlement;
                    return new CalcError(err);
                }
                xargs.push($settlement);
            }
            {
                var $maturity = args[i++];
                if ($maturity instanceof CalcError)
                    return $maturity;
                if (!((typeof ($maturity = this.force($maturity)) == 'number' || (typeof $maturity == 'boolean' ? ($maturity = +$maturity, true) : false) || (typeof $maturity == 'string' && !/^(?:=|true|false)/i.test($maturity) ? (tmp = calc.parse(0, 0, 0, $maturity), /^date|number|percent$/.test(tmp.type) ? ($maturity = +tmp.value, true) : false) : false)) && ($maturity |= 0, true))) {
                    if ($maturity instanceof CalcError)
                        return $maturity;
                    return new CalcError(err);
                }
                xargs.push($maturity);
            }
            {
                var $discount = args[i++];
                if ($discount instanceof CalcError)
                    return $discount;
                if (!(((typeof ($discount = this.force($discount)) == 'number' ? ($discount = limitPrecision($discount), true) : false) || (typeof $discount == 'boolean' ? ($discount = +$discount, true) : false) || (typeof $discount == 'string' && !/^(?:=|true|false)/i.test($discount) ? (tmp = calc.parse(0, 0, 0, $discount), /^date|number|percent$/.test(tmp.type) ? ($discount = +tmp.value, true) : false) : false)) && ($discount > 0 ? true : (err = 'NUM', false)))) {
                    if ($discount instanceof CalcError)
                        return $discount;
                    return new CalcError(err);
                }
                xargs.push($discount);
            }
            {
                var $redemption = args[i++];
                if ($redemption instanceof CalcError)
                    return $redemption;
                if (!(((typeof ($redemption = this.force($redemption)) == 'number' ? ($redemption = limitPrecision($redemption), true) : false) || (typeof $redemption == 'boolean' ? ($redemption = +$redemption, true) : false) || (typeof $redemption == 'string' && !/^(?:=|true|false)/i.test($redemption) ? (tmp = calc.parse(0, 0, 0, $redemption), /^date|number|percent$/.test(tmp.type) ? ($redemption = +tmp.value, true) : false) : false)) && ($redemption > 0 ? true : (err = 'NUM', false)))) {
                    if ($redemption instanceof CalcError)
                        return $redemption;
                    return new CalcError(err);
                }
                xargs.push($redemption);
            }
            {
                var $basis = args[i++];
                if ($basis instanceof CalcError)
                    return $basis;
                if (!((($basis = this.force($basis)) == null ? ($basis = 0, true) : false) || (typeof $basis == 'number' || (typeof $basis == 'boolean' ? ($basis = +$basis, true) : false) || (typeof $basis == 'string' && !/^(?:=|true|false)/i.test($basis) ? (tmp = calc.parse(0, 0, 0, $basis), /^date|number|percent$/.test(tmp.type) ? ($basis = +tmp.value, true) : false) : false)) && ($basis |= 0, true) && ($basis === 0 || $basis === 1 || $basis === 2 || $basis === 3 || $basis === 4))) {
                    if ($basis instanceof CalcError)
                        return $basis;
                    return new CalcError(err);
                }
                xargs.push($basis);
            }
            {
                if (!($settlement < $maturity ? true : (err = 'NUM', false)))
                    return new CalcError(err);
            }
            if (i < args.length)
                return new CalcError('N/A');
            return xargs;
        }
        function resolve(args, callback) {
            var toResolve = [], i = 0;
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            toResolve.push(args[i++]);
            this.resolveCells(toResolve, callback);
        }
        return {
            check: check,
            resolve: resolve
        };
    }(), PRICEDISC);

    /* -----[ utils ]----- */

    // function resultAsMatrix(f) {
    //     return function() {
    //         var a = f.apply(this, arguments);
    //         return this.asMatrix(a);
    //     };
    // }

    /* -----[ definitions: statistical functions ]----- */

    var MAX_IT = 300,     // Maximum allowed number of iterations
        EPS = 2.2204e-16, // Relative accuracy; 1-3*(4/3-1) = 2.220446049250313e-16
        FP_MIN = 1.0e-30, // Near the smallest representable as floating-point, number.
        f_abs = Math.abs;

    function ERF(x) {
        if (f_abs(x) >= 3.3) {
            return 1 - ERFC(x);
        }
        var S = x > 0 ? 1 : -1;
        if (S == -1) {
            x = -x;
        }
        var m = 0, an = 1;
        for (var n = 1; n < 100; n++) {
            m += an;
            an *= 2*x*x/(2*n+1);
        }
        return S*2/Math.sqrt(Math.PI)*x*Math.exp(-x*x)*m;
    }

    function ERFC(x) {
        if (f_abs(x) < 3.3) {
            return 1 - ERF(x);
        }
        var s = 1;
        if (x < 0) {
            s = -1;
            x = -x;
        }
        var frac = x;
        for (var n = 8; n >= 1; n -= 0.5) {
            frac = x + n/frac;
        }
        frac = 1 / (x + frac);
        return s == 1
            ? Math.exp(-x*x)/Math.sqrt(Math.PI)*frac
            : 2 - Math.exp(-x*x)/Math.sqrt(Math.PI)*frac;
    }

    function GAMMALN(x) { // Returns the value ln[Γ(x)] for x > 0.
        var cof = [
            1.000000000190015, 76.18009172947146, -86.50532032941677,
            24.01409824083091, -1.231739572450155, 0.1208650973866179e-2, -0.5395239384953e-5
        ];
        var y = x, tmp = x + 5.5, ser = cof[0];
        tmp -= (x + 0.5) * Math.log(tmp);
        for (var j = 1; j <= 6; j++) {
            y += 1;
            ser += cof[j] / y;
        }
        return -tmp + Math.log(Math.sqrt(2*Math.PI) * ser / x); // log(Γ(x)) = log(Γ(x+1)) - log(x)
    }

    function GAMMA(x) { // returns Infinity for 0 or negative _integer argument.
        if (x > 0) {
            return Math.exp(GAMMALN(x));
        }
        var pi = Math.PI, y = -x; // For x<0 we use the reflection formula: Γ(x)Γ(1-x) = PI / sin(PI*x)
        return -pi / (y*GAMMA(y)*Math.sin(pi*y));
    }

    function BETALN(a, b) {
        return GAMMALN(a) + GAMMALN(b) - GAMMALN(a+b);
    }

    function BETA(a, b) {
        return Math.exp(BETALN(a, b));
    }

    function gamma_inc(a, x) { // returns the normalized incomplete gamma function P(a, x); x > 0.
        return x < a+1.0 ? g_series(a, x) : 1 - g_contfrac(a, x);
    }

    function g_series(a, x) { // evaluate P(a, x) by its series representation (converges quickly for x < a+1).
        var sum = 1/a,
            frac = sum,
            ap = a;
        var gln = GAMMALN(a), n;
        for (n = 1; n <= MAX_IT; n++) {
            ap++;
            frac *= x/ap;
            sum += frac;
            if (f_abs(frac) < f_abs(sum)*EPS) {
                break; // already the last frac is too small versus the current sum value
            }
        }
        return sum * Math.exp(-x + a*Math.log(x) - gln); // e^{-x} * x^a * Γ(a) * sum
    }

    function g_contfrac(a, x) { // Q(a, x) by its continued fraction representation (converges quickly for x > a + 1); modified Lentz’s method (Numerical Recipes (The Art of Scientific Computing), 2rd Edition $5.2)
        var f = FP_MIN, c = f, d = 0, aj = 1, bj = x + 1 - a;
        var gln = GAMMALN(a);
        for (var i = 1; i <= MAX_IT; i++) {
            d = bj + aj * d;
            if (f_abs(d) < FP_MIN) {
                d = FP_MIN;
            }
            c = bj + aj / c;
            if (f_abs(c) < FP_MIN) {
                c = FP_MIN;
            }
            d = 1 / d;
            var delta = c * d;
            f *= delta;
            if (f_abs(delta - 1) < EPS) {
                break;
            }
            bj += 2;
            aj = -i * (i - a);
        }
        return f * Math.exp(-x - gln + a * Math.log(x));
    }

    function GAMMA_DIST(x, a, b, cumulative) { // a > 0, b > 0; x >= 0
        if (!cumulative) {
            return Math.pow(x/b, a-1)*Math.exp(-x/b)/(b*GAMMA(a)); // the PDF of the Gamma distribution
        }
        return gamma_inc(a, x/b); // (else) compute the CDF (using the incomplete Gamma function)
    }

    function GAMMA_INV(p, a, b) { // the quantile function of the Gamma distribution
        if (p === 0) {
            return 0;
        }
        if (p == 1) {
            return Infinity;
        }
        var m = 0, M = 10, x = 0, ab = a*b;
        if (ab > 1) {
            M *= ab;
        }
        for (var i = 0; i < MAX_IT; i++) {
            x = 0.5*(m + M); // console.log(x);
            var q = GAMMA_DIST(x, a, b, true);
            if (f_abs(p - q) < 1e-16) {
                break;
            }
            if (q > p) {
                M = x;
            } else {
                m = x;
            }
        }
        return x;
    }

    function NORM_S_DIST(x, cumulative) {
        if (!cumulative) {
            return Math.exp(-x*x/2)/Math.sqrt(2*Math.PI);
        }
        return 0.5 + 0.5*ERF(x/Math.sqrt(2));
    }

    function NORM_S_INV(p) { // see [1] $26.2.3 and http://home.online.no/~pjacklam/notes/invnorm/#References
        // Coefficients in rational approximations.
        var a = [-3.969683028665376e+01, 2.209460984245205e+02,
                 -2.759285104469687e+02, 1.383577518672690e+02,
                 -3.066479806614716e+01, 2.506628277459239e+00],
            b = [-5.447609879822406e+01, 1.615858368580409e+02,
                 -1.556989798598866e+02, 6.680131188771972e+01,
                 -1.328068155288572e+01],
            c = [-7.784894002430293e-03, -3.223964580411365e-01,
                 -2.400758277161838e+00, -2.549732539343734e+00,
                 4.374664141464968e+00, 2.938163982698783e+00],
            d = [ 7.784695709041462e-03, 3.224671290700398e-01,
                  2.445134137142996e+00, 3.754408661907416e+00];
        // Define break-points.
        var plow = 0.02425,
            phigh = 1 - plow;
        var q, r;
        // Rational approximation for lower region:
        if (p < plow) {
            q = Math.sqrt(-2*Math.log(p));
            return (((((c[0]*q+c[1])*q+c[2])*q+c[3])*q+c[4])*q+c[5]) / ((((d[0]*q+d[1])*q+d[2])*q+d[3])*q+1);
        }
        // Rational approximation for upper region:
        if (phigh < p) {
            q = Math.sqrt(-2*Math.log(1-p));
            return -(((((c[0]*q+c[1])*q+c[2])*q+c[3])*q+c[4])*q+c[5]) / ((((d[0]*q+d[1])*q+d[2])*q+d[3])*q+1);
        }
        // Rational approximation for central region:
        q = p - 0.5;
        r = q*q;
        return (((((a[0]*r+a[1])*r+a[2])*r+a[3])*r+a[4])*r+a[5])*q / (((((b[0]*r+b[1])*r+b[2])*r+b[3])*r+b[4])*r+1);
    }

    function NORM_DIST(x, m, s, cumulative) {
        if (!cumulative) {
            return Math.exp(-(x-m)*(x-m)/(2*s*s))/(s*Math.sqrt(2*Math.PI)); // NORM_S_DIST((x-m)/s)/s;
        }
        return NORM_S_DIST((x-m)/s, true);
    }

    function NORM_INV(p, m, s) {
        return m + s*NORM_S_INV(p);
    }

    function betastd_pdf(x, a, b) {
        return Math.exp((a-1)*Math.log(x) + (b-1)*Math.log(1-x) - BETALN(a, b));
    }

    function betastd_cdf(x, a, b) {
        var k = Math.exp(a*Math.log(x) + b*Math.log(1-x) - BETALN(a, b));
        return x < (a+1)/(a+b+2) ? k*beta_lentz(a, b, x)/a : 1 - k*beta_lentz(b, a, 1-x)/b;
    }

    function beta_lentz(a, b, x) { // estimates continued fraction by modified Lentz’s method ([2] $8.17.22)
        var m, m2;
        var aa, c, d, del, h, qab, qam, qap;
        qab = a + b; // These q’s will be used in factors that occur in the coefficients d_n
        qap = a + 1;
        qam = a - 1;
        c = 1; // First step of Lentz’s method.
        d = 1 - qab * x / qap;
        if (f_abs(d) < FP_MIN) {
            d = FP_MIN;
        }
        d = 1/d;
        h = d;
        for (m = 1; m <= MAX_IT; m++) {
            m2 = 2*m;
            aa = m*(b - m)*x / ((qam + m2)*(a + m2));
            d = 1 + aa*d; // One step (the even one) of the recurrence.
            if (f_abs(d) < FP_MIN) {
                d = FP_MIN;
            }
            c = 1 + aa/c;
            if (f_abs(c) < FP_MIN) {
                c = FP_MIN;
            }
            d = 1/d;
            h *= d*c;
            aa = -(a + m)*(qab + m)*x / ((a + m2)*(qap + m2));
            d = 1 + aa*d; // Next step of the recurrence (the odd one).
            if (f_abs(d) < FP_MIN) {
                d = FP_MIN;
            }
            c = 1 + aa/c;
            if (f_abs(c) < FP_MIN) {
                c = FP_MIN;
            }
            d = 1/d;
            del = d*c;
            h *= del;
            if (f_abs(del - 1) < EPS) {
                break;
            }
        }
        return h; // if(m > MAX_IT) throw new Error("a or b too big, or MAX_IT too small");
    }

    function betastd_inv(p, a, b) { // the quantile function of the standard Beta distribution
        var m = 0, M = 1, x = 0;
        for (var i = 0; i < MAX_IT; i++) {
            x = 0.5*(m + M);
            var q = betastd_cdf(x, a, b);
            if (f_abs(p - q) < EPS) {
                break;
            }
            if (q > p) {
                M = x;
            } else {
                m = x;
            }
        }
        return x;
    }

    function BETADIST(x, a, b, m, M) {
        return betastd_cdf((x-m)/(M-m), a, b);
    }

    function BETA_DIST(x, a, b, cdf, m, M) {
        if (cdf) {
            return betastd_cdf((x-m)/(M-m), a, b);
        }
        return betastd_pdf((x-m)/(M-m), a, b) / (M-m);
    }

    function BETA_INV(p, a, b, m, M) {
        return m + (M-m)*betastd_inv(p, a, b);
    }

    function chisq_left(x, n, cds) {  // CHISQ.DIST(x,deg_freedom,cumulative)
        return GAMMA_DIST(x, n/2, 2, cds);
    }

    function chisq_right(x, n) { // CHISQ.DIST.RT(x,deg_freedom)
        return 1 - chisq_left(x, n, true);
    }

    function chisq_left_inv(p, n) { // CHISQ.INV( probability, degrees_freedom )
        return GAMMA_INV(p, n/2, 2);
    }

    function chisq_right_inv(p, n) { // CHISQ.INV.RT(probability,deg_freedom)
        return chisq_left_inv(1-p, n);
    }

    function chisq_test(obsv, expect) {
        var rows = obsv.length, cols = obsv[0].length;
        var x = 0, i, j;
        for (i = 0; i < rows; i++) {
            for (j = 0; j < cols; j++) {
                var eij = expect[i][j];
                var delta = obsv[i][j] - eij;
                delta *= delta;
                x += delta/eij;
            }
        }
        var n = (rows - 1)*(cols - 1);
        return chisq_right(x, n);
    }

    function expon(x, r, cdf) { // EXPON.DIST(x, lambda, cumulative)
        if (cdf) {
            return 1 - Math.exp(-r*x);
        }
        return r * Math.exp(-r*x);
    }

    function poisson(k, m, cdf) { // POISSON.DIST(x, mean, cumulative)
        if (cdf) {
            return 1 - chisq_left(2*m, 2*(k+1), true);
        }
        //return chisq_left(2*m, 2*k, true) - chisq_left(2*m, 2*(k+1), true);
        var lnf = 0;
        for (var i = 2; i <= k; i++) {
            lnf += Math.log(i); // compute log(k!)
        }
        return Math.exp(k*Math.log(m) - m - lnf);
    }

    function Fdist(x, n, d, cdf) { //F.DIST(x,deg_freedom1,deg_freedom2,cumulative)
        if (cdf) {
            return betastd_cdf(n*x/(d+n*x), n/2, d/2);
        }
        var u = n/d;
        n /= 2; d /= 2;
        return u/BETA(n, d) * Math.pow(u*x, n-1) / Math.pow(1+u*x, n+d);
    }

    function Fdist_right(x, n, d) { // F.DIST.RT(x,deg_freedom1,deg_freedom2)
        return 1 - Fdist(x, n, d, true);
    }

    function Finv_right(p, n, d) { // F.INV.RT(probability,deg_freedom1,deg_freedom2
        return d/n*(1/BETA_INV(p, d/2, n/2, 0, 1) - 1);
    }

    function Finv(p, n, d) { // F.INV(probability,deg_freedom1,deg_freedom2
        return d/n*(1/BETA_INV(1-p, d/2, n/2, 0, 1) - 1);
    }

    function _mean(arr) {
        var me = 0, n = arr.length;
        for (var i = 0; i < n; i++) {
            me += arr[i];
        }
        return me / n;
    }

    function _var_sq(arr, m) { // returns the (n-1)-part of the sum of the squares of deviations from m (= VAR)
        var v = 0, n = arr.length;
        for (var i = 0; i < n; i++) {
            var delta = arr[i] - m;
            v += delta*delta;
        }
        return v / (n-1);
    }

    function Ftest(arr1, arr2) { // F.TEST(array1,array2)
        var n1 = arr1.length - 1, n2 = arr2.length - 1;
        var va1 = _var_sq(arr1, _mean(arr1)),
            va2 = _var_sq(arr2, _mean(arr2));
        if (!va1 || !va2) {
            throw new CalcError("DIV/0");
        }
        return 2*Fdist(va1 / va2, n1, n2, true);
    }

    function fisher(x) { // FISHER(x)
        return 0.5*Math.log((1+x)/(1-x));
    }

    function fisherinv(x) { // FISHERINV(x)
        var e2 = Math.exp(2*x);
        return (e2 - 1)/(e2 + 1);
    }

    function Tdist(x, n, cdf) { // T.DIST(x,deg_freedom, cumulative)
        if (cdf) {
            return 1 - 0.5*betastd_cdf(n/(x*x+n), n/2, 0.5);
        }
        return 1/(Math.sqrt(n)*BETA(0.5, n/2)) * Math.pow(1 + x*x/n, -(n+1)/2);
    }

    function Tdist_right(x, n) { // T.DIST.RT(x,deg_freedom)
        return 1 - Tdist(x, n, true);
    }

    function Tdist_2tail(x, n) { // T.DIST.2T(x,deg_freedom)
        if (x < 0) {
            x = -x;
        }
        return 2*Tdist_right(x, n);
    }

    function Tdist_inv(p, n) { // T.INV(probability,deg_freedom)
        var x = betastd_inv(2*Math.min(p, 1-p), n/2, 0.5); // ibetainv();
        x = Math.sqrt(n * (1 - x) / x);
        return (p > 0.5) ? x : -x;
    }

    function Tdist_2tail_inv(p, n) { // T.INV.2T(probability,deg_freedom)
        // T2 = 2T_r = p => T_r(x,n) = p/2 => 1 - T(x,n,true) = p/2 => x = T^-1(1-p/2, n)
        return Tdist_inv(1-p/2, n);
    }

    function Tdist_test(gr1, gr2, tail, type) { // T.TEST(array1,array2,tails,type)
        var n1 = gr1.length, n2 = gr2.length;
        var t_st, df; // the t-statistic and the "degree of freedom"
        if (type == 1) { // paired (dependent) samples
            var d = 0, d2 = 0;
            for (var i = 0; i < n1; i++) {
                var delta = gr1[i] - gr2[i];
                d += delta;
                d2 += delta*delta;
            }
            var md = d/n1; //, md2 = d2 / n1;
            t_st = md / Math.sqrt((d2 - d*md)/(n1*(n1-1))); // has a "Student T" distribution
            return tail == 1 ? Tdist_right(t_st, n1-1) : Tdist_2tail(t_st, n1-1);
        }
        // unpaired (independent) samples
        var m1 = _mean(gr1), m2 = _mean(gr2),
            v1 = _var_sq(gr1, m1), v2 = _var_sq(gr2, m2);
        if (type == 3) { // unpaired, unequal variances
            var u1 = v1/n1, u2 = v2/n2, u = u1 + u2;
            var q1 = u1/u, q2 = u2/u; // u==0 must be invalidated
            df = 1/(q1*q1/(n1-1) + q2*q2/(n2-1));
            t_st = f_abs(m1-m2)/Math.sqrt(u);
            return tail == 1 ? Tdist_right(t_st, df) : Tdist_2tail(t_st, df);
        }
        else { // (type == 2) unpaired, equal variances ("equal" in the sense that there is no significant difference in variance in both groups - a prealable F-test could revealed that)
            df = n1 + n2 - 2;
            t_st = f_abs(m1-m2)*Math.sqrt(df*n1*n2/((n1+n2)*((n1-1)*v1+(n2-1)*v2)));
            return tail == 1 ? Tdist_right(t_st, df) : Tdist_2tail(t_st, df);
        }
    }

    function confidence_t(alpha, stddev, size) { // CONFIDENCE.T(alpha,standard_dev,size)
        return -Tdist_inv(alpha/2, size-1)*stddev/Math.sqrt(size);
    }

    function confidence_norm(alpha, stddev, size) { // CONFIDENCE.NORM(alpha,standard_dev,size)
        return -NORM_S_INV(alpha/2)*stddev/Math.sqrt(size);
    }

    function gauss(z) { // GAUSS(z)
        return NORM_S_DIST(z, true) - 0.5;
    }

    function phi(x) { // PHI(x)
        return NORM_S_DIST(x);
    }

    function lognorm_dist(x, m, s, cumulative) { // LOGNORM.DIST(x,mean,standard_dev,cumulative)
        if (cumulative) {
            return 0.5 + 0.5*ERF((Math.log(x)-m)/(s*Math.sqrt(2)));
        }
        var t = Math.log(x)-m;
        return Math.exp(-t*t/(2*s*s))/(x*s*Math.sqrt(2*Math.PI));
    }

    function lognorm_inv(p, m, s) { //LOGNORM.INV(probability, mean, standard_dev)
        return Math.exp(NORM_INV(p, m, s));
    }

    function prob(x_, p_, lw, up) { //PROB(x_range, prob_range, [lower_limit], [upper_limit])
        var n = x_.length;
        var s = 0, i;
        for (i = 0; i < n; i++) {
            if (p_[i] <= 0 || p_[i] > 1) {
                throw new CalcError("NUM");
            }
            s += p_[i];
        }
        if (s != 1) {
            throw new CalcError("NUM");
        }
        var res = 0;
        for (i = 0; i < n; i++) {
            var x = x_[i];
            if (x >= lw && x <= up) {
                res += p_[i];
            }
        }
        return res;
    }

    function slope(y_, x_) { // SLOPE(known_y's, known_x's)
        var mx = _mean(x_), my = _mean(y_), b1 = 0, b2 = 0;
        for (var i = 0, n = y_.length; i < n; i++) {
            var t = x_[i] - mx;
            b1 += t*(y_[i] - my);
            b2 += t*t;
        }
        return b1/b2;
    }

    function intercept(y_, x_) { // INTERCEPT(known_y's, known_x's)
        var mx = _mean(x_), my = _mean(y_);
        // return my - mx*slope(y_, x_);  //but repeating the calls for _mean()
        var b1 = 0, b2 = 0;
        for (var i = 0, n = y_.length; i < n; i++) {
            var t = x_[i] - mx;
            b1 += t*(y_[i] - my);
            b2 += t*t;
        }
        return my - b1*mx/b2;
    }

    function pearson(x_, y_) { // PEARSON(array1, array2)
        whipNumberArrays(x_, y_);
        var mx = _mean(x_), my = _mean(y_);
        var s1 = 0, s2 = 0, s3 = 0;
        for (var i = 0, n = x_.length; i < n; i++) {
            var t1 = x_[i] - mx, t2 = y_[i] - my;
            s1 += t1*t2;
            s2 += t1*t1;
            s3 += t2*t2;
        }
        return s1/Math.sqrt(s2*s3);
    }

    function rsq(x_, y_) { // RSQ(known_y's,known_x's)
        var r = pearson(x_, y_);
        return r*r;
    }

    function steyx(y_, x_) { //STEYX(known_y's, known_x's)
        var n = x_.length;
        var mx = _mean(x_), my = _mean(y_);
        var s1 = 0, s2 = 0, s3 = 0;
        for (var i = 0; i < n; i++) {
            var t1 = x_[i] - mx, t2 = y_[i] - my;
            s1 += t2*t2;
            s2 += t1*t2;
            s3 += t1*t1;
        }
        return Math.sqrt((s1 - s2*s2/s3)/(n-2));
    }

    function forecast(x, y_, x_) { //FORECAST(x, known_y's, known_x's)
        var mx = _mean(x_), my = _mean(y_);
        var s1 = 0, s2 = 0;
        for (var i = 0, n = x_.length; i < n; i++) {
            var t1 = x_[i] - mx, t2 = y_[i] - my;
            s1 += t1*t2;
            s2 += t1*t1;
        }
        if (s2 === 0) {
            throw new CalcError("N/A");
        }
        var b = s1/s2, a = my - b*mx;
        return a + b*x;
    }

    function _mat_mean(Mat) { // returns the mean value of a Matrix(n, 1)
        var n = Mat.height, sum = 0;
        for (var i=0; i < n; i++) {
            sum += Mat.data[i][0];
        }
        return sum/n;
    }

    function _mat_devsq(Mat, mean) { // returns the sum of squares of deviations for a Matrix(n, 1)
        var n = Mat.height, sq = 0;
        for (var i=0; i < n; i++) {
            var x = Mat.data[i][0] - mean;
            sq += x*x;
        }
        return sq;
    }

    function linest(Y, X, konst, stats) { // LINEST(known_y's, [known_x's], [const], [stats])
        var i = 0;

        if (!X) {
            // if not passed, X should default to array {1, 2, 3, ...} (same size as Y)
            X = Y.map(function(){ return ++i; });
        }

        if (konst) { // adding 1's column is unnecessary when const==false (meaning that y_intercept==0)
            X = X.clone();
            X.eachRow(function(row){
                X.data[row].unshift(1);
            });
            ++X.width;
        }

        var Xt = X.transpose();
        var B = Xt.multiply(X).inverse().multiply(Xt).multiply(Y); // the last square estimate of the coefficients
        var line_1 = [];
        for (i = B.height-1; i >= 0; i--) {
            line_1.push(B.data[i][0]); // regression coefficients ('slopes') and the y_intercept
        }
        if (!konst) {
            line_1.push(0); // display 0 for y_intercept, when const==false
        }
        if (!stats) {
            return this.asMatrix([ line_1 ]); // don't display statistics about the regression, when stats==false
        }

        var Y1 = X.multiply(B); // the predicted Y values
        var y_y1 = Y.adds(Y1, true); // the errors of the predictions (= Y - Y1)
        var mp = !konst? 0 : _mat_mean(Y1);
        var SSreg = _mat_devsq(Y1, mp); // The regression sum of squares
        var me = !konst? 0 : _mat_mean(y_y1);
        var SSresid = _mat_devsq(y_y1, me); // The residual sum of squares
        var line_5 = [];
        line_5.push(SSreg, SSresid);
        var R2 = SSreg / (SSreg + SSresid); // The coefficient of determination
        var degfre = Y.height - X.width; // The degrees of freedom
        var err_est = Math.sqrt(SSresid / degfre); // The standard error for the y estimate
        var line_3 = [];
        line_3.push(R2, err_est);
        var F_sta = !konst ? (R2/X.width)/((1-R2)/(degfre)) : (SSreg/(X.width-1))/(SSresid/degfre); // The F statistic
        var line_4 = [];
        line_4.push(F_sta, degfre);
        var SCP = Xt.multiply(X).inverse();
        var line_2 = [];
        for (i=SCP.height-1; i >= 0; i--) { // The standard errors (of coefficients an y-intercept)
            line_2.push(Math.sqrt(SCP.data[i][i]*SSresid/degfre));
        }
        return this.asMatrix([line_1, line_2, line_3, line_4, line_5]);
    }

    function logest(Y, X, konst, stats) { // LOGEST(known_y's, [known_x's], [const], [stats])
        return linest.call(this, Y.map(Math.log), X, konst, stats).map(Math.exp);
    }

    function trend(Y, X, W, konst) { // TREND(known_y's, [known_x's], [new_x's], [const])
        var i = 0;

        if (!X) {
            // if not passed, X should default to array {1, 2, 3, ...} (same size as Y)
            X = Y.map(function(){ return ++i; });
        }

        if (konst) { // adding 1's column is unnecessary when const==false (meaning that y_intercept==0)
            X = X.clone();
            X.eachRow(function(row){
                X.data[row].unshift(1);
            });
            ++X.width;
        }

        var Xt = X.transpose();
        var B = Xt.multiply(X).inverse().multiply(Xt).multiply(Y); // the last square estimate of the coefficients

        if (!W) {
            W = X;
        } else {
            if (konst) { // for non-zero y_intercept
                W = W.clone();
                W.eachRow(function(row){
                    W.data[row].unshift(1);
                });
                ++W.width;
            }
        }
        return W.multiply(B); // the predicted Y values for the W values
    }

    function growth(Y, X, new_X, konst) { // GROWTH(known_y's, [known_x's], [new_x's], [const])
        // = EXP(TREND(LN(Y_), X_, new_X, const))
        return trend.call(this, Y.map(Math.log), X, new_X, konst).map(Math.exp);
    }

    /*
      [1] Handbook of Mathematical Functions (NIST, 1964-2010):
      https://en.wikipedia.org/wiki/Abramowitz_and_Stegun
      http://dlmf.nist.gov/
      http://www.aip.de/groups/soe/local/numres/

      [2] https://en.wikibooks.org/wiki/Statistics/Numerical_Methods/Numerics_in_Excel
    */

    /* -----[ financial functions ]----- */

    //// find the root of a function known an initial guess (Newton's method) ////
    function root_newton(func, guess, max_it, eps) { // func(x) must return [value_F(x), value_F'(x)]
        var MAX_IT = max_it || 20, // maximum number of iterations
            EPS = eps || 1E-7; // accuracy
        var root = guess;
        for (var j = 1; j <= MAX_IT; j++) {
            var f_d = func(root),
                f = f_d[0], // the value of the function
                df = f_d[1]; // the value of the derivative
            var dx = f / df;
            root -= dx;
            if (Math.abs(dx) < EPS) {
                return root;
            }
        }
        return new CalcError("NUM");
    }


    /* https://support.office.com/en-us/article/PV-function-23879d31-0e02-4321-be01-da16e8168cbd
       if(rate==0):
       PMT * nper + PV + FV = 0
       else: //the basic equation (with six variables) implied in financial problems
       PV * (1+rate)^nper + PMT * (1+rate*type) * ((1+rate)^nper-1) / rate + FV = 0         [1]
    */


    //// FV (final or future value) ////
    /* I initially invest £1000 in a saving scheme and then at the end of each month I invest an
       extra £50. If the interest rate is 0.5% per month and I continue this process for two year,
       how much will my saving be worth: =FV(0.005, 24, -50, -1000, 0) */
    function FV(rate, nper, pmt, pv, type) { // FV(rate,nper,pmt,[pv],[type])
        var h1 = Math.pow(1+rate, nper);
        var h2 = rate ? (h1 - 1)/rate : nper;
        return -(pv * h1 + pmt * h2 * (1 + rate*type));
    }

    //// PV (present value of investment) ////
    /* If I wish to accumulate £5000 in four years time by depositing £75 per month in a fixed
       rate account with interest rate of 0.4% per month, what initial investment must I also
       make: =PV(0.004, 4*12, -75, 5000, 0) */
    function PV(rate, nper, pmt, fv, type) { // PV(rate, nper, pmt, [fv], [type])
        if (!rate) {
            return -fv - pmt*nper;
        }
        var h1 = Math.pow(1+rate, nper);
        return -(fv + pmt * (h1 - 1)/rate * (1 + rate*type)) / h1;
    }

    //// PMT monthly payments (= principal part PPMT + interest part IPMT) ////
    /* How much will the monthly repayments be if I borrow £100,000 over 20 years with an
       effective monthly interest rate is 0.5%: =PMT(0.005, 12*20, 100000, 0, 0) */
    function PMT(rate, nper, pv, fv, type) { // PMT(rate, nper, pv, [fv], [type])
        if (!rate) {
            return -(fv + pv)/nper;
        }
        var h1 = Math.pow(1+rate, nper);
        return -rate*(fv + pv*h1)/((1 + rate*type)*(h1 - 1));
    }

    //// NPER (number of periods for an investment) ////
    /* How long would it take me to pay off a loan of £10,000 at a rate of 0.5% per month if I
       can afford to pay £100 per month: =NPER(0.5%, -100, 10000, 0, 0) */
    function NPER(rate, pmt, pv, fv, type) { // NPER(rate,pmt,pv,[fv],[type])
        if (!rate) {
            return -(fv + pv) / pmt;
        }
        var h1 = pmt*(1 + rate*type);
        return Math.log((h1 - fv*rate)/(h1 + pv*rate)) / Math.log(1 + rate);
    }

    //// RATE (the interest rate per period) ////
    /* I borrow £1000 over 1 year making payments of £100 per month at the end of each
       month. What is the monthly interest rate: =RATE(12, −100, 1000, 0, 0, 0) */

    function RATE(nper, pmt, pv, fv, type, guess) { // RATE(nper, pmt, pv, [fv], [type], [guess])
        function xfd(x) { // returns F(x) and F'(x), where F is given by the equation [1]
            var h2 = Math.pow(1+x, nper-1), h1 = h2*(1+x);
            return [ pv*h1 + pmt*(1/x + type)*(h1 - 1) + fv,
                     nper*pv*h2 + pmt*(-(h1 - 1)/(x*x) + (1/x + type)*nper*h2) ];
        }
        return root_newton(xfd, guess); // a root of the equation F(x)=0
    }

    //// IPMT (interest part of a loan or investment) ////
    //// PPMT (principal part of a loan) ////

    function IPMT(rate, per, nper, pv, fv, type) { // IPMT(rate, per, nper, pv, [fv], [type])
        if (type==1 && per==1) { // interest before beginnig of the payments... = ZERO
            return 0;
        }
        var pmt = PMT(rate, nper, pv, fv, type);
        var ipmt = FV(rate, per - 1, pmt, pv, type) * rate;
        return type ? ipmt/(1 + rate) : ipmt;
    }

    function PPMT(rate, per, nper, pv, fv, type) { // PPMT(rate, per, nper, pv, [fv], [type])
        var pmt = PMT(rate, nper, pv, fv, type);
        return pmt - IPMT(rate, per, nper, pv, fv, type);
    }

    //// CUMPRINC (cumulative principal paid) ////
    /* The amount financed is $200,000 at an interest rate of 7.25% for 30 years. How much is the amount of principal
       and the amount of interest paid in the first year: CUMPRINC(0.0725/12, 12*30, 200000, 1, 12, 0)
       and CUMIPMT(0.0725/12, 12*30, 200000, 1, 12, 0) */
    function CUMPRINC(rate, nper, pv, start, end, type) { // CUMPRINC(rate, nper, pv, start_period, end_period, type)
        if (type == 1) { // start >= 1 (as in Excel), but if pay at beginning of the period (type==1),
            start --;    // then periods must be counted from Zero (decreasing given start and end parameters)
            end --;
        }
        var tn = Math.pow(1 + rate, nper),
            ts = Math.pow(1 + rate, start-1),
            te = Math.pow(1 + rate, end);
        var monthlyPayment = rate * pv * tn / (tn - 1);
        var remainingBalanceAtStart = ts * pv - ((ts - 1) / rate) * monthlyPayment;
        var remainingBalanceAtEnd = te * pv - ((te - 1) / rate) * monthlyPayment;
        return remainingBalanceAtEnd - remainingBalanceAtStart;
    }

    //// CUMIPMT (cumulative  interest paid) ////
    function CUMIPMT(rate, nper, pv, start, end, type) { // CUMIPMT(rate, nper, pv, start_period, end_period, type)
        var cip = 0;
        for (var i=start; i<=end; i++) {
            cip += IPMT(rate, i, nper, pv, 0, type);
        }
        return cip;
    }

    //// NPV (Net Present Value of an investment based on a series of periodic cash flows and a discount rate) ////
    function NPV(rate, flows) { // NPV(rate,value1,[value2],...)
        var npv = 0;
        for (var i=0, n=flows.length; i < n; i++) {
            npv += flows[i]*Math.pow(1 + rate, -i-1);
        }
        return npv;
    }

    //// IRR (Internal Rate of Return on an investment based on a series of periodic cash flows) ////
    function IRR(flows, guess) { // IRR(values, [guess])
        function xfd(x) {
            var npv = 0, npv1 = 0;
            for (var j=0, n=flows.length; j < n; j++) {
                npv += flows[j]*Math.pow(1 + x, -j-1); // construct the NPV(x) value,
                npv1 += -j*flows[j]*Math.pow(1+x, -j-2); // the value in x of the NPV()-derivative
            }
            return [npv, npv1];
        }
        return root_newton(xfd, guess);
    }

    //// EFFECT (effective annual interest rate) ////
    /* which investment option is better - one that pays 5 percent after one year, or a
       savings account that pays a monthly interest of 4.75 percent:
       = (5% - EFFECT(4.75%, 12)) * 10000 */
    function EFFECT(nominal_rate, npery) { // EFFECT(nominal_rate, npery)
        return Math.pow(1 + nominal_rate/npery, npery) - 1;
    }

    //// NOMINAL (nominal annual interest rate) ////
    function NOMINAL(effect_rate, npery) { // NOMINAL(effect_rate, npery)
        return npery*(Math.pow(effect_rate + 1, 1/npery) - 1);
    }

    //// XNPV (Net Present Value of a series of cashflows at irregular intervals) ////
    function XNPV(rate, values, dates) { // XNPV(rate, values, dates)
        var npv = 0;
        for (var i=0, n=values.length; i < n; i++) {
            npv += values[i]*Math.pow(1 + rate, (dates[0]-dates[i])/365);
        }
        return npv;
    }

    //// XIRR (Internal Rate of Return of a series of cashflows at irregular intervals) ////
    function XIRR(values, dates, guess) { // XIRR(values, dates, [guess])
        function xfd(x) {
            var npv = values[0], npv1 = 0;
            for (var j=1, n=values.length; j < n; j++) {
                var delta = (dates[0] - dates[j]) / 365;
                npv += values[j]*Math.pow(1 + x, delta); // construct the XNPV(x) value,
                npv1 += delta*values[j]*Math.pow(1+x, delta - 1); // the value in x of the XNPV()-derivative
            }
            return [npv, npv1];
        }
        return root_newton(xfd, guess); // , 100, 0.1);
    }

    //// ISPMT (Interest paid during a Specific Period of an investment) ////
    function ISPMT(rate, per, nper, pv) { // ISPMT(rate, per, nper, pv)
        var tmp = -pv*rate;
        return tmp*(1 - per/nper);
    }

    //// DB (Declining Balance depreciation) ////
    function DB(cost, salvage, life, period, month) { // DB(cost, salvage, life, period, [month])
        var rate = 1 - Math.pow(salvage/cost, 1/life);
        rate = Math.floor(rate*1000 + 0.5) / 1000; // rounded to three decimals
        var db = cost * rate * month / 12;
        if (period == 1) {
            return db;
        }
        for (var i=1; i < life; i++) {
            if (i == period - 1) {
                return (cost - db) * rate;
            }
            db += (cost - db) * rate;
        }
        return (cost - db) * rate * (12 - month) / 12;
    }

    //// DDB (Double Declining Balance depreciation) ////
    function DDB(cost, salvage, life, period, factor) { // DDB(cost, salvage, life, period, [factor])
        var f = factor / life;
        var prior = -cost * (Math.pow(1-f, period-1) - 1);
        var dep = (cost - prior) * f;
        /* Depreciation cannot exceed book value.  */
        dep = Math.min(dep, Math.max(0, cost - prior - salvage));
        return dep;
    }

    //// SLN (straight-line depreciation) ////
    function SLN(cost, salvage, life) { // SLN(cost, salvage, life)
        return (cost - salvage) / life;
    }

    //// SYD (Sum-of-Years' digits Depreciation) ////
    function SYD(cost, salvage, life, per) { // SYD(cost, salvage, life, per)
        return (cost - salvage) * (life - per + 1) * 2 / (life * (life + 1));
    }

    //// VDB (Variable Declining Balance) ////
    //
    // Code adapted from Gnumeric, which in turn took it from OpenOffice.  The original code is
    // available under GNU Lesser General Public License (LGPL).
    // https://github.com/GNOME/gnumeric/blob/master/plugins/fn-financial/sc-fin.c
    function VDB(cost, salvage, life, start, end, factor, no_switch) {
        var interest = factor >= life ? 1 : factor / life;

        function _getGDA(value, period) {
            var gda, oldValue, newValue;
            if (interest == 1) {
                oldValue = period == 1 ? value : 0;
            } else {
                oldValue = value * Math.pow(1 - interest, period - 1);
            }
            newValue = value * Math.pow(1 - interest, period);
            gda = newValue < salvage ? oldValue - salvage : oldValue - newValue;
            return gda < 0 ? 0 : gda;
        }

        function _interVDB(cost, life1, period) {
            var remValue = cost - salvage;
            var intEnd = Math.ceil(period);
            var term, lia = 0, vdb = 0, nowLia = false;
            for (var i = 1; i <= intEnd; i++) {
                if (!nowLia) {
                    var gda = _getGDA(cost, i);
                    lia = remValue / (life1 - i + 1);
                    if (lia > gda) {
                        term = lia;
                        nowLia = true;
                    } else {
                        term = gda;
                        remValue -= gda;
                    }
                } else {
                    term = lia;
                }
                if (i == intEnd) {
                    term *= period + 1 - intEnd;
                }
                vdb += term;
            }
            return vdb;
        }

        var intStart = Math.floor(start), intEnd = Math.ceil(end);
        var vdb = 0;
        if (no_switch) {
            for (var i = intStart + 1; i <= intEnd; i++) {
                var term = _getGDA(cost, i);
                if (i == intStart + 1) {
                    term *= Math.min(end, intStart + 1) - start;
                } else {
                    if (i == intEnd) {
                        term *= end + 1 - intEnd;
                    }
                }
                vdb += term;
            }
        } else {
            var life1 = life;
            if (start != Math.floor(start)) {
                if (factor > 1) {
                    if (start >= life / 2) {
                        var part = start - life / 2;
                        start = life / 2;
                        end -= part;
                        life1 += 1;
                    }
                }
            }
            cost -= _interVDB(cost, life1, start);
            vdb = _interVDB(cost, life - start, end - start);
        }
        return vdb;
    }

    /*************************************************************************************/

    /*   (from  http://beginnersinvest.about.com)
         an investor agrees to loan money to a company or government in exchange for a predetermined interest rate for a pre-determined length of time.

         If an investor wanted to buy a $25,000 Coca-Cola bond with a 30 year maturity and an 10% coupon, it would work like this: He would send in the $25,000 from his savings account and get a $25,000 engraved bond certificate in exchange. After 30 years, he would be able to get his whole $25,000 back from the Coca-Cola company (of course, he can always sell it before then if he needs the money).

         Every year, he’s entitled to receive 10% interest on the money he lent, or $2,500. Since most companies in the United States pay interest semi-annually, he would likely have 60 coupons attached to his bond for $1,250 each.
         Every June 30th and December 31st, the investor would go down, clip the proper coupon, send it in, and get their money.

         Although the practice is now defunct, the terminology stuck and interest payments on bonds will forever be known as coupons.
    */


    // "Use EDATE to calculate maturity dates or due dates that fall on the same day of the month as the date of issue."
    // See also: DATEDIF, DAY, DAYS, DAY360, EOMONTH (wich can be useful to determine limits of coupon periods)
    function _edate(base, months) { // EDATE(start_date, months)
        var d = unpackDate$1(base);
        var m = d.month + months;
        var y = d.year + Math.floor(m/12);
        m %= 12;
        if (m < 0) {
            m += 12;
        }
        d = Math.min(d.date, daysInMonth(y, m));
        return packDate$1(y, m, d);
    }

    function _daysBetween(from, to, basis) {
        if (basis == 1 || basis == 2 || basis == 3) { // Actual/Actual || Actual/360 || Actual/365
            return to - from;
        }
        return _days_360(from, to, basis);
    }

    // Find coupon dates that enclose the settlement date, counting backward from the maturity date.
    /* independent of the 'basis' convention to count days - here we have no need to count days */
    function _borderCoupons(settlement, maturity, freq) {
        var sett = unpackDate$1(settlement), base = unpackDate$1(maturity);
        var periods = base.year - sett.year;
        if (periods > 0) {
            periods = (periods - 1) * freq;
        }
        var prev, next, months = 12/freq;
        do {
            periods++;
            prev = _edate(maturity, - periods*months);
        } while (settlement < prev);
        periods--;
        next = _edate(maturity, - periods*months);
        return [ prev, next ];
    }

    // Find coupon dates that enclose the settlement date, counting forward from the first-coupon payment.
    /* independent of the 'basis' convention to count days - here we have no need to count days */
    function _borderCoupons_fw(first, settlement, freq) {
        var sett = unpackDate$1(settlement), base = unpackDate$1(first);
        var periods = sett.year - base.year;
        if (periods > 0) {
            periods = (periods - 1) * freq;
        }
        var prev = first, next, months = 12/freq;
        while (settlement > prev) {
            next = prev;
            periods++;
            prev = _edate(first, periods*months);
        }
        return [ next, prev ];
    }

    //// COUPDAYBS (COUPon DAYs Beginning to Settlement) ////
    /* returns the number of days from the beginning of the coupon period to the settlement date */
    function COUPDAYBS(settlement, maturity, frequency, basis) { // COUPDAYBS(settlement, maturity, frequency, [basis])
        var prev = _borderCoupons(settlement, maturity, frequency)[0];
        return _daysBetween(prev, settlement, basis);
    }

    //// COUPDAYS (COUPon DAYs containing Settlement) ////
    /* Returns the number of days in the coupon period that contains the settlement date */
    function COUPDAYS(settl, matur, freq, basis) { // COUPDAYS(settlement, maturity, frequency, [basis])
        if (basis == 1) {
            var borders = _borderCoupons(settl, matur, freq);
            return _daysBetween(borders[0], borders[1], 1);
        }
        if (basis == 3) {
            return 365/freq;
        }
        return 360/freq;
    }

    //// COUPDAYSNC (COUPon DAYs Settlement to Next Coupon) ////
    /* Returns the number of days from the settlement date to the next coupon date */
    function COUPDAYSNC(settl, matur, freq, basis) { // COUPDAYSNC(settlement, maturity, frequency, [basis])
        var next = _borderCoupons(settl, matur, freq)[1];
        return _daysBetween(settl, next, basis);
    }

    //// COUPPCD (COUPon, Previous Coupon Date) ////
    /* Returns the previous coupon date before the settlement date */
    function COUPPCD(settl, matur, freq/*, basis*/) { // COUPPCD(settlement, maturity, frequency, [basis])
        // It is no need to count days, so 'basis' becomes a inutil parameter.
        return _borderCoupons(settl, matur, freq)[0];
    }

    //// COUPNCD (COUPon, Next Coupon Date) ////
    /* Returns the next coupon date after the settlement date */
    function COUPNCD(settl, matur, freq/*, basis*/) { // COUPNCD(settlement, maturity, frequency, [basis])
        // It is no need to count days, so 'basis' becomes a inutil parameter.
        return _borderCoupons(settl, matur, freq)[1];
    }

    function COUPNUM(settl, matur, freq/*, basis*/) { // COUPNUM(settlement, maturity, frequency, [basis])
        var sett = unpackDate$1(settl),
            mat = unpackDate$1(matur);
        var months = 12*(mat.year - sett.year) + mat.month - sett.month;
        //// Discount the last month if there are not enough days? Finally - we decide to not discount.
        //// (if this "last month" have 2 days, Excel.COUPNUM returns 6 but GoogleSpreads give only 5)
        //    var res = _edate(matur, -months);
        //    if (sett.date >= unpackDate(res).date) {
        //        months--; // an incomplete last month correspond to a qvasi-coupon period
        //    }
        return 1 + (months * freq / 12 | 0);
    }

    function daysInYear2(yr, basis) {
        if (basis == 3) { return 365; }
        if (basis == 1) { return isLeapYear(yr) ? 366 : 365; }
        return 360;
    }

    //// ACCRINTM  the accrued interest for a security that pays interest at maturity ////
    function ACCRINTM(issue, maturity, rate, par, basis) { // ACCRINTM(issue, settlement, rate, par, [basis])
        var year_days = daysInYear2(unpackDate$1(maturity).year, basis); // 360;
        return rate*par * _daysBetween(issue, maturity, basis) / year_days;
    }

    function ACCRINT(issue, first, settl, rate, par, freq, basis, calc) {
        var accr = 0, cost = par * rate / freq;
        var brace, prev, next, prev1, next1, nrc;

        var annual = basis % 2 === 0 ? 360 : 365; // only if to >> from, we eventually need to count leap years
        function _numCoupons(from, to) { // better than COUPNUM(from, to, freq, basis)-1
            return (to - from)*freq/annual | 0;
        }

        if (settl <= first) {
            brace = _borderCoupons(settl, first, freq);
            prev = brace[0];
            next = brace[1];
            if (prev <= issue) {
                return cost * _daysBetween(issue, settl, basis) / _daysBetween(prev, next, basis);
            }
            brace = _borderCoupons(issue, prev, freq);
            prev1 = brace[0];
            next1 = brace[1];
            nrc = _numCoupons(next1, settl); // when settl==next, days are counted implicitly by nrc
            return cost *
                (nrc +
                 _daysBetween(issue, next1, basis) / _daysBetween(prev1, next1, basis) +
                 (settl < next? _daysBetween(prev, settl, basis) / _daysBetween(prev, next, basis) : 0));
        } else {
            brace = _borderCoupons_fw(first, settl, freq);
            prev = brace[0];
            next = brace[1];
            nrc = _numCoupons(first, settl); // COUPNUM(first, settl, freq, basis) - 1;
            if (next == settl) {
                accr = cost * nrc;
            } else {
                accr = cost * (nrc + _daysBetween(prev, settl, basis) / _daysBetween(prev, next, basis));
            }
            if (!calc) { return accr; } // Only the accrued interest between first and settlement dates.
            brace = _borderCoupons(issue, first, freq); // Add the accrued interest between issue and first dates.
            prev = brace[0];
            next = brace[1];
            nrc = _numCoupons(issue, first);
            accr += cost * (nrc + _daysBetween(issue, next, basis) / _daysBetween(prev, next, basis));
            return accr; // accrued interest between issue and settlement dates
        }
    }

    //// DISC  the discount rate for a security (given price and redemption values per 100$ face value) ////
    function DISC(settl, matur, pr, redemption, basis) { // DISC(settlement, maturity, pr, redemption, [basis])
        var annual = basis % 2 === 0 ? 360 : (isLeapYear(unpackDate$1(settl).year) ? 366 : 365);
        return (redemption - pr)/redemption*annual/_daysBetween(settl, matur, basis);
    }

    //// INTRATE  the interest rate for a fully invested security ////
    function INTRATE(settl, matur, investment, redemption, basis) { // INTRATE(settlement, maturity, investment, redemption, [basis])
        var annual = basis % 2 === 0 ? 360 : (isLeapYear(unpackDate$1(settl).year) ? 366 : 365);
        return (redemption - investment)/investment*annual/_daysBetween(settl, matur, basis);
    }

    //// RECEIVED  the amount received at maturity for a fully invested security ////
    function RECEIVED(settl, matur, investment, discount, basis) { // RECEIVED(settlement, maturity, investment, discount, [basis])
        var annual = basis % 2 === 0 ? 360 : (isLeapYear(unpackDate$1(settl).year) ? 366 : 365);
        return investment/(1 - discount*_daysBetween(settl, matur, basis)/annual);
    }

    //// PRICE  the price per $100 face value of a security that pays periodic interest ////
    function PRICE(settl, matur, rate, yld, redemption, freq, basis) { // PRICE(settlement, maturity, rate, yld, redemption, frequency, [basis])
        var N = 1 + ((matur - settl)*freq/(basis % 2 === 0 ? 360 : 365) | 0); // coupons playable between settlement and maturity dates
        var brace = _borderCoupons(settl, matur, freq),
            prev = brace[0], next = brace[1];
        var beg_settl = _daysBetween(prev, settl, basis),
            settl_end = _daysBetween(settl, next, basis),
            beg_end = _daysBetween(prev, next, basis);
        var den = 100*rate/freq,
            yf = yld/freq,
            frac = settl_end / beg_end;
        if (N == 1) {
            return (redemption + den)/(1 + frac*yf) - beg_settl / beg_end * den;
        }
        return redemption / Math.pow(1 + yf, N-1+frac)
            + den * Math.pow(1 + yf, 1-N-frac) * (Math.pow(1+yf, N) - 1) / yf
            - beg_settl / beg_end * den;
    }

    //// PRICEDISC  the price per $100 face value of a discounted security ////
    function PRICEDISC(settl, matur, discount, redemption, basis) { // PRICEDISC(settlement, maturity, discount, redemption, [basis])
        var dsm = _daysBetween(settl, matur, basis),
            dy = daysInYear2(unpackDate$1(matur).year, basis);
        return redemption - discount*redemption*dsm/dy;
    }

    // Used in PEARSON, more could follow.  In some situations Excel appears to silently ignore
    // missing or non-numeric values, for example if some value in a is missing a corresponding
    // value in b, then the one in a is going to be ignored as if not present.  Arrays must have the
    // same number of elements.  I couldn't come up with a good name for this function.
    function whipNumberArrays(a, b) {
        for (var i = a.length; --i >= 0;) {
            if (typeof a[i] != "number" || typeof b[i] != "number") {
                a.splice(i, 1);
                b.splice(i, 1);
            }
        }
    }

    const {
        packDate, unpackDate,
        packTime, unpackTime,
        serialToDate, dateToSerial,
        defineAlias
    } = calc.runtime;

    exports.ALL_PROPERTIES = ALL_PROPERTIES;
    exports.ALL_REASONS = ALL_REASONS;
    exports.AddColumnCommand = AddColumnCommand;
    exports.AddCommand = AddCommand;
    exports.AddRowCommand = AddRowCommand;
    exports.AdjustDecimalsCommand = AdjustDecimalsCommand;
    exports.AdjustRowHeightCommand = AdjustRowHeightCommand;
    exports.ApplyFilterCommand = ApplyFilterCommand;
    exports.AutoFillCalculator = AutoFillCalculator;
    exports.AutoFillCommand = AutoFillCommand;
    exports.Axis = Axis;
    exports.AxisManager = AxisManager;
    exports.BorderChangeCommand = BorderChangeCommand;
    exports.BringToFrontCommand = BringToFrontCommand;
    exports.CalcError = CalcError;
    exports.CellRef = CellRef;
    exports.ClearContentCommand = ClearContentCommand;
    exports.ClearFilterCommand = ClearFilterCommand;
    exports.Clipboard = Clipboard;
    exports.ColumnWidthCommand = ColumnWidthCommand;
    exports.Command = Command;
    exports.Context = Context;
    exports.Controller = Controller;
    exports.CopyCommand = CopyCommand;
    exports.CustomFilter = CustomFilter;
    exports.CutCommand = CutCommand;
    exports.Deferred = Deferred;
    exports.DefineNameCommand = DefineNameCommand;
    exports.DeleteColumnCommand = DeleteColumnCommand;
    exports.DeleteCommand = DeleteCommand;
    exports.DeleteDrawingCommand = DeleteDrawingCommand;
    exports.DeleteNameCommand = DeleteNameCommand;
    exports.DeleteRowCommand = DeleteRowCommand;
    exports.Drawing = Drawing;
    exports.DrawingCommand = DrawingCommand;
    exports.DrawingUpdateCommand = DrawingUpdateCommand;
    exports.DynamicFilter = DynamicFilter;
    exports.EditCommand = EditCommand;
    exports.EditValidationCommand = EditValidationCommand;
    exports.EventListener = EventListener;
    exports.FIRSTREF = FIRSTREF;
    exports.Filter = Filter;
    exports.FilterCommand = FilterCommand;
    exports.FormulaBar = FormulaBar;
    exports.FormulaContext = FormulaContext;
    exports.FormulaInput = FormulaInput;
    exports.FreezePanesCommand = FreezePanesCommand;
    exports.Grid = Grid;
    exports.GridLinesChangeCommand = GridLinesChangeCommand;
    exports.HideLineCommand = HideLineCommand;
    exports.HyperlinkCommand = HyperlinkCommand;
    exports.InsertCommentCommand = InsertCommentCommand;
    exports.InsertImageCommand = InsertImageCommand;
    exports.Matrix = Matrix;
    exports.MergeCellCommand = MergeCellCommand;
    exports.NULLREF = NULLREF;
    exports.NameCommand = NameCommand;
    exports.NameEditor = NameEditor;
    exports.NameRef = NameRef;
    exports.OpenCommand = OpenCommand;
    exports.Pane = Pane;
    exports.PaneAxis = PaneAxis;
    exports.PaneGrid = PaneGrid;
    exports.PasteCommand = PasteCommand;
    exports.PropertyBag = PropertyBag;
    exports.PropertyChangeCommand = PropertyChangeCommand;
    exports.PropertyCleanCommand = PropertyCleanCommand;
    exports.Range = Range$1;
    exports.RangeList = RangeList;
    exports.RangeRef = RangeRef;
    exports.RangeTree = RangeTree;
    exports.Ref = Ref;
    exports.ReorderDrawingsCommand = ReorderDrawingsCommand;
    exports.RowHeightCommand = RowHeightCommand;
    exports.SHEETREF = SHEETREF;
    exports.SaveAsCommand = SaveAsCommand;
    exports.SendToBackCommand = SendToBackCommand;
    exports.Sheet = Sheet;
    exports.SheetDataSourceBinder = SheetDataSourceBinder;
    exports.SheetEditor = SheetEditor;
    exports.SheetNavigator = SheetNavigator;
    exports.SortCommand = SortCommand;
    exports.Sorter = Sorter;
    exports.SpreadsheetWidget = SpreadsheetWidget;
    exports.TargetValueCommand = TargetValueCommand;
    exports.TextWrapCommand = TextWrapCommand;
    exports.ToolbarCopyCommand = ToolbarCopyCommand;
    exports.ToolbarCutCommand = ToolbarCutCommand;
    exports.ToolbarPasteCommand = ToolbarPasteCommand;
    exports.TopFilter = TopFilter;
    exports.UnHideLineCommand = UnHideLineCommand;
    exports.UnionRef = UnionRef;
    exports.ValidationFormulaContext = ValidationFormulaContext;
    exports.ValueFilter = ValueFilter;
    exports.View = View;
    exports.Workbook = Workbook;
    exports.calc = calc;
    exports.dateToNumber = dateToNumber;
    exports.dateToSerial = dateToSerial;
    exports.defineAlias = defineAlias;
    exports.defineFunction = defineFunction;
    exports.draw = draw;
    exports.drawCell = drawCell;
    exports.formatting = formatting;
    exports.initDynamicFilter = initDynamicFilter;
    exports.intl = intl;
    exports.numberToDate = numberToDate;
    exports.packDate = packDate;
    exports.packTime = packTime;
    exports.registerEditor = registerEditor;
    exports.serialToDate = serialToDate;
    exports.unpackDate = unpackDate;
    exports.unpackTime = unpackTime;
    exports.validation = validationExport;

}));
