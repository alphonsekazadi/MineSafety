/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import { htmlToFragment as x } from "@progress/kendo-editor-common";
import { selectedCells as v, tableCells as W, getUnit as N, parseStyle as S, setNodeStyle as u } from "./utils.mjs";
import { parentNode as k } from "../utils.mjs";
const f = "k-colgroup-data", H = (o, e, r) => {
  const l = {
    cellWidth: null,
    widthUnit: ""
  }, n = e.node, t = r.start(e.depth);
  if (!n.attrs[f])
    return l;
  const h = /* @__PURE__ */ new Set();
  let s = "";
  const b = x(n.attrs[f]).firstChild;
  return o.forEach((d) => {
    const a = n.resolve(d.pos - t), c = a.parent, m = a.index();
    let g = 0;
    for (let y = 0; y <= m; y++)
      g += c.child(y).attrs.colspan;
    const i = b.children[g - 1];
    i && (s = i.style.width, h.add(s));
  }), h.size === 1 && s && (l.cellWidth = parseFloat(s) || null, l.widthUnit = N(s)), l;
}, P = (o, e, r) => {
  const l = {
    cellHeight: null,
    heightUnit: ""
  }, n = e.node, t = r.start(e.depth), h = /* @__PURE__ */ new Set();
  let s = "";
  return o.forEach((b) => {
    var c;
    const a = n.resolve(b.pos - t).parent;
    s = S(((c = a.attrs) == null ? void 0 : c.style) || "").height || "", h.add(s);
  }), h.size === 1 && s && (l.cellHeight = parseFloat(s) || null, l.heightUnit = N(s)), l;
}, p = (o, e) => {
  const r = /* @__PURE__ */ new Set();
  let l = "";
  return o.forEach((n) => {
    var t;
    l = S(((t = n.node.attrs) == null ? void 0 : t.style) || "")[e] || "", r.add(l);
  }), r.size === 1 && l ? l : "";
}, w = (o, e) => {
  const r = /* @__PURE__ */ new Set();
  let l = "";
  return o.forEach((n) => {
    l = (n.node.attrs || {})[e] || "", r.add(l);
  }), r.size === 1 && l ? l : "";
}, C = {
  applyToAll: !1,
  cellWidth: null,
  widthUnit: "",
  cellHeight: null,
  heightUnit: "",
  alignment: { x: "", y: "" },
  textControl: "",
  backgroundColor: void 0,
  cellPadding: null,
  borderWidth: null,
  borderColor: void 0,
  borderStyle: null,
  id: "",
  className: ""
}, T = (o) => {
  const e = v(o), r = o.selection.$from, l = e.length ? k(r, (n) => n.type.spec.tableRole === "table") : null;
  return l ? {
    ...C,
    ...H(e, l, r),
    ...P(e, l, r),
    alignment: { x: p(e, "text-align"), y: p(e, "vertical-align") },
    textControl: p(e, "white-space"),
    backgroundColor: p(e, "background-color") || void 0,
    cellPadding: parseFloat(p(e, "padding")) || null,
    borderWidth: parseFloat(p(e, "border-width")) || null,
    borderColor: p(e, "border-color") || void 0,
    borderStyle: p(e, "border-style") || null,
    id: w(e, "id"),
    className: w(e, "class")
  } : C;
}, U = (o, e, r) => {
  const l = o.doc.resolve(e), n = l.parent, t = l.index();
  let h = 0;
  for (let c = 0; c <= t; c++)
    h += n.child(c).attrs.colspan;
  const s = l.node(l.depth - 1), b = l.posAtIndex(0, l.depth - 1) - 1;
  let d = s.attrs, a;
  if (d && d[f]) {
    const c = x(d[f]).firstChild;
    a = c.children[h - 1], a.style.width = r, d = { ...d, [f]: c.outerHTML }, o.setNodeMarkup(b, null, d);
  } else {
    let c = 0;
    for (let i = 0; i < n.childCount; i++)
      c += n.child(i).attrs.colspan;
    const m = document.createElement("colgroup"), g = new Array(c);
    for (let i = 0; i < c; i++)
      g[i] = document.createElement("col"), m.appendChild(g[i]);
    a = g[t], a.style.width = r, d = {
      ...d,
      [f]: "<colgroup>" + g.reduce((i, y) => i + y.outerHTML, "") + "</colgroup>"
    }, o.setNodeMarkup(b, null, d);
  }
}, E = (o, e, r) => {
  const l = o.doc.resolve(e), n = l.parent, t = l.posAtIndex(0) - 1;
  o.setNodeMarkup(t, null, u(n.attrs, "height", r));
}, $ = (o, e, r) => {
  r.forEach(({ node: l, pos: n }) => {
    let t = { ...l.attrs };
    t = u(t, "border-color", e.borderColor || ""), t = u(t, "border-style", e.borderStyle || ""), t = u(
      t,
      "border-width",
      typeof e.borderWidth == "number" ? e.borderWidth + "px" : ""
    ), t = u(t, "padding", typeof e.cellPadding == "number" ? e.cellPadding + "px" : ""), t = u(t, "background-color", e.backgroundColor || ""), t = u(t, "text-align", e.alignment.x || ""), t = u(t, "vertical-align", e.alignment.y || ""), t = u(t, "white-space", e.textControl || ""), t.id = e.id || null, t.class = e.className || null, o.setNodeMarkup(n, null, t), typeof e.cellWidth == "number" && U(o, n, e.cellWidth + (e.widthUnit || "px")), typeof e.cellHeight == "number" && E(o, n, e.cellHeight + (e.heightUnit || "px"));
  });
}, z = (o, e) => {
  const r = o.tr, l = e.applyToAll ? W(o) : v(o);
  return $(r, e, l), r;
};
export {
  z as applyCellsData,
  T as cellsDefaultData,
  C as initialCellData
};
