"use client";
import {
  v2
} from "./chunk-UJTBNSOU.js";
import {
  color_default,
  drawing_exports,
  geometry_exports,
  logToConsole,
  parseColor,
  support_default,
  throttle
} from "./chunk-KFMC7H2N.js";
import "./chunk-6T67ERTR.js";
import "./chunk-37IBAHXC.js";
import {
  i,
  i2,
  l,
  p,
  te
} from "./chunk-HJAFCX7L.js";
import {
  arrowLeftIcon,
  arrowRightIcon,
  homeIcon
} from "./chunk-IX5JQNBR.js";
import {
  M2 as M,
  P,
  d5 as d,
  e,
  n4 as n,
  o6 as o,
  require_prop_types,
  u3 as u,
  v3 as v,
  w2 as w
} from "./chunk-TPJZDNMR.js";
import {
  require_react_dom
} from "./chunk-PJEEZAML.js";
import {
  require_react
} from "./chunk-DRWLMN53.js";
import {
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/@progress/kendo-react-charts/Chart.mjs
var t3 = __toESM(require_react(), 1);

// node_modules/@progress/kendo-react-charts/BaseChart.mjs
var l5 = __toESM(require_react(), 1);
var import_prop_types = __toESM(require_prop_types(), 1);

// node_modules/@progress/kendo-charts/dist/es/common/constants.js
var ARC = "arc";
var ARROW_UP = "ArrowUp";
var ARROW_DOWN = "ArrowDown";
var ARROW_LEFT = "ArrowLeft";
var ARROW_RIGHT = "ArrowRight";
var TAB = "Tab";
var ARIA_ACTIVE_DESCENDANT = "aria-activedescendant";
var AXIS_LABEL_CLICK = "axisLabelClick";
var BLACK = "#000";
var BOTTOM = "bottom";
var CENTER = "center";
var CIRCLE = "circle";
var COORD_PRECISION = 3;
var CROSS = "cross";
var DATE = "date";
var DEFAULT_FONT = "12px sans-serif";
var DEFAULT_HEIGHT = 400;
var DEFAULT_PRECISION = 10;
var DEFAULT_WIDTH = 600;
var END = "end";
var ENTER = "Enter";
var ESCAPE = "Escape";
var FORMAT_REGEX = /\{\d+:?/;
var HEIGHT = "height";
var HIGHLIGHT_ZINDEX = 100;
var INSIDE = "inside";
var INHERIT = "inherit";
var LEFT = "left";
var MAX_VALUE = Number.MAX_VALUE;
var MIN_VALUE = -Number.MAX_VALUE;
var NONE = "none";
var NOTE_CLICK = "noteClick";
var NOTE_HOVER = "noteHover";
var NOTE_LEAVE = "noteLeave";
var OBJECT = "object";
var OUTSIDE = "outside";
var RIGHT = "right";
var ROUNDED_RECT = "roundedRect";
var START = "start";
var STRING = "string";
var TOP = "top";
var TRIANGLE = "triangle";
var SQUARE = "square";
var RECT = "rect";
var VALUE = "value";
var WHITE = "#fff";
var WIDTH = "width";
var X = "x";
var Y = "y";
var DEFAULT_SERIES_OPACITY = 1;
var POINTER = "pointer";
var HORIZONTAL = "horizontal";
var VERTICAL = "vertical";

// node_modules/@progress/kendo-charts/dist/es/common/is-array.js
function isArray(value2) {
  return Array.isArray(value2);
}

// node_modules/@progress/kendo-charts/dist/es/common/add-class.js
function addClass(element, classes) {
  const classArray = isArray(classes) ? classes : [classes];
  for (let idx = 0; idx < classArray.length; idx++) {
    const className = classArray[idx];
    if (element.className.indexOf(className) === -1) {
      element.className += " " + className;
    }
  }
}

// node_modules/@progress/kendo-charts/dist/es/common/remove-class.js
var SPACE_REGEX = /\s+/g;
function removeClass(element, className) {
  if (element && element.className) {
    element.className = element.className.replace(className, "").replace(SPACE_REGEX, " ");
  }
}

// node_modules/@progress/kendo-charts/dist/es/common/align-path-to-pixel.js
function alignPathToPixel(path) {
  let offset = 0.5;
  if (path.options.stroke && drawing_exports.util.defined(path.options.stroke.width)) {
    if (path.options.stroke.width % 2 === 0) {
      offset = 0;
    }
  }
  for (let i37 = 0; i37 < path.segments.length; i37++) {
    path.segments[i37].anchor().round(0).translate(offset, offset);
  }
  return path;
}

// node_modules/@progress/kendo-charts/dist/es/common/clockwise.js
function clockwise(angle1, angle2) {
  return -angle1.x * angle2.y + angle1.y * angle2.x < 0;
}

// node_modules/@progress/kendo-charts/dist/es/common/is-number.js
function isNumber(value2) {
  return typeof value2 === "number" && !isNaN(value2);
}

// node_modules/@progress/kendo-charts/dist/es/common/is-string.js
function isString(value2) {
  return typeof value2 === STRING;
}

// node_modules/@progress/kendo-charts/dist/es/common/convertable-to-number.js
function convertableToNumber(value2) {
  return isNumber(value2) || isString(value2) && isFinite(value2);
}

// node_modules/@progress/kendo-charts/dist/es/common/cycleUp.js
function cycleUp(index, count) {
  return (index + 1) % count;
}

// node_modules/@progress/kendo-charts/dist/es/common/cycleDown.js
function cycleDown(index, count) {
  let result = index - 1;
  return result < 0 ? count - 1 : result;
}

// node_modules/@progress/kendo-charts/dist/es/common/cycleIndex.js
function cycleIndex(index, length) {
  if (length === 1 || index % length === 0) {
    return 0;
  }
  if (index < 0) {
    return length + index % length;
  } else if (index >= length) {
    return index % length;
  }
  return index;
}

// node_modules/@progress/kendo-charts/dist/es/common/is-function.js
function isFunction(fn) {
  return typeof fn === "function";
}

// node_modules/@progress/kendo-charts/dist/es/common/deep-extend.js
var OBJECT2 = "object";
var UNDEFINED = "undefined";
function deepExtendOne(destination, source) {
  for (let property in source) {
    if (property === "__proto__" || property === "constructor") {
      continue;
    }
    let propValue = source[property];
    let propType = typeof propValue;
    let propInit;
    if (propType === OBJECT2 && propValue !== null) {
      propInit = propValue.constructor;
    } else {
      propInit = null;
    }
    if (propInit && propInit !== Array) {
      if (propValue instanceof Date) {
        destination[property] = new Date(propValue.getTime());
      } else if (isFunction(propValue.clone)) {
        destination[property] = propValue.clone();
      } else {
        let destProp = destination[property];
        if (typeof destProp === OBJECT2) {
          destination[property] = destProp || {};
        } else {
          destination[property] = {};
        }
        deepExtendOne(destination[property], propValue);
      }
    } else if (propType !== UNDEFINED) {
      destination[property] = propValue;
    }
  }
  return destination;
}
function deepExtend(destination) {
  const length = arguments.length;
  for (let i37 = 1; i37 < length; i37++) {
    deepExtendOne(destination, arguments[i37]);
  }
  return destination;
}

// node_modules/@progress/kendo-charts/dist/es/common/is-object.js
function isObject(value2) {
  return typeof value2 === "object";
}

// node_modules/@progress/kendo-charts/dist/es/common/style-value.js
function styleValue(value2) {
  if (isNumber(value2)) {
    return value2 + "px";
  }
  return value2;
}

// node_modules/@progress/kendo-charts/dist/es/common/element-styles.js
var SIZE_STYLES_REGEX = /width|height|top|left|bottom|right/i;
function isSizeField(field) {
  return SIZE_STYLES_REGEX.test(field);
}
function elementStyles(element, styles) {
  const stylesArray = isString(styles) ? [styles] : styles;
  if (isArray(stylesArray)) {
    const result = {};
    const style = window.getComputedStyle(element);
    for (let idx = 0; idx < stylesArray.length; idx++) {
      let field = stylesArray[idx];
      result[field] = isSizeField(field) ? parseFloat(style[field]) : style[field];
    }
    return result;
  } else if (isObject(styles)) {
    for (let field in styles) {
      element.style[field] = styleValue(styles[field]);
    }
  }
}

// node_modules/@progress/kendo-charts/dist/es/common/get-spacing.js
function getSpacing(value2, defaultSpacing = 0) {
  const spacing = { top: 0, right: 0, bottom: 0, left: 0 };
  if (typeof value2 === "number") {
    spacing[TOP] = spacing[RIGHT] = spacing[BOTTOM] = spacing[LEFT] = value2;
  } else {
    spacing[TOP] = value2[TOP] || defaultSpacing;
    spacing[RIGHT] = value2[RIGHT] || defaultSpacing;
    spacing[BOTTOM] = value2[BOTTOM] || defaultSpacing;
    spacing[LEFT] = value2[LEFT] || defaultSpacing;
  }
  return spacing;
}

// node_modules/@progress/kendo-charts/dist/es/services/template-service.js
var current = {
  compile: function(template) {
    return template;
  }
};
var TemplateService = class {
  static register(userImplementation) {
    current = userImplementation;
  }
  static compile(template, options) {
    return current.compile(template, options);
  }
};
var template_service_default = TemplateService;

// node_modules/@progress/kendo-charts/dist/es/common/get-template.js
function getTemplate(options = {}) {
  let template;
  if (options.template) {
    options.template = template = template_service_default.compile(options.template);
  } else if (isFunction(options.content)) {
    template = options.content;
  }
  return template;
}

// node_modules/@progress/kendo-charts/dist/es/common/get-aria-template.js
function getTemplate2(options = {}) {
  let ariaTemplate;
  if (options.ariaTemplate) {
    options.ariaTemplate = ariaTemplate = template_service_default.compile(options.ariaTemplate);
  } else if (isFunction(options.ariaContent)) {
    ariaTemplate = options.ariaContent;
  }
  return ariaTemplate;
}

// node_modules/@progress/kendo-charts/dist/es/common/getter.js
var FIELD_REGEX = /\[(?:(\d+)|['"](.*?)['"])\]|((?:(?!\[.*?\]|\.).)+)/g;
var getterCache = {};
getterCache["undefined"] = function(obj) {
  return obj;
};
function getter(field) {
  if (getterCache[field]) {
    return getterCache[field];
  }
  const fields = [];
  field.replace(FIELD_REGEX, function(match, index, indexAccessor, field2) {
    fields.push(index !== void 0 ? index : indexAccessor || field2);
  });
  getterCache[field] = function(obj) {
    let result = obj;
    for (let idx = 0; idx < fields.length && result; idx++) {
      result = result[fields[idx]];
    }
    return result;
  };
  return getterCache[field];
}

// node_modules/@progress/kendo-charts/dist/es/common/grep.js
var grep = (array, callback) => array.filter(callback);
var grep_default = grep;

// node_modules/@progress/kendo-charts/dist/es/common/has-classes.js
function hasClasses(element, classNames) {
  if (element.className) {
    const names = classNames.split(" ");
    for (let idx = 0; idx < names.length; idx++) {
      if (element.className.indexOf && element.className.indexOf(names[idx]) !== -1) {
        return true;
      }
    }
  }
}

// node_modules/@progress/kendo-charts/dist/es/common/hash-map.js
var HashMap = class {
  constructor() {
    this._map = /* @__PURE__ */ new Map();
  }
  get(key) {
    return this._map.get(key);
  }
  set(key, value2) {
    this._map.set(key, value2);
  }
};

// node_modules/@progress/kendo-charts/dist/es/common/in-array.js
function inArray(value2, array) {
  if (array) {
    return array.includes(value2);
  }
}

// node_modules/@progress/kendo-charts/dist/es/common/interpolate-value.js
function interpolateValue(start, end, progress) {
  return drawing_exports.util.round(start + (end - start) * progress, COORD_PRECISION);
}

// node_modules/@progress/kendo-charts/dist/es/common/instance-observer.js
var TRIGGER = "trigger";
var InstanceObserver = class {
  constructor(observer, handlers) {
    this.observer = observer;
    this.handlerMap = deepExtend({}, this.handlerMap, handlers);
  }
  trigger(name, args) {
    const { observer, handlerMap } = this;
    let isDefaultPrevented2;
    if (handlerMap[name]) {
      isDefaultPrevented2 = this.callObserver(handlerMap[name], args);
    } else if (observer[TRIGGER]) {
      isDefaultPrevented2 = this.callObserver(TRIGGER, name, args);
    }
    return isDefaultPrevented2;
  }
  callObserver(fnName, ...args) {
    return this.observer[fnName].apply(this.observer, args);
  }
  requiresHandlers(names) {
    if (this.observer.requiresHandlers) {
      return this.observer.requiresHandlers(names);
    }
    for (let idx = 0; idx < names.length; idx++) {
      if (this.handlerMap[names[idx]]) {
        return true;
      }
    }
  }
};
var instance_observer_default = InstanceObserver;

// node_modules/@progress/kendo-charts/dist/es/common/is-plain-object.js
function isPlainObject(value2) {
  return Object.prototype.toString.call(value2) === "[object Object]";
}

// node_modules/@progress/kendo-charts/dist/es/common/map.js
function map(array, callback) {
  const length = array.length;
  const result = [];
  for (let idx = 0; idx < length; idx++) {
    let value2 = callback(array[idx]);
    if (drawing_exports.util.defined(value2)) {
      result.push(value2);
    }
  }
  return result;
}

// node_modules/@progress/kendo-charts/dist/es/common/mousewheel-delta.js
var browser = support_default.browser || {};
function mousewheelDelta(e41) {
  let delta = 0;
  if (e41.wheelDelta) {
    delta = -e41.wheelDelta / 120;
    if (browser.webkit) {
      delta = delta / (2 * Math.max(window.devicePixelRatio, 0.625));
    }
  } else if (e41.detail) {
    delta = e41.detail / 3;
  }
  delta = delta > 0 ? Math.ceil(delta) : Math.floor(delta);
  return delta;
}

// node_modules/@progress/kendo-charts/dist/es/drawing-utils.js
var {
  append,
  bindEvents,
  defined,
  deg,
  elementOffset,
  elementSize,
  eventCoordinates,
  eventElement,
  hashKey,
  last,
  limitValue,
  objectKey,
  rad,
  round,
  unbindEvents,
  valueOrDefault
} = drawing_exports.util;

// node_modules/@progress/kendo-charts/dist/es/common/font-loader.js
var FontLoader = class _FontLoader {
  static fetchFonts(options, fonts, state = { depth: 0 }) {
    const MAX_DEPTH = 5;
    if (!options || state.depth > MAX_DEPTH || !document.fonts) {
      return;
    }
    Object.keys(options).forEach(function(key) {
      const value2 = options[key];
      if (key === "dataSource" || key[0] === "$" || !value2) {
        return;
      }
      if (key === "font") {
        fonts.push(value2);
      } else if (typeof value2 === "object") {
        state.depth++;
        _FontLoader.fetchFonts(value2, fonts, state);
        state.depth--;
      }
    });
  }
  static loadFonts(fonts, callback) {
    let promises = [];
    if (fonts.length > 0 && document.fonts) {
      try {
        promises = fonts.map(function(font) {
          return document.fonts.load(font);
        });
      } catch (e41) {
        logToConsole(e41);
      }
      Promise.all(promises).then(callback, callback);
    } else {
      callback();
    }
  }
  static preloadFonts(options, callback) {
    const fonts = [];
    _FontLoader.fetchFonts(options, fonts);
    _FontLoader.loadFonts(fonts, callback);
  }
};
var font_loader_default = FontLoader;

// node_modules/@progress/kendo-charts/dist/es/common/set-default-options.js
function setDefaultOptions(type, options) {
  const proto = type.prototype;
  if (proto.options) {
    proto.options = deepExtend({}, proto.options, options);
  } else {
    proto.options = options;
  }
}

// node_modules/@progress/kendo-charts/dist/es/common/render-icon.js
var KICON = "k-icon";
var KI_PREFFIX = "k-i-";
var KFONTICON = "k-font-icon";
var KSVGICON = "k-svg-icon";
var KSVG_PREFFIX = "k-svg-i-";
var HTMLBaseIcon = class {
  constructor(element, options) {
    this.element = element;
    this.options = deepExtend({}, this.options, options);
    this.wrapper();
  }
  wrapper() {
    this.addClasses();
  }
  addClasses() {
  }
  html() {
    return this.element.outerHTML;
  }
};
setDefaultOptions(HTMLBaseIcon, {
  name: "",
  size: "none",
  themeColor: "none",
  flip: "default",
  iconClass: "",
  stylingOptions: ["size", "themeColor", "fill"]
});
var HTMLFontIcon = class extends HTMLBaseIcon {
  constructor(element, options) {
    super(element, options);
  }
  wrapper() {
    let currentIconClass = this.element.className.split(" ").find((x7) => x7.startsWith(KI_PREFFIX));
    let className = this.options.icon ? `${this.options.icon.startsWith(KI_PREFFIX) ? "" : KI_PREFFIX}${this.options.icon}` : "";
    this._className = className;
    addClass(this.element, KICON);
    addClass(this.element, KFONTICON);
    removeClass(this.element, currentIconClass);
    addClass(this.element, className);
    addClass(this.element, this.options.iconClass || "");
    super.wrapper();
  }
};
setDefaultOptions(HTMLFontIcon, {
  name: "HTMLFontIcon",
  icon: null
});
var HTMLSvgIcon = class extends HTMLBaseIcon {
  constructor(element, options) {
    element.innerHTML = "";
    super(element, options);
  }
  wrapper() {
    let icon = this.options.icon;
    let iconClass = this.options.iconClass;
    let currentIconClass = this.element.className.split(" ").find((x7) => x7.startsWith(KSVG_PREFFIX));
    if (!icon && iconClass) {
      const regex = /k-i-(\w+(?:-\w+)*)/;
      let iconNameMatch = iconClass.match(regex);
      if (iconNameMatch) {
        icon = iconNameMatch[1];
        iconClass = iconClass.replace(iconNameMatch[0], "");
      }
    }
    if (isString(icon)) {
      icon = icon.replace("k-i-", "").replace(/-./g, (x7) => x7[1].toUpperCase());
      icon = this.options.svgIcons[icon] || this.options.svgIcons[`${icon}Icon`];
    }
    let className = icon && icon.name ? `${KSVG_PREFFIX}${icon.name}` : "";
    this._className = className;
    addClass(this.element, KSVGICON);
    removeClass(this.element, currentIconClass);
    addClass(this.element, className);
    addClass(this.element, iconClass || "");
    this.element.setAttribute("aria-hidden", "true");
    if (icon && isPlainObject(icon)) {
      let svgElement = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svgElement.setAttribute("viewBox", icon.viewBox || "");
      svgElement.setAttribute("focusable", "false");
      svgElement.innerHTML = icon.content || "";
      this.element.appendChild(svgElement);
    }
    super.wrapper();
  }
};
setDefaultOptions(HTMLSvgIcon, {
  name: "HTMLSvgIcon",
  icon: null,
  svgIcons: {}
});
var ICON_TYPES = {
  "svg": HTMLSvgIcon,
  "font": HTMLFontIcon
};
function renderIcon(iconElement, iconOptions) {
  let element = iconElement;
  let options = iconOptions;
  if (!element || isObject(element) && !(element instanceof HTMLElement) || isString(element)) {
    options = element;
    element = document.createElement("span");
  }
  if (isString(options)) {
    options = {
      icon: options
    };
  }
  if (!options.type) {
    options.type = "svg";
  }
  if (!ICON_TYPES[options.type]) {
    return null;
  }
  return new ICON_TYPES[options.type](element, options).html();
}

// node_modules/@progress/kendo-charts/dist/es/common/sparse-array-limits.js
function sparseArrayLimits(arr) {
  let min4 = MAX_VALUE;
  let max3 = MIN_VALUE;
  for (let idx = 0, length = arr.length; idx < length; idx++) {
    const value2 = arr[idx];
    if (value2 !== null && isFinite(value2)) {
      min4 = Math.min(min4, value2);
      max3 = Math.max(max3, value2);
    }
  }
  return {
    min: min4 === MAX_VALUE ? void 0 : min4,
    max: max3 === MIN_VALUE ? void 0 : max3
  };
}

// node_modules/@progress/kendo-charts/dist/es/common/find.js
function find(array, predicate) {
  for (let i37 = 0; i37 < array.length; i37++) {
    const item = array[i37];
    if (predicate(item, i37, array)) {
      return item;
    }
  }
}

// node_modules/@progress/kendo-charts/dist/es/common/element-scale.js
var Matrix = geometry_exports.Matrix;
var matrixRegexp = /matrix\((.*)\)/;
function parseMatrix(matrixString) {
  const match = matrixString.match(matrixRegexp);
  if (match === null || match.length !== 2) {
    return Matrix.unit();
  }
  const members = match[1].split(",").map((x7) => parseFloat(x7));
  return new Matrix(...members);
}
function transformMatrix(element) {
  const transform = getComputedStyle(element).transform;
  if (transform === "none") {
    return Matrix.unit();
  }
  return parseMatrix(transform);
}
function elementScale(element) {
  if (!element) {
    return Matrix.unit();
  }
  let matrix = transformMatrix(element);
  let parent = element.parentElement;
  while (parent) {
    const parentMatrix = transformMatrix(parent);
    matrix = matrix.multiplyCopy(parentMatrix);
    parent = parent.parentElement;
  }
  matrix.b = matrix.c = matrix.e = matrix.f = 0;
  return matrix;
}

// node_modules/@progress/kendo-charts/dist/es/common/auto-text-color.js
function autoTextColor(color) {
  const isDark = new color_default(color).isDark();
  if (isDark) {
    return WHITE;
  }
  return BLACK;
}
var auto_text_color_default = autoTextColor;

// node_modules/@progress/kendo-charts/dist/es/common/create-hash-set.js
var DELETED = {};
var LegacySet = class {
  constructor(values) {
    this._index = {};
    this._values = values ? values.slice(0) : [];
    for (let i37 = 0; i37 < this._values.length; i37++) {
      this._index[this._values[i37]] = i37;
    }
  }
  values() {
    return this._values.filter((item) => item !== DELETED);
  }
  has(value2) {
    return this._index[value2] !== void 0;
  }
  add(value2) {
    if (!this.has(value2)) {
      this._index[value2] = this._values.length;
      this._values.push(value2);
    }
  }
  delete(value2) {
    const index = this._index[value2];
    if (index !== void 0) {
      this._values[index] = DELETED;
      delete this._index[value2];
    }
  }
  clear() {
    this._index = {};
    this._values = [];
  }
  get size() {
    return this._values.length;
  }
};
var SetWrapper = class {
  constructor(values) {
    this._set = new Set(values);
  }
  values() {
    return Array.from(this._set);
  }
  has(value2) {
    return this._set.has(value2);
  }
  add(value2) {
    this._set.add(value2);
  }
  delete(value2) {
    this._set.delete(value2);
  }
  clear() {
    this._set.clear();
  }
  get size() {
    return this._set.size;
  }
};
var supportsSet = () => {
  let supported = false;
  if (typeof Set === "function") {
    const set = /* @__PURE__ */ new Set([1]);
    supported = set.has(1);
  }
  return supported;
};
function createHashSet(values) {
  if (supportsSet()) {
    return new SetWrapper(values);
  }
  return new LegacySet(values);
}

// node_modules/@progress/kendo-charts/dist/es/common/default-error-handler.js
function defaultErrorHandler(error) {
  throw error;
}

// node_modules/@progress/kendo-charts/dist/es/common/keys.js
var keys = {
  INSERT: 45,
  DELETE: 46,
  BACKSPACE: 8,
  TAB: 9,
  ENTER: 13,
  ESC: 27,
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40,
  END: 35,
  HOME: 36,
  SPACEBAR: 32,
  PAGEUP: 33,
  PAGEDOWN: 34,
  F2: 113,
  F10: 121,
  F12: 123,
  NUMPAD_PLUS: 107,
  NUMPAD_MINUS: 109,
  NUMPAD_DOT: 110
};
var keys_default = keys;

// node_modules/@progress/kendo-charts/dist/es/common/has-own-property.js
function hasOwnProperty(obj, property) {
  return Object.prototype.hasOwnProperty.call(obj, property);
}

// node_modules/@progress/kendo-charts/dist/es/common/matrix.js
var Matrix2 = class _Matrix {
  constructor() {
    this.height = 0;
    this.width = 0;
    this.data = [];
  }
  clone() {
    const m10 = new _Matrix();
    m10.height = this.height;
    m10.width = this.width;
    m10.data = this.data.map((row) => row.slice());
    return m10;
  }
  get(row, col) {
    const line = this.data[row];
    const val = line ? line[col] : null;
    return val;
  }
  set(row, col, data) {
    let line = this.data[row];
    if (line == null) {
      line = this.data[row] = [];
    }
    line[col] = data;
    if (row >= this.height) {
      this.height = row + 1;
    }
    if (col >= this.width) {
      this.width = col + 1;
    }
  }
  each(f5, includeEmpty) {
    for (let row = 0; row < this.height; ++row) {
      for (let col = 0; col < this.width; ++col) {
        let val = this.get(row, col);
        if (includeEmpty || val != null) {
          val = f5(val, row, col);
          if (val !== void 0) {
            return val;
          }
        }
      }
    }
  }
  map(f5, includeEmpty) {
    const m10 = new _Matrix();
    this.each(function(el, row, col) {
      m10.set(row, col, f5(el, row, col));
    }, includeEmpty);
    return m10;
  }
  transpose() {
    const m10 = new _Matrix();
    this.each(function(el, row, col) {
      m10.set(col, row, el);
    });
    return m10;
  }
  unit(n21) {
    this.width = this.height = n21;
    const a50 = this.data = new Array(n21);
    for (let i37 = n21; --i37 >= 0; ) {
      const row = a50[i37] = new Array(n21);
      for (let j = n21; --j >= 0; ) {
        row[j] = i37 === j ? 1 : 0;
      }
    }
    return this;
  }
  multiply(b2) {
    const a50 = this;
    const m10 = new _Matrix();
    for (let row = 0; row < a50.height; ++row) {
      for (let col = 0; col < b2.width; ++col) {
        let s10 = 0;
        for (let i37 = 0; i37 < a50.width; ++i37) {
          const va = a50.get(row, i37);
          const vb = b2.get(i37, col);
          if (typeof va === "number" && typeof vb === "number") {
            s10 += va * vb;
          }
        }
        m10.set(row, col, s10);
      }
    }
    return m10;
  }
  inverse() {
    const n21 = this.width;
    const m10 = this.augment(new _Matrix().unit(n21));
    const a50 = m10.data;
    for (let k2 = 0; k2 < n21; ++k2) {
      const imax = argmax(k2, n21, function(i37) {
        return a50[i37][k2];
      });
      if (!a50[imax][k2]) {
        return null;
      }
      if (k2 !== imax) {
        let tmp = a50[k2];
        a50[k2] = a50[imax];
        a50[imax] = tmp;
      }
      for (let i37 = k2 + 1; i37 < n21; ++i37) {
        for (let j = k2 + 1; j < 2 * n21; ++j) {
          a50[i37][j] -= a50[k2][j] * a50[i37][k2] / a50[k2][k2];
        }
        a50[i37][k2] = 0;
      }
    }
    for (let i37 = 0; i37 < n21; ++i37) {
      for (let f5 = a50[i37][i37], j = 0; j < 2 * n21; ++j) {
        a50[i37][j] /= f5;
      }
    }
    for (let k2 = n21; --k2 >= 0; ) {
      for (let i37 = k2; --i37 >= 0; ) {
        if (a50[i37][k2]) {
          for (let j = 2 * n21; --j >= n21; ) {
            a50[i37][j] -= a50[k2][j] * a50[i37][k2];
          }
        }
      }
    }
    return m10.slice(0, n21, n21, n21);
  }
  augment(m10) {
    const ret = this.clone();
    const n21 = ret.width;
    m10.each(function(val, row, col) {
      ret.set(row, col + n21, val);
    });
    return ret;
  }
  slice(row, col, height, width) {
    const m10 = new _Matrix();
    for (let i37 = 0; i37 < height; ++i37) {
      for (let j = 0; j < width; ++j) {
        m10.set(i37, j, this.get(row + i37, col + j));
      }
    }
    return m10;
  }
};
function argmax(start, end, f5) {
  let max3 = f5(start), pos = start;
  for (let i37 = start + 1; i37 < end; i37++) {
    const v5 = f5(start);
    if (v5 > max3) {
      max3 = v5;
      pos = start;
    }
  }
  return pos;
}
var matrix_default = Matrix2;

// node_modules/@progress/kendo-charts/dist/es/common/event-map.js
var eventMap = {
  down: "pointerdown",
  move: "pointermove",
  up: "pointerup",
  cancel: "pointercancel pointerleave"
};
function queryEventMap(e41) {
  return eventMap[e41] || e41;
}
var applyEventMap = (events) => {
  const eventRegEx = /([^ ]+)/g;
  const appliedEvents = events.replace(eventRegEx, queryEventMap);
  return appliedEvents;
};

// node_modules/@progress/kendo-charts/dist/es/core/utils/element-id.js
var elId = 1;
function elementId() {
  return "kchart" + elId++;
}

// node_modules/@progress/kendo-charts/dist/es/core/utils/guid.js
function guid() {
  return elementId();
}

// node_modules/@progress/kendo-charts/dist/es/common/event-utils.js
var elementEventHandlers = /* @__PURE__ */ new WeakMap();
var ID = Symbol("id");
function on(element, events, filter, handler, useCapture) {
  addEventListeners(element, events, filter, handler, useCapture);
}
function off(element, events, filter, handler, useCapture) {
  removeEventListeners(element, events, filter, handler, useCapture);
}
function isString2(value2) {
  return typeof value2 === "string";
}
function addEventListeners(element, events, filter, handler, useCapture) {
  const eventNames = isArray(events) ? events : (events || "").split(" ");
  eventNames.forEach(function(eventName) {
    addEventListener(element, eventName, filter, handler, useCapture);
  });
}
function addEventListener(element, event, filter, handler, useCapture) {
  let eventHandler = handler;
  let eventFilter;
  if (filter && isFunction(filter) && !handler) {
    eventHandler = filter;
  } else if (filter && isString2(filter) && isFunction(eventHandler)) {
    eventFilter = filter;
  }
  const attachedHandler = function(e41) {
    const closestMatchingTarget = e41.target ? e41.target.closest(eventFilter) : null;
    if (!eventFilter || eventFilter && e41.target && closestMatchingTarget) {
      const currentTarget = eventFilter ? closestMatchingTarget : e41.currentTarget;
      Object.defineProperty(e41, "currentTarget", { value: currentTarget });
      Object.defineProperty(e41, "delegateTarget", { value: element });
      eventHandler(e41);
    }
  };
  if (!eventHandler[ID]) {
    eventHandler[ID] = guid();
  }
  let eventHandlers = elementEventHandlers.get(element);
  if (!eventHandlers) {
    eventHandlers = /* @__PURE__ */ new Map();
    elementEventHandlers.set(element, eventHandlers);
  }
  eventHandlers.set(event + eventHandler[ID], attachedHandler);
  element.addEventListener(event, attachedHandler, Boolean(useCapture));
}
function removeEventListeners(element, events, handler, useCapture) {
  const eventNames = isArray(events) ? events : (events || "").split(" ");
  eventNames.forEach(function(eventName) {
    removeEventListener(element, eventName, handler, useCapture);
  });
}
function removeEventListener(element, event, handler, useCapture) {
  const eventHandlers = elementEventHandlers.get(element);
  if (eventHandlers && handler && handler[ID]) {
    const handlerId = event + handler[ID];
    const attachedHandler = eventHandlers.get(handlerId);
    eventHandlers.delete(handlerId);
    if (attachedHandler) {
      element.removeEventListener(event, attachedHandler, Boolean(useCapture));
    }
  }
}

// node_modules/@progress/kendo-charts/dist/es/common/get-supported-features.js
function getSupportedFeatures() {
  const os = detectOS(navigator.userAgent);
  const support = {};
  support.mobileOS = os;
  return support;
}
function detectOS(ua) {
  let os = false;
  const agentRxs = {
    wp: /(Windows Phone(?: OS)?)\s(\d+)\.(\d+(\.\d+)?)/,
    fire: /(Silk)\/(\d+)\.(\d+(\.\d+)?)/,
    android: /(Android|Android.*(?:Opera|Firefox).*?\/)\s*(\d+)\.?(\d+(\.\d+)?)?/,
    iphone: /(iPhone|iPod).*OS\s+(\d+)[._]([\d._]+)/,
    ipad: /(iPad).*OS\s+(\d+)[._]([\d_]+)/,
    playbook: /(PlayBook).*?Tablet\s*OS\s*(\d+)\.(\d+(\.\d+)?)/,
    windows: /(MSIE)\s+(\d+)\.(\d+(\.\d+)?)/,
    tizen: /(tizen).*?Version\/(\d+)\.(\d+(\.\d+)?)/i,
    sailfish: /(sailfish).*rv:(\d+)\.(\d+(\.\d+)?).*firefox/i
  }, osRxs = {
    ios: /^i(phone|pad|pod)$/i,
    android: /^android|fire$/i,
    windows: /windows/,
    wp: /wp/,
    flat: /sailfish|ffos|tizen/i
  };
  for (let agent in agentRxs) {
    let match = ua.match(agentRxs[agent]);
    if (match) {
      if (agent === "windows" && "plugins" in navigator) {
        return false;
      }
      os = {};
      os.device = agent;
      os.name = testRegex(agent, osRxs);
      os[os.name] = true;
      break;
    }
  }
  return os;
}
function testRegex(agent, regexes, dflt) {
  for (let regex in regexes) {
    if (regexes[regex].test(agent)) {
      return regex;
    }
  }
  return dflt !== void 0 ? dflt : agent;
}

// node_modules/@progress/kendo-charts/dist/es/common/noop.js
function noop() {
}

// node_modules/@progress/kendo-charts/dist/es/common/now.js
function now() {
  return (/* @__PURE__ */ new Date()).getTime();
}

// node_modules/@progress/kendo-charts/dist/es/common/observable.js
var STRING2 = "string";
var FUNCTION = "function";
var preventDefault = function() {
  this._defaultPrevented = true;
};
var isDefaultPrevented = function() {
  return this._defaultPrevented === true;
};
var Observable = class {
  constructor() {
    this._events = {};
  }
  destroy() {
    this.unbind();
  }
  bind(event, handlers, one) {
    let that = this, idx, eventNames = typeof event === STRING2 ? [event] : event || [], length, original, handler, handlersIsFunction = typeof handlers === FUNCTION, events;
    if (handlers === void 0) {
      for (idx in event) {
        that.bind(idx, event[idx]);
      }
      return that;
    }
    for (idx = 0, length = eventNames.length; idx < length; idx++) {
      let eventName = eventNames[idx];
      handler = handlersIsFunction ? handlers : handlers[eventName];
      if (handler) {
        if (one) {
          original = handler;
          handler = function() {
            that.unbind(eventName, handler);
            original.apply(that, arguments);
          };
          handler.original = original;
        }
        events = that._events[eventName] = that._events[eventName] || [];
        events.push(handler);
      }
    }
    return that;
  }
  one(eventNames, handlers) {
    return this.bind(eventNames, handlers, true);
  }
  first(eventName, handlers) {
    let that = this, idx, eventNames = typeof eventName === STRING2 ? [eventName] : eventName, length, handler, handlersIsFunction = typeof handlers === FUNCTION, events;
    for (idx = 0, length = eventNames.length; idx < length; idx++) {
      let eventName2 = eventNames[idx];
      handler = handlersIsFunction ? handlers : handlers[eventName2];
      if (handler) {
        events = that._events[eventName2] = that._events[eventName2] || [];
        events.unshift(handler);
      }
    }
    return that;
  }
  trigger(eventName, eventArgs) {
    let that = this, events = that._events[eventName], idx, length;
    if (events) {
      let e41 = eventArgs || {};
      e41.sender = that;
      e41._defaultPrevented = false;
      e41.preventDefault = preventDefault;
      e41.isDefaultPrevented = isDefaultPrevented;
      events = events.slice();
      for (idx = 0, length = events.length; idx < length; idx++) {
        events[idx].call(that, e41);
      }
      return e41._defaultPrevented === true;
    }
    return false;
  }
  unbind(eventName, handler) {
    let that = this, events = that._events[eventName], idx;
    if (eventName === void 0) {
      that._events = {};
    } else if (events) {
      if (handler) {
        for (idx = events.length - 1; idx >= 0; idx--) {
          if (events[idx] === handler || events[idx].original === handler) {
            events.splice(idx, 1);
          }
        }
      } else {
        that._events[eventName] = [];
      }
    }
    return that;
  }
  _setEvents(options) {
    const length = (this.events || []).length;
    for (let idx = 0; idx < length; idx++) {
      let e41 = this.events[idx];
      if (this.options[e41] && options[e41]) {
        this.unbind(e41, this.options[e41]);
        if (this._events && this._events[e41]) {
          delete this._events[e41];
        }
      }
    }
    this.bind(this.events, options);
  }
};

// node_modules/@progress/kendo-charts/dist/es/common/user-events.js
var extend = Object.assign;
var preventDefault2 = (e41) => {
  e41.preventDefault();
};
var DEFAULT_MIN_HOLD = 800;
var CLICK_DELAY = 300;
var DEFAULT_THRESHOLD = 0;
var PRESS = "press";
var HOLD = "hold";
var SELECT = "select";
var START2 = "start";
var MOVE = "move";
var END2 = "end";
var CANCEL = "cancel";
var TAP = "tap";
var DOUBLETAP = "doubleTap";
var RELEASE = "release";
var GESTURESTART = "gesturestart";
var GESTURECHANGE = "gesturechange";
var GESTUREEND = "gestureend";
var GESTURETAP = "gesturetap";
var THRESHOLD = {
  "api": 0,
  "touch": 0,
  "mouse": 9,
  "pointer": 9
};
function touchDelta(touch1, touch2) {
  let x1 = touch1.x.location, y1 = touch1.y.location, x22 = touch2.x.location, y2 = touch2.y.location, dx = x1 - x22, dy = y1 - y2;
  return {
    center: {
      x: (x1 + x22) / 2,
      y: (y1 + y2) / 2
    },
    distance: Math.sqrt(dx * dx + dy * dy)
  };
}
function getTouches(e41) {
  let touches = [], originalEvent = e41.originalEvent || e41, currentTarget = e41.currentTarget;
  if (e41.api) {
    touches.push({
      id: 2,
      // hardcoded ID for API call
      event: e41,
      target: e41.target,
      currentTarget: e41.target,
      location: e41,
      type: "api"
    });
  } else {
    touches.push({
      location: originalEvent,
      event: e41,
      target: e41.target,
      currentTarget,
      id: originalEvent.pointerId,
      type: "pointer"
    });
  }
  return touches;
}
var TouchAxis = class {
  constructor(axis, location) {
    let that = this;
    that.support = getSupportedFeatures();
    that.invalidZeroEvents = this.support.mobileOS && this.support.mobileOS.android;
    that.axis = axis;
    that._updateLocationData(location);
    that.startLocation = that.location;
    that.velocity = that.delta = 0;
    that.timeStamp = now();
  }
  move(location) {
    let that = this, offset = location["page" + that.axis], timeStamp = now(), timeDelta = timeStamp - that.timeStamp || 1;
    if (!offset && this.invalidZeroEvents) {
      return;
    }
    that.delta = offset - that.location;
    that._updateLocationData(location);
    that.initialDelta = offset - that.startLocation;
    that.velocity = that.delta / timeDelta;
    that.timeStamp = timeStamp;
  }
  _updateLocationData(location) {
    let that = this, axis = that.axis;
    that.location = location["page" + axis];
    that.client = location["client" + axis];
    that.screen = location["screen" + axis];
  }
};
var Touch = class {
  constructor(userEvents, target, touchInfo) {
    extend(this, {
      x: new TouchAxis("X", touchInfo.location),
      y: new TouchAxis("Y", touchInfo.location),
      type: touchInfo.type,
      threshold: userEvents.threshold || THRESHOLD[touchInfo.type],
      userEvents,
      target,
      currentTarget: touchInfo.currentTarget,
      initialTouch: touchInfo.target,
      id: touchInfo.id,
      pressEvent: touchInfo,
      _clicks: userEvents._clicks,
      supportDoubleTap: userEvents.supportDoubleTap,
      _moved: false,
      _finished: false
    });
  }
  press() {
    this._holdTimeout = setTimeout(() => this._hold(), this.userEvents.minHold);
    this._trigger(PRESS, this.pressEvent);
  }
  _tap(touchInfo) {
    let that = this;
    that.userEvents._clicks++;
    if (that.userEvents._clicks === 1) {
      that._clickTimeout = setTimeout(function() {
        if (that.userEvents._clicks === 1) {
          that._trigger(TAP, touchInfo);
        } else {
          that._trigger(DOUBLETAP, touchInfo);
        }
        that.userEvents._clicks = 0;
      }, CLICK_DELAY);
    }
  }
  _hold() {
    this._trigger(HOLD, this.pressEvent);
  }
  /* eslint-disable consistent-return */
  move(touchInfo) {
    let that = this;
    let preventMove = touchInfo.type !== "api" && that.userEvents._shouldNotMove;
    if (that._finished || preventMove) {
      return;
    }
    that.x.move(touchInfo.location);
    that.y.move(touchInfo.location);
    if (!that._moved) {
      if (that._withinIgnoreThreshold()) {
        return;
      }
      if (!UserEvents.current || UserEvents.current === that.userEvents) {
        that._start(touchInfo);
      } else {
        return that.dispose();
      }
    }
    if (!that._finished) {
      that._trigger(MOVE, touchInfo);
    }
  }
  /* eslint-enable consistent-return */
  end(touchInfo) {
    this.endTime = now();
    if (this._finished) {
      return;
    }
    this._finished = true;
    this._trigger(RELEASE, touchInfo);
    if (this._moved) {
      this._trigger(END2, touchInfo);
    } else {
      if (this.supportDoubleTap) {
        this._tap(touchInfo);
      } else {
        this._trigger(TAP, touchInfo);
      }
    }
    clearTimeout(this._holdTimeout);
    this.dispose();
  }
  dispose() {
    let userEvents = this.userEvents, activeTouches = userEvents.touches || [];
    this._finished = true;
    this.pressEvent = null;
    clearTimeout(this._holdTimeout);
    const activeTouchIndex = activeTouches.indexOf(this);
    activeTouches.splice(activeTouchIndex, 1);
  }
  skip() {
    this.dispose();
  }
  cancel() {
    this.dispose();
  }
  isMoved() {
    return this._moved;
  }
  _start(touchInfo) {
    clearTimeout(this._holdTimeout);
    this.startTime = now();
    this._moved = true;
    this._trigger(START2, touchInfo);
  }
  _trigger(name, touchInfo) {
    const e41 = touchInfo.event;
    const data = {
      touch: this,
      x: this.x,
      y: this.y,
      target: this.target,
      event: e41
    };
    if (this.userEvents.notify(name, data)) {
      e41.preventDefault();
    }
  }
  _withinIgnoreThreshold() {
    let xDelta = this.x.initialDelta, yDelta = this.y.initialDelta;
    return Math.sqrt(xDelta * xDelta + yDelta * yDelta) <= this.threshold;
  }
};
function withEachUpEvent(callback) {
  let downEvents = eventMap.up.split(" "), idx = 0, length = downEvents.length;
  for (; idx < length; idx++) {
    callback(downEvents[idx]);
  }
}
var UserEvents = class _UserEvents extends Observable {
  constructor(element, options) {
    super();
    let that = this;
    let filter;
    const support = getSupportedFeatures();
    this.support = support;
    options = options || {};
    this.options = options;
    filter = that.filter = options.filter;
    that.threshold = options.threshold || DEFAULT_THRESHOLD;
    that.minHold = options.minHold || DEFAULT_MIN_HOLD;
    that.touches = [];
    that._maxTouches = options.multiTouch ? 2 : 1;
    that.allowSelection = options.allowSelection;
    that.captureUpIfMoved = options.captureUpIfMoved;
    that._clicks = 0;
    that.supportDoubleTap = options.supportDoubleTap;
    extend(that, {
      element,
      surface: options.surface || element,
      stopPropagation: options.stopPropagation,
      pressed: false
    });
    this._surfaceMoveHandler = this._move.bind(this);
    on(that.surface, applyEventMap("move"), this._surfaceMoveHandler);
    this._surfaceEndHandler = this._end.bind(this);
    on(that.surface, applyEventMap("up cancel"), this._surfaceEndHandler);
    this._elementStartHandler = this._start.bind(this);
    on(element, applyEventMap("down"), filter, this._elementStartHandler);
    element.style["touch-action"] = options.touchAction || "none";
    if (options.preventDragEvent) {
      this._elementDragStartHandler = preventDefault2;
      on(element, applyEventMap("dragstart"), this._elementDragStartHandler);
    }
    this._elementSelectHandler = this._select.bind(this);
    on(element, applyEventMap("mousedown"), filter, this._elementSelectHandler);
    if (that.captureUpIfMoved) {
      let surfaceElement = that.surface;
      that._preventIfMovingProxy = that.preventIfMoving.bind(that);
      withEachUpEvent(function(eventName) {
        surfaceElement.addEventListener(eventName, that._preventIfMovingProxy, true);
      });
    }
    that.bind([
      PRESS,
      HOLD,
      TAP,
      DOUBLETAP,
      START2,
      MOVE,
      END2,
      RELEASE,
      CANCEL,
      GESTURESTART,
      GESTURECHANGE,
      GESTUREEND,
      GESTURETAP,
      SELECT
    ], options);
  }
  preventIfMoving(e41) {
    if (this._isMoved()) {
      e41.preventDefault();
    }
  }
  destroy() {
    let that = this;
    const options = this.options;
    const element = this.element;
    if (that._destroyed) {
      return;
    }
    that._destroyed = true;
    if (that.captureUpIfMoved) {
      let surfaceElement = that.surface;
      withEachUpEvent(function(eventName) {
        surfaceElement.removeEventListener(eventName, that._preventIfMovingProxy, true);
      });
    }
    off(that.surface, applyEventMap("move"), this._surfaceMoveHandler);
    off(that.surface, applyEventMap("up cancel"), this._surfaceEndHandler);
    off(element, applyEventMap("down"), this._elementStartHandler);
    if (options.preventDragEvent) {
      off(element, applyEventMap("dragstart"), this._elementDragStartHandler);
    }
    off(element, applyEventMap("mousedown"), this._elementSelectHandler);
    that._disposeAll();
    that.unbind();
    delete that.surface;
    delete that.element;
    delete that.currentTarget;
  }
  capture() {
    _UserEvents.current = this;
  }
  cancel() {
    this._disposeAll();
    this.trigger(CANCEL);
  }
  notify(event, data) {
    let that = this, touches = that.touches;
    let eventName = event;
    if (this._isMultiTouch()) {
      switch (eventName) {
        case MOVE:
          eventName = GESTURECHANGE;
          break;
        case END2:
          eventName = GESTUREEND;
          break;
        case TAP:
          eventName = GESTURETAP;
          break;
        default:
          break;
      }
      extend(data, {
        touches
      }, touchDelta(touches[0], touches[1]));
    }
    return this.trigger(eventName, extend(data, {
      type: eventName
    }));
  }
  press(x7, y2, target) {
    this._apiCall("_start", x7, y2, target);
  }
  move(x7, y2) {
    this._apiCall("_move", x7, y2);
  }
  end(x7, y2) {
    this._apiCall("_end", x7, y2);
  }
  _isMultiTouch() {
    return this.touches.length > 1;
  }
  _maxTouchesReached() {
    return this.touches.length >= this._maxTouches;
  }
  _disposeAll() {
    let touches = this.touches;
    while (touches.length > 0) {
      touches.pop().dispose();
    }
  }
  _isMoved() {
    return grep_default(this.touches, function(touch) {
      return touch.isMoved();
    }).length;
  }
  _select(e41) {
    if (!this.allowSelection || this.trigger(SELECT, { event: e41 })) {
      e41.preventDefault();
    }
  }
  _start(e41) {
    if (e41.which && e41.which > 1 || this._maxTouchesReached()) {
      return;
    }
    _UserEvents.current = null;
    this.currentTarget = e41.currentTarget;
    if (this.stopPropagation) {
      e41.stopPropagation();
    }
    let target;
    const eventTouches = getTouches(e41);
    for (let idx = 0; idx < eventTouches.length; idx++) {
      if (this._maxTouchesReached()) {
        break;
      }
      const eventTouch = eventTouches[idx];
      if (this.filter) {
        target = eventTouch.currentTarget;
      } else {
        target = this.element;
      }
      if (target && target.length === 0) {
        continue;
      }
      const touch = new Touch(this, target, eventTouch);
      this.touches.push(touch);
      touch.press();
      if (this._isMultiTouch()) {
        this.notify("gesturestart", {});
      }
    }
  }
  _move(e41) {
    this._eachTouch("move", e41);
  }
  _end(e41) {
    this._eachTouch("end", e41);
  }
  _eachTouch(methodName, e41) {
    let that = this, dict = {}, touches = getTouches(e41), activeTouches = that.touches, idx, touch, touchInfo, matchingTouch;
    for (idx = 0; idx < activeTouches.length; idx++) {
      touch = activeTouches[idx];
      dict[touch.id] = touch;
    }
    for (idx = 0; idx < touches.length; idx++) {
      touchInfo = touches[idx];
      matchingTouch = dict[touchInfo.id];
      if (matchingTouch) {
        const shouldCapture = methodName === "move" && touchInfo.type === "pointer" && !this.surface.hasPointerCapture(touchInfo.id);
        if (shouldCapture) {
          this.surface.setPointerCapture(touchInfo.id);
        }
        matchingTouch[methodName](touchInfo);
      }
    }
  }
  _apiCall(type, x7, y2, target) {
    this[type]({
      api: true,
      pageX: x7,
      pageY: y2,
      clientX: x7,
      clientY: y2,
      target: target || this.element,
      stopPropagation: noop,
      preventDefault: noop
    });
  }
  static defaultThreshold(value2) {
    DEFAULT_THRESHOLD = value2;
  }
  static minHold(value2) {
    DEFAULT_MIN_HOLD = value2;
  }
};

// node_modules/@progress/kendo-charts/dist/es/core/utils/auto-major-unit.js
function autoMajorUnit(min4, max3) {
  let diff = round(max3 - min4, DEFAULT_PRECISION - 1);
  if (diff === 0) {
    if (max3 === 0) {
      return 0.1;
    }
    diff = Math.abs(max3);
  }
  const scale = Math.pow(10, Math.floor(Math.log(diff) / Math.log(10)));
  const relativeValue = round(diff / scale, DEFAULT_PRECISION);
  let scaleMultiplier = 1;
  if (relativeValue < 1.904762) {
    scaleMultiplier = 0.2;
  } else if (relativeValue < 4.761904) {
    scaleMultiplier = 0.5;
  } else if (relativeValue < 9.523809) {
    scaleMultiplier = 1;
  } else {
    scaleMultiplier = 2;
  }
  return round(scale * scaleMultiplier, DEFAULT_PRECISION);
}

// node_modules/@progress/kendo-charts/dist/es/core/point.js
var Point = class _Point {
  constructor(x7, y2) {
    this.x = x7 || 0;
    this.y = y2 || 0;
  }
  clone() {
    return new _Point(this.x, this.y);
  }
  equals(point) {
    return point && this.x === point.x && this.y === point.y;
  }
  rotate(center, degrees) {
    const theta = rad(degrees);
    const cosT = Math.cos(theta);
    const sinT = Math.sin(theta);
    const { x: cx, y: cy } = center;
    const { x: x7, y: y2 } = this;
    this.x = round(
      cx + (x7 - cx) * cosT + (y2 - cy) * sinT,
      COORD_PRECISION
    );
    this.y = round(
      cy + (y2 - cy) * cosT - (x7 - cx) * sinT,
      COORD_PRECISION
    );
    return this;
  }
  multiply(a50) {
    this.x *= a50;
    this.y *= a50;
    return this;
  }
  distanceTo(point) {
    const dx = this.x - point.x;
    const dy = this.y - point.y;
    return Math.sqrt(dx * dx + dy * dy);
  }
  static onCircle(center, angle, radius) {
    const radians = rad(angle);
    return new _Point(
      center.x - radius * Math.cos(radians),
      center.y - radius * Math.sin(radians)
    );
  }
};
var point_default = Point;

// node_modules/@progress/kendo-charts/dist/es/core/box.js
var Box = class _Box {
  constructor(x1, y1, x22, y2) {
    this.x1 = x1 || 0;
    this.y1 = y1 || 0;
    this.x2 = x22 || 0;
    this.y2 = y2 || 0;
  }
  equals(box) {
    return this.x1 === box.x1 && this.x2 === box.x2 && this.y1 === box.y1 && this.y2 === box.y2;
  }
  width() {
    return this.x2 - this.x1;
  }
  height() {
    return this.y2 - this.y1;
  }
  translate(dx, dy) {
    this.x1 += dx;
    this.x2 += dx;
    this.y1 += dy;
    this.y2 += dy;
    return this;
  }
  move(x7, y2) {
    const height = this.height();
    const width = this.width();
    if (x7 !== void 0) {
      this.x1 = x7;
      this.x2 = this.x1 + width;
    }
    if (y2 !== void 0) {
      this.y1 = y2;
      this.y2 = this.y1 + height;
    }
    return this;
  }
  wrap(targetBox) {
    this.x1 = Math.min(this.x1, targetBox.x1);
    this.y1 = Math.min(this.y1, targetBox.y1);
    this.x2 = Math.max(this.x2, targetBox.x2);
    this.y2 = Math.max(this.y2, targetBox.y2);
    return this;
  }
  wrapLimit(targetBox, widthLimit, heightLimit) {
    this.x1 = Math.min(this.x1, Math.max(this.x1 - widthLimit, targetBox.x1));
    this.y1 = Math.min(this.y1, Math.max(this.y1 - heightLimit, targetBox.y1));
    this.x2 = Math.max(this.x2, Math.min(this.x2 + widthLimit, targetBox.x2));
    this.y2 = Math.max(this.y2, Math.min(this.y2 + heightLimit, targetBox.y2));
    return this;
  }
  wrapPoint(point) {
    const arrayPoint = isArray(point);
    const x7 = arrayPoint ? point[0] : point.x;
    const y2 = arrayPoint ? point[1] : point.y;
    this.wrap(new _Box(x7, y2, x7, y2));
    return this;
  }
  snapTo(targetBox, axis) {
    if (axis === X || !axis) {
      this.x1 = targetBox.x1;
      this.x2 = targetBox.x2;
    }
    if (axis === Y || !axis) {
      this.y1 = targetBox.y1;
      this.y2 = targetBox.y2;
    }
    return this;
  }
  alignTo(targetBox, anchor) {
    const height = this.height();
    const width = this.width();
    const axis = anchor === TOP || anchor === BOTTOM ? Y : X;
    const offset = axis === Y ? height : width;
    if (anchor === CENTER) {
      const targetCenter = targetBox.center();
      const center = this.center();
      this.x1 += targetCenter.x - center.x;
      this.y1 += targetCenter.y - center.y;
    } else if (anchor === TOP || anchor === LEFT) {
      this[axis + 1] = targetBox[axis + 1] - offset;
    } else {
      this[axis + 1] = targetBox[axis + 2];
    }
    this.x2 = this.x1 + width;
    this.y2 = this.y1 + height;
    return this;
  }
  shrink(dw, dh) {
    this.x2 -= dw;
    this.y2 -= dh;
    return this;
  }
  expand(dw, dh) {
    this.shrink(-dw, -dh);
    return this;
  }
  pad(padding) {
    const spacing = getSpacing(padding);
    this.x1 -= spacing.left;
    this.x2 += spacing.right;
    this.y1 -= spacing.top;
    this.y2 += spacing.bottom;
    return this;
  }
  unpad(padding) {
    const spacing = getSpacing(padding);
    spacing.left = -spacing.left;
    spacing.top = -spacing.top;
    spacing.right = -spacing.right;
    spacing.bottom = -spacing.bottom;
    return this.pad(spacing);
  }
  clone() {
    return new _Box(this.x1, this.y1, this.x2, this.y2);
  }
  center() {
    return new point_default(
      this.x1 + this.width() / 2,
      this.y1 + this.height() / 2
    );
  }
  containsPoint(point) {
    return point.x >= this.x1 && point.x <= this.x2 && point.y >= this.y1 && point.y <= this.y2;
  }
  points() {
    return [
      new point_default(this.x1, this.y1),
      new point_default(this.x2, this.y1),
      new point_default(this.x2, this.y2),
      new point_default(this.x1, this.y2)
    ];
  }
  getHash() {
    return [this.x1, this.y1, this.x2, this.y2].join(",");
  }
  overlaps(box) {
    return !(box.y2 < this.y1 || this.y2 < box.y1 || box.x2 < this.x1 || this.x2 < box.x1);
  }
  rotate(rotation) {
    let width = this.width();
    let height = this.height();
    const { x: cx, y: cy } = this.center();
    const r1 = rotatePoint(0, 0, cx, cy, rotation);
    const r28 = rotatePoint(width, 0, cx, cy, rotation);
    const r32 = rotatePoint(width, height, cx, cy, rotation);
    const r42 = rotatePoint(0, height, cx, cy, rotation);
    width = Math.max(r1.x, r28.x, r32.x, r42.x) - Math.min(r1.x, r28.x, r32.x, r42.x);
    height = Math.max(r1.y, r28.y, r32.y, r42.y) - Math.min(r1.y, r28.y, r32.y, r42.y);
    this.x2 = this.x1 + width;
    this.y2 = this.y1 + height;
    return this;
  }
  toRect() {
    return new geometry_exports.Rect([this.x1, this.y1], [this.width(), this.height()]);
  }
  hasSize() {
    return this.width() !== 0 && this.height() !== 0;
  }
  align(targetBox, axis, alignment) {
    if (axis === X) {
      this.alignX(targetBox, alignment);
    } else {
      this.alignY(targetBox, alignment);
    }
    return this;
  }
  alignX(targetBox, alignment) {
    const width = this.width();
    if (alignment === LEFT) {
      this.x1 = targetBox.x1;
      this.x2 = this.x1 + width;
    } else if (alignment === RIGHT) {
      this.x2 = targetBox.x2;
      this.x1 = this.x2 - width;
    } else if (alignment === CENTER) {
      this.x1 = targetBox.x1 + (targetBox.width() - width) / 2;
      this.x2 = this.x1 + width;
    }
  }
  alignY(targetBox, alignment) {
    const height = this.height();
    if (alignment === TOP) {
      this.y1 = targetBox.y1;
      this.y2 = this.y1 + height;
    } else if (alignment === BOTTOM) {
      this.y2 = targetBox.y2;
      this.y1 = this.y2 - height;
    } else if (alignment === CENTER) {
      this.y1 = targetBox.y1 + (targetBox.height() - height) / 2;
      this.y2 = this.y1 + height;
    }
  }
};
function rotatePoint(x7, y2, cx, cy, angle) {
  const theta = rad(angle);
  return new point_default(
    cx + (x7 - cx) * Math.cos(theta) + (y2 - cy) * Math.sin(theta),
    cy - (x7 - cx) * Math.sin(theta) + (y2 - cy) * Math.cos(theta)
  );
}
var box_default = Box;

// node_modules/@progress/kendo-charts/dist/es/core/ring.js
var Ring = class _Ring {
  constructor(center, innerRadius, radius, startAngle, angle) {
    this.center = center;
    this.innerRadius = innerRadius;
    this.radius = radius;
    this.startAngle = startAngle;
    this.angle = angle;
  }
  clone() {
    return new _Ring(this.center, this.innerRadius, this.radius, this.startAngle, this.angle);
  }
  middle() {
    return this.startAngle + this.angle / 2;
  }
  setRadius(newRadius, innerRadius) {
    if (innerRadius) {
      this.innerRadius = newRadius;
    } else {
      this.radius = newRadius;
    }
    return this;
  }
  // TODO: Remove and replace with Point.onCircle
  point(angle, innerRadius) {
    const radianAngle = rad(angle);
    const ax = Math.cos(radianAngle);
    const ay = Math.sin(radianAngle);
    const radius = innerRadius ? this.innerRadius : this.radius;
    const x7 = round(this.center.x - ax * radius, COORD_PRECISION);
    const y2 = round(this.center.y - ay * radius, COORD_PRECISION);
    return new point_default(x7, y2);
  }
  adjacentBox(distance, width, height) {
    const sector = this.clone().expand(distance);
    const midAndle = sector.middle();
    const midPoint = sector.point(midAndle);
    const hw = width / 2;
    const hh = height / 2;
    const sa = Math.sin(rad(midAndle));
    const ca = Math.cos(rad(midAndle));
    let x7 = midPoint.x - hw;
    let y2 = midPoint.y - hh;
    if (Math.abs(sa) < 0.9) {
      x7 += hw * -ca / Math.abs(ca);
    }
    if (Math.abs(ca) < 0.9) {
      y2 += hh * -sa / Math.abs(sa);
    }
    return new box_default(x7, y2, x7 + width, y2 + height);
  }
  containsPoint(p9) {
    const center = this.center;
    const innerRadius = this.innerRadius;
    const radius = this.radius;
    const startAngle = this.startAngle;
    const endAngle = this.startAngle + this.angle;
    const dx = p9.x - center.x;
    const dy = p9.y - center.y;
    const vector = new point_default(dx, dy);
    const startPoint = this.point(startAngle);
    const startVector = new point_default(startPoint.x - center.x, startPoint.y - center.y);
    const endPoint = this.point(endAngle);
    const endVector = new point_default(endPoint.x - center.x, endPoint.y - center.y);
    const dist = round(dx * dx + dy * dy, COORD_PRECISION);
    return (startVector.equals(vector) || clockwise(startVector, vector)) && !clockwise(endVector, vector) && dist >= innerRadius * innerRadius && dist <= radius * radius;
  }
  getBBox() {
    const box = new box_default(MAX_VALUE, MAX_VALUE, MIN_VALUE, MIN_VALUE);
    const startAngle = round(this.startAngle % 360);
    const endAngle = round((startAngle + this.angle) % 360);
    const innerRadius = this.innerRadius;
    const allAngles = [0, 90, 180, 270, startAngle, endAngle].sort(numericComparer);
    const startAngleIndex = allAngles.indexOf(startAngle);
    const endAngleIndex = allAngles.indexOf(endAngle);
    let angles;
    if (startAngle === endAngle) {
      angles = allAngles;
    } else {
      if (startAngleIndex < endAngleIndex) {
        angles = allAngles.slice(startAngleIndex, endAngleIndex + 1);
      } else {
        angles = [].concat(
          allAngles.slice(0, endAngleIndex + 1),
          allAngles.slice(startAngleIndex, allAngles.length)
        );
      }
    }
    for (let i37 = 0; i37 < angles.length; i37++) {
      let point = this.point(angles[i37]);
      box.wrapPoint(point);
      box.wrapPoint(point, innerRadius);
    }
    if (!innerRadius) {
      box.wrapPoint(this.center);
    }
    return box;
  }
  expand(value2) {
    this.radius += value2;
    return this;
  }
};
function numericComparer(a50, b2) {
  return a50 - b2;
}
var ring_default = Ring;

// node_modules/@progress/kendo-charts/dist/es/core/shape-builder.js
var DIRECTION_ANGLE = 1e-3;
var ShapeBuilder = class {
  createRing(sector, options) {
    const startAngle = sector.startAngle + 180;
    let endAngle = sector.angle + startAngle;
    if (sector.angle === 0 || sector.angle > 0 && startAngle === endAngle) {
      endAngle += DIRECTION_ANGLE;
    }
    const center = new geometry_exports.Point(sector.center.x, sector.center.y);
    const radius = Math.max(sector.radius, 0);
    const innerRadius = Math.max(sector.innerRadius, 0);
    const arc = new geometry_exports.Arc(center, {
      startAngle,
      endAngle,
      radiusX: radius,
      radiusY: radius
    });
    const path = drawing_exports.Path.fromArc(arc, options).close();
    if (innerRadius) {
      arc.radiusX = arc.radiusY = innerRadius;
      const innerEnd = arc.pointAt(endAngle);
      path.lineTo(innerEnd.x, innerEnd.y);
      path.arc(endAngle, startAngle, innerRadius, innerRadius, true);
    } else {
      path.lineTo(center.x, center.y);
    }
    return path;
  }
};
ShapeBuilder.current = new ShapeBuilder();
var shape_builder_default = ShapeBuilder;

// node_modules/@progress/kendo-charts/dist/es/core/chart-element.js
var ChartElement = class {
  constructor(options) {
    this.children = [];
    this.initOptions(options);
  }
  initOptions(options) {
    this.options = deepExtend({}, this.options, this.initUserOptions(options));
  }
  initUserOptions(options) {
    return options;
  }
  reflow(targetBox) {
    const children = this.children;
    let box;
    for (let i37 = 0; i37 < children.length; i37++) {
      let currentChild = children[i37];
      currentChild.reflow(targetBox);
      box = box ? box.wrap(currentChild.box) : currentChild.box.clone();
    }
    this.box = box || targetBox;
  }
  destroy() {
    const children = this.children;
    if (this.animation) {
      this.animation.destroy();
    }
    for (let i37 = 0; i37 < children.length; i37++) {
      children[i37].destroy();
    }
  }
  getRoot() {
    const parent = this.parent;
    return parent ? parent.getRoot() : null;
  }
  getSender() {
    const service = this.getService();
    if (service) {
      return service.sender;
    }
  }
  getService() {
    let element = this;
    while (element) {
      if (element.chartService) {
        return element.chartService;
      }
      element = element.parent;
    }
  }
  translateChildren(dx, dy) {
    const children = this.children;
    const childrenCount = children.length;
    for (let i37 = 0; i37 < childrenCount; i37++) {
      children[i37].box.translate(dx, dy);
    }
  }
  append() {
    for (let i37 = 0; i37 < arguments.length; i37++) {
      let item = arguments[i37];
      this.children.push(item);
      item.parent = this;
    }
  }
  renderVisual() {
    if (this.options.visible === false) {
      return;
    }
    this.createVisual();
    this.addVisual();
    this.renderChildren();
    this.createAnimation();
    this.renderComplete();
  }
  addVisual() {
    if (this.visual) {
      this.visual.chartElement = this;
      if (this.parent) {
        this.parent.appendVisual(this.visual);
      }
    }
  }
  renderChildren() {
    const children = this.children;
    const length = children.length;
    for (let i37 = 0; i37 < length; i37++) {
      children[i37].renderVisual();
    }
  }
  createVisual() {
    this.visual = new drawing_exports.Group({
      zIndex: this.options.zIndex,
      visible: valueOrDefault(this.options.visible, true)
    });
  }
  createAnimation() {
    if (this.visual && this.options.animation) {
      this.animation = drawing_exports.Animation.create(
        this.visual,
        this.options.animation
      );
    }
  }
  appendVisual(childVisual) {
    if (!childVisual.chartElement) {
      childVisual.chartElement = this;
    }
    if (childVisual.options.noclip) {
      this.clipRoot().visual.append(childVisual);
    } else if (childVisual.options.zIndex !== void 0) {
      this.stackRoot().stackVisual(childVisual);
    } else if (this.isStackRoot) {
      this.stackVisual(childVisual);
    } else if (this.visual) {
      this.visual.append(childVisual);
    } else {
      this.parent.appendVisual(childVisual);
    }
  }
  clipRoot() {
    if (this.parent) {
      return this.parent.clipRoot();
    }
    return this;
  }
  stackRoot() {
    if (this.parent) {
      return this.parent.stackRoot();
    }
    return this;
  }
  stackVisual(childVisual) {
    const zIndex = childVisual.options.zIndex || 0;
    const visuals = this.visual.children;
    const length = visuals.length;
    let pos;
    for (pos = 0; pos < length; pos++) {
      let sibling = visuals[pos];
      let here = valueOrDefault(sibling.options.zIndex, 0);
      if (here > zIndex) {
        break;
      }
    }
    this.visual.insert(pos, childVisual);
  }
  traverse(callback) {
    const children = this.children;
    const length = children.length;
    for (let i37 = 0; i37 < length; i37++) {
      let child = children[i37];
      callback(child);
      if (child.traverse) {
        child.traverse(callback);
      }
    }
  }
  closest(match) {
    let element = this;
    let matched = false;
    while (element && !matched) {
      matched = match(element);
      if (!matched) {
        element = element.parent;
      }
    }
    if (matched) {
      return element;
    }
  }
  renderComplete() {
  }
  hasHighlight() {
    const options = (this.options || {}).highlight;
    return !(!this.createHighlight || options && options.visible === false || this.visible === false);
  }
  toggleHighlight(show2, opacity) {
    const options = (this.options || {}).highlight || {};
    const customVisual = options.visual;
    let highlight = this._highlight;
    if (!highlight) {
      const highlightOptions2 = {
        fill: {
          color: WHITE,
          opacity: opacity || 0.2
        },
        stroke: {
          color: WHITE,
          width: 1,
          opacity: opacity || 0.2
        }
      };
      if (customVisual) {
        highlight = this._highlight = customVisual(
          Object.assign(this.highlightVisualArgs(), {
            createVisual: () => this.createHighlight(highlightOptions2),
            sender: this.getSender(),
            series: this.series,
            dataItem: this.dataItem,
            category: this.category,
            value: this.value,
            percentage: this.percentage,
            runningTotal: this.runningTotal,
            total: this.total
          })
        );
        if (!highlight) {
          return;
        }
      } else {
        highlight = this._highlight = this.createHighlight(highlightOptions2);
      }
      if (highlight.options.zIndex === void 0) {
        highlight.options.zIndex = valueOrDefault(options.zIndex, this.options.zIndex);
      }
      this.appendVisual(highlight);
    }
    highlight.visible(show2);
  }
  toggleFocusHighlight(show2) {
    const options = (this.options || {}).focusHighlight || {};
    let focusHighlight = this._focusHighlight;
    if (!show2 && !focusHighlight) {
      return;
    }
    if (!focusHighlight) {
      const rootBackground = this.getRoot().options.background;
      const highlightColor = auto_text_color_default(rootBackground);
      const focusHighlightOptions = {
        fill: {
          opacity: options.opacity,
          color: options.color
        },
        stroke: Object.assign({}, { color: highlightColor }, options.border),
        zIndex: options.zIndex
      };
      focusHighlight = this._focusHighlight = this.createFocusHighlight(focusHighlightOptions);
      this.appendVisual(focusHighlight);
    }
    focusHighlight.visible(show2);
  }
  createGradientOverlay(element, options, gradientOptions) {
    const overlay = new drawing_exports.Path(Object.assign({
      stroke: {
        color: "none"
      },
      fill: this.createGradient(gradientOptions),
      closed: element.options.closed
    }, options));
    overlay.segments.elements(element.segments.elements());
    return overlay;
  }
  createGradient(options) {
    if (this.parent) {
      return this.parent.createGradient(options);
    }
  }
  supportsPointInactiveOpacity() {
    return true;
  }
};
ChartElement.prototype.options = {};
var chart_element_default = ChartElement;

// node_modules/@progress/kendo-charts/dist/es/core/pattern.js
var { dotsPattern, verticalStripesPattern, crosshatchPattern, diagonalStripesPattern, gridPattern } = drawing_exports;
var patternMap = {
  dots: dotsPattern,
  verticalStripes: verticalStripesPattern,
  crosshatch: crosshatchPattern,
  diagonalStripes: diagonalStripesPattern,
  grid: gridPattern
};
function evaluatePattern(options, point) {
  return isFunction(options) ? options(point) : options;
}
function createPatternFill(options, fill, point) {
  const patternOptions = evaluatePattern(options, point);
  const pattern = patternOptions && patternMap[patternOptions.type];
  return pattern ? pattern(Object.assign({}, fill, patternOptions)) : fill;
}

// node_modules/@progress/kendo-charts/dist/es/core/box-element.js
var BoxElement = class extends chart_element_default {
  constructor(options) {
    super(options);
    this.options.margin = getSpacing(this.options.margin);
    this.options.padding = getSpacing(this.options.padding);
  }
  reflow(targetBox) {
    const options = this.options;
    const { width, height, shrinkToFit } = options;
    const hasSetSize = width && height;
    const margin = options.margin;
    const padding = options.padding;
    const borderWidth = options.border.width;
    let box;
    const reflowPaddingBox = () => {
      this.align(targetBox, X, options.align);
      this.align(targetBox, Y, options.vAlign);
      this.paddingBox = box.clone().unpad(margin).unpad(borderWidth);
    };
    let contentBox = targetBox.clone();
    if (hasSetSize) {
      contentBox.x2 = contentBox.x1 + width;
      contentBox.y2 = contentBox.y1 + height;
    }
    if (shrinkToFit) {
      contentBox.unpad(margin).unpad(borderWidth).unpad(padding);
    }
    super.reflow(contentBox);
    if (hasSetSize) {
      box = this.box = new box_default(0, 0, width, height);
    } else {
      box = this.box;
    }
    if (shrinkToFit && hasSetSize) {
      reflowPaddingBox();
      contentBox = this.contentBox = this.paddingBox.clone().unpad(padding);
    } else {
      contentBox = this.contentBox = box.clone();
      box.pad(padding).pad(borderWidth).pad(margin);
      reflowPaddingBox();
    }
    this.translateChildren(
      box.x1 - contentBox.x1 + margin.left + borderWidth + padding.left,
      box.y1 - contentBox.y1 + margin.top + borderWidth + padding.top
    );
    const children = this.children;
    for (let i37 = 0; i37 < children.length; i37++) {
      let item = children[i37];
      item.reflow(item.box);
    }
  }
  align(targetBox, axis, alignment) {
    this.box.align(targetBox, axis, alignment);
  }
  hasBox() {
    const options = this.options;
    return options.border.width || options.background;
  }
  createVisual() {
    super.createVisual();
    const options = this.options;
    if (options.visible && this.hasBox()) {
      this.visual.append(drawing_exports.Path.fromRect(
        this.paddingBox.toRect(),
        this.visualStyle()
      ));
    }
  }
  visualStyle() {
    const options = this.options;
    const border = options.border || {};
    return {
      stroke: {
        width: border.width,
        color: border.color,
        opacity: valueOrDefault(border.opacity, options.opacity),
        dashType: border.dashType
      },
      fill: createPatternFill(options.pattern, {
        color: options.background,
        opacity: options.opacity
      }, void 0),
      cursor: options.cursor
    };
  }
};
setDefaultOptions(BoxElement, {
  align: LEFT,
  vAlign: TOP,
  margin: {},
  padding: {},
  border: {
    color: BLACK,
    width: 0
  },
  background: "",
  shrinkToFit: false,
  width: 0,
  height: 0,
  visible: true
});
var box_element_default = BoxElement;

// node_modules/@progress/kendo-charts/dist/es/core/utils/add-accessibility-attributes-to-visual.js
function addAccessibilityAttributesToVisual(visual, accessibilityOptions) {
  if (accessibilityOptions) {
    visual.options.className = accessibilityOptions.className;
    visual.options.role = accessibilityOptions.role;
    visual.options.ariaLabel = accessibilityOptions.ariaLabel;
    visual.options.ariaRoleDescription = accessibilityOptions.ariaRoleDescription;
    visual.options.ariaChecked = accessibilityOptions.ariaChecked;
  }
}

// node_modules/@progress/kendo-charts/dist/es/core/shape-element.js
var ShapeElement = class extends box_element_default {
  constructor(options, pointData) {
    super(options);
    this.pointData = pointData;
  }
  getElement() {
    const { options, paddingBox: box } = this;
    const { type, rotation } = options;
    const center = box.center();
    const halfWidth = box.width() / 2;
    const halfHeight = box.height() / 2;
    if (!options.visible || !this.hasBox()) {
      return null;
    }
    const style = this.visualStyle();
    let element;
    if (type === CIRCLE) {
      element = new drawing_exports.Circle(
        new geometry_exports.Circle([
          round(box.x1 + halfWidth, COORD_PRECISION),
          round(box.y1 + halfHeight, COORD_PRECISION)
        ], Math.min(halfWidth, halfHeight)),
        style
      );
    } else if (type === TRIANGLE) {
      element = drawing_exports.Path.fromPoints([
        [box.x1 + halfWidth, box.y1],
        [box.x1, box.y2],
        [box.x2, box.y2]
      ], style).close();
    } else if (type === CROSS) {
      element = new drawing_exports.MultiPath(style);
      element.moveTo(box.x1, box.y1).lineTo(box.x2, box.y2);
      element.moveTo(box.x1, box.y2).lineTo(box.x2, box.y1);
    } else {
      const rect = box.toRect();
      if (type === ROUNDED_RECT) {
        const borderRadius = valueOrDefault(options.borderRadius, rect.width() / 5);
        rect.setCornerRadius(borderRadius);
      }
      element = drawing_exports.Path.fromRect(rect, style);
    }
    if (rotation) {
      element.transform(
        geometry_exports.transform().rotate(-rotation, [center.x, center.y])
      );
    }
    element.options.zIndex = options.zIndex;
    return element;
  }
  createElement() {
    const customVisual = this.options.visual;
    const pointData = this.pointData || {};
    let visual;
    if (customVisual) {
      visual = customVisual({
        value: pointData.value,
        dataItem: pointData.dataItem,
        sender: this.getSender(),
        series: pointData.series,
        category: pointData.category,
        rect: this.paddingBox.toRect(),
        options: this.visualOptions(),
        createVisual: () => this.getElement()
      });
    } else {
      visual = this.getElement();
    }
    return visual;
  }
  visualOptions() {
    const options = this.options;
    return {
      background: options.background,
      border: options.border,
      margin: options.margin,
      padding: options.padding,
      type: options.type,
      size: options.width,
      visible: options.visible
    };
  }
  createVisual() {
    this.visual = this.createElement();
    addAccessibilityAttributesToVisual(this.visual, this.options.accessibilityOptions);
  }
};
setDefaultOptions(ShapeElement, {
  type: CIRCLE,
  align: CENTER,
  vAlign: CENTER
});
var shape_element_default = ShapeElement;

// node_modules/@progress/kendo-charts/dist/es/core/gradients.js
var LINEAR = "linear";
var RADIAL = "radial";
var GRADIENTS = {
  glass: {
    type: LINEAR,
    rotation: 0,
    stops: [{
      offset: 0,
      color: WHITE,
      opacity: 0
    }, {
      offset: 0.25,
      color: WHITE,
      opacity: 0.3
    }, {
      offset: 1,
      color: WHITE,
      opacity: 0
    }]
  },
  sharpBevel: {
    type: RADIAL,
    stops: [{
      offset: 0,
      color: WHITE,
      opacity: 0.55
    }, {
      offset: 0.65,
      color: WHITE,
      opacity: 0
    }, {
      offset: 0.95,
      color: WHITE,
      opacity: 0.25
    }]
  },
  roundedBevel: {
    type: RADIAL,
    stops: [{
      offset: 0.33,
      color: WHITE,
      opacity: 0.06
    }, {
      offset: 0.83,
      color: WHITE,
      opacity: 0.2
    }, {
      offset: 0.95,
      color: WHITE,
      opacity: 0
    }]
  },
  roundedGlass: {
    type: RADIAL,
    supportVML: false,
    stops: [{
      offset: 0,
      color: WHITE,
      opacity: 0
    }, {
      offset: 0.5,
      color: WHITE,
      opacity: 0.3
    }, {
      offset: 0.99,
      color: WHITE,
      opacity: 0
    }]
  },
  sharpGlass: {
    type: RADIAL,
    supportVML: false,
    stops: [{
      offset: 0,
      color: WHITE,
      opacity: 0.2
    }, {
      offset: 0.15,
      color: WHITE,
      opacity: 0.15
    }, {
      offset: 0.17,
      color: WHITE,
      opacity: 0.35
    }, {
      offset: 0.85,
      color: WHITE,
      opacity: 0.05
    }, {
      offset: 0.87,
      color: WHITE,
      opacity: 0.15
    }, {
      offset: 0.99,
      color: WHITE,
      opacity: 0
    }]
  },
  bubbleShadow: {
    type: RADIAL,
    center: [0.5, 0.5],
    radius: 0.5
  }
};
var gradients_default = GRADIENTS;

// node_modules/@progress/kendo-charts/dist/es/core/utils/box-diff.js
function boxDiff(r28, s10) {
  if (r28.x1 === s10.x1 && r28.y1 === s10.y1 && r28.x2 === s10.x2 && r28.y2 === s10.y2) {
    return s10;
  }
  const a50 = Math.min(r28.x1, s10.x1);
  const b2 = Math.max(r28.x1, s10.x1);
  const c9 = Math.min(r28.x2, s10.x2);
  const d5 = Math.max(r28.x2, s10.x2);
  const e41 = Math.min(r28.y1, s10.y1);
  const f5 = Math.max(r28.y1, s10.y1);
  const g2 = Math.min(r28.y2, s10.y2);
  const h4 = Math.max(r28.y2, s10.y2);
  const boxes = [];
  boxes[0] = new box_default(b2, e41, c9, f5);
  boxes[1] = new box_default(a50, f5, b2, g2);
  boxes[2] = new box_default(c9, f5, d5, g2);
  boxes[3] = new box_default(b2, g2, c9, h4);
  if (r28.x1 === a50 && r28.y1 === e41 || s10.x1 === a50 && s10.y1 === e41) {
    boxes[4] = new box_default(a50, e41, b2, f5);
    boxes[5] = new box_default(c9, g2, d5, h4);
  } else {
    boxes[4] = new box_default(c9, e41, d5, f5);
    boxes[5] = new box_default(a50, g2, b2, h4);
  }
  return grep_default(boxes, function(box) {
    return box.height() > 0 && box.width() > 0;
  })[0];
}

// node_modules/@progress/kendo-charts/dist/es/core/root-element.js
var RootElement = class extends chart_element_default {
  constructor(options) {
    super(options);
    const rootOptions = this.options;
    rootOptions.width = parseInt(rootOptions.width, 10);
    rootOptions.height = parseInt(rootOptions.height, 10);
    this.gradients = {};
  }
  reflow() {
    const { options, children } = this;
    let currentBox = new box_default(0, 0, options.width, options.height);
    this.box = currentBox.unpad(options.margin);
    for (let i37 = 0; i37 < children.length; i37++) {
      children[i37].reflow(currentBox);
      currentBox = boxDiff(currentBox, children[i37].box) || new box_default();
    }
  }
  createVisual() {
    this.visual = new drawing_exports.Group();
    this.createBackground();
  }
  createBackground() {
    const options = this.options;
    const border = options.border || {};
    const box = this.box.clone().pad(options.margin).unpad(border.width);
    const background = drawing_exports.Path.fromRect(box.toRect(), {
      stroke: {
        color: border.width ? border.color : "",
        width: border.width,
        dashType: border.dashType
      },
      fill: {
        color: options.background,
        opacity: options.opacity
      },
      zIndex: -10
    });
    this.visual.append(background);
  }
  getRoot() {
    return this;
  }
  createGradient(options) {
    const gradients = this.gradients;
    const hashCode = objectKey(options);
    const gradient = gradients_default[options.gradient];
    let drawingGradient;
    if (gradients[hashCode]) {
      drawingGradient = gradients[hashCode];
    } else {
      const gradientOptions = Object.assign({}, gradient, options);
      if (gradient.type === "linear") {
        drawingGradient = new drawing_exports.LinearGradient(gradientOptions);
      } else {
        if (options.innerRadius) {
          gradientOptions.stops = innerRadialStops(gradientOptions);
        }
        drawingGradient = new drawing_exports.RadialGradient(gradientOptions);
        drawingGradient.supportVML = gradient.supportVML !== false;
      }
      gradients[hashCode] = drawingGradient;
    }
    return drawingGradient;
  }
  cleanGradients() {
    const gradients = this.gradients;
    for (let hashCode in gradients) {
      gradients[hashCode]._observers = [];
    }
  }
  size() {
    const options = this.options;
    return new box_default(0, 0, options.width, options.height);
  }
};
setDefaultOptions(RootElement, {
  width: DEFAULT_WIDTH,
  height: DEFAULT_HEIGHT,
  background: WHITE,
  border: {
    color: BLACK,
    width: 0
  },
  margin: getSpacing(5),
  zIndex: -2
});
function innerRadialStops(options) {
  const stops = options.stops;
  const usedSpace = options.innerRadius / options.radius * 100;
  const length = stops.length;
  const currentStops = [];
  for (let i37 = 0; i37 < length; i37++) {
    let currentStop = Object.assign({}, stops[i37]);
    currentStop.offset = (currentStop.offset * (100 - usedSpace) + usedSpace) / 100;
    currentStops.push(currentStop);
  }
  return currentStops;
}
var root_element_default = RootElement;

// node_modules/@progress/kendo-charts/dist/es/core/float-element.js
var FloatElement = class extends chart_element_default {
  constructor(options) {
    super(options);
    this._initDirection();
  }
  _initDirection() {
    const options = this.options;
    if (options.vertical) {
      this.groupAxis = X;
      this.elementAxis = Y;
      this.groupSizeField = WIDTH;
      this.elementSizeField = HEIGHT;
      this.groupSpacing = options.spacing;
      this.elementSpacing = options.vSpacing;
    } else {
      this.groupAxis = Y;
      this.elementAxis = X;
      this.groupSizeField = HEIGHT;
      this.elementSizeField = WIDTH;
      this.groupSpacing = options.vSpacing;
      this.elementSpacing = options.spacing;
    }
  }
  reflow(targetBox) {
    this.box = targetBox.clone();
    this.reflowChildren();
  }
  reflowChildren() {
    const { box, elementAxis, groupAxis, elementSizeField, groupSizeField } = this;
    const { groups, groupsSize, maxGroupElementsSize } = this.groupOptions();
    const groupsCount = groups.length;
    const groupsStart = box[groupAxis + 1] + this.alignStart(groupsSize, box[groupSizeField]());
    if (groupsCount) {
      let groupStart = groupsStart;
      for (let groupIdx = 0; groupIdx < groupsCount; groupIdx++) {
        let group = groups[groupIdx];
        let groupElements = group.groupElements;
        let elementStart = box[elementAxis + 1];
        let groupElementsCount = groupElements.length;
        for (let idx = 0; idx < groupElementsCount; idx++) {
          let element = groupElements[idx];
          let elementSize2 = this.elementSize(element);
          let groupElementStart = groupStart + this.alignStart(elementSize2[groupSizeField], group.groupSize);
          let elementBox = new box_default();
          elementBox[groupAxis + 1] = groupElementStart;
          elementBox[groupAxis + 2] = groupElementStart + elementSize2[groupSizeField];
          elementBox[elementAxis + 1] = elementStart;
          elementBox[elementAxis + 2] = elementStart + elementSize2[elementSizeField];
          element.reflow(elementBox);
          elementStart += elementSize2[elementSizeField] + this.elementSpacing;
        }
        groupStart += group.groupSize + this.groupSpacing;
      }
      box[groupAxis + 1] = groupsStart;
      box[groupAxis + 2] = groupsStart + groupsSize;
      box[elementAxis + 2] = box[elementAxis + 1] + maxGroupElementsSize;
    }
  }
  alignStart(size, maxSize) {
    let start = 0;
    const align = this.options.align;
    if (align === RIGHT || align === BOTTOM) {
      start = maxSize - size;
    } else if (align === CENTER) {
      start = (maxSize - size) / 2;
    }
    return start;
  }
  groupOptions() {
    const { box, children, elementSizeField, groupSizeField, elementSpacing, groupSpacing } = this;
    const maxSize = round(box[elementSizeField]());
    const childrenCount = children.length;
    const groups = [];
    let groupSize = 0;
    let groupElementsSize = 0;
    let groupsSize = 0;
    let maxGroupElementsSize = 0;
    let groupElements = [];
    for (let idx = 0; idx < childrenCount; idx++) {
      let element = children[idx];
      if (!element.box) {
        element.reflow(box);
      }
      let elementSize2 = this.elementSize(element);
      if (this.options.wrap && round(groupElementsSize + elementSpacing + elementSize2[elementSizeField]) > maxSize) {
        groups.push({
          groupElements,
          groupSize,
          groupElementsSize
        });
        maxGroupElementsSize = Math.max(maxGroupElementsSize, groupElementsSize);
        groupsSize += groupSpacing + groupSize;
        groupSize = 0;
        groupElementsSize = 0;
        groupElements = [];
      }
      groupSize = Math.max(groupSize, elementSize2[groupSizeField]);
      if (groupElementsSize > 0) {
        groupElementsSize += elementSpacing;
      }
      groupElementsSize += elementSize2[elementSizeField];
      groupElements.push(element);
    }
    groups.push({
      groupElements,
      groupSize,
      groupElementsSize
    });
    maxGroupElementsSize = Math.max(maxGroupElementsSize, groupElementsSize);
    groupsSize += groupSize;
    return {
      groups,
      groupsSize,
      maxGroupElementsSize
    };
  }
  elementSize(element) {
    return {
      width: element.box.width(),
      height: element.box.height()
    };
  }
  createVisual() {
  }
};
setDefaultOptions(FloatElement, {
  vertical: true,
  wrap: true,
  vSpacing: 0,
  spacing: 0
});
var float_element_default = FloatElement;

// node_modules/@progress/kendo-charts/dist/es/core/text.js
var DrawingText = drawing_exports.Text;
var Text = class extends chart_element_default {
  constructor(content, options) {
    super(options);
    this.content = content;
    this.reflow(new box_default());
  }
  reflow(targetBox) {
    const options = this.options;
    const size = options.size = drawing_exports.util.measureText(this.content, { font: options.font });
    this.baseline = size.baseline;
    this.box = new box_default(
      targetBox.x1,
      targetBox.y1,
      targetBox.x1 + size.width,
      targetBox.y1 + size.height
    );
  }
  createVisual() {
    const { font, color, opacity, cursor, stroke, paintOrder } = this.options;
    this.visual = new DrawingText(this.content, this.box.toRect().topLeft(), {
      font,
      fill: { color, opacity },
      cursor,
      stroke,
      paintOrder
    });
  }
};
setDefaultOptions(Text, {
  font: DEFAULT_FONT,
  color: BLACK
});
var text_default = Text;

// node_modules/@progress/kendo-charts/dist/es/core/utils/rect-to-box.js
function rectToBox(rect) {
  const origin = rect.origin;
  const bottomRight = rect.bottomRight();
  return new box_default(origin.x, origin.y, bottomRight.x, bottomRight.y);
}

// node_modules/@progress/kendo-charts/dist/es/core/text-box.js
var ROWS_SPLIT_REGEX = /\n/m;
var TextBox = class extends box_element_default {
  constructor(content, options, data) {
    super(options);
    this.content = content;
    this.data = data;
    this._initContainer();
    if (this.options._autoReflow !== false) {
      this.reflow(new box_default());
    }
  }
  _initContainer() {
    const options = this.options;
    const rows = String(this.content).split(ROWS_SPLIT_REGEX);
    const floatElement = new float_element_default({ vertical: true, align: options.align, wrap: false });
    const textOptions = deepExtend({}, options, { opacity: 1, animation: null });
    this.container = floatElement;
    this.append(floatElement);
    for (let rowIdx = 0; rowIdx < rows.length; rowIdx++) {
      let text = new text_default(rows[rowIdx].trim(), textOptions);
      floatElement.append(text);
    }
  }
  reflow(targetBox) {
    const options = this.options;
    const visualFn = options.visual;
    this.container.options.align = options.align;
    if (visualFn && !this._boxReflow) {
      let visualBox = targetBox;
      if (!visualBox.hasSize()) {
        this._boxReflow = true;
        this.reflow(visualBox);
        this._boxReflow = false;
        visualBox = this.box;
      }
      const visual = this.visual = visualFn(this.visualContext(visualBox));
      if (visual) {
        visualBox = rectToBox(visual.clippedBBox() || new geometry_exports.Rect());
        visual.options.zIndex = options.zIndex;
      }
      this.box = this.contentBox = this.paddingBox = visualBox;
    } else {
      super.reflow(targetBox);
      if (options.rotation) {
        const margin = getSpacing(options.margin);
        let box = this.box.unpad(margin);
        this.targetBox = targetBox;
        this.normalBox = box.clone();
        box = this.rotate();
        box.translate(margin.left - margin.right, margin.top - margin.bottom);
        this.rotatedBox = box.clone();
        box.pad(margin);
      }
    }
  }
  createVisual() {
    const options = this.options;
    this.visual = new drawing_exports.Group({
      transform: this.rotationTransform(),
      zIndex: options.zIndex,
      noclip: options.noclip
    });
    if (this.hasBox()) {
      const box = drawing_exports.Path.fromRect(this.paddingBox.toRect(), this.visualStyle());
      this.visual.append(box);
    }
  }
  renderVisual() {
    if (!this.options.visible) {
      return;
    }
    if (this.options.visual) {
      const visual = this.visual;
      if (visual && !defined(visual.options.noclip)) {
        visual.options.noclip = this.options.noclip;
      }
      this.addVisual();
      this.createAnimation();
    } else {
      super.renderVisual();
    }
  }
  visualContext(targetBox) {
    const context = {
      text: this.content,
      rect: targetBox.toRect(),
      sender: this.getSender(),
      options: this.options,
      createVisual: () => {
        this._boxReflow = true;
        this.reflow(targetBox);
        this._boxReflow = false;
        return this.getDefaultVisual();
      }
    };
    if (this.data) {
      Object.assign(context, this.data);
    }
    return context;
  }
  getDefaultVisual() {
    this.createVisual();
    this.renderChildren();
    const visual = this.visual;
    delete this.visual;
    return visual;
  }
  rotate() {
    const options = this.options;
    this.box.rotate(options.rotation);
    this.align(this.targetBox, X, options.align);
    this.align(this.targetBox, Y, options.vAlign);
    return this.box;
  }
  rotationTransform() {
    const rotation = this.options.rotation;
    if (!rotation) {
      return null;
    }
    const { x: cx, y: cy } = this.normalBox.center();
    const boxCenter = this.rotatedBox.center();
    return geometry_exports.transform().translate(boxCenter.x - cx, boxCenter.y - cy).rotate(rotation, [cx, cy]);
  }
};
var text_box_default = TextBox;

// node_modules/@progress/kendo-charts/dist/es/core/title.js
var Title = class _Title extends chart_element_default {
  constructor(options) {
    super(options);
    this._textBox = new text_box_default(this.options.text, Object.assign({}, this.options, {
      vAlign: this.options.position
    }));
    this.append(this._textBox);
  }
  reflow(targetBox) {
    super.reflow(targetBox);
    this.box.snapTo(targetBox, X);
  }
  static buildTitle(options, defaultOptions) {
    let titleOptions = options;
    if (typeof options === "string") {
      titleOptions = { text: options };
    }
    titleOptions = Object.assign({ visible: true }, defaultOptions, titleOptions);
    let title3;
    if (titleOptions && titleOptions.visible && titleOptions.text) {
      title3 = new _Title(titleOptions);
    }
    return title3;
  }
  static orderTitles(titles) {
    const items = [].concat(titles);
    const top = items.filter((item) => item && item.options.position !== BOTTOM);
    const bottom = items.filter((item) => item && item.options.position === BOTTOM);
    collapseVerticalMargins(top);
    collapseVerticalMargins(bottom);
    bottom.reverse();
    return top.concat(bottom);
  }
};
function collapseVerticalMargins(items) {
  for (let i37 = 1; i37 < items.length; i37++) {
    const box = items[i37]._textBox;
    const prevBox = items[i37 - 1]._textBox;
    prevBox.options.margin = Object.assign(getSpacing(prevBox.options.margin), { bottom: 0 });
    box.options.margin = Object.assign(getSpacing(box.options.margin), { top: 0 });
  }
}
setDefaultOptions(Title, {
  color: BLACK,
  position: TOP,
  align: CENTER,
  margin: getSpacing(5),
  padding: getSpacing(5)
});
var title_default = Title;

// node_modules/@progress/kendo-charts/dist/es/core/axis-label.js
var AxisLabel = class extends text_box_default {
  constructor(value2, text, index, dataItem, options) {
    super(text, options);
    this.text = text;
    this.value = value2;
    this.index = index;
    this.dataItem = dataItem;
    this.reflow(new box_default());
  }
  visualContext(targetBox) {
    const context = super.visualContext(targetBox);
    context.value = this.value;
    context.dataItem = this.dataItem;
    context.format = this.options.format;
    context.culture = this.options.culture;
    return context;
  }
  click(widget, e41) {
    widget.trigger(AXIS_LABEL_CLICK, {
      element: eventElement(e41),
      value: this.value,
      text: this.text,
      index: this.index,
      dataItem: this.dataItem,
      axis: this.parent.options
    });
  }
  rotate() {
    if (this.options.alignRotation !== CENTER) {
      const box = this.normalBox.toRect();
      const transform = this.rotationTransform();
      this.box = rectToBox(box.bbox(transform.matrix()));
    } else {
      super.rotate();
    }
    return this.box;
  }
  rotationTransform() {
    const options = this.options;
    const rotation = options.rotation;
    if (!rotation) {
      return null;
    }
    if (options.alignRotation === CENTER) {
      return super.rotationTransform();
    }
    const rotationMatrix = geometry_exports.transform().rotate(rotation).matrix();
    const box = this.normalBox.toRect();
    const rect = this.targetBox.toRect();
    const rotationOrigin = options.rotationOrigin || TOP;
    const alignAxis = rotationOrigin === TOP || rotationOrigin === BOTTOM ? X : Y;
    const distanceAxis = rotationOrigin === TOP || rotationOrigin === BOTTOM ? Y : X;
    const axisAnchor = rotationOrigin === TOP || rotationOrigin === LEFT ? rect.origin : rect.bottomRight();
    const topLeft = box.topLeft().transformCopy(rotationMatrix);
    const topRight = box.topRight().transformCopy(rotationMatrix);
    const bottomRight = box.bottomRight().transformCopy(rotationMatrix);
    const bottomLeft = box.bottomLeft().transformCopy(rotationMatrix);
    const rotatedBox = geometry_exports.Rect.fromPoints(topLeft, topRight, bottomRight, bottomLeft);
    const translate2 = {
      [distanceAxis]: rect.origin[distanceAxis] - rotatedBox.origin[distanceAxis]
    };
    const distanceLeft = Math.abs(topLeft[distanceAxis] + translate2[distanceAxis] - axisAnchor[distanceAxis]);
    const distanceRight = Math.abs(topRight[distanceAxis] + translate2[distanceAxis] - axisAnchor[distanceAxis]);
    let alignStart, alignEnd;
    if (round(distanceLeft, DEFAULT_PRECISION) === round(distanceRight, DEFAULT_PRECISION)) {
      alignStart = topLeft;
      alignEnd = topRight;
    } else if (distanceRight < distanceLeft) {
      alignStart = topRight;
      alignEnd = bottomRight;
    } else {
      alignStart = topLeft;
      alignEnd = bottomLeft;
    }
    const alignCenter = alignStart[alignAxis] + (alignEnd[alignAxis] - alignStart[alignAxis]) / 2;
    translate2[alignAxis] = rect.center()[alignAxis] - alignCenter;
    return geometry_exports.transform().translate(translate2.x, translate2.y).rotate(rotation);
  }
};
setDefaultOptions(AxisLabel, {
  _autoReflow: false
});
var axis_label_default = AxisLabel;

// node_modules/@progress/kendo-charts/dist/es/core/note.js
var DEFAULT_ICON_SIZE = 7;
var DEFAULT_LABEL_COLOR = "#fff";
var Note = class extends box_element_default {
  constructor(fields, options, chartService) {
    super(options);
    this.fields = fields;
    this.chartService = chartService;
    this.render();
  }
  hide() {
    this.options.visible = false;
  }
  show() {
    this.options.visible = true;
  }
  render() {
    const options = this.options;
    if (options.visible) {
      const { label, icon } = options;
      const box = new box_default();
      const childAlias = () => this;
      let size = icon.size;
      let text = this.fields.text;
      let width, height;
      if (defined(label) && label.visible) {
        const noteTemplate = getTemplate(label);
        if (noteTemplate) {
          text = noteTemplate(this.fields);
        } else if (label.format) {
          text = this.chartService.format.auto(label.format, text);
        }
        if (!label.color) {
          label.color = label.position === INSIDE ? DEFAULT_LABEL_COLOR : icon.background;
        }
        this.label = new text_box_default(text, deepExtend({}, label));
        this.label.aliasFor = childAlias;
        if (label.position === INSIDE && !defined(size)) {
          if (icon.type === CIRCLE) {
            size = Math.max(this.label.box.width(), this.label.box.height());
          } else {
            width = this.label.box.width();
            height = this.label.box.height();
          }
          box.wrap(this.label.box);
        }
      }
      icon.width = width || size || DEFAULT_ICON_SIZE;
      icon.height = height || size || DEFAULT_ICON_SIZE;
      const marker = new shape_element_default(deepExtend({}, icon));
      marker.aliasFor = childAlias;
      this.marker = marker;
      this.append(marker);
      if (this.label) {
        this.append(this.label);
      }
      marker.reflow(new box_default());
      this.wrapperBox = box.wrap(marker.box);
    }
  }
  reflow(targetBox) {
    const { options, label, marker, wrapperBox } = this;
    const center = targetBox.center();
    const length = options.line.length;
    const position = options.position;
    if (options.visible) {
      let lineStart, box, contentBox;
      if (inArray(position, [LEFT, RIGHT])) {
        if (position === LEFT) {
          contentBox = wrapperBox.alignTo(targetBox, position).translate(-length, targetBox.center().y - wrapperBox.center().y);
          if (options.line.visible) {
            lineStart = [targetBox.x1, center.y];
            this.linePoints = [
              lineStart,
              [contentBox.x2, center.y]
            ];
            box = contentBox.clone().wrapPoint(lineStart);
          }
        } else {
          contentBox = wrapperBox.alignTo(targetBox, position).translate(length, targetBox.center().y - wrapperBox.center().y);
          if (options.line.visible) {
            lineStart = [targetBox.x2, center.y];
            this.linePoints = [
              lineStart,
              [contentBox.x1, center.y]
            ];
            box = contentBox.clone().wrapPoint(lineStart);
          }
        }
      } else {
        if (position === BOTTOM) {
          contentBox = wrapperBox.alignTo(targetBox, position).translate(targetBox.center().x - wrapperBox.center().x, length);
          if (options.line.visible) {
            lineStart = [center.x, targetBox.y2];
            this.linePoints = [
              lineStart,
              [center.x, contentBox.y1]
            ];
            box = contentBox.clone().wrapPoint(lineStart);
          }
        } else {
          contentBox = wrapperBox.alignTo(targetBox, position).translate(targetBox.center().x - wrapperBox.center().x, -length);
          if (options.line.visible) {
            lineStart = [center.x, targetBox.y1];
            this.linePoints = [
              lineStart,
              [center.x, contentBox.y2]
            ];
            box = contentBox.clone().wrapPoint(lineStart);
          }
        }
      }
      if (marker) {
        marker.reflow(contentBox);
      }
      if (label) {
        label.reflow(contentBox);
        if (marker) {
          if (options.label.position === OUTSIDE) {
            label.box.alignTo(marker.box, position);
          }
          label.reflow(label.box);
        }
      }
      this.contentBox = contentBox;
      this.targetBox = targetBox;
      this.box = box || contentBox;
    }
  }
  createVisual() {
    super.createVisual();
    this.visual.options.noclip = this.options.noclip;
    if (this.options.visible) {
      this.createLine();
    }
  }
  renderVisual() {
    const options = this.options;
    const customVisual = options.visual;
    if (options.visible && customVisual) {
      this.visual = customVisual(Object.assign(this.fields, {
        sender: this.getSender(),
        rect: this.targetBox.toRect(),
        options: {
          background: options.background,
          border: options.background,
          icon: options.icon,
          label: options.label,
          line: options.line,
          position: options.position,
          visible: options.visible
        },
        createVisual: () => {
          this.createVisual();
          this.renderChildren();
          const defaultVisual = this.visual;
          delete this.visual;
          return defaultVisual;
        }
      }));
      this.addVisual();
    } else {
      super.renderVisual();
    }
  }
  createLine() {
    const options = this.options.line;
    if (this.linePoints) {
      const path = drawing_exports.Path.fromPoints(this.linePoints, {
        stroke: {
          color: options.color,
          width: options.width,
          dashType: options.dashType
        }
      });
      alignPathToPixel(path);
      this.visual.append(path);
    }
  }
  click(widget, e41) {
    const args = this.eventArgs(e41);
    if (!widget.trigger(NOTE_CLICK, args)) {
      e41.preventDefault();
    }
  }
  over(widget, e41) {
    const args = this.eventArgs(e41);
    if (!widget.trigger(NOTE_HOVER, args)) {
      e41.preventDefault();
    }
  }
  out(widget, e41) {
    const args = this.eventArgs(e41);
    widget.trigger(NOTE_LEAVE, args);
  }
  eventArgs(e41) {
    const options = this.options;
    return Object.assign(this.fields, {
      element: eventElement(e41),
      text: defined(options.label) ? options.label.text : "",
      visual: this.visual
    });
  }
};
setDefaultOptions(Note, {
  icon: {
    visible: true,
    type: CIRCLE
  },
  label: {
    position: INSIDE,
    visible: true,
    align: CENTER,
    vAlign: CENTER
  },
  line: {
    visible: true
  },
  visible: true,
  position: TOP,
  zIndex: 2
});
var note_default = Note;

// node_modules/@progress/kendo-charts/dist/es/services/intl-service.js
var defaultImplementation = {
  format: (format, value2) => value2,
  toString: (value2) => value2,
  parseDate: (value2) => new Date(value2),
  firstDay: () => 0
};
var current2 = defaultImplementation;
var IntlService = class {
  static register(userImplementation) {
    current2 = userImplementation;
  }
  static get implementation() {
    return current2;
  }
};
var intl_service_default = IntlService;

// node_modules/@progress/kendo-charts/dist/es/services/format-service.js
var FORMAT_REPLACE_REGEX = /\{(\d+)(:[^\}]+)?\}/g;
var FormatService = class {
  constructor(intlService) {
    this._intlService = intlService;
  }
  get intl() {
    return this._intlService || intl_service_default.implementation;
  }
  set intl(value2) {
    this._intlService = value2;
  }
  auto(formatString, ...values) {
    const intl = this.intl;
    if (isString(formatString) && formatString.match(FORMAT_REGEX)) {
      return intl.format(formatString, ...values);
    }
    return intl.toString(values[0], formatString);
  }
  localeAuto(formatString, values, locale) {
    const intl = this.intl;
    let result;
    if (isString(formatString) && formatString.match(FORMAT_REGEX)) {
      result = formatString.replace(FORMAT_REPLACE_REGEX, function(match, index, placeholderFormat) {
        let value2 = values[parseInt(index, 10)];
        return intl.toString(value2, placeholderFormat ? placeholderFormat.substring(1) : "", locale);
      });
    } else {
      result = intl.toString(values[0], formatString, locale);
    }
    return result;
  }
};
var format_service_default = FormatService;

// node_modules/@progress/kendo-charts/dist/es/services/chart-service.js
var ChartService = class {
  constructor(chart, context = {}) {
    this._intlService = context.intlService;
    this.sender = context.sender || chart;
    this.format = new format_service_default(context.intlService);
    this.chart = chart;
    this.rtl = Boolean(context.rtl);
  }
  get intl() {
    return this._intlService || intl_service_default.implementation;
  }
  set intl(value2) {
    this._intlService = value2;
    this.format.intl = value2;
  }
  notify(name, args) {
    if (this.chart) {
      this.chart.trigger(name, args);
    }
  }
  isPannable(axis) {
    const pannable = ((this.chart || {}).options || {}).pannable;
    return pannable && pannable.lock !== axis;
  }
};
var chart_service_default = ChartService;

// node_modules/@progress/kendo-charts/dist/es/services/dom-events-builder.js
var current3;
var DomEventsBuilder = class {
  static register(userImplementation) {
    current3 = userImplementation;
  }
  static create(element, events) {
    let builder;
    if (current3) {
      builder = current3.create(element, events);
    } else {
      builder = new UserEvents(element, Object.assign(
        {},
        {
          multiTouch: true,
          touchAction: "manipulation"
        },
        events
      ));
    }
    return builder;
  }
};
var dom_events_builder_default = DomEventsBuilder;

// node_modules/@progress/kendo-charts/dist/es/core/utils/create-axis-tick.js
function createAxisTick(options, tickOptions) {
  const { tickX, tickY, position } = options;
  const tick = new drawing_exports.Path({
    stroke: {
      width: tickOptions.width,
      color: tickOptions.color
    }
  });
  if (options.vertical) {
    tick.moveTo(tickX, position).lineTo(tickX + tickOptions.size, position);
  } else {
    tick.moveTo(position, tickY).lineTo(position, tickY + tickOptions.size);
  }
  alignPathToPixel(tick);
  return tick;
}

// node_modules/@progress/kendo-charts/dist/es/core/utils/create-axis-grid-line.js
function createAxisGridLine(options, gridLine) {
  const { lineStart, lineEnd, position } = options;
  const line = new drawing_exports.Path({
    stroke: {
      width: gridLine.width,
      color: gridLine.color,
      dashType: gridLine.dashType
    }
  });
  if (options.vertical) {
    line.moveTo(lineStart, position).lineTo(lineEnd, position);
  } else {
    line.moveTo(position, lineStart).lineTo(position, lineEnd);
  }
  alignPathToPixel(line);
  return line;
}

// node_modules/@progress/kendo-charts/dist/es/core/axis.js
var Axis = class extends chart_element_default {
  constructor(options, chartService = new chart_service_default()) {
    super(options);
    this.chartService = chartService;
    if (!this.options.visible) {
      this.options = deepExtend({}, this.options, {
        labels: {
          visible: false
        },
        line: {
          visible: false
        },
        margin: 0,
        majorTickSize: 0,
        minorTickSize: 0
      });
    }
    this.options.minorTicks = deepExtend({}, {
      color: this.options.line.color,
      width: this.options.line.width,
      visible: this.options.minorTickType !== NONE
    }, this.options.minorTicks, {
      size: this.options.minorTickSize,
      align: this.options.minorTickType
    });
    this.options.majorTicks = deepExtend({}, {
      color: this.options.line.color,
      width: this.options.line.width,
      visible: this.options.majorTickType !== NONE
    }, this.options.majorTicks, {
      size: this.options.majorTickSize,
      align: this.options.majorTickType
    });
    this.initFields();
    if (!this.options._deferLabels) {
      this.createLabels();
    }
    this.createTitle();
    this.createNotes();
  }
  initFields() {
  }
  // abstract labelsCount(): Number
  // abstract createAxisLabel(index, options): AxisLabel
  labelsRange() {
    return {
      min: this.options.labels.skip,
      max: this.labelsCount()
    };
  }
  normalizeLabelRotation(labelOptions) {
    const rotation = labelOptions.rotation;
    if (isObject(rotation)) {
      labelOptions.alignRotation = rotation.align;
      labelOptions.rotation = rotation.angle;
    }
  }
  createLabels() {
    const options = this.options;
    const align = options.vertical ? RIGHT : CENTER;
    const labelOptions = deepExtend({}, options.labels, {
      align,
      zIndex: options.zIndex
    });
    const step = Math.max(1, labelOptions.step);
    this.clearLabels();
    if (labelOptions.visible) {
      this.normalizeLabelRotation(labelOptions);
      if (labelOptions.rotation === "auto") {
        labelOptions.rotation = 0;
        options.autoRotateLabels = true;
      }
      const range = this.labelsRange();
      for (let idx = range.min; idx < range.max; idx += step) {
        const labelContext = { index: idx, count: range.max };
        let label = this.createAxisLabel(idx, labelOptions, labelContext);
        if (label) {
          this.append(label);
          this.labels.push(label);
        }
      }
    }
  }
  clearLabels() {
    this.children = grep_default(this.children, (child) => !(child instanceof axis_label_default));
    this.labels = [];
  }
  clearTitle() {
    if (this.title) {
      this.children = grep_default(this.children, (child) => child !== this.title);
      this.title = void 0;
    }
  }
  clear() {
    this.clearLabels();
    this.clearTitle();
  }
  lineBox() {
    const { options, box } = this;
    const vertical = options.vertical;
    const mirror = options.labels.mirror;
    const axisX = mirror ? box.x1 : box.x2;
    const axisY = mirror ? box.y2 : box.y1;
    const lineWidth = options.line.width || 0;
    return vertical ? new box_default(axisX, box.y1, axisX, box.y2 - lineWidth) : new box_default(box.x1, axisY, box.x2 - lineWidth, axisY);
  }
  createTitle() {
    const options = this.options;
    const titleOptions = deepExtend({
      rotation: options.vertical ? -90 : 0,
      text: "",
      zIndex: 1,
      visualSize: true
    }, options.title);
    if (titleOptions.visible && titleOptions.text) {
      const title3 = new text_box_default(titleOptions.text, titleOptions);
      this.append(title3);
      this.title = title3;
    }
  }
  createNotes() {
    const options = this.options;
    const notes3 = options.notes;
    const items = notes3.data || [];
    this.notes = [];
    for (let i37 = 0; i37 < items.length; i37++) {
      const item = deepExtend({}, notes3, items[i37]);
      item.value = this.parseNoteValue(item.value);
      const note = new note_default({
        value: item.value,
        text: item.label.text,
        dataItem: item
      }, item, this.chartService);
      if (note.options.visible) {
        if (defined(note.options.position)) {
          if (options.vertical && !inArray(note.options.position, [LEFT, RIGHT])) {
            note.options.position = options.reverse ? LEFT : RIGHT;
          } else if (!options.vertical && !inArray(note.options.position, [TOP, BOTTOM])) {
            note.options.position = options.reverse ? BOTTOM : TOP;
          }
        } else {
          if (options.vertical) {
            note.options.position = options.reverse ? LEFT : RIGHT;
          } else {
            note.options.position = options.reverse ? BOTTOM : TOP;
          }
        }
        this.append(note);
        this.notes.push(note);
      }
    }
  }
  parseNoteValue(value2) {
    return value2;
  }
  renderVisual() {
    super.renderVisual();
    this.createPlotBands();
  }
  createVisual() {
    super.createVisual();
    this.createBackground();
    this.createLine();
  }
  gridLinesVisual() {
    let gridLines = this._gridLines;
    if (!gridLines) {
      gridLines = this._gridLines = new drawing_exports.Group({
        zIndex: -2
      });
      this.appendVisual(this._gridLines);
    }
    return gridLines;
  }
  createTicks(lineGroup) {
    const options = this.options;
    const lineBox = this.lineBox();
    const mirror = options.labels.mirror;
    const majorUnit = options.majorTicks.visible ? options.majorUnit : 0;
    const tickLineOptions = {
      // TODO
      // _alignLines: options._alignLines,
      vertical: options.vertical
    };
    function render(tickPositions, tickOptions, skipUnit) {
      const count = tickPositions.length;
      const step = Math.max(1, tickOptions.step);
      if (tickOptions.visible) {
        for (let i37 = tickOptions.skip; i37 < count; i37 += step) {
          if (defined(skipUnit) && i37 % skipUnit === 0) {
            continue;
          }
          tickLineOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;
          tickLineOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;
          tickLineOptions.position = tickPositions[i37];
          lineGroup.append(createAxisTick(tickLineOptions, tickOptions));
        }
      }
    }
    render(this.getMajorTickPositions(), options.majorTicks);
    render(this.getMinorTickPositions(), options.minorTicks, majorUnit / options.minorUnit);
  }
  createLine() {
    const options = this.options;
    const line = options.line;
    const lineBox = this.lineBox();
    if (line.width > 0 && line.visible) {
      const path = new drawing_exports.Path({
        stroke: {
          width: line.width,
          color: line.color,
          dashType: line.dashType
        }
        /* TODO
        zIndex: line.zIndex,
        */
      });
      path.moveTo(lineBox.x1, lineBox.y1).lineTo(lineBox.x2, lineBox.y2);
      if (options._alignLines) {
        alignPathToPixel(path);
      }
      const group = this._lineGroup = new drawing_exports.Group();
      group.append(path);
      this.visual.append(group);
      this.createTicks(group);
    }
  }
  getActualTickSize() {
    const options = this.options;
    let tickSize = 0;
    if (options.majorTicks.visible && options.minorTicks.visible) {
      tickSize = Math.max(options.majorTicks.size, options.minorTicks.size);
    } else if (options.majorTicks.visible) {
      tickSize = options.majorTicks.size;
    } else if (options.minorTicks.visible) {
      tickSize = options.minorTicks.size;
    }
    return tickSize;
  }
  createBackground() {
    const { options, box } = this;
    const background = options.background;
    if (background) {
      this._backgroundPath = drawing_exports.Path.fromRect(box.toRect(), {
        fill: {
          color: background
        },
        stroke: null
      });
      this.visual.append(this._backgroundPath);
    }
  }
  createPlotBands() {
    const options = this.options;
    const plotBands = options.plotBands || [];
    const vertical = options.vertical;
    const plotArea = this.plotArea;
    if (plotBands.length === 0) {
      return;
    }
    const group = this._plotbandGroup = new drawing_exports.Group({
      zIndex: -1
    });
    const altAxis = grep_default(this.pane.axes, (axis) => axis.options.vertical !== this.options.vertical)[0];
    for (let idx = 0; idx < plotBands.length; idx++) {
      let item = plotBands[idx];
      let slotX, slotY;
      let labelOptions = item.label;
      let label;
      if (vertical) {
        slotX = (altAxis || plotArea.axisX).lineBox();
        slotY = this.getSlot(item.from, item.to, true);
      } else {
        slotX = this.getSlot(item.from, item.to, true);
        slotY = (altAxis || plotArea.axisY).lineBox();
      }
      if (labelOptions) {
        labelOptions.vAlign = labelOptions.position || LEFT;
        label = this.createPlotBandLabel(
          labelOptions,
          item,
          new box_default(
            slotX.x1,
            slotY.y1,
            slotX.x2,
            slotY.y2
          )
        );
      }
      if (slotX.width() !== 0 && slotY.height() !== 0) {
        const bandRect = new geometry_exports.Rect(
          [slotX.x1, slotY.y1],
          [slotX.width(), slotY.height()]
        );
        const path = drawing_exports.Path.fromRect(bandRect, {
          fill: {
            color: item.color,
            opacity: item.opacity
          },
          stroke: null
        });
        group.append(path);
        if (label) {
          group.append(label);
        }
      }
    }
    this.appendVisual(group);
  }
  createPlotBandLabel(label, item, box) {
    if (label.visible === false) {
      return null;
    }
    let text = label.text;
    let textbox;
    if (defined(label) && label.visible) {
      const labelTemplate = getTemplate(label);
      if (labelTemplate) {
        text = labelTemplate({ text, item });
      } else if (label.format) {
        text = this.chartService.format.auto(label.format, text);
      }
      if (!label.color) {
        label.color = this.options.labels.color;
      }
    }
    textbox = new text_box_default(text, label);
    textbox.reflow(box);
    textbox.renderVisual();
    return textbox.visual;
  }
  createGridLines(altAxis) {
    const options = this.options;
    const { minorGridLines, majorGridLines, minorUnit, vertical } = options;
    const axisLineVisible = altAxis.options.line.visible;
    const majorUnit = majorGridLines.visible ? options.majorUnit : 0;
    const lineBox = altAxis.lineBox();
    const linePos = lineBox[vertical ? "y1" : "x1"];
    const lineOptions = {
      lineStart: lineBox[vertical ? "x1" : "y1"],
      lineEnd: lineBox[vertical ? "x2" : "y2"],
      vertical
    };
    const majorTicks = [];
    const container = this.gridLinesVisual();
    function render(tickPositions, gridLine, skipUnit) {
      const count = tickPositions.length;
      const step = Math.max(1, gridLine.step);
      if (gridLine.visible) {
        for (let i37 = gridLine.skip; i37 < count; i37 += step) {
          let pos = round(tickPositions[i37]);
          if (!inArray(pos, majorTicks)) {
            if (i37 % skipUnit !== 0 && (!axisLineVisible || linePos !== pos)) {
              lineOptions.position = pos;
              container.append(createAxisGridLine(lineOptions, gridLine));
              majorTicks.push(pos);
            }
          }
        }
      }
    }
    render(this.getMajorTickPositions(), majorGridLines);
    render(this.getMinorTickPositions(), minorGridLines, majorUnit / minorUnit);
    return container.children;
  }
  reflow(box) {
    const { options, labels, title: title3 } = this;
    const vertical = options.vertical;
    const count = labels.length;
    const sizeFn = vertical ? WIDTH : HEIGHT;
    const titleSize = title3 ? title3.box[sizeFn]() : 0;
    const space = this.getActualTickSize() + options.margin + titleSize;
    const rootBox = (this.getRoot() || {}).box || box;
    const boxSize = rootBox[sizeFn]();
    let maxLabelSize = 0;
    for (let i37 = 0; i37 < count; i37++) {
      let labelSize = labels[i37].box[sizeFn]();
      if (labelSize + space <= boxSize) {
        maxLabelSize = Math.max(maxLabelSize, labelSize);
      }
    }
    if (vertical) {
      this.box = new box_default(
        box.x1,
        box.y1,
        box.x1 + maxLabelSize + space,
        box.y2
      );
    } else {
      this.box = new box_default(
        box.x1,
        box.y1,
        box.x2,
        box.y1 + maxLabelSize + space
      );
    }
    this.arrangeTitle();
    this.arrangeLabels();
    this.arrangeNotes();
  }
  getLabelsTickPositions() {
    return this.getMajorTickPositions();
  }
  labelTickIndex(label) {
    return label.index;
  }
  arrangeLabels() {
    const { options, labels } = this;
    const labelsBetweenTicks = this.labelsBetweenTicks();
    const vertical = options.vertical;
    const mirror = options.labels.mirror;
    const tickPositions = this.getLabelsTickPositions();
    for (let idx = 0; idx < labels.length; idx++) {
      const label = labels[idx];
      const tickIx = this.labelTickIndex(label);
      const labelSize = vertical ? label.box.height() : label.box.width();
      const firstTickPosition = tickPositions[tickIx];
      const nextTickPosition = tickPositions[tickIx + 1];
      let positionStart, positionEnd;
      if (vertical) {
        if (labelsBetweenTicks) {
          const middle = firstTickPosition + (nextTickPosition - firstTickPosition) / 2;
          positionStart = middle - labelSize / 2;
        } else {
          positionStart = firstTickPosition - labelSize / 2;
        }
        positionEnd = positionStart;
      } else {
        if (labelsBetweenTicks) {
          positionStart = firstTickPosition;
          positionEnd = nextTickPosition;
        } else {
          positionStart = firstTickPosition - labelSize / 2;
          positionEnd = positionStart + labelSize;
        }
      }
      this.positionLabel(label, mirror, positionStart, positionEnd);
    }
  }
  positionLabel(label, mirror, positionStart, positionEnd = positionStart) {
    const options = this.options;
    const vertical = options.vertical;
    const lineBox = this.lineBox();
    const labelOffset = this.getActualTickSize() + options.margin;
    let labelBox;
    if (vertical) {
      let labelX = lineBox.x2;
      if (mirror) {
        labelX += labelOffset;
        label.options.rotationOrigin = LEFT;
      } else {
        labelX -= labelOffset + label.box.width();
        label.options.rotationOrigin = RIGHT;
      }
      labelBox = label.box.move(labelX, positionStart);
    } else {
      let labelY = lineBox.y1;
      if (mirror) {
        labelY -= labelOffset + label.box.height();
        label.options.rotationOrigin = BOTTOM;
      } else {
        labelY += labelOffset;
        label.options.rotationOrigin = TOP;
      }
      labelBox = new box_default(
        positionStart,
        labelY,
        positionEnd,
        labelY + label.box.height()
      );
    }
    label.reflow(labelBox);
  }
  autoRotateLabelAngle(labelBox, slotWidth) {
    if (labelBox.width() < slotWidth) {
      return 0;
    }
    if (labelBox.height() > slotWidth) {
      return -90;
    }
    return -45;
  }
  autoRotateLabels() {
    if (!this.options.autoRotateLabels || this.options.vertical) {
      return false;
    }
    const tickPositions = this.getMajorTickPositions();
    const labels = this.labels;
    const limit = Math.min(labels.length, tickPositions.length - 1);
    let angle = 0;
    for (let idx = 0; idx < limit; idx++) {
      const width = Math.abs(tickPositions[idx + 1] - tickPositions[idx]);
      const labelBox = labels[idx].box;
      const labelAngle = this.autoRotateLabelAngle(labelBox, width);
      if (labelAngle !== 0) {
        angle = labelAngle;
      }
      if (angle === -90) {
        break;
      }
    }
    if (angle !== 0) {
      for (let idx = 0; idx < labels.length; idx++) {
        labels[idx].options.rotation = angle;
        labels[idx].reflow(new box_default());
      }
      return true;
    }
  }
  arrangeTitle() {
    const { options, title: title3 } = this;
    const mirror = options.labels.mirror;
    const vertical = options.vertical;
    if (title3) {
      if (vertical) {
        title3.options.align = mirror ? RIGHT : LEFT;
        title3.options.vAlign = title3.options.position;
      } else {
        title3.options.align = title3.options.position;
        title3.options.vAlign = mirror ? TOP : BOTTOM;
      }
      title3.reflow(this.box);
    }
  }
  arrangeNotes() {
    for (let idx = 0; idx < this.notes.length; idx++) {
      const item = this.notes[idx];
      const value2 = item.options.value;
      let slot;
      if (defined(value2)) {
        if (this.shouldRenderNote(value2)) {
          item.show();
        } else {
          item.hide();
        }
        slot = this.noteSlot(value2);
      } else {
        item.hide();
      }
      item.reflow(slot || this.lineBox());
    }
  }
  noteSlot(value2) {
    return this.getSlot(value2);
  }
  alignTo(secondAxis) {
    const lineBox = secondAxis.lineBox();
    const vertical = this.options.vertical;
    const pos = vertical ? Y : X;
    this.box.snapTo(lineBox, pos);
    if (vertical) {
      this.box.shrink(0, this.lineBox().height() - lineBox.height());
    } else {
      this.box.shrink(this.lineBox().width() - lineBox.width(), 0);
    }
    this.box[pos + 1] -= this.lineBox()[pos + 1] - lineBox[pos + 1];
    this.box[pos + 2] -= this.lineBox()[pos + 2] - lineBox[pos + 2];
  }
  axisLabelText(value2, options, context) {
    let text;
    const tmpl = getTemplate(options);
    const defaultText = () => {
      if (!options.format) {
        return value2;
      }
      return this.chartService.format.localeAuto(
        options.format,
        [value2],
        options.culture
      );
    };
    if (tmpl) {
      const templateContext = Object.assign({}, context, {
        get text() {
          return defaultText();
        },
        value: value2,
        format: options.format,
        culture: options.culture
      });
      text = tmpl(templateContext);
    } else {
      text = defaultText();
    }
    return text;
  }
  slot(from, to, limit) {
    const slot = this.getSlot(from, to, limit);
    if (slot) {
      return slot.toRect();
    }
  }
  contentBox() {
    const box = this.box.clone();
    const labels = this.labels;
    if (labels.length) {
      const axis = this.options.vertical ? Y : X;
      if (this.chartService.isPannable(axis)) {
        const offset = this.maxLabelOffset();
        box[axis + 1] -= offset.start;
        box[axis + 2] += offset.end;
      } else {
        if (labels[0].options.visible) {
          box.wrap(labels[0].box);
        }
        const lastLabel = labels[labels.length - 1];
        if (lastLabel.options.visible) {
          box.wrap(lastLabel.box);
        }
      }
    }
    return box;
  }
  maxLabelOffset() {
    const { vertical, reverse } = this.options;
    const labelsBetweenTicks = this.labelsBetweenTicks();
    const tickPositions = this.getLabelsTickPositions();
    const offsetField = vertical ? Y : X;
    const labels = this.labels;
    const startPosition = reverse ? 1 : 0;
    const endPosition = reverse ? 0 : 1;
    let maxStartOffset = 0;
    let maxEndOffset = 0;
    for (let idx = 0; idx < labels.length; idx++) {
      const label = labels[idx];
      const tickIx = this.labelTickIndex(label);
      let startTick, endTick;
      if (labelsBetweenTicks) {
        startTick = tickPositions[tickIx + startPosition];
        endTick = tickPositions[tickIx + endPosition];
      } else {
        startTick = endTick = tickPositions[tickIx];
      }
      maxStartOffset = Math.max(maxStartOffset, startTick - label.box[offsetField + 1]);
      maxEndOffset = Math.max(maxEndOffset, label.box[offsetField + 2] - endTick);
    }
    return {
      start: maxStartOffset,
      end: maxEndOffset
    };
  }
  limitRange(from, to, min4, max3, offset) {
    const options = this.options;
    if (from < min4 && offset < 0 && (!defined(options.min) || options.min <= min4) || max3 < to && offset > 0 && (!defined(options.max) || max3 <= options.max)) {
      return null;
    }
    if (to < min4 && offset > 0 || max3 < from && offset < 0) {
      return {
        min: from,
        max: to
      };
    }
    const rangeSize = to - from;
    let minValue = from;
    let maxValue = to;
    if (from < min4 && offset < 0) {
      minValue = limitValue(from, min4, max3);
      maxValue = limitValue(from + rangeSize, min4 + rangeSize, max3);
    } else if (to > max3 && offset > 0) {
      maxValue = limitValue(to, min4, max3);
      minValue = limitValue(to - rangeSize, min4, max3 - rangeSize);
    }
    return {
      min: minValue,
      max: maxValue
    };
  }
  valueRange() {
    return {
      min: this.seriesMin,
      max: this.seriesMax
    };
  }
  lineDir() {
    const { vertical, reverse } = this.options;
    return (vertical ? -1 : 1) * (reverse ? -1 : 1);
  }
  lineInfo() {
    const { vertical } = this.options;
    const lineBox = this.lineBox();
    const lineSize = vertical ? lineBox.height() : lineBox.width();
    const axis = vertical ? Y : X;
    const axisDir = this.lineDir();
    const startEdge = axisDir === 1 ? 1 : 2;
    const axisOrigin = axis + startEdge.toString();
    const lineStart = lineBox[axisOrigin];
    return {
      axis,
      axisOrigin,
      axisDir,
      lineBox,
      lineSize,
      lineStart
    };
  }
  pointOffset(point) {
    const { axis, axisDir, axisOrigin, lineBox, lineSize } = this.lineInfo();
    const relative = axisDir > 0 ? point[axis] - lineBox[axisOrigin] : lineBox[axisOrigin] - point[axis];
    const offset = relative / lineSize;
    return offset;
  }
  // Computes the axis range change (delta) for a given scale factor.
  // The delta is subtracted from the axis range:
  //   * delta > 0 reduces the axis range (zoom-in)
  //   * delta < 0 expands the axis range (zoom-out)
  scaleToDelta(rawScale, range) {
    const MAX_SCALE = 0.999;
    const scale = limitValue(rawScale, -MAX_SCALE, MAX_SCALE);
    let delta;
    if (scale > 0) {
      delta = range * Math.min(1, scale);
    } else {
      delta = range - range / (1 + scale);
    }
    return delta;
  }
  labelsBetweenTicks() {
    return !this.options.justified;
  }
  //add legacy fields to the options that are no longer generated by default
  prepareUserOptions() {
  }
};
setDefaultOptions(Axis, {
  labels: {
    visible: true,
    rotation: 0,
    mirror: false,
    step: 1,
    skip: 0
  },
  line: {
    width: 1,
    color: BLACK,
    visible: true
  },
  title: {
    visible: true,
    position: CENTER
  },
  majorTicks: {
    align: OUTSIDE,
    size: 4,
    skip: 0,
    step: 1
  },
  minorTicks: {
    align: OUTSIDE,
    size: 3,
    skip: 0,
    step: 1
  },
  axisCrossingValue: 0,
  majorTickType: OUTSIDE,
  minorTickType: NONE,
  majorGridLines: {
    skip: 0,
    step: 1
  },
  minorGridLines: {
    visible: false,
    width: 1,
    color: BLACK,
    skip: 0,
    step: 1
  },
  // TODO: Move to line or labels options
  margin: 5,
  visible: true,
  reverse: false,
  justified: true,
  notes: {
    label: {
      text: ""
    }
  },
  _alignLines: true,
  _deferLabels: false
});
var axis_default = Axis;

// node_modules/@progress/kendo-charts/dist/es/date-utils/constants.js
var MILLISECONDS = "milliseconds";
var SECONDS = "seconds";
var MINUTES = "minutes";
var HOURS = "hours";
var DAYS = "days";
var WEEKS = "weeks";
var MONTHS = "months";
var YEARS = "years";
var TIME_PER_MILLISECOND = 1;
var TIME_PER_SECOND = 1e3;
var TIME_PER_MINUTE = 60 * TIME_PER_SECOND;
var TIME_PER_HOUR = 60 * TIME_PER_MINUTE;
var TIME_PER_DAY = 24 * TIME_PER_HOUR;
var TIME_PER_WEEK = 7 * TIME_PER_DAY;
var TIME_PER_MONTH = 31 * TIME_PER_DAY;
var TIME_PER_YEAR = 365 * TIME_PER_DAY;
var TIME_PER_UNIT = {
  "years": TIME_PER_YEAR,
  "months": TIME_PER_MONTH,
  "weeks": TIME_PER_WEEK,
  "days": TIME_PER_DAY,
  "hours": TIME_PER_HOUR,
  "minutes": TIME_PER_MINUTE,
  "seconds": TIME_PER_SECOND,
  "milliseconds": TIME_PER_MILLISECOND
};

// node_modules/@progress/kendo-charts/dist/es/date-utils/absolute-date-diff.js
function absoluteDateDiff(a50, b2) {
  const diff = a50.getTime() - b2;
  const offsetDiff = a50.getTimezoneOffset() - b2.getTimezoneOffset();
  return diff - offsetDiff * TIME_PER_MINUTE;
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/add-ticks.js
function addTicks(date, ticks) {
  return new Date(date.getTime() + ticks);
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/to-date.js
function toDate(value2) {
  let result;
  if (value2 instanceof Date) {
    result = value2;
  } else if (value2) {
    result = new Date(value2);
  }
  return result;
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/start-of-week.js
function startOfWeek(date, weekStartDay = 0) {
  let daysToSubtract = 0;
  let day = date.getDay();
  if (!isNaN(day)) {
    while (day !== weekStartDay) {
      if (day === 0) {
        day = 6;
      } else {
        day--;
      }
      daysToSubtract++;
    }
  }
  return addTicks(date, -daysToSubtract * TIME_PER_DAY);
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/add-duration.js
function adjustDST(date, hours) {
  if (hours === 0 && date.getHours() === 23) {
    date.setHours(date.getHours() + 2);
    return true;
  }
  return false;
}
function addHours(date, hours) {
  const roundedDate = new Date(date);
  roundedDate.setMinutes(0, 0, 0);
  const tzDiff = (date.getTimezoneOffset() - roundedDate.getTimezoneOffset()) * TIME_PER_MINUTE;
  return addTicks(roundedDate, tzDiff + hours * TIME_PER_HOUR);
}
function addDuration(dateValue, value2, unit, weekStartDay) {
  let result = dateValue;
  if (dateValue) {
    let date = toDate(dateValue);
    const hours = date.getHours();
    if (unit === YEARS) {
      result = new Date(date.getFullYear() + value2, 0, 1);
      adjustDST(result, 0);
    } else if (unit === MONTHS) {
      result = new Date(date.getFullYear(), date.getMonth() + value2, 1);
      adjustDST(result, hours);
    } else if (unit === WEEKS) {
      result = addDuration(startOfWeek(date, weekStartDay), value2 * 7, DAYS);
      adjustDST(result, hours);
    } else if (unit === DAYS) {
      result = new Date(date.getFullYear(), date.getMonth(), date.getDate() + value2);
      adjustDST(result, hours);
    } else if (unit === HOURS) {
      result = addHours(date, value2);
    } else if (unit === MINUTES) {
      result = addTicks(date, value2 * TIME_PER_MINUTE);
      if (result.getSeconds() > 0) {
        result.setSeconds(0);
      }
    } else if (unit === SECONDS) {
      result = addTicks(date, value2 * TIME_PER_SECOND);
    } else if (unit === MILLISECONDS) {
      result = addTicks(date, value2);
    }
    if (unit !== MILLISECONDS && result.getMilliseconds() > 0) {
      result.setMilliseconds(0);
    }
  }
  return result;
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/floor-date.js
function floorDate(date, unit, weekStartDay) {
  return addDuration(toDate(date), 0, unit, weekStartDay);
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/ceil-date.js
function ceilDate(dateValue, unit, weekStartDay) {
  const date = toDate(dateValue);
  if (date && floorDate(date, unit, weekStartDay).getTime() === date.getTime()) {
    return date;
  }
  return addDuration(date, 1, unit, weekStartDay);
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/date-comparer.js
function dateComparer(a50, b2) {
  if (a50 && b2) {
    return a50.getTime() - b2.getTime();
  }
  return -1;
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/date-diff.js
function dateDiff(a50, b2) {
  return a50.getTime() - b2;
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/to-time.js
function toTime(value2) {
  if (isArray(value2)) {
    let result = [];
    for (let idx = 0; idx < value2.length; idx++) {
      result.push(toTime(value2[idx]));
    }
    return result;
  } else if (value2) {
    return toDate(value2).getTime();
  }
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/date-equals.js
function dateEquals(a50, b2) {
  if (a50 && b2) {
    return toTime(a50) === toTime(b2);
  }
  return a50 === b2;
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/date-index.js
function timeIndex(date, start, baseUnit) {
  return absoluteDateDiff(date, start) / TIME_PER_UNIT[baseUnit];
}
function dateIndex(value2, start, baseUnit, baseUnitStep) {
  const date = toDate(value2);
  const startDate = toDate(start);
  let index;
  if (baseUnit === MONTHS) {
    index = date.getMonth() - startDate.getMonth() + (date.getFullYear() - startDate.getFullYear()) * 12 + timeIndex(date, new Date(date.getFullYear(), date.getMonth()), DAYS) / new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();
  } else if (baseUnit === YEARS) {
    index = date.getFullYear() - startDate.getFullYear() + dateIndex(date, new Date(date.getFullYear(), 0), MONTHS, 1) / 12;
  } else if (baseUnit === DAYS || baseUnit === WEEKS) {
    index = timeIndex(date, startDate, baseUnit);
  } else {
    index = dateDiff(date, start) / TIME_PER_UNIT[baseUnit];
  }
  return index / baseUnitStep;
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/duration.js
function duration(a50, b2, unit) {
  let diff;
  if (unit === YEARS) {
    diff = b2.getFullYear() - a50.getFullYear();
  } else if (unit === MONTHS) {
    diff = duration(a50, b2, YEARS) * 12 + b2.getMonth() - a50.getMonth();
  } else if (unit === DAYS) {
    diff = Math.floor(dateDiff(b2, a50) / TIME_PER_DAY);
  } else {
    diff = Math.floor(dateDiff(b2, a50) / TIME_PER_UNIT[unit]);
  }
  return diff;
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/parse-date.js
function parseDate(intlService, date) {
  let result;
  if (isString(date)) {
    result = intlService.parseDate(date) || toDate(date);
  } else {
    result = toDate(date);
  }
  return result;
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/parse-dates.js
function parseDates(intlService, dates) {
  if (isArray(dates)) {
    const result = [];
    for (let idx = 0; idx < dates.length; idx++) {
      result.push(parseDate(intlService, dates[idx]));
    }
    return result;
  }
  return parseDate(intlService, dates);
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/first-day.js
function firstDay(options, intlService) {
  if (isNumber(options.weekStartDay)) {
    return options.weekStartDay;
  }
  if (intlService && intlService.firstDay) {
    return intlService.firstDay();
  }
  return 0;
}

// node_modules/@progress/kendo-charts/dist/es/core/category-axis.js
var MIN_CATEGORY_POINTS_RANGE = 0.01;
var MIN_CATEGORY_RANGE = 0.1;
function indexOf(value2, arr) {
  if (value2 instanceof Date) {
    return arr.findIndex((item) => dateEquals(item, value2));
  }
  return arr.indexOf(value2);
}
var CategoryAxis = class _CategoryAxis extends axis_default {
  initFields() {
    this._ticks = {};
  }
  categoriesHash() {
    return "";
  }
  clone() {
    const copy = new _CategoryAxis(Object.assign({}, this.options, {
      categories: this.options.srcCategories
    }), this.chartService);
    copy.createLabels();
    return copy;
  }
  initUserOptions(options) {
    const categories = options.categories || [];
    const definedMin = options.min !== void 0;
    const definedMax = options.max !== void 0;
    options.srcCategories = options.categories = categories;
    if ((definedMin || definedMax) && categories.length) {
      const min4 = definedMin ? Math.floor(options.min) : 0;
      let max3;
      if (definedMax) {
        max3 = options.justified ? Math.floor(options.max) + 1 : Math.ceil(options.max);
      } else {
        max3 = categories.length;
      }
      options.categories = options.categories.slice(min4, max3);
    }
    return options;
  }
  rangeIndices() {
    const options = this.options;
    const length = options.categories.length || 1;
    const min4 = isNumber(options.min) ? options.min % 1 : 0;
    let max3;
    if (isNumber(options.max) && options.max % 1 !== 0 && options.max < this.totalRange().max) {
      max3 = length - (1 - options.max % 1);
    } else {
      max3 = length - (options.justified ? 1 : 0);
    }
    return {
      min: min4,
      max: max3
    };
  }
  range() {
    const options = this.options;
    const min4 = isNumber(options.min) ? options.min : 0;
    const max3 = isNumber(options.max) ? options.max : this.totalRange().max;
    return {
      min: min4,
      max: max3
    };
  }
  roundedRange() {
    return this.range();
  }
  totalRange() {
    const options = this.options;
    return { min: 0, max: Math.max(this._seriesMax || 0, options.srcCategories.length) - (options.justified ? 1 : 0) };
  }
  scaleOptions() {
    const { min: min4, max: max3 } = this.rangeIndices();
    const lineBox = this.lineBox();
    const size = this.options.vertical ? lineBox.height() : lineBox.width();
    const scale = size / (max3 - min4 || 1);
    return {
      scale: scale * (this.options.reverse ? -1 : 1),
      box: lineBox,
      min: min4,
      max: max3
    };
  }
  arrangeLabels() {
    super.arrangeLabels();
    this.hideOutOfRangeLabels();
  }
  hideOutOfRangeLabels() {
    const { box, labels } = this;
    if (labels.length > 0) {
      const valueAxis = this.options.vertical ? Y : X;
      const start = box[valueAxis + 1];
      const end = box[valueAxis + 2];
      const firstLabel = labels[0];
      const lastLabel = last(labels);
      if (firstLabel.box[valueAxis + 1] > end || firstLabel.box[valueAxis + 2] < start) {
        firstLabel.options.visible = false;
      }
      if (lastLabel.box[valueAxis + 1] > end || lastLabel.box[valueAxis + 2] < start) {
        lastLabel.options.visible = false;
      }
    }
  }
  getMajorTickPositions() {
    return this.getTicks().majorTicks;
  }
  getMinorTickPositions() {
    return this.getTicks().minorTicks;
  }
  getLabelsTickPositions() {
    return this.getTicks().labelTicks;
  }
  tickIndices(stepSize) {
    const { min: min4, max: max3 } = this.rangeIndices();
    const limit = Math.ceil(max3);
    let current4 = Math.floor(min4);
    const indices = [];
    while (current4 <= limit) {
      indices.push(current4);
      current4 += stepSize;
    }
    return indices;
  }
  getTickPositions(stepSize) {
    const { vertical, reverse } = this.options;
    const { scale, box, min: min4 } = this.scaleOptions();
    const pos = box[(vertical ? Y : X) + (reverse ? 2 : 1)];
    const indices = this.tickIndices(stepSize);
    const positions = [];
    for (let idx = 0; idx < indices.length; idx++) {
      positions.push(pos + round(scale * (indices[idx] - min4), COORD_PRECISION));
    }
    return positions;
  }
  getTicks() {
    const options = this.options;
    const cache2 = this._ticks;
    const range = this.rangeIndices();
    const lineBox = this.lineBox();
    const hash = lineBox.getHash() + range.min + "," + range.max + options.reverse + options.justified;
    if (cache2._hash !== hash) {
      const hasMinor = options.minorTicks.visible || options.minorGridLines.visible;
      cache2._hash = hash;
      cache2.labelTicks = this.getTickPositions(1);
      cache2.majorTicks = this.filterOutOfRangePositions(cache2.labelTicks, lineBox);
      cache2.minorTicks = hasMinor ? this.filterOutOfRangePositions(this.getTickPositions(0.5), lineBox) : [];
    }
    return cache2;
  }
  filterOutOfRangePositions(positions, lineBox) {
    if (!positions.length) {
      return positions;
    }
    const axis = this.options.vertical ? Y : X;
    const inRange = (position) => lineBox[axis + 1] <= position && position <= lineBox[axis + 2];
    const end = positions.length - 1;
    let startIndex = 0;
    while (!inRange(positions[startIndex]) && startIndex <= end) {
      startIndex++;
    }
    let endIndex = end;
    while (!inRange(positions[endIndex]) && endIndex >= 0) {
      endIndex--;
    }
    return positions.slice(startIndex, endIndex + 1);
  }
  lineInfo() {
    const { vertical, reverse } = this.options;
    const lineBox = this.lineBox();
    const lineSize = vertical ? lineBox.height() : lineBox.width();
    const axis = vertical ? Y : X;
    const axisDir = reverse ? -1 : 1;
    const startEdge = axisDir === 1 ? 1 : 2;
    const axisOrigin = axis + startEdge.toString();
    const lineStart = lineBox[axisOrigin];
    return {
      axis,
      axisOrigin,
      axisDir,
      lineBox,
      lineSize,
      lineStart
    };
  }
  lineDir() {
    const { reverse } = this.options;
    return reverse ? -1 : 1;
  }
  // TODO: Rename to slotBox, valueSlot, slotByIndex?
  getSlot(from, to, limit) {
    const options = this.options;
    const { reverse, justified } = options;
    const { scale, box, min: min4 } = this.scaleOptions();
    const { axis: valueAxis, lineStart } = this.lineInfo();
    const slotBox = box.clone();
    const singleSlot = to === void 0;
    const start = valueOrDefault(from, 0);
    let end = valueOrDefault(to, start);
    end = Math.max(end - 1, start);
    end = Math.max(start, end);
    let p1 = lineStart + (start - min4) * scale;
    let p22 = lineStart + (end + 1 - min4) * scale;
    if (singleSlot && justified) {
      p22 = p1;
    }
    if (limit) {
      p1 = limitValue(p1, box[valueAxis + 1], box[valueAxis + 2]);
      p22 = limitValue(p22, box[valueAxis + 1], box[valueAxis + 2]);
    }
    slotBox[valueAxis + 1] = reverse ? p22 : p1;
    slotBox[valueAxis + 2] = reverse ? p1 : p22;
    return slotBox;
  }
  limitSlot(slot) {
    const vertical = this.options.vertical;
    const valueAxis = vertical ? Y : X;
    const lineBox = this.lineBox();
    const limittedSlot = slot.clone();
    limittedSlot[valueAxis + 1] = limitValue(slot[valueAxis + 1], lineBox[valueAxis + 1], lineBox[valueAxis + 2]);
    limittedSlot[valueAxis + 2] = limitValue(slot[valueAxis + 2], lineBox[valueAxis + 1], lineBox[valueAxis + 2]);
    return limittedSlot;
  }
  slot(from, to, limit) {
    const min4 = Math.floor(this.options.min || 0);
    let start = from;
    let end = to;
    if (typeof start === "string") {
      start = this.categoryIndex(start);
    } else if (isNumber(start)) {
      start -= min4;
    }
    if (typeof end === "string") {
      end = this.categoryIndex(end);
    } else if (isNumber(end)) {
      end -= min4;
    }
    return super.slot(start, end, limit);
  }
  pointCategoryIndex(point) {
    const { reverse, justified, vertical } = this.options;
    const valueAxis = vertical ? Y : X;
    const { scale, box, min: min4, max: max3 } = this.scaleOptions();
    const startValue = reverse ? max3 : min4;
    const lineStart = box[valueAxis + 1];
    const lineEnd = box[valueAxis + 2];
    const pos = point[valueAxis];
    if (pos < lineStart || pos > lineEnd) {
      return null;
    }
    let value2 = startValue + (pos - lineStart) / scale;
    const diff = value2 % 1;
    if (justified) {
      value2 = Math.round(value2);
    } else if (diff === 0 && value2 > 0) {
      value2--;
    }
    return Math.floor(value2);
  }
  getCategory(point) {
    const index = this.pointCategoryIndex(point);
    if (index === null) {
      return null;
    }
    return this.options.categories[index];
  }
  categoryIndex(value2) {
    return this.totalIndex(value2) - Math.floor(this.options.min || 0);
  }
  categoryAt(index, total) {
    const options = this.options;
    return (total ? options.srcCategories : options.categories)[index];
  }
  categoriesCount() {
    return (this.options.categories || []).length;
  }
  translateRange(delta) {
    const options = this.options;
    const lineBox = this.lineBox();
    const size = options.vertical ? lineBox.height() : lineBox.width();
    const range = options.categories.length;
    const scale = size / range;
    const offset = round(delta / scale, DEFAULT_PRECISION);
    return {
      min: offset,
      max: range + offset
    };
  }
  scaleRange(scale, cursor) {
    const position = Math.abs(this.pointOffset(cursor));
    const rangeIndices = this.limitedRangeIndices();
    const range = rangeIndices.max - rangeIndices.min;
    const delta = this.scaleToDelta(scale, range);
    const minDelta = position * delta;
    const maxDelta = (1 - position) * delta;
    const min4 = rangeIndices.min + minDelta;
    let max3 = rangeIndices.max - maxDelta;
    if (max3 - min4 < MIN_CATEGORY_RANGE) {
      max3 = min4 + MIN_CATEGORY_RANGE;
    }
    return {
      min: min4,
      max: max3
    };
  }
  zoomRange(scale, cursor) {
    const { min: totalMin, max: totalMax } = this.totalRange();
    const range = this.scaleRange(scale, cursor);
    return {
      min: limitValue(range.min, totalMin, totalMax),
      max: limitValue(range.max, totalMin, totalMax)
    };
  }
  labelsCount() {
    const labelsRange = this.labelsRange();
    return labelsRange.max - labelsRange.min;
  }
  labelsRange() {
    const options = this.options;
    const { justified, labels: labelOptions } = options;
    let { min: min4, max: max3 } = this.limitedRangeIndices(true);
    const start = Math.floor(min4);
    if (!justified) {
      min4 = Math.floor(min4);
      max3 = Math.ceil(max3);
    } else {
      min4 = Math.ceil(min4);
      max3 = Math.floor(max3);
    }
    let skip;
    if (min4 > labelOptions.skip) {
      skip = labelOptions.skip + labelOptions.step * Math.ceil((min4 - labelOptions.skip) / labelOptions.step);
    } else {
      skip = labelOptions.skip;
    }
    return {
      min: skip - start,
      max: (options.categories.length ? max3 + (justified ? 1 : 0) : 0) - start
    };
  }
  createAxisLabel(index, labelOptions, labelContext) {
    const options = this.options;
    const dataItem = options.dataItems ? options.dataItems[index] : null;
    const category = valueOrDefault(options.categories[index], "");
    labelContext.dataItem = dataItem;
    const text = this.axisLabelText(category, labelOptions, labelContext);
    return new axis_label_default(category, text, index, dataItem, labelOptions);
  }
  shouldRenderNote(value2) {
    const range = this.limitedRangeIndices();
    return Math.floor(range.min) <= value2 && value2 <= Math.ceil(range.max);
  }
  noteSlot(value2) {
    const options = this.options;
    const index = value2 - Math.floor(options.min || 0);
    return this.getSlot(index);
  }
  arrangeNotes() {
    super.arrangeNotes();
    this.hideOutOfRangeNotes();
  }
  hideOutOfRangeNotes() {
    const { notes: notes3, box } = this;
    if (notes3 && notes3.length) {
      const valueAxis = this.options.vertical ? Y : X;
      const start = box[valueAxis + 1];
      const end = box[valueAxis + 2];
      for (let idx = 0; idx < notes3.length; idx++) {
        const note = notes3[idx];
        if (note.box && (end < note.box[valueAxis + 1] || note.box[valueAxis + 2] < start)) {
          note.hide();
        }
      }
    }
  }
  pan(delta) {
    const range = this.limitedRangeIndices(true);
    const { scale } = this.scaleOptions();
    const offset = round(delta / scale, DEFAULT_PRECISION);
    const totalRange = this.totalRange();
    const min4 = range.min + offset;
    const max3 = range.max + offset;
    return this.limitRange(min4, max3, 0, totalRange.max, offset);
  }
  pointsRange(start, end) {
    const { reverse, vertical } = this.options;
    const valueAxis = vertical ? Y : X;
    const range = this.limitedRangeIndices(true);
    const { scale, box } = this.scaleOptions();
    const lineStart = box[valueAxis + (reverse ? 2 : 1)];
    const diffStart = start[valueAxis] - lineStart;
    const diffEnd = end[valueAxis] - lineStart;
    const min4 = range.min + diffStart / scale;
    const max3 = range.min + diffEnd / scale;
    const rangeMin = Math.min(min4, max3);
    const rangeMax = Math.max(min4, max3);
    if (rangeMax - rangeMin >= MIN_CATEGORY_POINTS_RANGE) {
      return {
        min: rangeMin,
        max: rangeMax
      };
    }
  }
  valueRange() {
    return this.range();
  }
  totalIndex(value2) {
    const options = this.options;
    const index = this._categoriesMap ? this._categoriesMap.get(value2) : indexOf(value2, options.srcCategories);
    return index;
  }
  currentRangeIndices() {
    const options = this.options;
    let min4 = 0;
    if (isNumber(options.min)) {
      min4 = Math.floor(options.min);
    }
    let max3;
    if (isNumber(options.max)) {
      max3 = options.justified ? Math.floor(options.max) : Math.ceil(options.max) - 1;
    } else {
      max3 = this.totalCount() - 1;
    }
    return {
      min: min4,
      max: max3
    };
  }
  limitedRangeIndices(totalLimit) {
    const options = this.options;
    let min4 = isNumber(options.min) ? options.min : 0;
    let max3;
    if (isNumber(options.max)) {
      max3 = options.max;
    } else if (isNumber(options.min)) {
      max3 = min4 + options.categories.length;
    } else {
      max3 = this.totalRange().max || 1;
    }
    if (totalLimit) {
      const totalRange = this.totalRange();
      min4 = limitValue(min4, 0, totalRange.max);
      max3 = limitValue(max3, 0, totalRange.max);
    }
    return {
      min: min4,
      max: max3
    };
  }
  totalRangeIndices() {
    return {
      min: 0,
      max: this.totalRange().max || 1
    };
  }
  indexCategories() {
    if (!this._categoriesMap) {
      const map2 = this._categoriesMap = new HashMap();
      const srcCategories = this.options.srcCategories;
      for (let idx = 0; idx < srcCategories.length; idx++) {
        map2.set(srcCategories[idx], idx);
      }
    }
  }
  totalCount() {
    return Math.max(this.options.srcCategories.length, this._seriesMax || 0);
  }
};
setDefaultOptions(CategoryAxis, {
  type: "category",
  vertical: false,
  majorGridLines: {
    visible: false,
    width: 1,
    color: BLACK
  },
  labels: {
    zIndex: 1
  },
  justified: false,
  _deferLabels: true
});
var category_axis_default = CategoryAxis;

// node_modules/@progress/kendo-charts/dist/es/core/constants.js
var COORDINATE_LIMIT = 3e5;
var DateLabelFormats = {
  milliseconds: "HH:mm:ss.fff",
  seconds: "HH:mm:ss",
  minutes: "HH:mm",
  hours: "HH:mm",
  days: "M/d",
  weeks: "M/d",
  months: "MMM 'yy",
  years: "yyyy"
};
var ZERO_THRESHOLD = 0.2;

// node_modules/@progress/kendo-charts/dist/es/core/date-category-axis.js
var AUTO = "auto";
var BASE_UNITS = [
  MILLISECONDS,
  SECONDS,
  MINUTES,
  HOURS,
  DAYS,
  WEEKS,
  MONTHS,
  YEARS
];
var FIT = "fit";
function categoryRange(categories, clearCache) {
  if (clearCache) {
    categories._range = void 0;
  }
  let range = categories._range;
  if (!range) {
    range = categories._range = sparseArrayLimits(categories);
    range.min = toDate(range.min);
    range.max = toDate(range.max);
  }
  return range;
}
var EmptyDateRange = class {
  constructor(options) {
    this.options = options;
  }
  displayIndices() {
    return {
      min: 0,
      max: 1
    };
  }
  displayRange() {
    return {};
  }
  total() {
    return {};
  }
  valueRange() {
    return {};
  }
  valueIndex() {
    return -1;
  }
  values() {
    return [];
  }
  totalIndex() {
    return -1;
  }
  valuesCount() {
    return 0;
  }
  totalCount() {
    return 0;
  }
  dateAt() {
    return null;
  }
};
var DateRange = class {
  constructor(start, end, options) {
    this.options = options;
    options.baseUnitStep = options.baseUnitStep || 1;
    const { roundToBaseUnit, justified } = options;
    this.start = addDuration(start, 0, options.baseUnit, options.weekStartDay);
    const lowerEnd = this.roundToTotalStep(end);
    const expandEnd = !justified && dateEquals(end, lowerEnd) && !options.justifyEnd;
    this.end = this.roundToTotalStep(end, !justified, expandEnd ? 1 : 0);
    const min4 = options.min || start;
    this.valueStart = this.roundToTotalStep(min4);
    this.displayStart = roundToBaseUnit ? this.valueStart : min4;
    const max3 = options.max;
    if (!max3) {
      this.valueEnd = lowerEnd;
      this.displayEnd = roundToBaseUnit || expandEnd ? this.end : end;
    } else {
      const next = !justified && dateEquals(max3, this.roundToTotalStep(max3)) ? -1 : 0;
      this.valueEnd = this.roundToTotalStep(max3, false, next);
      this.displayEnd = roundToBaseUnit ? this.roundToTotalStep(max3, !justified) : options.max;
    }
    if (this.valueEnd < this.valueStart) {
      this.valueEnd = this.valueStart;
    }
    if (this.displayEnd <= this.displayStart) {
      this.displayEnd = this.roundToTotalStep(this.displayStart, false, 1);
    }
  }
  displayRange() {
    return {
      min: this.displayStart,
      max: this.displayEnd
    };
  }
  displayIndices() {
    if (!this._indices) {
      const options = this.options;
      const { baseUnit, baseUnitStep } = options;
      const minIdx = dateIndex(this.displayStart, this.valueStart, baseUnit, baseUnitStep);
      const maxIdx = dateIndex(this.displayEnd, this.valueStart, baseUnit, baseUnitStep);
      this._indices = { min: minIdx, max: maxIdx };
    }
    return this._indices;
  }
  total() {
    return {
      min: this.start,
      max: this.end
    };
  }
  totalCount() {
    const last2 = this.totalIndex(this.end);
    return last2 + (this.options.justified ? 1 : 0);
  }
  valueRange() {
    return {
      min: this.valueStart,
      max: this.valueEnd
    };
  }
  valueIndex(value2) {
    const options = this.options;
    return Math.floor(dateIndex(value2, this.valueStart, options.baseUnit, options.baseUnitStep));
  }
  totalIndex(value2) {
    const options = this.options;
    return Math.floor(dateIndex(value2, this.start, options.baseUnit, options.baseUnitStep));
  }
  dateIndex(value2) {
    const options = this.options;
    return dateIndex(value2, this.valueStart, options.baseUnit, options.baseUnitStep);
  }
  valuesCount() {
    const maxIdx = this.valueIndex(this.valueEnd);
    return maxIdx + 1;
  }
  values() {
    let values = this._values;
    if (!values) {
      const options = this.options;
      const range = this.valueRange();
      this._values = values = [];
      for (let date = range.min; date <= range.max; ) {
        values.push(date);
        date = addDuration(date, options.baseUnitStep, options.baseUnit, options.weekStartDay);
      }
    }
    return values;
  }
  dateAt(index, total) {
    const options = this.options;
    return addDuration(total ? this.start : this.valueStart, options.baseUnitStep * index, options.baseUnit, options.weekStartDay);
  }
  roundToTotalStep(value2, upper, next) {
    const { baseUnit, baseUnitStep, weekStartDay } = this.options;
    const start = this.start;
    const step = dateIndex(value2, start, baseUnit, baseUnitStep);
    let roundedStep = upper ? Math.ceil(step) : Math.floor(step);
    if (next) {
      roundedStep += next;
    }
    return addDuration(start, roundedStep * baseUnitStep, baseUnit, weekStartDay);
  }
};
function autoBaseUnit(options, startUnit, startStep) {
  const categoryLimits = categoryRange(options.categories);
  const span = (options.max || categoryLimits.max) - (options.min || categoryLimits.min);
  const { autoBaseUnitSteps, maxDateGroups } = options;
  const autoUnit = options.baseUnit === FIT;
  let autoUnitIx = startUnit ? BASE_UNITS.indexOf(startUnit) : 0;
  let baseUnit = autoUnit ? BASE_UNITS[autoUnitIx++] : options.baseUnit;
  let units = span / TIME_PER_UNIT[baseUnit];
  let totalUnits = units;
  let unitSteps, step, nextStep;
  while (!step || units >= maxDateGroups) {
    unitSteps = unitSteps || autoBaseUnitSteps[baseUnit].slice(0);
    do {
      nextStep = unitSteps.shift();
    } while (nextStep && startUnit === baseUnit && nextStep < startStep);
    if (nextStep) {
      step = nextStep;
      units = totalUnits / step;
    } else if (baseUnit === last(BASE_UNITS)) {
      step = Math.ceil(totalUnits / maxDateGroups);
      break;
    } else if (autoUnit) {
      baseUnit = BASE_UNITS[autoUnitIx++] || last(BASE_UNITS);
      totalUnits = span / TIME_PER_UNIT[baseUnit];
      unitSteps = null;
    } else {
      if (units > maxDateGroups) {
        step = Math.ceil(totalUnits / maxDateGroups);
      }
      break;
    }
  }
  options.baseUnitStep = step;
  options.baseUnit = baseUnit;
}
function defaultBaseUnit(options) {
  const categories = options.categories;
  const count = defined(categories) ? categories.length : 0;
  let minDiff = MAX_VALUE;
  let lastCategory, unit;
  for (let categoryIx = 0; categoryIx < count; categoryIx++) {
    const category = categories[categoryIx];
    if (category && lastCategory) {
      let diff = Math.abs(absoluteDateDiff(category, lastCategory));
      if (diff !== 0) {
        minDiff = Math.min(minDiff, diff);
        if (minDiff >= TIME_PER_YEAR) {
          unit = YEARS;
        } else if (minDiff >= TIME_PER_MONTH - TIME_PER_DAY * 3) {
          unit = MONTHS;
        } else if (minDiff >= TIME_PER_WEEK) {
          unit = WEEKS;
        } else if (minDiff >= TIME_PER_DAY) {
          unit = DAYS;
        } else if (minDiff >= TIME_PER_HOUR) {
          unit = HOURS;
        } else if (minDiff >= TIME_PER_MINUTE) {
          unit = MINUTES;
        } else {
          unit = SECONDS;
        }
      }
    }
    lastCategory = category;
  }
  options.baseUnit = unit || DAYS;
}
function initUnit(options) {
  const baseUnit = (options.baseUnit || "").toLowerCase();
  const useDefault = baseUnit !== FIT && !inArray(baseUnit, BASE_UNITS);
  if (useDefault) {
    defaultBaseUnit(options);
  }
  if (baseUnit === FIT || options.baseUnitStep === AUTO) {
    autoBaseUnit(options);
  }
  return options;
}
var DateCategoryAxis = class _DateCategoryAxis extends category_axis_default {
  clone() {
    const copy = new _DateCategoryAxis(Object.assign({}, this.options), this.chartService);
    copy.createLabels();
    return copy;
  }
  categoriesHash() {
    const start = this.dataRange.total().min;
    return this.options.baseUnit + this.options.baseUnitStep + start;
  }
  initUserOptions(options) {
    return options;
  }
  initFields() {
    super.initFields();
    const chartService = this.chartService;
    const intlService = chartService.intl;
    let options = this.options;
    let categories = options.categories || [];
    if (!categories._parsed) {
      categories = parseDates(intlService, categories);
      categories._parsed = true;
    }
    options = deepExtend({
      roundToBaseUnit: true
    }, options, {
      categories,
      min: parseDate(intlService, options.min),
      max: parseDate(intlService, options.max),
      weekStartDay: firstDay(options, intlService)
    });
    if (chartService.panning && chartService.isPannable(options.vertical ? Y : X)) {
      options.roundToBaseUnit = false;
    }
    options.userSetBaseUnit = options.userSetBaseUnit || options.baseUnit;
    options.userSetBaseUnitStep = options.userSetBaseUnitStep || options.baseUnitStep;
    this.options = options;
    options.srcCategories = categories;
    if (categories.length > 0) {
      const range = categoryRange(categories, true);
      const maxDivisions = options.maxDivisions;
      const safeOptions = initUnit(options);
      const forecast = options._forecast;
      if (forecast) {
        if (forecast.before > 0) {
          range.min = addDuration(range.min, -forecast.before, safeOptions.baseUnit, safeOptions.weekStartDay);
        }
        if (forecast.after > 0) {
          range.max = addDuration(range.max, forecast.after, safeOptions.baseUnit, safeOptions.weekStartDay);
        }
      }
      this.dataRange = new DateRange(range.min, range.max, safeOptions);
      if (maxDivisions) {
        const dataRange = this.dataRange.displayRange();
        const divisionOptions = Object.assign({}, options, {
          justified: true,
          roundToBaseUnit: false,
          baseUnit: "fit",
          min: dataRange.min,
          max: dataRange.max,
          maxDateGroups: maxDivisions
        });
        const dataRangeOptions = this.dataRange.options;
        autoBaseUnit(divisionOptions, dataRangeOptions.baseUnit, dataRangeOptions.baseUnitStep);
        this.divisionRange = new DateRange(range.min, range.max, divisionOptions);
      } else {
        this.divisionRange = this.dataRange;
      }
    } else {
      options.baseUnit = options.baseUnit || DAYS;
      this.dataRange = this.divisionRange = new EmptyDateRange(options);
    }
    this.rangeLabels = [];
  }
  tickIndices(stepSize) {
    const { dataRange, divisionRange } = this;
    const valuesCount = divisionRange.valuesCount();
    if (!this.options.maxDivisions || !valuesCount) {
      return super.tickIndices(stepSize);
    }
    const indices = [];
    let values = divisionRange.values();
    let offset = 0;
    if (!this.options.justified) {
      values = values.concat(divisionRange.dateAt(valuesCount));
      offset = 0.5;
    }
    for (let idx = 0; idx < values.length; idx++) {
      indices.push(dataRange.dateIndex(values[idx]) + offset);
      if (stepSize !== 1 && idx >= 1) {
        const last2 = indices.length - 1;
        indices.splice(idx, 0, indices[last2 - 1] + (indices[last2] - indices[last2 - 1]) * stepSize);
      }
    }
    return indices;
  }
  shouldRenderNote(value2) {
    const range = this.range();
    const categories = this.options.categories || [];
    return dateComparer(value2, range.min) >= 0 && dateComparer(value2, range.max) <= 0 && categories.length;
  }
  parseNoteValue(value2) {
    return parseDate(this.chartService.intl, value2);
  }
  noteSlot(value2) {
    return this.getSlot(value2);
  }
  translateRange(delta) {
    const options = this.options;
    const { baseUnit, weekStartDay, vertical } = options;
    const lineBox = this.lineBox();
    const size = vertical ? lineBox.height() : lineBox.width();
    let range = this.range();
    const scale = size / (range.max - range.min);
    const offset = round(delta / scale, DEFAULT_PRECISION);
    if (range.min && range.max) {
      const from = addTicks(options.min || range.min, offset);
      const to = addTicks(options.max || range.max, offset);
      range = {
        min: addDuration(from, 0, baseUnit, weekStartDay),
        max: addDuration(to, 0, baseUnit, weekStartDay)
      };
    }
    return range;
  }
  labelsRange() {
    return {
      min: this.options.labels.skip,
      max: this.divisionRange.valuesCount()
    };
  }
  pan(delta) {
    if (this.isEmpty()) {
      return null;
    }
    const options = this.options;
    const lineBox = this.lineBox();
    const size = options.vertical ? lineBox.height() : lineBox.width();
    const { min: min4, max: max3 } = this.dataRange.displayRange();
    const totalLimits = this.dataRange.total();
    const scale = size / (max3 - min4);
    const offset = round(delta / scale, DEFAULT_PRECISION) * (options.reverse ? -1 : 1);
    const from = addTicks(min4, offset);
    const to = addTicks(max3, offset);
    const panRange = this.limitRange(toTime(from), toTime(to), toTime(totalLimits.min), toTime(totalLimits.max), offset);
    if (panRange) {
      panRange.min = toDate(panRange.min);
      panRange.max = toDate(panRange.max);
      panRange.baseUnit = options.baseUnit;
      panRange.baseUnitStep = options.baseUnitStep || 1;
      panRange.userSetBaseUnit = options.userSetBaseUnit;
      panRange.userSetBaseUnitStep = options.userSetBaseUnitStep;
      return panRange;
    }
  }
  pointsRange(start, end) {
    if (this.isEmpty()) {
      return null;
    }
    const pointsRange = super.pointsRange(start, end);
    const datesRange = this.dataRange.displayRange();
    const indicesRange = this.dataRange.displayIndices();
    const scale = dateDiff(datesRange.max, datesRange.min) / (indicesRange.max - indicesRange.min);
    const options = this.options;
    const min4 = addTicks(datesRange.min, pointsRange.min * scale);
    const max3 = addTicks(datesRange.min, pointsRange.max * scale);
    return {
      min: min4,
      max: max3,
      baseUnit: options.userSetBaseUnit || options.baseUnit,
      baseUnitStep: options.userSetBaseUnitStep || options.baseUnitStep
    };
  }
  scaleRange(scale, cursor) {
    if (this.isEmpty()) {
      return {};
    }
    const options = this.options;
    const fit = options.userSetBaseUnit === FIT;
    const totalLimits = this.dataRange.total();
    const { min: rangeMin, max: rangeMax } = this.dataRange.displayRange();
    const position = Math.abs(this.pointOffset(cursor));
    const range = rangeMax - rangeMin;
    const delta = this.scaleToDelta(scale, range);
    const minDelta = Math.round(position * delta);
    const maxDelta = Math.round((1 - position) * delta);
    let { baseUnit } = this.dataRange.options;
    let min4 = new Date(rangeMin.getTime() + minDelta);
    let max3 = new Date(rangeMax.getTime() - maxDelta);
    if (fit) {
      const { autoBaseUnitSteps, maxDateGroups } = options;
      const maxDiff = last(autoBaseUnitSteps[baseUnit]) * maxDateGroups * TIME_PER_UNIT[baseUnit];
      const rangeDiff = dateDiff(rangeMax, rangeMin);
      const diff = dateDiff(max3, min4);
      let baseUnitIndex = BASE_UNITS.indexOf(baseUnit);
      let autoBaseUnitStep, ticks;
      if (diff < TIME_PER_UNIT[baseUnit] && baseUnit !== MILLISECONDS) {
        baseUnit = BASE_UNITS[baseUnitIndex - 1];
        autoBaseUnitStep = last(autoBaseUnitSteps[baseUnit]);
        ticks = (rangeDiff - (maxDateGroups - 1) * autoBaseUnitStep * TIME_PER_UNIT[baseUnit]) / 2;
        min4 = addTicks(rangeMin, ticks);
        max3 = addTicks(rangeMax, -ticks);
      } else if (diff > maxDiff && baseUnit !== YEARS) {
        let stepIndex = 0;
        do {
          baseUnitIndex++;
          baseUnit = BASE_UNITS[baseUnitIndex];
          stepIndex = 0;
          ticks = 2 * TIME_PER_UNIT[baseUnit];
          do {
            autoBaseUnitStep = autoBaseUnitSteps[baseUnit][stepIndex];
            stepIndex++;
          } while (stepIndex < autoBaseUnitSteps[baseUnit].length && ticks * autoBaseUnitStep < rangeDiff);
        } while (baseUnit !== YEARS && ticks * autoBaseUnitStep < rangeDiff);
        ticks = (ticks * autoBaseUnitStep - rangeDiff) / 2;
        if (ticks > 0) {
          min4 = addTicks(rangeMin, -ticks);
          max3 = addTicks(rangeMax, ticks);
          min4 = addTicks(min4, limitValue(max3, totalLimits.min, totalLimits.max) - max3);
          max3 = addTicks(max3, limitValue(min4, totalLimits.min, totalLimits.max) - min4);
        }
      }
    }
    if (min4 && max3 && dateDiff(max3, min4) > 0) {
      return {
        min: min4,
        max: max3,
        baseUnit: options.userSetBaseUnit || options.baseUnit,
        baseUnitStep: options.userSetBaseUnitStep || options.baseUnitStep
      };
    }
  }
  zoomRange(scale, cursor) {
    const totalLimits = this.dataRange.total();
    const range = this.scaleRange(scale, cursor);
    if (range) {
      if (range.min < totalLimits.min) {
        range.min = totalLimits.min;
      }
      if (range.max > totalLimits.max) {
        range.max = totalLimits.max;
      }
    }
    return range;
  }
  range() {
    return this.dataRange.displayRange();
  }
  createLabels() {
    super.createLabels();
    this.createRangeLabels();
  }
  clearLabels() {
    super.clearLabels();
    this.rangeLabels = [];
  }
  arrangeLabels() {
    this.arrangeRangeLabels();
    super.arrangeLabels();
  }
  arrangeRangeLabels() {
    const { options, rangeLabels } = this;
    if (rangeLabels.length === 0) {
      return;
    }
    const lineBox = this.lineBox();
    const vertical = options.vertical;
    const mirror = options.rangeLabels.mirror || options.labels.mirror;
    const firstLabel = rangeLabels[0];
    if (firstLabel) {
      const position = vertical ? lineBox.y1 - firstLabel.box.height() / 2 : lineBox.x1;
      this.positionLabel(firstLabel, mirror, position);
    }
    const lastLabel = rangeLabels[1];
    if (lastLabel) {
      const position = vertical ? lineBox.y2 - lastLabel.box.height() / 2 : lineBox.x2;
      this.positionLabel(lastLabel, mirror, position);
    }
  }
  autoRotateLabels() {
    super.autoRotateLabels();
    this.autoRotateRangeLabels();
  }
  hideOutOfRangeLabels() {
    super.hideOutOfRangeLabels();
    this.hideOverlappingLabels();
  }
  hideOverlappingLabels() {
    const { rangeLabels, labels } = this;
    if (rangeLabels.length === 0) {
      return;
    }
    function clip(rangeLabel, label) {
      if (!label.options.visible || label.box.overlaps(rangeLabel.box)) {
        label.options.visible = false;
        return true;
      }
      return false;
    }
    const firstRangeLabel = rangeLabels[0];
    if (firstRangeLabel && firstRangeLabel.options.visible) {
      for (let i37 = 0; i37 < labels.length; i37++) {
        const overlaps = clip(firstRangeLabel, labels[i37]);
        if (!overlaps) {
          break;
        }
      }
    }
    const lastRangeLabel = rangeLabels[1];
    if (lastRangeLabel && lastRangeLabel.options.visible) {
      for (let i37 = labels.length - 1; i37 > 0; --i37) {
        const overlaps = clip(lastRangeLabel, labels[i37]);
        if (!overlaps) {
          break;
        }
      }
    }
  }
  contentBox() {
    const box = super.contentBox();
    const rangeLabels = this.rangeLabels;
    for (let i37 = 0; i37 < rangeLabels.length; i37++) {
      const label = rangeLabels[i37];
      if (label.options.visible) {
        box.wrap(label.box);
      }
    }
    return box;
  }
  createAxisLabel(index, labelOptions, labelContext = {}) {
    const options = this.options;
    const dataItem = options.dataItems && !options.maxDivisions ? options.dataItems[index] : null;
    const date = this.divisionRange.dateAt(index);
    const unitFormat = labelOptions.dateFormats[this.divisionRange.options.baseUnit];
    labelOptions.format = labelOptions.format || unitFormat;
    labelContext.dataItem = dataItem;
    const text = this.axisLabelText(date, labelOptions, labelContext);
    if (text) {
      return new axis_label_default(date, text, index, dataItem, labelOptions);
    }
  }
  createRangeLabels() {
    const { displayStart, displayEnd } = this.divisionRange;
    const options = this.options;
    const labelOptions = Object.assign({}, options.labels, options.rangeLabels, {
      align: CENTER,
      zIndex: options.zIndex
    });
    if (labelOptions.visible !== true) {
      return;
    }
    this.normalizeLabelRotation(labelOptions);
    labelOptions.alignRotation = CENTER;
    if (labelOptions.rotation === "auto") {
      labelOptions.rotation = 0;
      options.autoRotateRangeLabels = true;
    }
    const unitFormat = labelOptions.dateFormats[this.divisionRange.options.baseUnit];
    labelOptions.format = labelOptions.format || unitFormat;
    const createLabel = (index, date, text) => {
      if (text) {
        const label = new axis_label_default(date, text, index, null, labelOptions);
        this.append(label);
        this.rangeLabels.push(label);
      }
    };
    const startText = this.axisLabelText(displayStart, labelOptions, { index: 0, count: 2 });
    createLabel(0, displayStart, startText);
    const endText = this.axisLabelText(displayEnd, labelOptions, { index: 1, count: 2 });
    createLabel(1, displayEnd, endText);
  }
  autoRotateRangeLabels() {
    const labels = this.rangeLabels;
    if (!this.options.autoRotateRangeLabels || this.options.vertical || labels.length !== 2) {
      return;
    }
    const rotateLabel = (label, tickPositions2, index) => {
      const width = Math.abs(tickPositions2[index + 1] - tickPositions2[index]) * 2;
      const angle = this.autoRotateLabelAngle(label.box, width);
      if (angle !== 0) {
        label.options.rotation = angle;
        label.reflow(new box_default());
      }
    };
    const tickPositions = this.getMajorTickPositions();
    rotateLabel(labels[0], tickPositions, 0);
    rotateLabel(labels[1], tickPositions, tickPositions.length - 2);
  }
  categoryIndex(value2) {
    return this.dataRange.valueIndex(value2);
  }
  slot(from, to, limit) {
    const dateRange = this.dataRange;
    let start = from;
    let end = to;
    if (start instanceof Date) {
      start = dateRange.dateIndex(start);
    }
    if (end instanceof Date) {
      end = dateRange.dateIndex(end);
    }
    const slot = this.getSlot(start, end, limit);
    if (slot) {
      return slot.toRect();
    }
  }
  getSlot(a50, b2, limit) {
    let start = a50;
    let end = b2;
    if (typeof start === OBJECT) {
      start = this.categoryIndex(start);
    }
    if (typeof end === OBJECT) {
      end = this.categoryIndex(end);
    }
    return super.getSlot(start, end, limit);
  }
  valueRange() {
    const options = this.options;
    const range = categoryRange(options.srcCategories);
    return {
      min: toDate(range.min),
      max: toDate(range.max)
    };
  }
  categoryAt(index, total) {
    return this.dataRange.dateAt(index, total);
  }
  categoriesCount() {
    return this.dataRange.valuesCount();
  }
  rangeIndices() {
    return this.dataRange.displayIndices();
  }
  labelsBetweenTicks() {
    return !this.divisionRange.options.justified;
  }
  prepareUserOptions() {
    if (this.isEmpty()) {
      return;
    }
    this.options.categories = this.dataRange.values();
  }
  getCategory(point) {
    const index = this.pointCategoryIndex(point);
    if (index === null) {
      return null;
    }
    return this.dataRange.dateAt(index);
  }
  totalIndex(value2) {
    return this.dataRange.totalIndex(value2);
  }
  currentRangeIndices() {
    const range = this.dataRange.valueRange();
    return {
      min: this.dataRange.totalIndex(range.min),
      max: this.dataRange.totalIndex(range.max)
    };
  }
  totalRange() {
    return this.dataRange.total();
  }
  totalRangeIndices() {
    const range = this.dataRange.total();
    return {
      min: this.dataRange.totalIndex(range.min),
      max: this.dataRange.totalIndex(range.max)
    };
  }
  totalCount() {
    return this.dataRange.totalCount();
  }
  isEmpty() {
    return !this.options.srcCategories.length;
  }
  roundedRange() {
    if (this.options.roundToBaseUnit !== false || this.isEmpty()) {
      return this.range();
    }
    const options = this.options;
    const datesRange = categoryRange(options.srcCategories);
    const dateRange = new DateRange(datesRange.min, datesRange.max, Object.assign({}, options, {
      justified: false,
      roundToBaseUnit: true,
      justifyEnd: false
    }));
    return dateRange.displayRange();
  }
};
setDefaultOptions(DateCategoryAxis, {
  type: DATE,
  labels: {
    dateFormats: DateLabelFormats
  },
  rangeLabels: {
    visible: false
  },
  autoBaseUnitSteps: {
    milliseconds: [1, 10, 100],
    seconds: [1, 2, 5, 15, 30],
    minutes: [1, 2, 5, 15, 30],
    hours: [1, 2, 3],
    days: [1, 2, 3],
    weeks: [1, 2],
    months: [1, 2, 3, 6],
    years: [1, 2, 3, 5, 10, 25, 50]
  },
  maxDateGroups: 10
});
var date_category_axis_default = DateCategoryAxis;

// node_modules/@progress/kendo-charts/dist/es/core/utils/auto-axis-min.js
function autoAxisMin(min4, max3, narrow) {
  if (!min4 && !max3) {
    return 0;
  }
  let axisMin;
  if (min4 >= 0 && max3 >= 0) {
    const minValue = min4 === max3 ? 0 : min4;
    let diff = (max3 - minValue) / max3;
    if (narrow === false || !narrow && diff > ZERO_THRESHOLD) {
      return 0;
    }
    axisMin = Math.max(0, minValue - (max3 - minValue) / 2);
  } else {
    axisMin = min4;
  }
  return axisMin;
}

// node_modules/@progress/kendo-charts/dist/es/core/utils/auto-axis-max.js
function autoAxisMax(min4, max3, narrow) {
  if (!min4 && !max3) {
    return 1;
  }
  let axisMax;
  if (min4 <= 0 && max3 <= 0) {
    const maxValue = min4 === max3 ? 0 : max3;
    let diff = Math.abs((maxValue - min4) / maxValue);
    if (narrow === false || !narrow && diff > ZERO_THRESHOLD) {
      return 0;
    }
    axisMax = Math.min(0, maxValue - (min4 - maxValue) / 2);
  } else {
    axisMax = max3;
  }
  return axisMax;
}

// node_modules/@progress/kendo-charts/dist/es/core/utils/floor.js
function floor(value2, step) {
  return round(Math.floor(value2 / step) * step, DEFAULT_PRECISION);
}

// node_modules/@progress/kendo-charts/dist/es/core/utils/ceil.js
function ceil(value2, step) {
  return round(Math.ceil(value2 / step) * step, DEFAULT_PRECISION);
}

// node_modules/@progress/kendo-charts/dist/es/core/utils/limit-coordinate.js
function limitCoordinate(value2) {
  return Math.max(Math.min(value2, COORDINATE_LIMIT), -COORDINATE_LIMIT);
}

// node_modules/@progress/kendo-charts/dist/es/core/numeric-axis.js
var MIN_VALUE_RANGE = Math.pow(10, -DEFAULT_PRECISION + 1);
var NumericAxis = class _NumericAxis extends axis_default {
  constructor(seriesMin, seriesMax, options, chartService) {
    super(Object.assign({}, options, {
      seriesMin,
      seriesMax
    }), chartService);
  }
  initUserOptions(options) {
    const autoOptions = autoAxisOptions(options.seriesMin, options.seriesMax, options);
    this.totalOptions = totalAxisOptions(autoOptions, options);
    return axisOptions(autoOptions, options);
  }
  initFields() {
    this.totalMin = this.totalOptions.min;
    this.totalMax = this.totalOptions.max;
    this.totalMajorUnit = this.totalOptions.majorUnit;
    this.seriesMin = this.options.seriesMin;
    this.seriesMax = this.options.seriesMax;
  }
  clone() {
    return new _NumericAxis(
      this.seriesMin,
      this.seriesMax,
      Object.assign({}, this.options),
      this.chartService
    );
  }
  startValue() {
    return 0;
  }
  range() {
    const options = this.options;
    return { min: options.min, max: options.max };
  }
  getDivisions(stepValue) {
    if (stepValue === 0) {
      return 1;
    }
    const options = this.options;
    const range = options.max - options.min;
    return Math.floor(round(range / stepValue, COORD_PRECISION)) + 1;
  }
  getTickPositions(unit, skipUnit) {
    const options = this.options;
    const { axisDir, axisOrigin, lineBox, lineSize } = this.lineInfo();
    const range = options.max - options.min;
    const scale = lineSize / range;
    const step = unit * scale;
    const divisions = this.getDivisions(unit);
    const positions = [];
    let pos = lineBox[axisOrigin];
    let skipStep = 0;
    if (skipUnit) {
      skipStep = skipUnit / unit;
    }
    for (let idx = 0; idx < divisions; idx++) {
      if (idx % skipStep !== 0) {
        positions.push(round(pos, COORD_PRECISION));
      }
      pos = pos + step * axisDir;
    }
    return positions;
  }
  getMajorTickPositions() {
    return this.getTickPositions(this.options.majorUnit);
  }
  getMinorTickPositions() {
    return this.getTickPositions(this.options.minorUnit);
  }
  getSlot(a50, b2, limit = false) {
    const options = this.options;
    const { axis, axisDir, lineBox, lineSize, lineStart } = this.lineInfo();
    const step = axisDir * (lineSize / (options.max - options.min));
    let start = valueOrDefault(a50, b2 || 0);
    let end = valueOrDefault(b2, a50 || 0);
    if (limit) {
      start = limitValue(start, options.min, options.max);
      end = limitValue(end, options.min, options.max);
    }
    const p1 = Math.min(start, end) - options.min;
    const p22 = Math.max(start, end) - options.min;
    const slotBox = new box_default(lineBox.x1, lineBox.y1, lineBox.x1, lineBox.y1);
    slotBox[axis + 1] = limitCoordinate(lineStart + step * (axisDir > 0 ? p1 : p22));
    slotBox[axis + 2] = limitCoordinate(lineStart + step * (axisDir > 0 ? p22 : p1));
    return slotBox;
  }
  getValue(point) {
    const options = this.options;
    const max3 = Number(options.max);
    const min4 = Number(options.min);
    const offset = this.pointOffset(point);
    const valueOffset = offset * (max3 - min4);
    if (offset < 0 || offset > 1) {
      return null;
    }
    const value2 = min4 + valueOffset;
    return round(value2, DEFAULT_PRECISION);
  }
  translateRange(delta) {
    const options = this.options;
    const { vertical, reverse, max: max3, min: min4 } = options;
    const { lineSize } = this.lineInfo();
    const range = max3 - min4;
    const scale = lineSize / range;
    let offset = round(delta / scale, DEFAULT_PRECISION);
    if ((vertical || reverse) && !(vertical && reverse)) {
      offset = -offset;
    }
    return {
      min: min4 + offset,
      max: max3 + offset,
      offset
    };
  }
  labelsCount() {
    return this.getDivisions(this.options.majorUnit);
  }
  createAxisLabel(index, labelOptions, labelContext) {
    const options = this.options;
    const value2 = round(options.min + index * options.majorUnit, DEFAULT_PRECISION);
    const text = this.axisLabelText(value2, labelOptions, labelContext);
    return new axis_label_default(value2, text, index, null, labelOptions);
  }
  shouldRenderNote(value2) {
    const range = this.range();
    return range.min <= value2 && value2 <= range.max;
  }
  pan(delta) {
    const range = this.translateRange(delta);
    return this.limitRange(range.min, range.max, this.totalMin, this.totalMax, range.offset);
  }
  pointsRange(start, end) {
    const startValue = this.getValue(start);
    const endValue = this.getValue(end);
    const min4 = Math.min(startValue, endValue);
    const max3 = Math.max(startValue, endValue);
    if (this.isValidRange(min4, max3)) {
      return {
        min: min4,
        max: max3
      };
    }
  }
  scaleRange(scale, cursor) {
    const position = Math.abs(this.pointOffset(cursor));
    const range = this.options.max - this.options.min;
    const delta = this.scaleToDelta(scale, range);
    const minDelta = position * delta;
    const maxDelta = (1 - position) * delta;
    const min4 = round(this.options.min + minDelta, DEFAULT_PRECISION);
    let max3 = round(this.options.max - maxDelta, DEFAULT_PRECISION);
    if (max3 - min4 < MIN_VALUE_RANGE) {
      max3 = min4 + MIN_VALUE_RANGE;
    }
    return {
      min: min4,
      max: max3
    };
  }
  zoomRange(scale, cursor) {
    const { totalMin, totalMax } = this;
    const range = this.scaleRange(scale, cursor);
    return {
      min: limitValue(range.min, totalMin, totalMax),
      max: limitValue(range.max, totalMin, totalMax),
      narrowRange: false
    };
  }
  isValidRange(min4, max3) {
    return max3 - min4 > MIN_VALUE_RANGE;
  }
};
function autoAxisOptions(seriesMin, seriesMax, options) {
  const narrowRange = options.narrowRange;
  let autoMin = autoAxisMin(seriesMin, seriesMax, narrowRange);
  let autoMax = autoAxisMax(seriesMin, seriesMax, narrowRange);
  const majorUnit = autoMajorUnit(autoMin, autoMax);
  const autoOptions = {
    majorUnit
  };
  if (options.roundToMajorUnit !== false) {
    if (autoMin < 0 && remainderClose(autoMin, majorUnit, 1 / 3)) {
      autoMin -= majorUnit;
    }
    if (autoMax > 0 && remainderClose(autoMax, majorUnit, 1 / 3)) {
      autoMax += majorUnit;
    }
  }
  autoOptions.min = floor(autoMin, majorUnit);
  autoOptions.max = ceil(autoMax, majorUnit);
  return autoOptions;
}
function totalAxisOptions(autoOptions, options) {
  return {
    min: defined(options.min) ? Math.min(autoOptions.min, options.min) : autoOptions.min,
    max: defined(options.max) ? Math.max(autoOptions.max, options.max) : autoOptions.max,
    majorUnit: autoOptions.majorUnit
  };
}
function clearNullValues(options, fields) {
  for (let idx = 0; idx < fields.length; idx++) {
    const field = fields[idx];
    if (options[field] === null) {
      options[field] = void 0;
    }
  }
}
function axisOptions(autoOptions, userOptions) {
  let options = userOptions;
  let userSetMin, userSetMax;
  if (userOptions) {
    clearNullValues(userOptions, ["min", "max"]);
    userSetMin = defined(userOptions.min);
    userSetMax = defined(userOptions.max);
    const userSetLimits = userSetMin || userSetMax;
    if (userSetLimits) {
      if (userOptions.min === userOptions.max) {
        if (userOptions.min > 0) {
          userOptions.min = 0;
        } else {
          userOptions.max = 1;
        }
      }
    }
    if (userOptions.majorUnit) {
      autoOptions.min = floor(autoOptions.min, userOptions.majorUnit);
      autoOptions.max = ceil(autoOptions.max, userOptions.majorUnit);
    } else if (userSetLimits) {
      options = deepExtend(autoOptions, userOptions);
      autoOptions.majorUnit = autoMajorUnit(options.min, options.max);
    }
  }
  autoOptions.minorUnit = (options.majorUnit || autoOptions.majorUnit) / 5;
  const result = deepExtend(autoOptions, options);
  if (result.min >= result.max) {
    if (userSetMin && !userSetMax) {
      result.max = result.min + result.majorUnit;
    } else if (!userSetMin && userSetMax) {
      result.min = result.max - result.majorUnit;
    }
  }
  return result;
}
function remainderClose(value2, divisor, ratio) {
  const remainder = round(Math.abs(value2 % divisor), DEFAULT_PRECISION);
  const threshold = divisor * (1 - ratio);
  return remainder === 0 || remainder > threshold;
}
setDefaultOptions(NumericAxis, {
  type: "numeric",
  min: 0,
  max: 1,
  vertical: true,
  majorGridLines: {
    visible: true,
    width: 1,
    color: BLACK
  },
  labels: {
    format: "#.####################"
  },
  zIndex: 1
});
var numeric_axis_default = NumericAxis;

// node_modules/@progress/kendo-charts/dist/es/core/date-value-axis.js
var MIN_VALUE_RANGE2 = 1e3;
var DateValueAxis = class _DateValueAxis extends axis_default {
  constructor(seriesMin, seriesMax, axisOptions2, chartService) {
    const min4 = toDate(seriesMin);
    const max3 = toDate(seriesMax);
    const intlService = chartService.intl;
    let options = axisOptions2 || {};
    options = deepExtend(options || {}, {
      min: parseDate(intlService, options.min),
      max: parseDate(intlService, options.max),
      axisCrossingValue: parseDates(intlService, options.axisCrossingValues || options.axisCrossingValue),
      weekStartDay: firstDay(options, intlService)
    });
    options = applyDefaults(min4, max3, options);
    super(options, chartService);
    this.intlService = intlService;
    this.seriesMin = min4;
    this.seriesMax = max3;
    const weekStartDay = options.weekStartDay || 0;
    this.totalMin = toTime(floorDate(toTime(min4) - 1, options.baseUnit, weekStartDay));
    this.totalMax = toTime(ceilDate(toTime(max3) + 1, options.baseUnit, weekStartDay));
  }
  clone() {
    return new _DateValueAxis(this.seriesMin, this.seriesMax, Object.assign({}, this.options), this.chartService);
  }
  range() {
    const options = this.options;
    return { min: options.min, max: options.max };
  }
  getDivisions(stepValue) {
    const options = this.options;
    return Math.floor(
      duration(options.min, options.max, options.baseUnit) / stepValue + 1
    );
  }
  getTickPositions(step) {
    const options = this.options;
    const { axisDir: dir, lineSize, lineStart: start } = this.lineInfo();
    const divisions = this.getDivisions(step);
    const timeRange = dateDiff(options.max, options.min);
    const scale = lineSize / timeRange;
    const weekStartDay = options.weekStartDay || 0;
    const positions = [start];
    for (let i37 = 1; i37 < divisions; i37++) {
      const date = addDuration(options.min, i37 * step, options.baseUnit, weekStartDay);
      const pos = start + dateDiff(date, options.min) * scale * dir;
      positions.push(round(pos, COORD_PRECISION));
    }
    return positions;
  }
  getMajorTickPositions() {
    return this.getTickPositions(this.options.majorUnit);
  }
  getMinorTickPositions() {
    return this.getTickPositions(this.options.minorUnit);
  }
  getSlot(a50, b2, limit) {
    return numeric_axis_default.prototype.getSlot.call(
      this,
      parseDate(this.intlService, a50),
      parseDate(this.intlService, b2),
      limit
    );
  }
  getValue(point) {
    const value2 = numeric_axis_default.prototype.getValue.call(this, point);
    return value2 !== null ? toDate(value2) : null;
  }
  labelsCount() {
    return this.getDivisions(this.options.majorUnit);
  }
  createAxisLabel(index, labelOptions, labelContext) {
    const options = this.options;
    const offset = index * options.majorUnit;
    const weekStartDay = options.weekStartDay || 0;
    let date = options.min;
    if (offset > 0) {
      date = addDuration(date, offset, options.baseUnit, weekStartDay);
    }
    const unitFormat = labelOptions.dateFormats[options.baseUnit];
    labelOptions.format = labelOptions.format || unitFormat;
    const text = this.axisLabelText(date, labelOptions, labelContext);
    return new axis_label_default(date, text, index, null, labelOptions);
  }
  translateRange(delta) {
    const options = this.options;
    const lineBox = this.lineBox();
    const { vertical, reverse } = options;
    const size = vertical ? lineBox.height() : lineBox.width();
    const range = this.range();
    const scale = size / dateDiff(range.max, range.min);
    let offset = round(delta / scale, DEFAULT_PRECISION);
    if ((vertical || reverse) && !(vertical && reverse)) {
      offset = -offset;
    }
    let from = addTicks(options.min, offset);
    let to = addTicks(options.max, offset);
    return {
      min: from,
      max: to,
      offset
    };
  }
  shouldRenderNote(value2) {
    const range = this.range();
    return dateComparer(value2, range.min) >= 0 && dateComparer(value2, range.max) <= 0;
  }
  pan(delta) {
    const range = this.translateRange(delta, true);
    const limittedRange = this.limitRange(toTime(range.min), toTime(range.max), this.totalMin, this.totalMax, range.offset);
    if (limittedRange) {
      return {
        min: toDate(limittedRange.min),
        max: toDate(limittedRange.max)
      };
    }
  }
  pointsRange(start, end) {
    const startValue = this.getValue(start);
    const endValue = this.getValue(end);
    const min4 = Math.min(startValue, endValue);
    const max3 = Math.max(startValue, endValue);
    return {
      min: toDate(min4),
      max: toDate(max3)
    };
  }
  scaleRange(scale, cursor) {
    const position = Math.abs(this.pointOffset(cursor));
    const range = this.options.max - this.options.min;
    const delta = this.scaleToDelta(scale, range);
    const minDelta = position * delta;
    const maxDelta = (1 - position) * delta;
    const min4 = toDate(toTime(this.options.min) + minDelta);
    let max3 = toDate(toTime(this.options.max) - maxDelta);
    if (max3 - min4 < MIN_VALUE_RANGE2) {
      max3 = toDate(toTime(min4) + MIN_VALUE_RANGE2);
    }
    return {
      min: min4,
      max: max3
    };
  }
  zoomRange(scale, cursor) {
    const range = this.scaleRange(scale, cursor);
    const min4 = toDate(limitValue(toTime(range.min), this.totalMin, this.totalMax));
    const max3 = toDate(limitValue(toTime(range.max), this.totalMin, this.totalMax));
    return {
      min: min4,
      max: max3
    };
  }
};
function timeUnits(delta) {
  let unit = HOURS;
  if (delta >= TIME_PER_YEAR) {
    unit = YEARS;
  } else if (delta >= TIME_PER_MONTH) {
    unit = MONTHS;
  } else if (delta >= TIME_PER_WEEK) {
    unit = WEEKS;
  } else if (delta >= TIME_PER_DAY) {
    unit = DAYS;
  }
  return unit;
}
function applyDefaults(seriesMin, seriesMax, options) {
  const min4 = options.min || seriesMin;
  const max3 = options.max || seriesMax;
  const baseUnit = options.baseUnit || (max3 && min4 ? timeUnits(absoluteDateDiff(max3, min4)) : HOURS);
  const baseUnitTime = TIME_PER_UNIT[baseUnit];
  const weekStartDay = options.weekStartDay || 0;
  const autoMin = floorDate(toTime(min4) - 1, baseUnit, weekStartDay) || toDate(max3);
  const autoMax = ceilDate(toTime(max3) + 1, baseUnit, weekStartDay);
  const userMajorUnit = options.majorUnit ? options.majorUnit : void 0;
  const majorUnit = userMajorUnit || ceil(
    autoMajorUnit(autoMin.getTime(), autoMax.getTime()),
    baseUnitTime
  ) / baseUnitTime;
  const actualUnits = duration(autoMin, autoMax, baseUnit);
  const totalUnits = ceil(actualUnits, majorUnit);
  const unitsToAdd = totalUnits - actualUnits;
  const head = Math.floor(unitsToAdd / 2);
  const tail = unitsToAdd - head;
  if (!options.baseUnit) {
    delete options.baseUnit;
  }
  options.baseUnit = options.baseUnit || baseUnit;
  options.min = options.min || addDuration(autoMin, -head, baseUnit, weekStartDay);
  options.max = options.max || addDuration(autoMax, tail, baseUnit, weekStartDay);
  options.minorUnit = options.minorUnit || majorUnit / 5;
  options.majorUnit = majorUnit;
  return options;
}
setDefaultOptions(DateValueAxis, {
  type: DATE,
  majorGridLines: {
    visible: true,
    width: 1,
    color: BLACK
  },
  labels: {
    dateFormats: DateLabelFormats
  }
});
var date_value_axis_default = DateValueAxis;

// node_modules/@progress/kendo-charts/dist/es/core/logarithmic-axis.js
var DEFAULT_MAJOR_UNIT = 10;
var MIN_VALUE_RANGE3 = 1e-6;
var LogarithmicAxis = class _LogarithmicAxis extends axis_default {
  constructor(seriesMin, seriesMax, options, chartService) {
    const axisOptions2 = deepExtend({ majorUnit: DEFAULT_MAJOR_UNIT, min: seriesMin, max: seriesMax }, options);
    const base = axisOptions2.majorUnit;
    const autoMax = autoAxisMax2(seriesMax, base);
    const autoMin = autoAxisMin2(seriesMin, seriesMax, axisOptions2);
    const range = initRange(autoMin, autoMax, axisOptions2, options);
    axisOptions2.max = range.max;
    axisOptions2.min = range.min;
    axisOptions2.minorUnit = options.minorUnit || round(base - 1, DEFAULT_PRECISION);
    super(axisOptions2, chartService);
    this.totalMin = defined(options.min) ? Math.min(autoMin, options.min) : autoMin;
    this.totalMax = defined(options.max) ? Math.max(autoMax, options.max) : autoMax;
    this.logMin = round(log(range.min, base), DEFAULT_PRECISION);
    this.logMax = round(log(range.max, base), DEFAULT_PRECISION);
    this.seriesMin = seriesMin;
    this.seriesMax = seriesMax;
    this.createLabels();
  }
  clone() {
    return new _LogarithmicAxis(
      this.seriesMin,
      this.seriesMax,
      Object.assign({}, this.options),
      this.chartService
    );
  }
  startValue() {
    return this.options.min;
  }
  getSlot(a50, b2, limit) {
    const { options, logMin, logMax } = this;
    const { majorUnit: base, min: min4, max: max3 } = options;
    const { axis, axisDir, lineBox, lineSize, lineStart } = this.lineInfo();
    const step = axisDir * (lineSize / (logMax - logMin));
    let start = valueOrDefault(a50, b2 || 1);
    let end = valueOrDefault(b2, a50 || 1);
    if (start <= 0 || end <= 0) {
      return null;
    }
    if (limit) {
      start = limitValue(start, min4, max3);
      end = limitValue(end, min4, max3);
    }
    start = log(start, base);
    end = log(end, base);
    const p1 = Math.min(start, end) - logMin;
    const p22 = Math.max(start, end) - logMin;
    const slotBox = new box_default(lineBox.x1, lineBox.y1, lineBox.x1, lineBox.y1);
    slotBox[axis + 1] = limitCoordinate(lineStart + step * (axisDir > 0 ? p1 : p22));
    slotBox[axis + 2] = limitCoordinate(lineStart + step * (axisDir > 0 ? p22 : p1));
    return slotBox;
  }
  getValue(point) {
    const { options, logMin, logMax } = this;
    const { majorUnit: base } = options;
    const { axis, axisDir, lineStart, lineSize } = this.lineInfo();
    const step = (logMax - logMin) / lineSize;
    const offset = axisDir * (point[axis] - lineStart);
    const valueOffset = offset * step;
    if (offset < 0 || offset > lineSize) {
      return null;
    }
    const value2 = logMin + valueOffset;
    return round(Math.pow(base, value2), DEFAULT_PRECISION);
  }
  range() {
    const options = this.options;
    return { min: options.min, max: options.max };
  }
  translateRange(delta) {
    const { options, logMin, logMax } = this;
    const { reverse, vertical, majorUnit: base } = options;
    const lineBox = this.lineBox();
    const size = vertical ? lineBox.height() : lineBox.width();
    const scale = size / (logMax - logMin);
    let offset = round(delta / scale, DEFAULT_PRECISION);
    if ((vertical || reverse) && !(vertical && reverse)) {
      offset = -offset;
    }
    return {
      min: Math.pow(base, logMin + offset),
      max: Math.pow(base, logMax + offset),
      offset
    };
  }
  labelsCount() {
    const floorMax = Math.floor(this.logMax);
    const count = Math.floor(floorMax - this.logMin) + 1;
    return count;
  }
  getMajorTickPositions() {
    const ticks = [];
    this.traverseMajorTicksPositions((position) => {
      ticks.push(position);
    }, { step: 1, skip: 0 });
    return ticks;
  }
  createTicks(lineGroup) {
    const options = this.options;
    const { majorTicks, minorTicks, vertical } = options;
    const mirror = options.labels.mirror;
    const lineBox = this.lineBox();
    const ticks = [];
    const tickLineOptions = {
      // TODO
      // _alignLines: options._alignLines,
      vertical
    };
    function render(tickPosition, tickOptions) {
      tickLineOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;
      tickLineOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;
      tickLineOptions.position = tickPosition;
      lineGroup.append(createAxisTick(tickLineOptions, tickOptions));
    }
    if (majorTicks.visible) {
      this.traverseMajorTicksPositions(render, majorTicks);
    }
    if (minorTicks.visible) {
      this.traverseMinorTicksPositions(render, minorTicks);
    }
    return ticks;
  }
  createGridLines(altAxis) {
    const options = this.options;
    const { minorGridLines, majorGridLines, vertical } = options;
    const lineBox = altAxis.lineBox();
    const lineOptions = {
      lineStart: lineBox[vertical ? "x1" : "y1"],
      lineEnd: lineBox[vertical ? "x2" : "y2"],
      vertical
    };
    const majorTicks = [];
    const container = this.gridLinesVisual();
    function render(tickPosition, gridLine) {
      if (!inArray(tickPosition, majorTicks)) {
        lineOptions.position = tickPosition;
        container.append(createAxisGridLine(lineOptions, gridLine));
        majorTicks.push(tickPosition);
      }
    }
    if (majorGridLines.visible) {
      this.traverseMajorTicksPositions(render, majorGridLines);
    }
    if (minorGridLines.visible) {
      this.traverseMinorTicksPositions(render, minorGridLines);
    }
    return container.children;
  }
  traverseMajorTicksPositions(callback, tickOptions) {
    const { lineStart, step } = this.lineInfo();
    const { logMin, logMax } = this;
    for (let power = Math.ceil(logMin) + tickOptions.skip; power <= logMax; power += tickOptions.step) {
      let position = round(lineStart + step * (power - logMin), DEFAULT_PRECISION);
      callback(position, tickOptions);
    }
  }
  traverseMinorTicksPositions(callback, tickOptions) {
    const { min: min4, max: max3, minorUnit, majorUnit: base } = this.options;
    const { lineStart, step } = this.lineInfo();
    const { logMin, logMax } = this;
    const start = Math.floor(logMin);
    for (let power = start; power < logMax; power++) {
      const minorOptions = this._minorIntervalOptions(power);
      for (let idx = tickOptions.skip; idx < minorUnit; idx += tickOptions.step) {
        const value2 = minorOptions.value + idx * minorOptions.minorStep;
        if (value2 > max3) {
          break;
        }
        if (value2 >= min4) {
          const position = round(lineStart + step * (log(value2, base) - logMin), DEFAULT_PRECISION);
          callback(position, tickOptions);
        }
      }
    }
  }
  createAxisLabel(index, labelOptions, labelContext) {
    const power = Math.ceil(this.logMin + index);
    const value2 = Math.pow(this.options.majorUnit, power);
    const text = this.axisLabelText(value2, labelOptions, labelContext);
    return new axis_label_default(value2, text, index, null, labelOptions);
  }
  shouldRenderNote(value2) {
    const range = this.range();
    return range.min <= value2 && value2 <= range.max;
  }
  pan(delta) {
    const range = this.translateRange(delta);
    return this.limitRange(range.min, range.max, this.totalMin, this.totalMax, range.offset);
  }
  pointsRange(start, end) {
    const startValue = this.getValue(start);
    const endValue = this.getValue(end);
    const min4 = Math.min(startValue, endValue);
    const max3 = Math.max(startValue, endValue);
    return {
      min: min4,
      max: max3
    };
  }
  scaleRange(scale, cursor) {
    const { majorUnit: base } = this.options;
    const logMin = log(this.options.min, base);
    const logMax = log(this.options.max, base);
    const position = Math.abs(this.pointOffset(cursor));
    const range = logMax - logMin;
    const delta = this.scaleToDelta(scale, range);
    const min4 = Math.pow(base, logMin + position * delta);
    let max3 = Math.pow(base, logMax - (1 - position) * delta);
    if (max3 - min4 < MIN_VALUE_RANGE3) {
      max3 = min4 + MIN_VALUE_RANGE3;
    }
    return {
      min: min4,
      max: max3
    };
  }
  zoomRange(scale, cursor) {
    const range = this.scaleRange(scale, cursor);
    const { totalMin, totalMax } = this;
    return {
      min: limitValue(range.min, totalMin, totalMax),
      max: limitValue(range.max, totalMin, totalMax)
    };
  }
  _minorIntervalOptions(power) {
    const { minorUnit, majorUnit: base } = this.options;
    const value2 = Math.pow(base, power);
    const nextValue = Math.pow(base, power + 1);
    const difference = nextValue - value2;
    const minorStep = difference / minorUnit;
    return {
      value: value2,
      minorStep
    };
  }
  lineInfo() {
    const info = super.lineInfo();
    info.step = info.axisDir * (info.lineSize / (this.logMax - this.logMin));
    return info;
  }
};
function initRange(autoMin, autoMax, axisOptions2, options) {
  let { min: min4, max: max3 } = axisOptions2;
  if (defined(axisOptions2.axisCrossingValue) && axisOptions2.axisCrossingValue <= 0) {
    throwNegativeValuesError();
  }
  if (!defined(options.max)) {
    max3 = autoMax;
  } else if (options.max <= 0) {
    throwNegativeValuesError();
  }
  if (!defined(options.min)) {
    min4 = autoMin;
  } else if (options.min <= 0) {
    throwNegativeValuesError();
  }
  return {
    min: min4,
    max: max3
  };
}
function autoAxisMin2(min4, max3, options) {
  const base = options.majorUnit;
  let autoMin = min4;
  if (min4 <= 0) {
    autoMin = max3 <= 1 ? Math.pow(base, -2) : 1;
  } else if (!options.narrowRange) {
    autoMin = Math.pow(base, Math.floor(log(min4, base)));
  }
  return autoMin;
}
function autoAxisMax2(max3, base) {
  const logMaxRemainder = round(log(max3, base), DEFAULT_PRECISION) % 1;
  let autoMax;
  if (max3 <= 0) {
    autoMax = base;
  } else if (logMaxRemainder !== 0 && (logMaxRemainder < 0.3 || logMaxRemainder > 0.9)) {
    autoMax = Math.pow(base, log(max3, base) + 0.2);
  } else {
    autoMax = Math.pow(base, Math.ceil(log(max3, base)));
  }
  return autoMax;
}
function throwNegativeValuesError() {
  throw new Error("Non positive values cannot be used for a logarithmic axis");
}
function log(x7, base) {
  return Math.log(x7) / Math.log(base);
}
setDefaultOptions(LogarithmicAxis, {
  type: "log",
  majorUnit: DEFAULT_MAJOR_UNIT,
  minorUnit: 1,
  axisCrossingValue: 1,
  vertical: true,
  majorGridLines: {
    visible: true,
    width: 1,
    color: BLACK
  },
  zIndex: 1,
  _deferLabels: true
});
var logarithmic_axis_default = LogarithmicAxis;

// node_modules/@progress/kendo-charts/dist/es/core/mixins/grid-lines-mixin.js
var GridLinesMixin = {
  createGridLines: function(altAxis) {
    const options = this.options;
    const radius = Math.abs(this.box.center().y - altAxis.lineBox().y1);
    let gridLines = [];
    let skipMajor = false;
    let majorAngles, minorAngles;
    if (options.majorGridLines.visible) {
      majorAngles = this.majorGridLineAngles(altAxis);
      skipMajor = true;
      gridLines = this.renderMajorGridLines(
        majorAngles,
        radius,
        options.majorGridLines
      );
    }
    if (options.minorGridLines.visible) {
      minorAngles = this.minorGridLineAngles(altAxis, skipMajor);
      append(gridLines, this.renderMinorGridLines(
        minorAngles,
        radius,
        options.minorGridLines,
        altAxis,
        skipMajor
      ));
    }
    return gridLines;
  },
  renderMajorGridLines: function(angles, radius, options) {
    return this.renderGridLines(angles, radius, options);
  },
  renderMinorGridLines: function(angles, radius, options, altAxis, skipMajor) {
    const radiusCallback = this.radiusCallback && this.radiusCallback(radius, altAxis, skipMajor);
    return this.renderGridLines(angles, radius, options, radiusCallback);
  },
  renderGridLines: function(angles, radius, options, radiusCallback) {
    const style = {
      stroke: {
        width: options.width,
        color: options.color,
        dashType: options.dashType
      }
    };
    const center = this.box.center();
    const circle = new geometry_exports.Circle([center.x, center.y], radius);
    const container = this.gridLinesVisual();
    for (let i37 = 0; i37 < angles.length; i37++) {
      const line = new drawing_exports.Path(style);
      if (radiusCallback) {
        circle.radius = radiusCallback(angles[i37]);
      }
      line.moveTo(circle.center).lineTo(circle.pointAt(angles[i37] + 180));
      container.append(line);
    }
    return container.children;
  },
  gridLineAngles: function(altAxis, size, skip, step, skipAngles) {
    const divs = this.intervals(size, skip, step, skipAngles);
    const options = altAxis.options;
    const altAxisVisible = options.visible && (options.line || {}).visible !== false;
    return map(divs, (d5) => {
      const alpha = this.intervalAngle(d5);
      if (!altAxisVisible || alpha !== 90) {
        return alpha;
      }
    });
  }
};
var grid_lines_mixin_default = GridLinesMixin;

// node_modules/@progress/kendo-charts/dist/es/core/radar-category-axis.js
var RadarCategoryAxis = class extends category_axis_default {
  range() {
    return { min: 0, max: this.options.categories.length };
  }
  reflow(box) {
    this.box = box;
    this.reflowLabels();
  }
  lineBox() {
    return this.box;
  }
  reflowLabels() {
    const { labels, options: { labels: labelOptions } } = this;
    const skip = labelOptions.skip || 0;
    const step = labelOptions.step || 1;
    const measureBox = new box_default();
    for (let i37 = 0; i37 < labels.length; i37++) {
      labels[i37].reflow(measureBox);
      const labelBox = labels[i37].box;
      labels[i37].reflow(this.getSlot(skip + i37 * step).adjacentBox(
        0,
        labelBox.width(),
        labelBox.height()
      ));
    }
  }
  intervals(size, skipOption, stepOption, skipAngles = false) {
    const options = this.options;
    const categories = options.categories.length;
    const divCount = categories / size || 1;
    const divAngle = 360 / divCount;
    const skip = skipOption || 0;
    const step = stepOption || 1;
    const divs = [];
    let angle = 0;
    for (let i37 = skip; i37 < divCount; i37 += step) {
      if (options.reverse) {
        angle = 360 - i37 * divAngle;
      } else {
        angle = i37 * divAngle;
      }
      angle = round(angle, COORD_PRECISION) % 360;
      if (!(skipAngles && inArray(angle, skipAngles))) {
        divs.push(angle);
      }
    }
    return divs;
  }
  majorIntervals() {
    return this.intervals(1);
  }
  minorIntervals() {
    return this.intervals(0.5);
  }
  intervalAngle(interval) {
    return (360 + interval + this.options.startAngle) % 360;
  }
  majorAngles() {
    return map(this.majorIntervals(), (interval) => this.intervalAngle(interval));
  }
  createLine() {
    return [];
  }
  majorGridLineAngles(altAxis) {
    const majorGridLines = this.options.majorGridLines;
    return this.gridLineAngles(altAxis, 1, majorGridLines.skip, majorGridLines.step);
  }
  minorGridLineAngles(altAxis, skipMajor) {
    const { minorGridLines, majorGridLines } = this.options;
    const majorGridLineAngles = skipMajor ? this.intervals(1, majorGridLines.skip, majorGridLines.step) : null;
    return this.gridLineAngles(altAxis, 0.5, minorGridLines.skip, minorGridLines.step, majorGridLineAngles);
  }
  radiusCallback(radius, altAxis, skipMajor) {
    if (altAxis.options.type !== ARC) {
      const minorAngle = rad(360 / (this.options.categories.length * 2));
      const minorRadius = Math.cos(minorAngle) * radius;
      const majorAngles = this.majorAngles();
      const radiusCallback = function(angle) {
        if (!skipMajor && inArray(angle, majorAngles)) {
          return radius;
        }
        return minorRadius;
      };
      return radiusCallback;
    }
  }
  createPlotBands() {
    const plotBands = this.options.plotBands || [];
    const group = this._plotbandGroup = new drawing_exports.Group({
      zIndex: -1
    });
    for (let i37 = 0; i37 < plotBands.length; i37++) {
      const band = plotBands[i37];
      const slot = this.plotBandSlot(band);
      const singleSlot = this.getSlot(band.from);
      const head = band.from - Math.floor(band.from);
      slot.startAngle += head * singleSlot.angle;
      const tail = Math.ceil(band.to) - band.to;
      slot.angle -= (tail + head) * singleSlot.angle;
      const ring = shape_builder_default.current.createRing(slot, {
        fill: {
          color: band.color,
          opacity: band.opacity
        },
        stroke: {
          opacity: band.opacity
        }
      });
      group.append(ring);
    }
    this.appendVisual(group);
  }
  plotBandSlot(band) {
    return this.getSlot(band.from, band.to - 1);
  }
  getSlot(from, to) {
    const options = this.options;
    const justified = options.justified;
    const box = this.box;
    const divs = this.majorAngles();
    const totalDivs = divs.length;
    const slotAngle = 360 / totalDivs;
    let fromValue = from;
    if (options.reverse && !justified) {
      fromValue = (fromValue + 1) % totalDivs;
    }
    fromValue = limitValue(Math.floor(fromValue), 0, totalDivs - 1);
    let slotStart = divs[fromValue];
    if (justified) {
      slotStart = slotStart - slotAngle / 2;
      if (slotStart < 0) {
        slotStart += 360;
      }
    }
    const toValue = limitValue(Math.ceil(to || fromValue), fromValue, totalDivs - 1);
    const slots = toValue - fromValue + 1;
    const angle = slotAngle * slots;
    return new ring_default(box.center(), 0, box.height() / 2, slotStart, angle);
  }
  slot(from, to) {
    const slot = this.getSlot(from, to);
    const startAngle = slot.startAngle + 180;
    const endAngle = startAngle + slot.angle;
    return new geometry_exports.Arc([slot.center.x, slot.center.y], {
      startAngle,
      endAngle,
      radiusX: slot.radius,
      radiusY: slot.radius
    });
  }
  pointCategoryIndex(point) {
    const length = this.options.categories.length;
    let index = null;
    for (let i37 = 0; i37 < length; i37++) {
      const slot = this.getSlot(i37);
      if (slot.containsPoint(point)) {
        index = i37;
        break;
      }
    }
    return index;
  }
};
setDefaultOptions(RadarCategoryAxis, {
  startAngle: 90,
  labels: {
    margin: getSpacing(10)
  },
  majorGridLines: {
    visible: true
  },
  justified: true
});
deepExtend(RadarCategoryAxis.prototype, grid_lines_mixin_default);
var radar_category_axis_default = RadarCategoryAxis;

// node_modules/@progress/kendo-charts/dist/es/core/polar-axis.js
var PolarAxis = class extends axis_default {
  constructor(options, chartService) {
    super(options, chartService);
    const instanceOptions = this.options;
    instanceOptions.minorUnit = instanceOptions.minorUnit || instanceOptions.majorUnit / 2;
  }
  getDivisions(stepValue) {
    return numeric_axis_default.prototype.getDivisions.call(this, stepValue) - 1;
  }
  reflow(box) {
    this.box = box;
    this.reflowLabels();
  }
  reflowLabels() {
    const { options, labels, options: { labels: labelOptions } } = this;
    const skip = labelOptions.skip || 0;
    const step = labelOptions.step || 1;
    const measureBox = new box_default();
    const divs = this.intervals(options.majorUnit, skip, step);
    for (let i37 = 0; i37 < labels.length; i37++) {
      labels[i37].reflow(measureBox);
      const labelBox = labels[i37].box;
      labels[i37].reflow(this.getSlot(divs[i37]).adjacentBox(0, labelBox.width(), labelBox.height()));
    }
  }
  lineBox() {
    return this.box;
  }
  intervals(size, skipOption, stepOption, skipAngles = false) {
    const min4 = this.options.min;
    const divisions = this.getDivisions(size);
    const divs = [];
    const skip = skipOption || 0;
    const step = stepOption || 1;
    for (let i37 = skip; i37 < divisions; i37 += step) {
      const current4 = (360 + min4 + i37 * size) % 360;
      if (!(skipAngles && inArray(current4, skipAngles))) {
        divs.push(current4);
      }
    }
    return divs;
  }
  majorIntervals() {
    return this.intervals(this.options.majorUnit);
  }
  minorIntervals() {
    return this.intervals(this.options.minorUnit);
  }
  intervalAngle(i37) {
    return (540 - i37 - this.options.startAngle) % 360;
  }
  createLine() {
    return [];
  }
  majorGridLineAngles(altAxis) {
    const majorGridLines = this.options.majorGridLines;
    return this.gridLineAngles(altAxis, this.options.majorUnit, majorGridLines.skip, majorGridLines.step);
  }
  minorGridLineAngles(altAxis, skipMajor) {
    const options = this.options;
    const { minorGridLines, majorGridLines } = options;
    const majorGridLineAngles = skipMajor ? this.intervals(options.majorUnit, majorGridLines.skip, majorGridLines.step) : null;
    return this.gridLineAngles(altAxis, options.minorUnit, minorGridLines.skip, minorGridLines.step, majorGridLineAngles);
  }
  plotBandSlot(band) {
    return this.getSlot(band.from, band.to);
  }
  getSlot(a50, b2) {
    const { options, box } = this;
    const startAngle = options.startAngle;
    let start = limitValue(a50, options.min, options.max);
    let end = limitValue(b2 || start, start, options.max);
    if (options.reverse) {
      start *= -1;
      end *= -1;
    }
    start = (540 - start - startAngle) % 360;
    end = (540 - end - startAngle) % 360;
    if (end < start) {
      const tmp = start;
      start = end;
      end = tmp;
    }
    return new ring_default(box.center(), 0, box.height() / 2, start, end - start);
  }
  slot(from, to = from) {
    const options = this.options;
    const start = 360 - options.startAngle;
    const slot = this.getSlot(from, to);
    const min4 = Math.min(from, to);
    const max3 = Math.max(from, to);
    let startAngle, endAngle;
    if (options.reverse) {
      startAngle = min4;
      endAngle = max3;
    } else {
      startAngle = 360 - max3;
      endAngle = 360 - min4;
    }
    startAngle = (startAngle + start) % 360;
    endAngle = (endAngle + start) % 360;
    return new geometry_exports.Arc([slot.center.x, slot.center.y], {
      startAngle,
      endAngle,
      radiusX: slot.radius,
      radiusY: slot.radius
    });
  }
  getValue(point) {
    const options = this.options;
    const center = this.box.center();
    const dx = point.x - center.x;
    const dy = point.y - center.y;
    let theta = Math.round(deg(Math.atan2(dy, dx)));
    let start = options.startAngle;
    if (!options.reverse) {
      theta *= -1;
      start *= -1;
    }
    return (theta + start + 360) % 360;
  }
  valueRange() {
    return {
      min: 0,
      max: Math.PI * 2
    };
  }
};
setDefaultOptions(PolarAxis, {
  type: "polar",
  startAngle: 0,
  reverse: false,
  majorUnit: 60,
  min: 0,
  max: 360,
  labels: {
    margin: getSpacing(10)
  },
  majorGridLines: {
    color: BLACK,
    visible: true,
    width: 1
  },
  minorGridLines: {
    color: "#aaa"
  }
});
deepExtend(PolarAxis.prototype, grid_lines_mixin_default, {
  createPlotBands: radar_category_axis_default.prototype.createPlotBands,
  majorAngles: radar_category_axis_default.prototype.majorAngles,
  range: numeric_axis_default.prototype.range,
  labelsCount: numeric_axis_default.prototype.labelsCount,
  createAxisLabel: numeric_axis_default.prototype.createAxisLabel
});
var polar_axis_default = PolarAxis;

// node_modules/@progress/kendo-charts/dist/es/core/mixins/radar-numeric-axis-mixin.js
var RadarNumericAxisMixin = {
  options: {
    majorGridLines: {
      visible: true
    }
  },
  createPlotBands: function() {
    const { majorGridLines: { type }, plotBands = [] } = this.options;
    const altAxis = this.plotArea.polarAxis;
    const majorAngles = altAxis.majorAngles();
    const center = altAxis.box.center();
    const group = this._plotbandGroup = new drawing_exports.Group({
      zIndex: -1
    });
    for (let i37 = 0; i37 < plotBands.length; i37++) {
      const band = plotBands[i37];
      const bandStyle = {
        fill: {
          color: band.color,
          opacity: band.opacity
        },
        stroke: {
          opacity: band.opacity
        }
      };
      const slot = this.getSlot(band.from, band.to, true);
      const ring = new ring_default(center, center.y - slot.y2, center.y - slot.y1, 0, 360);
      let shape;
      if (type === ARC) {
        shape = shape_builder_default.current.createRing(ring, bandStyle);
      } else {
        shape = drawing_exports.Path.fromPoints(this.plotBandPoints(ring, majorAngles), bandStyle).close();
      }
      group.append(shape);
    }
    this.appendVisual(group);
  },
  plotBandPoints: function(ring, angles) {
    const innerPoints = [];
    const outerPoints = [];
    const center = [ring.center.x, ring.center.y];
    const innerCircle = new geometry_exports.Circle(center, ring.innerRadius);
    const outerCircle = new geometry_exports.Circle(center, ring.radius);
    for (let i37 = 0; i37 < angles.length; i37++) {
      innerPoints.push(innerCircle.pointAt(angles[i37] + 180));
      outerPoints.push(outerCircle.pointAt(angles[i37] + 180));
    }
    innerPoints.reverse();
    innerPoints.push(innerPoints[0]);
    outerPoints.push(outerPoints[0]);
    return outerPoints.concat(innerPoints);
  },
  createGridLines: function(altAxis) {
    const options = this.options;
    const majorTicks = this.radarMajorGridLinePositions();
    const majorAngles = altAxis.majorAngles();
    const center = altAxis.box.center();
    let gridLines = [];
    if (options.majorGridLines.visible) {
      gridLines = this.renderGridLines(
        center,
        majorTicks,
        majorAngles,
        options.majorGridLines
      );
    }
    if (options.minorGridLines.visible) {
      const minorTicks = this.radarMinorGridLinePositions();
      append(gridLines, this.renderGridLines(
        center,
        minorTicks,
        majorAngles,
        options.minorGridLines
      ));
    }
    return gridLines;
  },
  renderGridLines: function(center, ticks, angles, options) {
    const style = {
      stroke: {
        width: options.width,
        color: options.color,
        dashType: options.dashType
      }
    };
    const { skip = 0, step = 0 } = options;
    const container = this.gridLinesVisual();
    for (let tickIx = skip; tickIx < ticks.length; tickIx += step) {
      const tickRadius = center.y - ticks[tickIx];
      if (tickRadius > 0) {
        const circle = new geometry_exports.Circle([center.x, center.y], tickRadius);
        if (options.type === ARC) {
          container.append(new drawing_exports.Circle(circle, style));
        } else {
          const line = new drawing_exports.Path(style);
          for (let angleIx = 0; angleIx < angles.length; angleIx++) {
            line.lineTo(circle.pointAt(angles[angleIx] + 180));
          }
          line.close();
          container.append(line);
        }
      }
    }
    return container.children;
  },
  getValue: function(point) {
    const lineBox = this.lineBox();
    const altAxis = this.plotArea.polarAxis;
    const majorAngles = altAxis.majorAngles();
    const center = altAxis.box.center();
    const radius = point.distanceTo(center);
    let distance = radius;
    if (this.options.majorGridLines.type !== ARC && majorAngles.length > 1) {
      const dx = point.x - center.x;
      const dy = point.y - center.y;
      const theta = (deg(Math.atan2(dy, dx)) + 540) % 360;
      majorAngles.sort(function(a50, b2) {
        return angularDistance(a50, theta) - angularDistance(b2, theta);
      });
      const midAngle = angularDistance(majorAngles[0], majorAngles[1]) / 2;
      const alpha = angularDistance(theta, majorAngles[0]);
      const gamma = 90 - midAngle;
      const beta = 180 - alpha - gamma;
      distance = radius * (Math.sin(rad(beta)) / Math.sin(rad(gamma)));
    }
    return this.axisType().prototype.getValue.call(
      this,
      new point_default(lineBox.x1, lineBox.y2 - distance)
    );
  }
};
function angularDistance(a50, b2) {
  return 180 - Math.abs(Math.abs(a50 - b2) - 180);
}
var radar_numeric_axis_mixin_default = RadarNumericAxisMixin;

// node_modules/@progress/kendo-charts/dist/es/core/radar-numeric-axis.js
var RadarNumericAxis = class extends numeric_axis_default {
  radarMajorGridLinePositions() {
    return this.getTickPositions(this.options.majorUnit);
  }
  radarMinorGridLinePositions() {
    const options = this.options;
    let minorSkipStep = 0;
    if (options.majorGridLines.visible) {
      minorSkipStep = options.majorUnit;
    }
    return this.getTickPositions(options.minorUnit, minorSkipStep);
  }
  axisType() {
    return numeric_axis_default;
  }
};
deepExtend(RadarNumericAxis.prototype, radar_numeric_axis_mixin_default);
var radar_numeric_axis_default = RadarNumericAxis;

// node_modules/@progress/kendo-charts/dist/es/core/radar-logarithmic-axis.js
var RadarLogarithmicAxis = class extends logarithmic_axis_default {
  radarMajorGridLinePositions() {
    const positions = [];
    this.traverseMajorTicksPositions(function(position) {
      positions.push(position);
    }, this.options.majorGridLines);
    return positions;
  }
  radarMinorGridLinePositions() {
    const positions = [];
    this.traverseMinorTicksPositions(function(position) {
      positions.push(position);
    }, this.options.minorGridLines);
    return positions;
  }
  axisType() {
    return logarithmic_axis_default;
  }
};
deepExtend(RadarLogarithmicAxis.prototype, radar_numeric_axis_mixin_default);
var radar_logarithmic_axis_default = RadarLogarithmicAxis;

// node_modules/@progress/kendo-charts/dist/es/core/curve-processor.js
var WEIGHT = 0.333;
var EXTREMUM_ALLOWED_DEVIATION = 0.01;
var CurveProcessor = class {
  constructor(closed) {
    this.closed = closed;
  }
  process(dataPoints) {
    const points = dataPoints.slice(0);
    const segments = [];
    let closed = this.closed;
    let length = points.length;
    if (length > 2) {
      this.removeDuplicates(0, points);
      length = points.length;
    }
    if (length < 2 || length === 2 && points[0].equals(points[1])) {
      return segments;
    }
    let p0 = points[0];
    let p1 = points[1];
    let p22 = points[2];
    segments.push(new geometry_exports.Segment(p0));
    while (p0.equals(points[length - 1])) {
      closed = true;
      points.pop();
      length--;
    }
    if (length === 2) {
      const tangent = this.tangent(p0, p1, X, Y);
      last(segments).controlOut(
        this.firstControlPoint(tangent, p0, p1, X, Y)
      );
      segments.push(new geometry_exports.Segment(
        p1,
        this.secondControlPoint(tangent, p0, p1, X, Y)
      ));
      return segments;
    }
    let initialControlPoint, lastControlPoint;
    if (closed) {
      p0 = points[length - 1];
      p1 = points[0];
      p22 = points[1];
      const controlPoints = this.controlPoints(p0, p1, p22);
      initialControlPoint = controlPoints[1];
      lastControlPoint = controlPoints[0];
    } else {
      const tangent = this.tangent(p0, p1, X, Y);
      initialControlPoint = this.firstControlPoint(tangent, p0, p1, X, Y);
    }
    let cp0 = initialControlPoint;
    for (let idx = 0; idx <= length - 3; idx++) {
      this.removeDuplicates(idx, points);
      length = points.length;
      if (idx + 3 <= length) {
        p0 = points[idx];
        p1 = points[idx + 1];
        p22 = points[idx + 2];
        const controlPoints = this.controlPoints(p0, p1, p22);
        last(segments).controlOut(cp0);
        cp0 = controlPoints[1];
        const cp1 = controlPoints[0];
        segments.push(new geometry_exports.Segment(p1, cp1));
      }
    }
    if (closed) {
      p0 = points[length - 2];
      p1 = points[length - 1];
      p22 = points[0];
      const controlPoints = this.controlPoints(p0, p1, p22);
      last(segments).controlOut(cp0);
      segments.push(new geometry_exports.Segment(
        p1,
        controlPoints[0]
      ));
      last(segments).controlOut(controlPoints[1]);
      segments.push(new geometry_exports.Segment(
        p22,
        lastControlPoint
      ));
    } else {
      const tangent = this.tangent(p1, p22, X, Y);
      last(segments).controlOut(cp0);
      segments.push(new geometry_exports.Segment(
        p22,
        this.secondControlPoint(tangent, p1, p22, X, Y)
      ));
    }
    return segments;
  }
  removeDuplicates(idx, points) {
    while (points[idx + 1] && (points[idx].equals(points[idx + 1]) || points[idx + 1].equals(points[idx + 2]))) {
      points.splice(idx + 1, 1);
    }
  }
  invertAxis(p0, p1, p22) {
    let invertAxis = false;
    if (p0.x === p1.x) {
      invertAxis = true;
    } else if (p1.x === p22.x) {
      if (p1.y < p22.y && p0.y <= p1.y || p22.y < p1.y && p1.y <= p0.y) {
        invertAxis = true;
      }
    } else {
      const fn = this.lineFunction(p0, p1);
      const y2 = this.calculateFunction(fn, p22.x);
      if (!(p0.y <= p1.y && p22.y <= y2) && !(p1.y <= p0.y && p22.y >= y2)) {
        invertAxis = true;
      }
    }
    return invertAxis;
  }
  isLine(p0, p1, p22) {
    const fn = this.lineFunction(p0, p1);
    const y2 = this.calculateFunction(fn, p22.x);
    return p0.x === p1.x && p1.x === p22.x || round(y2, 1) === round(p22.y, 1);
  }
  lineFunction(p1, p22) {
    const a50 = (p22.y - p1.y) / (p22.x - p1.x);
    const b2 = p1.y - a50 * p1.x;
    return [b2, a50];
  }
  controlPoints(p0, p1, p22) {
    let xField = X;
    let yField = Y;
    let restrict = false;
    let switchOrientation = false;
    let tangent;
    if (this.isLine(p0, p1, p22)) {
      tangent = this.tangent(p0, p1, X, Y);
    } else {
      const monotonic = {
        x: this.isMonotonicByField(p0, p1, p22, X),
        y: this.isMonotonicByField(p0, p1, p22, Y)
      };
      if (monotonic.x && monotonic.y) {
        tangent = this.tangent(p0, p22, X, Y);
        restrict = true;
      } else {
        if (this.invertAxis(p0, p1, p22)) {
          xField = Y;
          yField = X;
        }
        if (monotonic[xField]) {
          tangent = 0;
        } else {
          let sign;
          if (p22[yField] < p0[yField] && p0[yField] <= p1[yField] || p0[yField] < p22[yField] && p1[yField] <= p0[yField]) {
            sign = numberSign((p22[yField] - p0[yField]) * (p1[xField] - p0[xField]));
          } else {
            sign = -numberSign((p22[xField] - p0[xField]) * (p1[yField] - p0[yField]));
          }
          tangent = EXTREMUM_ALLOWED_DEVIATION * sign;
          switchOrientation = true;
        }
      }
    }
    const secondControlPoint = this.secondControlPoint(tangent, p0, p1, xField, yField);
    if (switchOrientation) {
      const oldXField = xField;
      xField = yField;
      yField = oldXField;
    }
    const firstControlPoint = this.firstControlPoint(tangent, p1, p22, xField, yField);
    if (restrict) {
      this.restrictControlPoint(p0, p1, secondControlPoint, tangent);
      this.restrictControlPoint(p1, p22, firstControlPoint, tangent);
    }
    return [secondControlPoint, firstControlPoint];
  }
  restrictControlPoint(p1, p22, cp, tangent) {
    if (p1.y < p22.y) {
      if (p22.y < cp.y) {
        cp.x = p1.x + (p22.y - p1.y) / tangent;
        cp.y = p22.y;
      } else if (cp.y < p1.y) {
        cp.x = p22.x - (p22.y - p1.y) / tangent;
        cp.y = p1.y;
      }
    } else {
      if (cp.y < p22.y) {
        cp.x = p1.x - (p1.y - p22.y) / tangent;
        cp.y = p22.y;
      } else if (p1.y < cp.y) {
        cp.x = p22.x + (p1.y - p22.y) / tangent;
        cp.y = p1.y;
      }
    }
  }
  tangent(p0, p1, xField, yField) {
    const x7 = p1[xField] - p0[xField];
    const y2 = p1[yField] - p0[yField];
    let tangent;
    if (x7 === 0) {
      tangent = 0;
    } else {
      tangent = y2 / x7;
    }
    return tangent;
  }
  isMonotonicByField(p0, p1, p22, field) {
    return p22[field] > p1[field] && p1[field] > p0[field] || p22[field] < p1[field] && p1[field] < p0[field];
  }
  firstControlPoint(tangent, p0, p32, xField, yField) {
    const t1 = p0[xField];
    const t210 = p32[xField];
    const distance = (t210 - t1) * WEIGHT;
    return this.point(t1 + distance, p0[yField] + distance * tangent, xField, yField);
  }
  secondControlPoint(tangent, p0, p32, xField, yField) {
    const t1 = p0[xField];
    const t210 = p32[xField];
    const distance = (t210 - t1) * WEIGHT;
    return this.point(t210 - distance, p32[yField] - distance * tangent, xField, yField);
  }
  point(xValue, yValue, xField, yField) {
    const controlPoint = new geometry_exports.Point();
    controlPoint[xField] = xValue;
    controlPoint[yField] = yValue;
    return controlPoint;
  }
  calculateFunction(fn, x7) {
    const length = fn.length;
    let result = 0;
    for (let i37 = 0; i37 < length; i37++) {
      result += Math.pow(x7, i37) * fn[i37];
    }
    return result;
  }
};
function numberSign(value2) {
  return value2 <= 0 ? -1 : 1;
}
var curve_processor_default = CurveProcessor;

// node_modules/@progress/kendo-charts/dist/es/chart/api-elements/chart-axis.js
var ChartAxis = class {
  constructor(axis) {
    this._axis = axis;
    this.options = axis.options;
  }
  value(point) {
    const axis = this._axis;
    const value2 = axis.getCategory ? axis.getCategory(point) : axis.getValue(point);
    return value2;
  }
  slot(from, to, limit = true) {
    return this._axis.slot(from, to, limit);
  }
  range() {
    return this._axis.range();
  }
  valueRange() {
    return this._axis.valueRange();
  }
};
var chart_axis_default = ChartAxis;

// node_modules/@progress/kendo-charts/dist/es/chart/api-elements/find-axis-by-name.js
function findAxisByName(name, axes) {
  for (let idx = 0; idx < axes.length; idx++) {
    if (axes[idx].options.name === name) {
      axes[idx].prepareUserOptions();
      return new chart_axis_default(axes[idx]);
    }
  }
}

// node_modules/@progress/kendo-charts/dist/es/chart/api-elements/chart-pane.js
var ChartPane = class {
  constructor(pane) {
    this.visual = pane.visual;
    this.chartsVisual = pane.chartContainer.visual;
    this._pane = pane;
  }
  findAxisByName(name) {
    return findAxisByName(name, this._pane.axes);
  }
};
var chart_pane_default = ChartPane;

// node_modules/@progress/kendo-charts/dist/es/chart/api-elements/chart-plotarea.js
var ChartPlotArea = class {
  constructor(plotArea) {
    this._plotArea = plotArea;
    this.visual = plotArea.visual;
    this.backgroundVisual = plotArea._bgVisual;
  }
};
var chart_plotarea_default = ChartPlotArea;

// node_modules/@progress/kendo-charts/dist/es/chart/utils/count-numbers.js
function countNumbers(values) {
  const length = values.length;
  let count = 0;
  for (let i37 = 0; i37 < length; i37++) {
    const num = values[i37];
    if (isNumber(num)) {
      count++;
    }
  }
  return count;
}

// node_modules/@progress/kendo-charts/dist/es/chart/aggregates/aggregates.js
var Aggregates = {
  min: function(values) {
    const length = values.length;
    let min4 = MAX_VALUE;
    for (let i37 = 0; i37 < length; i37++) {
      const value2 = values[i37];
      if (isNumber(value2)) {
        min4 = Math.min(min4, value2);
      }
    }
    return min4 === MAX_VALUE ? values[0] : min4;
  },
  max: function(values) {
    const length = values.length;
    let max3 = MIN_VALUE;
    for (let i37 = 0; i37 < length; i37++) {
      const value2 = values[i37];
      if (isNumber(value2)) {
        max3 = Math.max(max3, value2);
      }
    }
    return max3 === MIN_VALUE ? values[0] : max3;
  },
  sum: function(values) {
    const length = values.length;
    let sum2 = 0;
    for (let i37 = 0; i37 < length; i37++) {
      const value2 = values[i37];
      if (isNumber(value2)) {
        sum2 += value2;
      }
    }
    return sum2;
  },
  sumOrNull: function(values) {
    let result = null;
    if (countNumbers(values)) {
      result = Aggregates.sum(values);
    }
    return result;
  },
  count: function(values) {
    const length = values.length;
    let count = 0;
    for (let i37 = 0; i37 < length; i37++) {
      const value2 = values[i37];
      if (value2 !== null && value2 !== void 0) {
        count++;
      }
    }
    return count;
  },
  avg: function(values) {
    const count = countNumbers(values);
    let result = values[0];
    if (count > 0) {
      result = Aggregates.sum(values) / count;
    }
    return result;
  },
  first: function(values) {
    const length = values.length;
    for (let i37 = 0; i37 < length; i37++) {
      const value2 = values[i37];
      if (value2 !== null && value2 !== void 0) {
        return value2;
      }
    }
    return values[0];
  }
};
var aggregates_default = Aggregates;

// node_modules/@progress/kendo-charts/dist/es/chart/utils/get-field.js
function getField(field, row) {
  if (row === null) {
    return row;
  }
  const get = getter(field, true);
  return get(row);
}

// node_modules/@progress/kendo-charts/dist/es/chart/series-binder.js
var SeriesBinder = class {
  constructor() {
    this._valueFields = {};
    this._otherFields = {};
    this._nullValue = {};
    this._undefinedValue = {};
  }
  register(seriesTypes, valueFields = [VALUE], otherFields = {}) {
    for (let i37 = 0; i37 < seriesTypes.length; i37++) {
      const type = seriesTypes[i37];
      this._valueFields[type] = valueFields;
      this._otherFields[type] = otherFields;
      this._nullValue[type] = this._makeValue(valueFields, null);
      this._undefinedValue[type] = this._makeValue(valueFields, void 0);
    }
  }
  canonicalFields(series) {
    return this.valueFields(series).concat(this.otherFields(series));
  }
  valueFields(series) {
    return this._valueFields[series.type] || [VALUE];
  }
  otherFields(series) {
    return this._otherFields[series.type] || [VALUE];
  }
  bindPoint(series, pointIx, item) {
    const data = series.data;
    const pointData = item !== void 0 ? item : data[pointIx];
    const result = { valueFields: { value: pointData } };
    const valueFields = this.valueFields(series);
    const otherFields = this._otherFields[series.type];
    let fields, value2;
    if (pointData === null) {
      value2 = this._nullValue[series.type];
    } else if (pointData === void 0) {
      value2 = this._undefinedValue[series.type];
    } else if (Array.isArray(pointData)) {
      const fieldData = pointData.slice(valueFields.length);
      value2 = this._bindFromArray(pointData, valueFields);
      fields = this._bindFromArray(fieldData, otherFields);
    } else if (typeof pointData === "object") {
      const srcValueFields = this.sourceFields(series, valueFields);
      const srcPointFields = this.sourceFields(series, otherFields);
      value2 = this._bindFromObject(pointData, valueFields, srcValueFields);
      fields = this._bindFromObject(pointData, otherFields, srcPointFields);
    }
    if (value2 !== void 0) {
      if (valueFields.length === 1) {
        result.valueFields.value = value2[valueFields[0]];
      } else {
        result.valueFields = value2;
      }
    }
    result.fields = fields || {};
    return result;
  }
  _makeValue(fields, initialValue) {
    const value2 = {};
    const length = fields.length;
    for (let i37 = 0; i37 < length; i37++) {
      const fieldName = fields[i37];
      value2[fieldName] = initialValue;
    }
    return value2;
  }
  _bindFromArray(array, fields) {
    const value2 = {};
    if (fields) {
      const length = Math.min(fields.length, array.length);
      for (let i37 = 0; i37 < length; i37++) {
        value2[fields[i37]] = array[i37];
      }
    }
    return value2;
  }
  _bindFromObject(object, fields, srcFields = fields) {
    const value2 = {};
    if (fields) {
      const length = fields.length;
      for (let i37 = 0; i37 < length; i37++) {
        const fieldName = fields[i37];
        const srcFieldName = srcFields[i37];
        if (srcFieldName !== null) {
          value2[fieldName] = getField(srcFieldName, object);
        }
      }
    }
    return value2;
  }
  sourceFields(series, canonicalFields) {
    const sourceFields = [];
    if (canonicalFields) {
      const length = canonicalFields.length;
      for (let i37 = 0; i37 < length; i37++) {
        const fieldName = canonicalFields[i37];
        const sourceFieldName = fieldName === VALUE ? "field" : fieldName + "Field";
        sourceFields.push(series[sourceFieldName] !== null ? series[sourceFieldName] || fieldName : null);
      }
    }
    return sourceFields;
  }
};
SeriesBinder.current = new SeriesBinder();
var series_binder_default = SeriesBinder;

// node_modules/@progress/kendo-charts/dist/es/chart/error-bars/error-range-calculator.js
var STD_ERR = "stderr";
var STD_DEV = "stddev";
var percentRegex = /percent(?:\w*)\((\d+)\)/;
var standardDeviationRegex = new RegExp("^" + STD_DEV + "(?:\\((\\d+(?:\\.\\d+)?)\\))?$");
var ErrorRangeCalculator = class {
  constructor(errorValue, series, field) {
    this.initGlobalRanges(errorValue, series, field);
  }
  initGlobalRanges(errorValue, series, field) {
    const data = series.data;
    const deviationMatch = standardDeviationRegex.exec(errorValue);
    if (deviationMatch) {
      this.valueGetter = this.createValueGetter(series, field);
      const average = this.getAverage(data);
      const deviation = this.getStandardDeviation(data, average, false);
      const multiple = deviationMatch[1] ? parseFloat(deviationMatch[1]) : 1;
      const errorRange = { low: average.value - deviation * multiple, high: average.value + deviation * multiple };
      this.globalRange = function() {
        return errorRange;
      };
    } else if (errorValue.indexOf && errorValue.indexOf(STD_ERR) >= 0) {
      this.valueGetter = this.createValueGetter(series, field);
      const standardError = this.getStandardError(data, this.getAverage(data));
      this.globalRange = function(value2) {
        return { low: value2 - standardError, high: value2 + standardError };
      };
    }
  }
  createValueGetter(series, field) {
    const data = series.data;
    const binder = series_binder_default.current;
    const valueFields = binder.valueFields(series);
    const item = defined(data[0]) ? data[0] : {};
    let valueGetter10;
    if (isArray(item)) {
      const index = field ? valueFields.indexOf(field) : 0;
      valueGetter10 = getter("[" + index + "]");
    } else if (isNumber(item)) {
      valueGetter10 = getter();
    } else if (typeof item === OBJECT) {
      const srcValueFields = binder.sourceFields(series, valueFields);
      valueGetter10 = getter(srcValueFields[valueFields.indexOf(field)]);
    }
    return valueGetter10;
  }
  getErrorRange(pointValue, errorValue) {
    let low, high, value2;
    if (!defined(errorValue)) {
      return null;
    }
    if (this.globalRange) {
      return this.globalRange(pointValue);
    }
    if (isArray(errorValue)) {
      low = pointValue - errorValue[0];
      high = pointValue + errorValue[1];
    } else if (isNumber(value2 = parseFloat(errorValue))) {
      low = pointValue - value2;
      high = pointValue + value2;
    } else if (value2 = percentRegex.exec(errorValue)) {
      const percentValue = pointValue * (parseFloat(value2[1]) / 100);
      low = pointValue - Math.abs(percentValue);
      high = pointValue + Math.abs(percentValue);
    } else {
      throw new Error("Invalid ErrorBar value: " + errorValue);
    }
    return { low, high };
  }
  getStandardError(data, average) {
    return this.getStandardDeviation(data, average, true) / Math.sqrt(average.count);
  }
  getStandardDeviation(data, average, isSample) {
    const length = data.length;
    const total = isSample ? average.count - 1 : average.count;
    let squareDifferenceSum = 0;
    for (let idx = 0; idx < length; idx++) {
      const value2 = this.valueGetter(data[idx]);
      if (isNumber(value2)) {
        squareDifferenceSum += Math.pow(value2 - average.value, 2);
      }
    }
    return Math.sqrt(squareDifferenceSum / total);
  }
  getAverage(data) {
    const length = data.length;
    let sum2 = 0;
    let count = 0;
    for (let idx = 0; idx < length; idx++) {
      const value2 = this.valueGetter(data[idx]);
      if (isNumber(value2)) {
        sum2 += value2;
        count++;
      }
    }
    return {
      value: sum2 / count,
      count
    };
  }
};
var error_range_calculator_default = ErrorRangeCalculator;

// node_modules/@progress/kendo-charts/dist/es/chart/constants.js
var browser2 = support_default.browser || {};
var INITIAL_ANIMATION_DURATION = 600;
var FADEIN = "fadeIn";
var BORDER_BRIGHTNESS = 0.8;
var TOOLTIP_OFFSET = 5;
var START_SCALE = browser2.msie ? 1e-3 : 0;
var ERROR_LOW_FIELD = "errorLow";
var ERROR_HIGH_FIELD = "errorHigh";
var X_ERROR_LOW_FIELD = "xErrorLow";
var X_ERROR_HIGH_FIELD = "xErrorHigh";
var Y_ERROR_LOW_FIELD = "yErrorLow";
var Y_ERROR_HIGH_FIELD = "yErrorHigh";
var LINE_MARKER_SIZE = 8;
var ZERO = "zero";
var INTERPOLATE = "interpolate";
var GAP = "gap";
var ABOVE = "above";
var BELOW = "below";
var SMOOTH = "smooth";
var STEP = "step";
var AREA = "area";
var BAR = "bar";
var BOX_PLOT = "boxPlot";
var BUBBLE = "bubble";
var BULLET = "bullet";
var CANDLESTICK = "candlestick";
var COLUMN = "column";
var DONUT = "donut";
var FUNNEL = "funnel";
var PYRAMID = "pyramid";
var HEATMAP = "heatmap";
var HORIZONTAL_WATERFALL = "horizontalWaterfall";
var LINE = "line";
var OHLC = "ohlc";
var PIE = "pie";
var POLAR_AREA = "polarArea";
var POLAR_LINE = "polarLine";
var POLAR_SCATTER = "polarScatter";
var RADAR_AREA = "radarArea";
var RADAR_COLUMN = "radarColumn";
var RADAR_LINE = "radarLine";
var RANGE_AREA = "rangeArea";
var RANGE_BAR = "rangeBar";
var RANGE_COLUMN = "rangeColumn";
var SCATTER = "scatter";
var SCATTER_LINE = "scatterLine";
var VERTICAL_AREA = "verticalArea";
var VERTICAL_BOX_PLOT = "verticalBoxPlot";
var VERTICAL_BULLET = "verticalBullet";
var VERTICAL_LINE = "verticalLine";
var VERTICAL_RANGE_AREA = "verticalRangeArea";
var WATERFALL = "waterfall";
var EQUALLY_SPACED_SERIES = [
  BAR,
  COLUMN,
  OHLC,
  CANDLESTICK,
  BOX_PLOT,
  VERTICAL_BOX_PLOT,
  BULLET,
  RANGE_COLUMN,
  RANGE_BAR,
  WATERFALL,
  HORIZONTAL_WATERFALL
];
var TRENDLINE_EXPONENTIAL = "exponentialTrendline";
var TRENDLINE_LINEAR = "linearTrendline";
var TRENDLINE_LOGARITHMIC = "logarithmicTrendline";
var TRENDLINE_MOVING_AVERAGE = "movingAverageTrendline";
var TRENDLINE_POLYNOMIAL = "polynomialTrendline";
var TRENDLINE_POWER = "powerTrendline";
var TRENDLINE_SERIES = [
  TRENDLINE_EXPONENTIAL,
  TRENDLINE_LINEAR,
  TRENDLINE_LOGARITHMIC,
  TRENDLINE_MOVING_AVERAGE,
  TRENDLINE_POLYNOMIAL,
  TRENDLINE_POWER
];
var LEGEND_ITEM_CLICK = "legendItemClick";
var LEGEND_ITEM_HOVER = "legendItemHover";
var LEGEND_ITEM_LEAVE = "legendItemLeave";
var SERIES_CLICK = "seriesClick";
var SERIES_HOVER = "seriesHover";
var SERIES_OVER = "seriesOver";
var SERIES_LEAVE = "seriesLeave";
var PLOT_AREA_CLICK = "plotAreaClick";
var PLOT_AREA_HOVER = "plotAreaHover";
var PLOT_AREA_LEAVE = "plotAreaLeave";
var DRAG = "drag";
var DRAG_END = "dragEnd";
var DRAG_START = "dragStart";
var ZOOM_START = "zoomStart";
var ZOOM = "zoom";
var ZOOM_END = "zoomEnd";
var SELECT_START = "selectStart";
var SELECT2 = "select";
var SELECT_END = "selectEnd";
var RENDER = "render";
var SHOW_TOOLTIP = "showTooltip";
var HIDE_TOOLTIP = "hideTooltip";
var PANE_RENDER = "paneRender";
var CHART_POINT_ROLE = "graphics-symbol";
var CHART_POINT_CLASSNAME = "k-chart-point";
var CHART_POINT_ROLE_DESCRIPTION = "Point";
var LEGEND_ITEM_ROLE = "checkbox";
var LEGEND_ITEM_CLASSNAME = "k-chart-legend-item";
var LEGEND_ITEM_ARIA_ROLE_DESCRIPTION = "Legend item";
var LOGARITHMIC = "log";
var CATEGORY = "category";
var INSIDE_END = "insideEnd";
var INSIDE_BASE = "insideBase";
var OUTSIDE_END = "outsideEnd";
var MOUSEWHEEL = "wheel";
var MOUSEWHEEL_DELAY = 150;
var MOUSEWHEEL_ZOOM_RATE = 0.3;
var DRILLDOWN = "drilldown";
var DRILLDOWN_FIELD = "drilldown";
var PATTERN_FIELD = "pattern";
var MIN_MOVING_AVERAGE_PERIOD = 2;

// node_modules/@progress/kendo-charts/dist/es/chart/error-bars/error-bar-base.js
var DEFAULT_ERROR_BAR_WIDTH = 4;
var ErrorBarBase = class extends chart_element_default {
  constructor(low, high, isVertical, chart, series, options) {
    super(options);
    this.low = low;
    this.high = high;
    this.isVertical = isVertical;
    this.chart = chart;
    this.series = series;
  }
  reflow(targetBox) {
    const endCaps = this.options.endCaps;
    const isVertical = this.isVertical;
    const axis = this.getAxis();
    const valueBox = axis.getSlot(this.low, this.high);
    const centerBox = targetBox.center();
    const capsWidth = this.getCapsWidth(targetBox, isVertical);
    const capValue = isVertical ? centerBox.x : centerBox.y;
    const capStart = capValue - capsWidth;
    const capEnd = capValue + capsWidth;
    let linePoints;
    if (isVertical) {
      linePoints = [
        new point_default(centerBox.x, valueBox.y1),
        new point_default(centerBox.x, valueBox.y2)
      ];
      if (endCaps) {
        linePoints.push(
          new point_default(capStart, valueBox.y1),
          new point_default(capEnd, valueBox.y1),
          new point_default(capStart, valueBox.y2),
          new point_default(capEnd, valueBox.y2)
        );
      }
      this.box = new box_default(capStart, valueBox.y1, capEnd, valueBox.y2);
    } else {
      linePoints = [
        new point_default(valueBox.x1, centerBox.y),
        new point_default(valueBox.x2, centerBox.y)
      ];
      if (endCaps) {
        linePoints.push(
          new point_default(valueBox.x1, capStart),
          new point_default(valueBox.x1, capEnd),
          new point_default(valueBox.x2, capStart),
          new point_default(valueBox.x2, capEnd)
        );
      }
      this.box = new box_default(valueBox.x1, capStart, valueBox.x2, capEnd);
    }
    this.linePoints = linePoints;
  }
  getCapsWidth(box, isVertical) {
    const boxSize = isVertical ? box.width() : box.height();
    const capsWidth = Math.min(Math.floor(boxSize / 2), DEFAULT_ERROR_BAR_WIDTH) || DEFAULT_ERROR_BAR_WIDTH;
    return capsWidth;
  }
  createVisual() {
    const options = this.options;
    const visual = options.visual;
    if (visual) {
      this.visual = visual({
        low: this.low,
        high: this.high,
        rect: this.box.toRect(),
        sender: this.getSender(),
        options: {
          endCaps: options.endCaps,
          color: options.color,
          line: options.line
        },
        createVisual: () => {
          this.createDefaultVisual();
          const defaultVisual = this.visual;
          delete this.visual;
          return defaultVisual;
        }
      });
    } else {
      this.createDefaultVisual();
    }
  }
  createDefaultVisual() {
    const { options, linePoints } = this;
    const lineOptions = {
      stroke: {
        color: options.color,
        width: options.line.width,
        dashType: options.line.dashType
      }
    };
    super.createVisual();
    for (let idx = 0; idx < linePoints.length; idx += 2) {
      const line = new drawing_exports.Path(lineOptions).moveTo(linePoints[idx].x, linePoints[idx].y).lineTo(linePoints[idx + 1].x, linePoints[idx + 1].y);
      alignPathToPixel(line);
      this.visual.append(line);
    }
  }
};
setDefaultOptions(ErrorBarBase, {
  animation: {
    type: FADEIN,
    delay: INITIAL_ANIMATION_DURATION
  },
  endCaps: true,
  line: {
    width: 2
  },
  zIndex: 1
});
var error_bar_base_default = ErrorBarBase;

// node_modules/@progress/kendo-charts/dist/es/chart/error-bars/categorical-error-bar.js
var CategoricalErrorBar = class extends error_bar_base_default {
  getAxis() {
    const axis = this.chart.seriesValueAxis(this.series);
    return axis;
  }
};
var categorical_error_bar_default = CategoricalErrorBar;

// node_modules/@progress/kendo-charts/dist/es/chart/utils/any-has-z-index.js
function anyHasZIndex(elements) {
  for (let idx = 0; idx < elements.length; idx++) {
    if (defined(elements[idx].zIndex)) {
      return true;
    }
  }
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/append-if-not-null.js
function appendIfNotNull(array, element) {
  if (element !== null) {
    array.push(element);
  }
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/are-numbers.js
function areNumbers(values) {
  return countNumbers(values) === values.length;
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/segment-visible.js
function segmentVisible(series, fields, index) {
  const visible = fields.visible;
  if (defined(visible)) {
    return visible;
  }
  const pointVisibility = series.pointVisibility;
  if (pointVisibility) {
    return pointVisibility[index];
  }
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/bind-segments.js
function bindSegments(series) {
  const data = series.data;
  const points = [];
  let sum2 = 0;
  let count = 0;
  for (let idx = 0; idx < data.length; idx++) {
    const pointData = series_binder_default.current.bindPoint(series, idx);
    let value2 = pointData.valueFields.value;
    if (isString(value2)) {
      value2 = parseFloat(value2);
    }
    if (isNumber(value2)) {
      pointData.visible = segmentVisible(series, pointData.fields, idx) !== false;
      pointData.value = Math.abs(value2);
      points.push(pointData);
      if (pointData.visible) {
        sum2 += pointData.value;
      }
      if (value2 !== 0) {
        count++;
      }
    } else {
      points.push(null);
    }
  }
  return {
    total: sum2,
    points,
    count
  };
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/categories-count.js
function categoriesCount(series) {
  const seriesCount = series.length;
  let categories = 0;
  for (let i37 = 0; i37 < seriesCount; i37++) {
    categories = Math.max(categories, series[i37].data.length);
  }
  return categories;
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/equals-ignore-case.js
function equalsIgnoreCase(a50, b2) {
  if (a50 && b2) {
    return a50.toLowerCase() === b2.toLowerCase();
  }
  return a50 === b2;
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/eval-options.js
var MAX_EXPAND_DEPTH = 5;
function evalOptions(options, context, state = {}, dryRun = false) {
  const defaults = state.defaults = state.defaults || {};
  const depth = state.depth = state.depth || 0;
  let needsEval = false;
  state.excluded = state.excluded || [];
  if (depth > MAX_EXPAND_DEPTH) {
    return null;
  }
  for (let property in options) {
    if (!inArray(property, state.excluded) && hasOwnProperty(options, property)) {
      const propValue = options[property];
      if (isFunction(propValue)) {
        needsEval = true;
        if (!dryRun) {
          options[property] = valueOrDefault(propValue(context), defaults[property]);
        }
      } else if (isObject(propValue)) {
        if (!dryRun) {
          state.defaults = defaults[property];
        }
        state.depth++;
        needsEval = evalOptions(propValue, context, state, dryRun) || needsEval;
        state.depth--;
      }
    }
  }
  return needsEval;
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/filter-series-by-type.js
function filterSeriesByType(series, types) {
  const result = [];
  const seriesTypes = [].concat(types);
  for (let idx = 0; idx < series.length; idx++) {
    const currentSeries = series[idx];
    if (inArray(currentSeries.type, seriesTypes)) {
      result.push(currentSeries);
    }
  }
  return result;
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/parse-date-category.js
var dateCache = /* @__PURE__ */ new WeakMap();
function parseDateCategory(category, row, intlService) {
  if (row === null || typeof row !== "object") {
    return parseDate(intlService, category);
  }
  let date = dateCache.get(row);
  if (!date) {
    date = parseDate(intlService, category);
    dateCache.set(row, date);
  }
  return date;
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/has-gradient-overlay.js
function hasGradientOverlay(options) {
  const overlay = options.overlay;
  return overlay && overlay.gradient && overlay.gradient !== "none";
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/has-value.js
function hasValue(value2) {
  return defined(value2) && value2 !== null;
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/is-date-axis.js
function isDateAxis(axisOptions2, sampleCategory) {
  const type = axisOptions2.type;
  const dateCategory = sampleCategory instanceof Date;
  return !type && dateCategory || equalsIgnoreCase(type, DATE);
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/single-item-or-array.js
function singleItemOrArray(array) {
  return array.length === 1 ? array[0] : array;
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/create-out-of-range-points.js
var AREA_REGEX = /area/i;
function seriesMissingValues(series) {
  if (series.missingValues) {
    return series.missingValues;
  }
  return AREA_REGEX.test(series.type) || series.stack ? ZERO : INTERPOLATE;
}
function hasValue2(series, item) {
  const fields = series_binder_default.current.bindPoint(series, null, item);
  const valueFields = fields.valueFields;
  for (let field in valueFields) {
    if (convertableToNumber(valueFields[field])) {
      return true;
    }
  }
}
function findNext({ start, dir, min: min4, max: max3, getter: getter2, hasItem, series }) {
  let pointHasValue, outPoint;
  let idx = start;
  do {
    idx += dir;
    if (hasItem(idx)) {
      outPoint = getter2(idx);
      pointHasValue = hasValue2(series, outPoint.item);
    }
  } while (min4 <= idx && idx <= max3 && !pointHasValue);
  if (pointHasValue) {
    return outPoint;
  }
}
function createOutOfRangePoints(series, range, count, getter2, hasItem) {
  const { min: min4, max: max3 } = range;
  const hasMinPoint = min4 > 0 && min4 < count;
  const hasMaxPoint = max3 + 1 < count;
  if (hasMinPoint || hasMaxPoint) {
    const missingValues = seriesMissingValues(series);
    let minPoint, maxPoint;
    if (missingValues !== INTERPOLATE) {
      if (hasMinPoint) {
        minPoint = getter2(min4 - 1);
      }
      if (hasMaxPoint) {
        maxPoint = getter2(max3 + 1);
      }
    } else {
      let outPoint, pointHasValue;
      if (hasMinPoint) {
        outPoint = getter2(min4 - 1);
        pointHasValue = hasValue2(series, outPoint.item);
        if (!pointHasValue) {
          minPoint = findNext({
            start: min4,
            dir: -1,
            min: 0,
            max: count - 1,
            getter: getter2,
            hasItem,
            series
          });
        } else {
          minPoint = outPoint;
        }
      }
      if (hasMaxPoint) {
        outPoint = getter2(max3 + 1);
        pointHasValue = hasValue2(series, outPoint.item);
        if (!pointHasValue) {
          maxPoint = findNext({
            start: max3,
            dir: 1,
            min: 0,
            max: count - 1,
            getter: getter2,
            hasItem,
            series
          });
        } else {
          maxPoint = outPoint;
        }
      }
    }
    if (minPoint) {
      series._outOfRangeMinPoint = minPoint;
    }
    if (maxPoint) {
      series._outOfRangeMaxPoint = maxPoint;
    }
  }
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/unclip-box.js
function unclipBox(box, elements) {
  elements.forEach((element) => {
    const options = element && element.options;
    const elBox = element && (element.box || element.wrapperBox);
    if (options && elBox && options.noclip !== false && options.visible !== false) {
      box.wrap(elBox);
    }
  });
  return box;
}

// node_modules/@progress/kendo-charts/dist/es/chart/categorical-chart.js
var CategoricalChart = class extends chart_element_default {
  constructor(plotArea, options) {
    super(options);
    this.plotArea = plotArea;
    this.chartService = plotArea.chartService;
    this.categoryAxis = plotArea.seriesCategoryAxis(options.series[0]);
    this.valueAxisRanges = {};
    this.points = [];
    this.categoryPoints = [];
    this.seriesPoints = [];
    this.seriesOptions = [];
    this._evalSeries = [];
    this.render();
  }
  render() {
    this.traverseDataPoints(this.addValue.bind(this));
  }
  pointOptions(series, seriesIx) {
    let options = this.seriesOptions[seriesIx];
    if (!options) {
      const defaults = this.pointType().prototype.defaults;
      this.seriesOptions[seriesIx] = options = deepExtend({}, defaults, {
        vertical: !this.options.invertAxes
      }, series);
    }
    return options;
  }
  plotValue(point) {
    if (!point) {
      return 0;
    }
    if (this.options.isStacked100 && isNumber(point.value)) {
      const categoryIx = point.categoryIx;
      const categoryPoints = this.categoryPoints[categoryIx];
      const otherValues = [];
      let categorySum = 0;
      for (let i37 = 0; i37 < categoryPoints.length; i37++) {
        const other = categoryPoints[i37];
        if (other) {
          const stack = point.series.stack;
          const otherStack = other.series.stack;
          if (stack && otherStack && stack.group !== otherStack.group) {
            continue;
          }
          if (isNumber(other.value)) {
            categorySum += Math.abs(other.value);
            otherValues.push(Math.abs(other.value));
          }
        }
      }
      if (categorySum > 0) {
        return point.value / categorySum;
      }
    }
    return point.value;
  }
  plotRange(point, startValue = 0) {
    const categoryPoints = this.categoryPoints[point.categoryIx];
    if (this.options.isStacked) {
      let plotValue = this.plotValue(point);
      const positive = plotValue >= 0;
      let prevValue = startValue;
      let isStackedBar = false;
      const stack = point.series.stack !== void 0 ? point.series.stack : this.options.defaultStack;
      const isNonGroupStack = (stack2) => stack2 === true || typeof stack2 === OBJECT && !stack2.group;
      if (stack) {
        for (let i37 = 0; i37 < categoryPoints.length; i37++) {
          const other = categoryPoints[i37];
          if (point === other) {
            break;
          }
          const otherStack = other.series.stack !== void 0 ? other.series.stack : this.options.defaultStack;
          if (!otherStack) {
            continue;
          }
          if (typeof stack === STRING && stack !== otherStack) {
            continue;
          }
          if (isNonGroupStack(stack) && !isNonGroupStack(otherStack)) {
            continue;
          }
          if (stack.group && stack.group !== otherStack.group) {
            continue;
          }
          const otherValue = this.plotValue(other);
          if (otherValue >= 0 && positive || otherValue < 0 && !positive) {
            if (startValue === 0 || otherValue !== 0) {
              prevValue += otherValue;
              plotValue += otherValue;
              isStackedBar = true;
              if (this.options.isStacked100) {
                plotValue = Math.min(plotValue, 1);
              }
            }
          }
        }
      }
      if (isStackedBar) {
        prevValue -= startValue;
      }
      return [prevValue, plotValue];
    }
    const series = point.series;
    const valueAxis = this.seriesValueAxis(series);
    const axisCrossingValue = this.categoryAxisCrossingValue(valueAxis);
    return [axisCrossingValue, convertableToNumber(point.value) ? point.value : axisCrossingValue];
  }
  stackLimits(axisName, stackName) {
    let min4 = MAX_VALUE;
    let max3 = MIN_VALUE;
    for (let i37 = 0; i37 < this.categoryPoints.length; i37++) {
      const categoryPoints = this.categoryPoints[i37];
      if (!categoryPoints) {
        continue;
      }
      for (let pIx = 0; pIx < categoryPoints.length; pIx++) {
        const point = categoryPoints[pIx];
        if (point) {
          if (point.series.stack === stackName || point.series.axis === axisName) {
            const to = this.plotRange(point, 0)[1];
            if (to !== void 0 && isFinite(to)) {
              max3 = Math.max(max3, to);
              min4 = Math.min(min4, to);
            }
          }
        }
      }
    }
    return { min: min4, max: max3 };
  }
  updateStackRange() {
    const { isStacked, series: chartSeries } = this.options;
    const limitsCache = {};
    if (isStacked) {
      for (let i37 = 0; i37 < chartSeries.length; i37++) {
        const series = chartSeries[i37];
        const axisName = series.axis;
        const key = axisName + series.stack;
        let limits = limitsCache[key];
        if (!limits) {
          limits = this.stackLimits(axisName, series.stack);
          const errorTotals = this.errorTotals;
          if (errorTotals) {
            if (errorTotals.negative.length) {
              limits.min = Math.min(limits.min, sparseArrayLimits(errorTotals.negative).min);
            }
            if (errorTotals.positive.length) {
              limits.max = Math.max(limits.max, sparseArrayLimits(errorTotals.positive).max);
            }
          }
          if (limits.min !== MAX_VALUE || limits.max !== MIN_VALUE) {
            limitsCache[key] = limits;
          } else {
            limits = null;
          }
        }
        if (limits) {
          this.valueAxisRanges[axisName] = limits;
        }
      }
    }
  }
  addErrorBar(point, data, categoryIx) {
    const { value: value2, series, seriesIx } = point;
    const errorBars = point.options.errorBars;
    const lowValue = data.fields[ERROR_LOW_FIELD];
    const highValue = data.fields[ERROR_HIGH_FIELD];
    let errorRange;
    if (isNumber(lowValue) && isNumber(highValue)) {
      errorRange = { low: lowValue, high: highValue };
    } else if (errorBars && errorBars.value !== void 0) {
      this.seriesErrorRanges = this.seriesErrorRanges || [];
      this.seriesErrorRanges[seriesIx] = this.seriesErrorRanges[seriesIx] || new error_range_calculator_default(errorBars.value, series, VALUE);
      errorRange = this.seriesErrorRanges[seriesIx].getErrorRange(value2, errorBars.value);
    }
    if (errorRange) {
      point.low = errorRange.low;
      point.high = errorRange.high;
      this.addPointErrorBar(point, categoryIx);
    }
  }
  addPointErrorBar(point, categoryIx) {
    const isVertical = !this.options.invertAxes;
    const options = point.options.errorBars;
    let { series, low, high } = point;
    if (this.options.isStacked) {
      const stackedErrorRange = this.stackedErrorRange(point, categoryIx);
      low = stackedErrorRange.low;
      high = stackedErrorRange.high;
    } else {
      const fields = { categoryIx, series };
      this.updateRange({ value: low }, fields);
      this.updateRange({ value: high }, fields);
    }
    const errorBar = new categorical_error_bar_default(low, high, isVertical, this, series, options);
    point.errorBars = [errorBar];
    point.append(errorBar);
  }
  stackedErrorRange(point, categoryIx) {
    const plotValue = this.plotRange(point, 0)[1] - point.value;
    const low = point.low + plotValue;
    const high = point.high + plotValue;
    this.errorTotals = this.errorTotals || { positive: [], negative: [] };
    if (low < 0) {
      this.errorTotals.negative[categoryIx] = Math.min(this.errorTotals.negative[categoryIx] || 0, low);
    }
    if (high > 0) {
      this.errorTotals.positive[categoryIx] = Math.max(this.errorTotals.positive[categoryIx] || 0, high);
    }
    return { low, high };
  }
  addValue(data, fields) {
    const { categoryIx, series, seriesIx } = fields;
    let categoryPoints = this.categoryPoints[categoryIx];
    if (!categoryPoints) {
      this.categoryPoints[categoryIx] = categoryPoints = [];
    }
    let seriesPoints = this.seriesPoints[seriesIx];
    if (!seriesPoints) {
      this.seriesPoints[seriesIx] = seriesPoints = [];
    }
    const point = this.createPoint(data, fields);
    if (point) {
      Object.assign(point, fields);
      point.owner = this;
      point.noteText = data.fields.noteText;
      if (point.dataItem === void 0) {
        point.dataItem = series.data[categoryIx];
      }
      this.addErrorBar(point, data, categoryIx);
    }
    this.points.push(point);
    seriesPoints.push(point);
    categoryPoints.push(point);
    this.updateRange(data.valueFields, fields);
  }
  evalPointOptions(options, value2, fields) {
    const categoryIx = fields.categoryIx;
    const category = fields.category;
    const series = fields.series;
    const seriesIx = fields.seriesIx;
    const state = {
      defaults: series._defaults,
      excluded: [
        "data",
        "aggregate",
        "_events",
        "tooltip",
        "content",
        "template",
        "visual",
        "toggle",
        "_outOfRangeMinPoint",
        "_outOfRangeMaxPoint",
        "drilldownSeriesFactory",
        "ariaTemplate",
        "ariaContent"
      ]
    };
    let doEval = this._evalSeries[seriesIx];
    if (doEval === void 0) {
      this._evalSeries[seriesIx] = doEval = evalOptions(options, {}, state, true);
    }
    let pointOptions = options;
    if (doEval) {
      pointOptions = deepExtend({}, pointOptions);
      evalOptions(pointOptions, {
        value: value2,
        category,
        index: categoryIx,
        series,
        dataItem: series.data[categoryIx]
      }, state);
    }
    return pointOptions;
  }
  updateRange(data, fields) {
    const axisName = fields.series.axis;
    const value2 = data.value;
    let axisRange = this.valueAxisRanges[axisName];
    if (isFinite(value2) && value2 !== null) {
      axisRange = this.valueAxisRanges[axisName] = axisRange || { min: MAX_VALUE, max: MIN_VALUE };
      axisRange.min = Math.min(axisRange.min, value2);
      axisRange.max = Math.max(axisRange.max, value2);
    }
  }
  seriesValueAxis(series) {
    const plotArea = this.plotArea;
    const axisName = series.axis;
    const axis = axisName ? plotArea.namedValueAxes[axisName] : plotArea.valueAxis;
    if (!axis) {
      throw new Error("Unable to locate value axis with name " + axisName);
    }
    return axis;
  }
  reflow(targetBox) {
    const categorySlots = this.categorySlots = [];
    const chartPoints = this.points;
    const categoryAxis = this.categoryAxis;
    let pointIx = 0;
    this.traverseDataPoints((data, fields) => {
      const { categoryIx, series: currentSeries } = fields;
      const valueAxis = this.seriesValueAxis(currentSeries);
      const point = chartPoints[pointIx++];
      let categorySlot = categorySlots[categoryIx];
      if (!categorySlot) {
        categorySlots[categoryIx] = categorySlot = this.categorySlot(categoryAxis, categoryIx, valueAxis);
      }
      if (point) {
        const plotRange = this.plotRange(point, valueAxis.startValue());
        const valueSlot = this.valueSlot(valueAxis, plotRange);
        if (valueSlot) {
          const pointSlot = this.pointSlot(categorySlot, valueSlot);
          point.aboveAxis = this.aboveAxis(point, valueAxis);
          point.stackValue = plotRange[1];
          if (this.options.isStacked100) {
            point.percentage = this.plotValue(point);
          }
          this.reflowPoint(point, pointSlot);
        } else {
          point.visible = false;
        }
      }
    });
    this.reflowCategories(categorySlots);
    if (!this.options.clip && this.options.limitPoints && this.points.length) {
      this.limitPoints();
    }
    this.box = targetBox;
  }
  valueSlot(valueAxis, plotRange) {
    return valueAxis.getSlot(plotRange[0], plotRange[1], !this.options.clip);
  }
  limitPoints() {
    const categoryPoints = this.categoryPoints;
    const points = categoryPoints[0].concat(last(categoryPoints));
    for (let idx = 0; idx < points.length; idx++) {
      if (points[idx]) {
        this.limitPoint(points[idx]);
      }
    }
  }
  limitPoint(point) {
    const limitedSlot = this.categoryAxis.limitSlot(point.box);
    if (!limitedSlot.equals(point.box)) {
      point.reflow(limitedSlot);
    }
  }
  aboveAxis(point, valueAxis) {
    const axisCrossingValue = this.categoryAxisCrossingValue(valueAxis);
    const value2 = point.value;
    return valueAxis.options.reverse ? value2 < axisCrossingValue : value2 >= axisCrossingValue;
  }
  categoryAxisCrossingValue(valueAxis) {
    const categoryAxis = this.categoryAxis;
    const options = valueAxis.options;
    const crossingValues = [].concat(
      options.axisCrossingValues || options.axisCrossingValue
    );
    return crossingValues[categoryAxis.axisIndex || 0] || 0;
  }
  reflowPoint(point, pointSlot) {
    point.reflow(pointSlot);
  }
  reflowCategories() {
  }
  pointSlot(categorySlot, valueSlot) {
    const options = this.options;
    const invertAxes = options.invertAxes;
    const slotX = invertAxes ? valueSlot : categorySlot;
    const slotY = invertAxes ? categorySlot : valueSlot;
    return new box_default(slotX.x1, slotY.y1, slotX.x2, slotY.y2);
  }
  categorySlot(categoryAxis, categoryIx) {
    return categoryAxis.getSlot(categoryIx);
  }
  traverseDataPoints(callback) {
    const series = this.options.series;
    const count = categoriesCount(series);
    const seriesCount = series.length;
    for (let seriesIx = 0; seriesIx < seriesCount; seriesIx++) {
      this._outOfRangeCallback(series[seriesIx], "_outOfRangeMinPoint", seriesIx, callback);
    }
    for (let categoryIx = 0; categoryIx < count; categoryIx++) {
      const currentCategory = this.categoryAxis.categoryAt(categoryIx);
      for (let seriesIx = 0; seriesIx < seriesCount; seriesIx++) {
        const currentSeries = series[seriesIx];
        const pointData = this.plotArea.bindPoint(currentSeries, categoryIx);
        callback(pointData, {
          category: currentCategory,
          categoryIx,
          categoriesCount: count,
          series: currentSeries,
          seriesIx
        });
      }
    }
    for (let seriesIx = 0; seriesIx < seriesCount; seriesIx++) {
      this._outOfRangeCallback(series[seriesIx], "_outOfRangeMaxPoint", seriesIx, callback);
    }
  }
  _outOfRangeCallback(series, field, seriesIx, callback) {
    const outOfRangePoint = series[field];
    if (outOfRangePoint) {
      const categoryIx = outOfRangePoint.categoryIx;
      const pointData = this.plotArea.bindPoint(series, categoryIx, outOfRangePoint.item);
      callback(pointData, {
        category: outOfRangePoint.category,
        categoryIx,
        series,
        seriesIx,
        dataItem: outOfRangePoint.item
      });
    }
  }
  formatPointValue(point, format) {
    if (point.value === null) {
      return "";
    }
    return this.chartService.format.auto(format, point.value);
  }
  pointValue(data) {
    return data.valueFields.value;
  }
};
setDefaultOptions(CategoricalChart, {
  series: [],
  invertAxes: false,
  isStacked: false,
  clip: true,
  limitPoints: true
});
var categorical_chart_default = CategoricalChart;

// node_modules/@progress/kendo-charts/dist/es/chart/mixins/point-events-mixin.js
var PointEventsMixin = {
  click: function(chart, e41) {
    return chart.trigger(
      SERIES_CLICK,
      this.eventArgs(e41)
    );
  },
  hover: function(chart, e41) {
    return chart.trigger(
      SERIES_HOVER,
      this.eventArgs(e41)
    );
  },
  over: function(chart, e41) {
    return chart.trigger(
      SERIES_OVER,
      this.eventArgs(e41)
    );
  },
  out: function(chart, e41) {
    return chart.trigger(
      SERIES_LEAVE,
      this.eventArgs(e41)
    );
  },
  eventArgs: function(e41) {
    return {
      value: this.value,
      percentage: this.percentage,
      stackValue: this.stackValue,
      category: this.category,
      series: this.series,
      dataItem: this.dataItem,
      runningTotal: this.runningTotal,
      total: this.total,
      element: eventElement(e41),
      originalEvent: e41,
      point: this
    };
  }
};
var point_events_mixin_default = PointEventsMixin;

// node_modules/@progress/kendo-charts/dist/es/chart/mixins/note-mixin.js
var NoteMixin = {
  createNote: function() {
    const options = this.options.notes;
    const text = this.noteText || options.label.text;
    if (options.visible !== false && text !== void 0 && text !== null) {
      this.note = new note_default({
        value: this.value,
        text,
        dataItem: this.dataItem,
        category: this.category,
        series: this.series
      }, this.options.notes, this.owner.chartService);
      this.append(this.note);
    }
  }
};
var note_mixin_default = NoteMixin;

// node_modules/@progress/kendo-charts/dist/es/chart/line-chart/line-point.js
var LinePoint = class extends chart_element_default {
  constructor(value2, options) {
    super(options);
    this.value = value2;
    this.aboveAxis = valueOrDefault(this.options.aboveAxis, true);
    this.tooltipTracking = true;
    this._id = elementId();
  }
  initOptions(options) {
    this.options = Object.assign({}, options);
  }
  render() {
    const { markers } = this.options;
    if (this._rendered) {
      return;
    }
    this._rendered = true;
    if (markers.visible && markers.size) {
      this.marker = this.createMarker();
      this.append(this.marker);
    }
    this.createLabel();
    this.createNote();
    if (this.errorBar) {
      this.append(this.errorBar);
    }
  }
  createLabel() {
    const options = this.options;
    const labels = options.labels;
    if (labels.visible) {
      this.label = this.createLabelElement(labels);
      this.append(this.label);
    }
  }
  createLabelElement(options) {
    return new text_box_default(
      this.getLabelText(options),
      Object.assign(
        {},
        {
          align: CENTER,
          vAlign: CENTER,
          zIndex: valueOrDefault(options.zIndex, this.series.zIndex)
        },
        options,
        { margin: Object.assign(
          {},
          {
            left: 5,
            right: 5
          },
          options.margin
        ) }
      ),
      this.pointData()
    );
  }
  getLabelText(options) {
    let labelTemplate = getTemplate(options);
    if (labelTemplate) {
      return labelTemplate(this.pointData());
    } else if (options.format) {
      return this.formatValue(options.format);
    }
    return this.value;
  }
  getAriaLabelText() {
    const labels = this.options.labels;
    const ariaTemplate = getTemplate2(labels);
    if (ariaTemplate) {
      return ariaTemplate(this.pointData());
    }
    return this.getLabelText(labels);
  }
  markerBorder() {
    const options = this.options.markers;
    const background = options.background;
    const border = Object.assign({}, { color: this.color }, options.border);
    if (border.color === void 0) {
      border.color = new color_default(background).brightness(BORDER_BRIGHTNESS).toHex();
    }
    return border;
  }
  createVisual() {
  }
  createMarker() {
    const options = this.options.markers;
    const marker = new shape_element_default({
      type: options.type,
      width: options.size,
      height: options.size,
      rotation: options.rotation,
      background: options.background,
      border: this.markerBorder(),
      opacity: options.opacity,
      pattern: this.options.pattern,
      zIndex: valueOrDefault(options.zIndex, this.series.zIndex),
      animation: options.animation,
      visual: options.visual,
      accessibilityOptions: Object.assign(
        {},
        { ariaLabel: this.getAriaLabelText(this.options.labels) },
        this.options.accessibility
      )
    }, {
      dataItem: this.dataItem,
      value: this.value,
      series: this.series,
      category: this.category
    });
    return marker;
  }
  markerBox() {
    if (!this.marker) {
      this.marker = this.createMarker();
      this.marker.reflow(this._childBox);
    }
    return this.marker.box;
  }
  reflow(targetBox) {
    const { options, aboveAxis } = this;
    const vertical = options.vertical;
    this.render();
    this.box = targetBox;
    const childBox = targetBox.clone();
    if (vertical) {
      if (aboveAxis) {
        childBox.y1 -= childBox.height();
      } else {
        childBox.y2 += childBox.height();
      }
    } else {
      if (aboveAxis) {
        childBox.x1 += childBox.width();
      } else {
        childBox.x2 -= childBox.width();
      }
    }
    this._childBox = childBox;
    if (this.marker) {
      this.marker.reflow(childBox);
    }
    this.reflowLabel(childBox);
    if (this.errorBars) {
      for (let i37 = 0; i37 < this.errorBars.length; i37++) {
        this.errorBars[i37].reflow(childBox);
      }
    }
    if (this.note) {
      let noteTargetBox = this.markerBox();
      if (!(options.markers.visible && options.markers.size)) {
        const center = noteTargetBox.center();
        noteTargetBox = new box_default(center.x, center.y, center.x, center.y);
      }
      this.note.reflow(noteTargetBox);
    }
  }
  reflowLabel(box) {
    const { options, label } = this;
    let anchor = options.labels.position;
    if (label) {
      anchor = anchor === ABOVE ? TOP : anchor;
      anchor = anchor === BELOW ? BOTTOM : anchor;
      label.reflow(box);
      label.box.alignTo(this.markerBox(), anchor);
      label.reflow(label.box);
    }
  }
  createHighlight() {
    const markers = this.options.highlight.markers;
    const defaultColor = this.markerBorder().color;
    const options = this.options.markers;
    const size = options.size + (options.border.width || 0) + (markers.border.width || 0);
    const shadow = new shape_element_default({
      type: options.type,
      width: size,
      height: size,
      rotation: options.rotation,
      background: markers.color || defaultColor,
      border: {
        color: markers.border.color,
        width: markers.border.width,
        opacity: valueOrDefault(markers.border.opacity, 1)
      },
      opacity: valueOrDefault(markers.opacity, 1)
    });
    shadow.reflow(this._childBox);
    return shadow.getElement();
  }
  highlightVisual() {
    return (this.marker || {}).visual;
  }
  highlightVisualArgs() {
    const marker = this.marker;
    let visual, rect;
    if (marker) {
      rect = marker.paddingBox.toRect();
      visual = marker.visual;
    } else {
      const size = this.options.markers.size;
      const halfSize = size / 2;
      const center = this.box.center();
      rect = new geometry_exports.Rect([center.x - halfSize, center.y - halfSize], [size, size]);
    }
    return {
      options: this.options,
      rect,
      visual
    };
  }
  createFocusHighlight() {
    const markerOptions = this.options.markers;
    const highlightOptions2 = this.options.focusHighlight;
    const size = markerOptions.size + (markerOptions.border.width || 0);
    const highlight = new shape_element_default({
      type: markerOptions.type,
      width: size,
      height: size,
      rotation: markerOptions.rotation,
      background: highlightOptions2.color,
      border: highlightOptions2.border,
      opacity: highlightOptions2.opacity,
      padding: highlightOptions2.border.width / 2,
      zIndex: highlightOptions2.zIndex
    });
    highlight.reflow(this._childBox);
    return highlight.getElement();
  }
  tooltipAnchor() {
    const markerBox = this.markerBox();
    const clipBox = this.owner.pane.clipBox();
    const showTooltip = !clipBox || clipBox.overlaps(markerBox);
    if (showTooltip) {
      const x7 = markerBox.x2 + TOOLTIP_OFFSET;
      const horizontalAlign = LEFT;
      let y2, verticalAlign;
      if (this.aboveAxis) {
        y2 = markerBox.y1;
        verticalAlign = BOTTOM;
      } else {
        y2 = markerBox.y2;
        verticalAlign = TOP;
      }
      return {
        point: new point_default(x7, y2),
        align: {
          horizontal: horizontalAlign,
          vertical: verticalAlign
        }
      };
    }
  }
  formatValue(format) {
    return this.owner.formatPointValue(this, format);
  }
  overlapsBox(box) {
    const markerBox = this.markerBox();
    return markerBox.overlaps(box);
  }
  clipElements() {
    this.options.visible = false;
  }
  unclipElements() {
    if (this.label) {
      this.label.options.noclip = true;
    }
    if (this.note) {
      this.note.options.noclip = true;
    }
  }
  unclipBox() {
    return unclipBox(this.markerBox().clone(), [this.label, this.note]);
  }
  labelBox() {
    return this.label ? this.label.box : new box_default();
  }
  noteBox() {
    return this.note ? this.note.box : new box_default();
  }
  pointData() {
    return {
      dataItem: this.dataItem,
      category: this.category,
      value: this.value,
      percentage: this.percentage,
      stackValue: this.stackValue,
      series: this.series
    };
  }
  focusVisual() {
    if (this.marker) {
      if (this.marker.visual) {
        this.marker.visual.options.set("id", this._id);
      }
      this.toggleFocusHighlight(true);
    }
  }
  clearFocusFromVisual() {
    if (this.marker) {
      if (this.marker.visual) {
        this.marker.visual.options.set("id", "");
      }
      this.toggleFocusHighlight(false);
    }
  }
  getIndex() {
    return this.categoryIx !== void 0 ? this.categoryIx : this.pointIx;
  }
};
LinePoint.prototype.defaults = {
  vertical: true,
  markers: {
    visible: true,
    background: WHITE,
    size: LINE_MARKER_SIZE,
    type: CIRCLE,
    border: {
      width: 2
    },
    opacity: 1
  },
  labels: {
    visible: false,
    position: ABOVE,
    margin: getSpacing(3),
    padding: getSpacing(4),
    animation: {
      type: FADEIN,
      delay: INITIAL_ANIMATION_DURATION
    }
  },
  notes: {
    label: {}
  },
  highlight: {
    markers: {
      border: {
        color: "#fff",
        width: 2
      }
    },
    zIndex: HIGHLIGHT_ZINDEX
  },
  errorBars: {
    line: {
      width: 1
    }
  },
  accessibility: {
    tabIndex: 0,
    role: CHART_POINT_ROLE,
    className: CHART_POINT_CLASSNAME,
    ariaRoleDescription: CHART_POINT_ROLE_DESCRIPTION
  }
};
deepExtend(LinePoint.prototype, point_events_mixin_default);
deepExtend(LinePoint.prototype, note_mixin_default);
var line_point_default = LinePoint;

// node_modules/@progress/kendo-charts/dist/es/chart/line-chart/line-segment.js
var LineSegment = class extends chart_element_default {
  constructor(linePoints, series, seriesIx) {
    super();
    this.linePoints = linePoints;
    this.series = series;
    this.seriesIx = seriesIx;
  }
  points() {
    return this.toGeometryPoints(this.linePoints);
  }
  toGeometryPoints(points) {
    const result = [];
    for (let i37 = 0, length = points.length; i37 < length; i37++) {
      if (points[i37] && points[i37].visible !== false) {
        result.push(points[i37]._childBox.toRect().center());
      }
    }
    return result;
  }
  createVisual() {
    const customVisual = this.series.visual;
    if (customVisual) {
      this.visual = customVisual({
        points: this.toGeometryPoints(this.linePoints),
        series: this.series,
        sender: this.getSender(),
        createVisual: () => {
          this.segmentVisual();
          return this.visual;
        }
      });
      if (this.visual && !defined(this.visual.options.zIndex)) {
        this.visual.options.zIndex = this.series.zIndex;
      }
    } else {
      this.segmentVisual();
    }
  }
  segmentVisual() {
    const { options, series } = this;
    let { color, _defaults: defaults } = series;
    if (isFunction(color) && defaults) {
      color = defaults.color;
    }
    const line = drawing_exports.Path.fromPoints(this.points(), {
      stroke: {
        color,
        width: series.width,
        opacity: series.opacity,
        dashType: series.dashType
      },
      zIndex: series.zIndex
    });
    if (options.closed) {
      line.close();
    }
    this.visual = line;
  }
  aliasFor(e41, coords) {
    return this.parent.getNearestPoint(coords.x, coords.y, this.seriesIx);
  }
};
setDefaultOptions(LineSegment, {
  closed: false
});
var line_segment_default = LineSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/line-chart/step-line-mixin.js
var StepLineMixin = {
  calculateStepPoints: function(points) {
    const categoryAxis = this.parent.plotArea.seriesCategoryAxis(this.series);
    const { justified, vertical, reverse } = categoryAxis.options;
    const stepAxis = vertical ? X : Y;
    const axis = vertical ? Y : X;
    const stepDir = reverse ? 2 : 1;
    const dir = stepDir;
    let previousPoint = toGeometryPoint(points[0], stepAxis, stepDir, axis, dir);
    const result = [previousPoint];
    for (let idx = 1; idx < points.length; idx++) {
      const point = toGeometryPoint(points[idx], stepAxis, stepDir, axis, dir);
      if (previousPoint[stepAxis] !== point[stepAxis]) {
        const stepPoint = new geometry_exports.Point();
        stepPoint[stepAxis] = previousPoint[stepAxis];
        stepPoint[axis] = point[axis];
        result.push(stepPoint, point);
      }
      previousPoint = point;
    }
    if (!justified) {
      result.push(toGeometryPoint(last(points), stepAxis, stepDir, axis, reverse ? 1 : 2));
    } else if (previousPoint !== last(result)) {
      result.push(previousPoint);
    }
    return result;
  }
};
function toGeometryPoint(lintPoint, stepAxis, stepDir, axis, dir) {
  const box = lintPoint.box;
  const result = new geometry_exports.Point();
  result[stepAxis] = box[stepAxis + stepDir];
  result[axis] = box[axis + dir];
  return result;
}
var step_line_mixin_default = StepLineMixin;

// node_modules/@progress/kendo-charts/dist/es/chart/line-chart/step-line-segment.js
var StepLineSegment = class extends line_segment_default {
  points() {
    return this.calculateStepPoints(this.linePoints);
  }
};
deepExtend(StepLineSegment.prototype, step_line_mixin_default);
var step_line_segment_default = StepLineSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/line-chart/spline-segment.js
var SplineSegment = class extends line_segment_default {
  segmentVisual() {
    const series = this.series;
    const defaults = series._defaults;
    let color = series.color;
    if (isFunction(color) && defaults) {
      color = defaults.color;
    }
    const curveProcessor = new curve_processor_default(this.options.closed);
    const segments = curveProcessor.process(this.points());
    const curve = new drawing_exports.Path({
      stroke: {
        color,
        width: series.width,
        opacity: series.opacity,
        dashType: series.dashType
      },
      zIndex: series.zIndex
    });
    curve.segments.push.apply(curve.segments, segments);
    this.visual = curve;
  }
};
var spline_segment_default = SplineSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/mixins/line-chart-mixin.js
var LineChartMixin = {
  renderSegments: function() {
    const { options, seriesPoints } = this;
    const series = options.series;
    const seriesCount = seriesPoints.length;
    let lastSegment;
    this._segments = [];
    for (let seriesIx = 0; seriesIx < seriesCount; seriesIx++) {
      const currentSeries = series[seriesIx];
      const sortedPoints = this.sortPoints(seriesPoints[seriesIx]);
      const pointCount = sortedPoints.length;
      let linePoints = [];
      for (let pointIx = 0; pointIx < pointCount; pointIx++) {
        const point = sortedPoints[pointIx];
        if (point) {
          linePoints.push(point);
        } else if (this.seriesMissingValues(currentSeries) !== INTERPOLATE) {
          if (linePoints.length > 1) {
            lastSegment = this.createSegment(
              linePoints,
              currentSeries,
              seriesIx,
              lastSegment
            );
            this._addSegment(lastSegment);
          }
          linePoints = [];
        }
      }
      if (linePoints.length > 1) {
        lastSegment = this.createSegment(
          linePoints,
          currentSeries,
          seriesIx,
          lastSegment
        );
        this._addSegment(lastSegment);
      }
    }
    this.children.unshift.apply(this.children, this._segments);
  },
  _addSegment: function(segment) {
    this._segments.push(segment);
    segment.parent = this;
  },
  sortPoints: function(points) {
    return points;
  },
  seriesMissingValues: function(series) {
    const missingValues = series.missingValues;
    const assumeZero = !missingValues && this.options.isStacked;
    return assumeZero ? ZERO : missingValues || INTERPOLATE;
  },
  getNearestPoint: function(x7, y2, seriesIx) {
    const target = new point_default(x7, y2);
    const allPoints = this.seriesPoints[seriesIx];
    let nearestPointDistance = MAX_VALUE;
    let nearestPoint;
    for (let i37 = 0; i37 < allPoints.length; i37++) {
      const point = allPoints[i37];
      if (point && point.value !== void 0 && point.value !== null && point.visible !== false) {
        const pointBox = point.box;
        const pointDistance = pointBox.center().distanceTo(target);
        if (pointDistance < nearestPointDistance) {
          nearestPoint = point;
          nearestPointDistance = pointDistance;
        }
      }
    }
    return nearestPoint;
  }
};
var line_chart_mixin_default = LineChartMixin;

// node_modules/@progress/kendo-charts/dist/es/chart/animations/clip-animation.js
var ClipAnimation = class extends drawing_exports.Animation {
  setup() {
    this._setEnd(this.options.box.x1);
  }
  step(pos) {
    const box = this.options.box;
    this._setEnd(interpolateValue(box.x1, box.x2, pos));
  }
  _setEnd(x7) {
    const element = this.element;
    const segments = element.segments;
    const topRight = segments[1].anchor();
    const bottomRight = segments[2].anchor();
    element.suspend();
    topRight.setX(x7);
    element.resume();
    bottomRight.setX(x7);
  }
};
setDefaultOptions(ClipAnimation, {
  duration: INITIAL_ANIMATION_DURATION
});
drawing_exports.AnimationFactory.current.register("clip", ClipAnimation);
var clip_animation_default = ClipAnimation;

// node_modules/@progress/kendo-charts/dist/es/chart/mixins/clip-animation-mixin.js
var ClipAnimationMixin = {
  createAnimation: function() {
    const root = this.getRoot();
    const transitions = (root && root.options || {}).transitions;
    if (root && transitions !== false) {
      const box = this.parent && this.parent.clipBox || root.size();
      const clipPath = drawing_exports.Path.fromRect(box.toRect());
      const loading = transitions && transitions !== true ? transitions.loading : transitions;
      this.visual.clip(clipPath);
      this.animation = new clip_animation_default(clipPath, Object.assign(
        {},
        { box },
        loading
      ));
      if (anyHasZIndex(this.options.series)) {
        this._setChildrenAnimation(clipPath);
      }
    }
  },
  _setChildrenAnimation: function(clipPath) {
    const points = this.animationPoints();
    for (let idx = 0; idx < points.length; idx++) {
      const point = points[idx];
      if (point && point.visual && defined(point.visual.options.zIndex)) {
        point.visual.clip(clipPath);
      }
    }
  }
};
var clip_animation_mixin_default = ClipAnimationMixin;

// node_modules/@progress/kendo-charts/dist/es/chart/line-chart/line-chart.js
var LineChart = class extends categorical_chart_default {
  render() {
    super.render();
    this.updateStackRange();
    this.renderSegments();
  }
  pointType() {
    return line_point_default;
  }
  createPoint(data, fields) {
    const { series, seriesIx } = fields;
    const missingValues = this.seriesMissingValues(series);
    let value2 = data.valueFields.value;
    if (value2 === void 0 || value2 === null) {
      if (missingValues === ZERO) {
        value2 = 0;
      } else {
        return null;
      }
    }
    let pointOptions = this.pointOptions(series, seriesIx);
    pointOptions = this.evalPointOptions(pointOptions, value2, fields);
    let color = data.fields.color || series.color;
    if (isFunction(series.color)) {
      color = pointOptions.color;
    }
    const point = new line_point_default(value2, pointOptions);
    point.color = color;
    this.append(point);
    return point;
  }
  plotRange(point) {
    let plotValue = this.plotValue(point);
    if (this.options.isStacked) {
      const categoryIx = point.categoryIx;
      const categoryPoints = this.categoryPoints[categoryIx];
      for (let i37 = 0; i37 < categoryPoints.length; i37++) {
        const other = categoryPoints[i37];
        if (point === other) {
          break;
        }
        plotValue += this.plotValue(other);
        if (this.options.isStacked100) {
          plotValue = Math.min(plotValue, 1);
        }
      }
    }
    return [plotValue, plotValue];
  }
  createSegment(linePoints, currentSeries, seriesIx) {
    const style = currentSeries.style;
    let pointType;
    if (style === STEP) {
      pointType = step_line_segment_default;
    } else if (style === SMOOTH) {
      pointType = spline_segment_default;
    } else {
      pointType = line_segment_default;
    }
    return new pointType(linePoints, currentSeries, seriesIx);
  }
  animationPoints() {
    const points = this.points;
    const result = [];
    for (let idx = 0; idx < points.length; idx++) {
      result.push((points[idx] || {}).marker);
    }
    return result.concat(this._segments);
  }
  supportsPointInactiveOpacity() {
    return false;
  }
};
deepExtend(LineChart.prototype, line_chart_mixin_default, clip_animation_mixin_default);
var line_chart_default = LineChart;

// node_modules/@progress/kendo-charts/dist/es/chart/area-chart/area-segment.js
var AreaSegment = class extends line_segment_default {
  constructor(linePoints, currentSeries, seriesIx, prevSegment, stackPoints) {
    super(linePoints, currentSeries, seriesIx);
    this.prevSegment = prevSegment;
    this.stackPoints = stackPoints;
  }
  createVisual() {
    const series = this.series;
    const defaults = series._defaults;
    const lineOptions = series.line || {};
    let color = series.color;
    if (isFunction(color) && defaults) {
      color = defaults.color;
    }
    this.visual = new drawing_exports.Group({
      zIndex: series.zIndex
    });
    this.createFill({
      fill: createPatternFill(series.pattern, {
        color,
        opacity: series.opacity
      }),
      stroke: null
    });
    if (lineOptions.width > 0 && lineOptions.visible !== false) {
      this.createStroke({
        stroke: deepExtend({
          color,
          opacity: series.opacity,
          lineCap: "butt"
        }, lineOptions)
      });
    }
  }
  strokeSegments() {
    let segments = this._strokeSegments;
    if (!segments) {
      segments = this._strokeSegments = this.createStrokeSegments();
    }
    return segments;
  }
  createStrokeSegments() {
    return this.segmentsFromPoints(this.points());
  }
  stackSegments() {
    if (this.prevSegment) {
      return this.prevSegment.createStackSegments(this.stackPoints);
    }
    return this.createStackSegments(this.stackPoints);
  }
  createStackSegments(stackPoints) {
    return this.segmentsFromPoints(this.toGeometryPoints(stackPoints)).reverse();
  }
  segmentsFromPoints(points) {
    return points.map((point) => new geometry_exports.Segment(point));
  }
  createStroke(style) {
    const stroke = new drawing_exports.Path(style);
    stroke.segments.push.apply(stroke.segments, this.strokeSegments());
    this.visual.append(stroke);
  }
  hasStackSegment() {
    return this.prevSegment || this.stackPoints && this.stackPoints.length;
  }
  createFill(style) {
    const strokeSegments = this.strokeSegments();
    const fillSegments = strokeSegments.slice(0);
    const hasStackSegments = this.hasStackSegment();
    if (hasStackSegments) {
      const stackSegments = this.stackSegments();
      append(fillSegments, stackSegments);
    }
    const fill = new drawing_exports.Path(style);
    fill.segments.push.apply(fill.segments, fillSegments);
    if (!hasStackSegments && strokeSegments.length > 1) {
      this.fillToAxes(fill);
    }
    this.visual.append(fill);
  }
  fillToAxes(fillPath) {
    const chart = this.parent;
    const invertAxes = chart.options.invertAxes;
    const valueAxis = chart.seriesValueAxis(this.series);
    const crossingValue = chart.categoryAxisCrossingValue(valueAxis);
    const endSlot = valueAxis.getSlot(crossingValue, crossingValue, true);
    const segments = this.strokeSegments();
    const firstPoint = segments[0].anchor();
    const lastPoint = last(segments).anchor();
    let end = invertAxes ? endSlot.x1 : endSlot.y1;
    if (invertAxes) {
      fillPath.lineTo(end, lastPoint.y).lineTo(end, firstPoint.y);
    } else {
      fillPath.lineTo(lastPoint.x, end).lineTo(firstPoint.x, end);
    }
  }
};
var area_segment_default = AreaSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/area-chart/step-area-segment.js
var StepAreaSegment = class extends area_segment_default {
  createStrokeSegments() {
    return this.segmentsFromPoints(this.calculateStepPoints(this.linePoints));
  }
  createStackSegments(stackPoints) {
    return this.segmentsFromPoints(this.calculateStepPoints(stackPoints)).reverse();
  }
};
deepExtend(StepAreaSegment.prototype, step_line_mixin_default);
var step_area_segment_default = StepAreaSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/area-chart/spline-area-segment.js
var SplineAreaSegment = class extends area_segment_default {
  createStrokeSegments() {
    const curveProcessor = new curve_processor_default(this.options.closed);
    const linePoints = this.points();
    return curveProcessor.process(linePoints);
  }
  createStackSegments() {
    const strokeSegments = this.strokeSegments();
    const stackSegments = [];
    for (let idx = strokeSegments.length - 1; idx >= 0; idx--) {
      const segment = strokeSegments[idx];
      stackSegments.push(new geometry_exports.Segment(
        segment.anchor(),
        segment.controlOut(),
        segment.controlIn()
      ));
    }
    return stackSegments;
  }
};
var spline_area_segment_default = SplineAreaSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/area-chart/area-chart.js
var AreaChart = class extends line_chart_default {
  createSegment(linePoints, currentSeries, seriesIx, prevSegment) {
    const isStacked = this.options.isStacked;
    const style = (currentSeries.line || {}).style;
    let previousSegment;
    let stackPoints;
    if (isStacked && seriesIx > 0 && prevSegment) {
      const missingValues = this.seriesMissingValues(currentSeries);
      if (missingValues !== "gap") {
        stackPoints = prevSegment.linePoints;
        previousSegment = prevSegment;
      } else {
        stackPoints = this._gapStackPoints(linePoints, seriesIx, style);
      }
    }
    let pointType;
    if (style === STEP) {
      pointType = step_area_segment_default;
    } else if (style === SMOOTH) {
      pointType = spline_area_segment_default;
    } else {
      pointType = area_segment_default;
    }
    return new pointType(linePoints, currentSeries, seriesIx, previousSegment, stackPoints);
  }
  reflow(targetBox) {
    super.reflow(targetBox);
    const stackPoints = this._stackPoints;
    if (stackPoints) {
      for (let idx = 0; idx < stackPoints.length; idx++) {
        const stackPoint = stackPoints[idx];
        const pointSlot = this.categoryAxis.getSlot(stackPoint.categoryIx);
        stackPoint.reflow(pointSlot);
      }
    }
  }
  _gapStackPoints(linePoints, seriesIx, style) {
    const seriesPoints = this.seriesPoints;
    let startIdx = linePoints[0].categoryIx;
    let length = linePoints.length;
    if (startIdx < 0) {
      startIdx = 0;
      length--;
    }
    const endIdx = startIdx + length;
    const pointOffset = this.seriesOptions[0]._outOfRangeMinPoint ? 1 : 0;
    const stackPoints = [];
    this._stackPoints = this._stackPoints || [];
    for (let categoryIx = startIdx; categoryIx < endIdx; categoryIx++) {
      const pointIx = categoryIx + pointOffset;
      let currentSeriesIx = seriesIx;
      let point;
      do {
        currentSeriesIx--;
        point = seriesPoints[currentSeriesIx][pointIx];
      } while (currentSeriesIx > 0 && !point);
      if (point) {
        if (style !== STEP && categoryIx > startIdx && !seriesPoints[currentSeriesIx][pointIx - 1]) {
          stackPoints.push(this._previousSegmentPoint(categoryIx, pointIx, pointIx - 1, currentSeriesIx));
        }
        stackPoints.push(point);
        if (style !== STEP && categoryIx + 1 < endIdx && !seriesPoints[currentSeriesIx][pointIx + 1]) {
          stackPoints.push(this._previousSegmentPoint(categoryIx, pointIx, pointIx + 1, currentSeriesIx));
        }
      } else {
        const gapStackPoint = this._createGapStackPoint(categoryIx);
        this._stackPoints.push(gapStackPoint);
        stackPoints.push(gapStackPoint);
      }
    }
    return stackPoints;
  }
  _previousSegmentPoint(categoryIx, pointIx, segmentIx, seriesIdx) {
    const seriesPoints = this.seriesPoints;
    let index = seriesIdx;
    let point;
    while (index > 0 && !point) {
      index--;
      point = seriesPoints[index][segmentIx];
    }
    if (!point) {
      point = this._createGapStackPoint(categoryIx);
      this._stackPoints.push(point);
    } else {
      point = seriesPoints[index][pointIx];
    }
    return point;
  }
  _createGapStackPoint(categoryIx) {
    const options = this.pointOptions({}, 0);
    const point = new line_point_default(0, options);
    point.categoryIx = categoryIx;
    point.series = {};
    return point;
  }
  seriesMissingValues(series) {
    return series.missingValues || ZERO;
  }
  supportsPointInactiveOpacity() {
    return false;
  }
};
var area_chart_default = AreaChart;

// node_modules/@progress/kendo-charts/dist/es/chart/axis-group-range-tracker.js
var AxisGroupRangeTracker = class {
  constructor() {
    this.axisRanges = {};
  }
  update(chartAxisRanges) {
    const axisRanges2 = this.axisRanges;
    for (let axisName in chartAxisRanges) {
      const chartRange = chartAxisRanges[axisName];
      let range = axisRanges2[axisName];
      axisRanges2[axisName] = range = range || { min: MAX_VALUE, max: MIN_VALUE };
      range.min = Math.min(range.min, chartRange.min);
      range.max = Math.max(range.max, chartRange.max);
    }
  }
  reset(axisName) {
    this.axisRanges[axisName] = void 0;
  }
  query(axisName) {
    return this.axisRanges[axisName];
  }
};
var axis_group_range_tracker_default = AxisGroupRangeTracker;

// node_modules/@progress/kendo-charts/dist/es/chart/bar-chart/bar-label.js
var BarLabel = class extends chart_element_default {
  constructor(content, options, pointData) {
    super(options);
    this.textBox = new text_box_default(content, this.options, pointData);
    this.append(this.textBox);
  }
  createVisual() {
    this.textBox.options.noclip = this.options.noclip;
  }
  reflow(targetBox) {
    const options = this.options;
    const { vertical, aboveAxis } = options;
    const text = this.children[0];
    const textOptions = text.options;
    const box = text.box;
    const padding = text.options.padding;
    let labelBox = targetBox;
    textOptions.align = vertical ? CENTER : LEFT;
    textOptions.vAlign = vertical ? TOP : CENTER;
    if (options.position === INSIDE_END) {
      if (vertical) {
        textOptions.vAlign = TOP;
        if (!aboveAxis && box.height() < targetBox.height()) {
          textOptions.vAlign = BOTTOM;
        }
      } else {
        textOptions.align = aboveAxis ? RIGHT : LEFT;
      }
    } else if (options.position === CENTER) {
      textOptions.vAlign = CENTER;
      textOptions.align = CENTER;
    } else if (options.position === INSIDE_BASE) {
      if (vertical) {
        textOptions.vAlign = aboveAxis ? BOTTOM : TOP;
      } else {
        textOptions.align = aboveAxis ? LEFT : RIGHT;
      }
    } else if (options.position === OUTSIDE_END) {
      if (vertical) {
        if (aboveAxis) {
          const boxesDiff = (box.width() - targetBox.width() - padding.left - padding.right) / 2;
          labelBox = new box_default(
            targetBox.x1 - boxesDiff,
            targetBox.y1 - box.height(),
            targetBox.x2 + boxesDiff,
            targetBox.y1
          );
        } else {
          labelBox = new box_default(
            targetBox.x1,
            targetBox.y2,
            targetBox.x2,
            targetBox.y2 + box.height()
          );
        }
      } else {
        textOptions.align = CENTER;
        if (aboveAxis) {
          labelBox = new box_default(
            targetBox.x2,
            targetBox.y1,
            targetBox.x2 + box.width(),
            targetBox.y2
          );
        } else {
          labelBox = new box_default(
            targetBox.x1 - box.width(),
            targetBox.y1,
            targetBox.x1,
            targetBox.y2
          );
        }
      }
    }
    if (!options.rotation) {
      if (vertical) {
        padding.left = padding.right = (labelBox.width() - text.contentBox.width()) / 2;
      } else {
        padding.top = padding.bottom = (labelBox.height() - text.contentBox.height()) / 2;
      }
    }
    text.reflow(labelBox);
  }
  alignToClipBox(clipBox) {
    const vertical = this.options.vertical;
    const field = vertical ? Y : X;
    const start = field + "1";
    const end = field + "2";
    const text = this.children[0];
    const parentBox = this.parent.box;
    if (parentBox[start] < clipBox[start] || clipBox[end] < parentBox[end]) {
      const targetBox = text.paddingBox.clone();
      targetBox[start] = Math.max(parentBox[start], clipBox[start]);
      targetBox[end] = Math.min(parentBox[end], clipBox[end]);
      this.reflow(targetBox);
    }
  }
};
setDefaultOptions(BarLabel, {
  position: OUTSIDE_END,
  margin: getSpacing(3),
  padding: getSpacing(4),
  color: BLACK,
  background: "",
  border: {
    width: 1,
    color: ""
  },
  aboveAxis: true,
  vertical: false,
  animation: {
    type: FADEIN,
    delay: INITIAL_ANIMATION_DURATION
  },
  zIndex: 2
});
var bar_label_default = BarLabel;

// node_modules/@progress/kendo-charts/dist/es/chart/mixins/accessibility-attributes-mixin.js
var AccessibilityAttributesMixin = {
  addAccessibilityAttributesToVisual: function() {
    this._id = this._id || guid();
    const accessibilityOptions = Object.assign(
      {},
      { ariaLabel: this.getAriaLabelText() },
      this.options.accessibility
    );
    addAccessibilityAttributesToVisual(this.visual, accessibilityOptions);
  },
  getAriaLabelText() {
    const labels = this.options.labels;
    const ariaTemplate = getTemplate2(labels);
    if (ariaTemplate) {
      return ariaTemplate(this.pointData());
    }
    return this.getLabelText(labels);
  },
  focusVisual() {
    this.visual.options.set("id", this._id);
    this.toggleFocusHighlight(true);
  },
  clearFocusFromVisual() {
    this.visual.options.set("id", "");
    this.toggleFocusHighlight(false);
  }
};
var accessibility_attributes_mixin_default = AccessibilityAttributesMixin;

// node_modules/@progress/kendo-charts/dist/es/chart/bar-chart/bar.js
var BAR_ALIGN_MIN_WIDTH = 6;
var Bar = class extends chart_element_default {
  constructor(value2, options) {
    super();
    this.options = options;
    this.color = options.color || WHITE;
    this.aboveAxis = valueOrDefault(this.options.aboveAxis, true);
    this.value = value2;
  }
  render() {
    if (this._rendered) {
      return;
    }
    this._rendered = true;
    this.createLabel();
    this.createNote();
    if (this.errorBar) {
      this.append(this.errorBar);
    }
  }
  createLabel() {
    const options = this.options;
    const labels = options.labels;
    if (labels.visible) {
      this.label = this.createLabelElement(labels);
      this.append(this.label);
    }
  }
  createLabelElement(options) {
    return new bar_label_default(
      this.getLabelText(options),
      deepExtend(
        {
          vertical: this.options.vertical
        },
        options
      ),
      this.pointData()
    );
  }
  getLabelText(options) {
    let labelTemplate = getTemplate(options);
    if (labelTemplate) {
      return labelTemplate(this.pointData());
    }
    return this.formatValue(options.format);
  }
  formatValue(format) {
    return this.owner.formatPointValue(this, format);
  }
  reflow(targetBox) {
    this.render();
    const label = this.label;
    this.box = targetBox;
    if (label) {
      label.options.aboveAxis = this.aboveAxis;
      label.reflow(targetBox);
    }
    if (this.note) {
      this.note.reflow(targetBox);
    }
    if (this.errorBars) {
      for (let i37 = 0; i37 < this.errorBars.length; i37++) {
        this.errorBars[i37].reflow(targetBox);
      }
    }
  }
  createVisual() {
    const { box, options } = this;
    const customVisual = options.visual;
    if (this.visible !== false) {
      super.createVisual();
      this.addAccessibilityAttributesToVisual();
      if (customVisual) {
        const visual = this.rectVisual = customVisual({
          category: this.category,
          dataItem: this.dataItem,
          value: this.value,
          sender: this.getSender(),
          series: this.series,
          percentage: this.percentage,
          stackValue: this.stackValue,
          runningTotal: this.runningTotal,
          total: this.total,
          rect: box.toRect(),
          createVisual: () => {
            const group = new drawing_exports.Group();
            this.createRect(group);
            return group;
          },
          options
        });
        if (visual) {
          this.visual.append(visual);
        }
      } else if (box.width() > 0 && box.height() > 0) {
        this.createRect(this.visual);
      }
    }
  }
  createRect(visual) {
    const options = this.options;
    const border = options.border;
    const strokeOpacity = defined(border.opacity) ? border.opacity : options.opacity;
    const rect = this.box.toRect();
    rect.size.width = Math.round(rect.size.width);
    const path = this.rectVisual = drawing_exports.Path.fromRect(rect, {
      fill: createPatternFill(options.pattern, {
        color: this.color,
        opacity: options.opacity
      }),
      stroke: {
        color: this.getBorderColor(),
        width: border.width,
        opacity: strokeOpacity,
        dashType: border.dashType
      }
    });
    const width = this.box.width();
    const height = this.box.height();
    const size = options.vertical ? width : height;
    if (size > BAR_ALIGN_MIN_WIDTH) {
      alignPathToPixel(path);
      if (width < 1 || height < 1) {
        path.options.stroke.lineJoin = "round";
      }
    }
    visual.append(path);
    if (hasGradientOverlay(options)) {
      const overlay = this.createGradientOverlay(path, { baseColor: this.color }, deepExtend({
        end: !options.vertical ? [0, 1] : void 0
      }, options.overlay));
      visual.append(overlay);
    }
  }
  createHighlight(style) {
    const highlight = drawing_exports.Path.fromRect(this.box.toRect(), style);
    return alignPathToPixel(highlight);
  }
  highlightVisual() {
    return this.rectVisual;
  }
  highlightVisualArgs() {
    return {
      options: this.options,
      rect: this.box.toRect(),
      visual: this.rectVisual
    };
  }
  createFocusHighlight(style) {
    const borderWidth = this.options.focusHighlight.border.width;
    const highlight = drawing_exports.Path.fromRect(this.box.pad(borderWidth / 2).toRect(), style);
    return alignPathToPixel(highlight);
  }
  getBorderColor() {
    const color = this.color;
    const border = this.options.border;
    const brightness = border._brightness || BORDER_BRIGHTNESS;
    let borderColor = border.color;
    if (!defined(borderColor)) {
      borderColor = new color_default(color).brightness(brightness).toHex();
    }
    return borderColor;
  }
  tooltipAnchor() {
    const { options, box, aboveAxis } = this;
    const clipBox = this.owner.pane.clipBox() || box;
    let horizontalAlign = LEFT;
    let verticalAlign = TOP;
    let x7, y2;
    if (options.vertical) {
      x7 = Math.min(box.x2, clipBox.x2) + TOOLTIP_OFFSET;
      if (aboveAxis) {
        y2 = Math.max(box.y1, clipBox.y1);
      } else {
        y2 = Math.min(box.y2, clipBox.y2);
        verticalAlign = BOTTOM;
      }
    } else {
      const x1 = Math.max(box.x1, clipBox.x1);
      const x22 = Math.min(box.x2, clipBox.x2);
      if (options.isStacked) {
        verticalAlign = BOTTOM;
        if (aboveAxis) {
          horizontalAlign = RIGHT;
          x7 = x22;
        } else {
          x7 = x1;
        }
        y2 = Math.max(box.y1, clipBox.y1) - TOOLTIP_OFFSET;
      } else {
        if (aboveAxis) {
          x7 = x22 + TOOLTIP_OFFSET;
        } else {
          x7 = x1 - TOOLTIP_OFFSET;
          horizontalAlign = RIGHT;
        }
        y2 = Math.max(box.y1, clipBox.y1);
      }
    }
    return {
      point: new point_default(x7, y2),
      align: {
        horizontal: horizontalAlign,
        vertical: verticalAlign
      }
    };
  }
  overlapsBox(box) {
    return this.box.overlaps(box);
  }
  unclipBox() {
    const label = this.label && this.label.textBox;
    return unclipBox(this.box.clone(), [label, this.note]);
  }
  labelBox() {
    const label = this.label && this.label.textBox;
    return label ? label.box : new box_default();
  }
  noteBox() {
    return this.note ? this.note.box : new box_default();
  }
  pointData() {
    return {
      dataItem: this.dataItem,
      category: this.category,
      value: this.value,
      percentage: this.percentage,
      stackValue: this.stackValue,
      runningTotal: this.runningTotal,
      total: this.total,
      series: this.series
    };
  }
  getIndex() {
    return this.categoryIx;
  }
};
deepExtend(Bar.prototype, point_events_mixin_default);
deepExtend(Bar.prototype, note_mixin_default);
deepExtend(Bar.prototype, accessibility_attributes_mixin_default);
Bar.prototype.defaults = {
  border: {
    width: 1
  },
  vertical: true,
  overlay: {
    gradient: "glass"
  },
  labels: {
    visible: false,
    format: "{0}"
  },
  opacity: 1,
  notes: {
    label: {}
  },
  accessibility: {
    role: CHART_POINT_ROLE,
    className: CHART_POINT_CLASSNAME,
    ariaRoleDescription: CHART_POINT_ROLE_DESCRIPTION
  }
};
var bar_default = Bar;

// node_modules/@progress/kendo-charts/dist/es/chart/layout/utils.js
function forEach(elements, callback) {
  elements.forEach(callback);
}
function forEachReverse(elements, callback) {
  const length = elements.length;
  for (let idx = length - 1; idx >= 0; idx--) {
    callback(elements[idx], idx - length - 1);
  }
}

// node_modules/@progress/kendo-charts/dist/es/chart/layout/cluster-layout.js
var ClusterLayout = class extends chart_element_default {
  constructor(options) {
    super(options);
    this.forEach = options.rtl ? forEachReverse : forEach;
  }
  reflow(box) {
    const { vertical, gap, spacing } = this.options;
    const children = this.children;
    const count = children.length;
    const axis = vertical ? Y : X;
    const slots = count + gap + spacing * (count - 1);
    const slotSize = (vertical ? box.height() : box.width()) / slots;
    let position = box[axis + 1] + slotSize * (gap / 2);
    this.forEach(children, (child, idx) => {
      const childBox = (child.box || box).clone();
      childBox[axis + 1] = position;
      childBox[axis + 2] = position + slotSize;
      child.reflow(childBox);
      if (idx < count - 1) {
        position += slotSize * spacing;
      }
      position += slotSize;
    });
  }
};
setDefaultOptions(ClusterLayout, {
  vertical: false,
  gap: 0,
  spacing: 0
});
var cluster_layout_default = ClusterLayout;

// node_modules/@progress/kendo-charts/dist/es/chart/layout/stack-wrap.js
var StackWrap = class extends chart_element_default {
  reflow(targetBox) {
    const positionAxis = this.options.vertical ? X : Y;
    const children = this.children;
    const childrenCount = children.length;
    let box = this.box = new box_default();
    for (let i37 = 0; i37 < childrenCount; i37++) {
      const currentChild = children[i37];
      if (currentChild.visible !== false) {
        const childBox = currentChild.box.clone();
        childBox.snapTo(targetBox, positionAxis);
        if (i37 === 0) {
          box = this.box = childBox.clone();
        }
        currentChild.reflow(childBox);
        box.wrap(childBox);
      }
    }
  }
};
setDefaultOptions(StackWrap, {
  vertical: true
});
var stack_wrap_default = StackWrap;

// node_modules/@progress/kendo-charts/dist/es/chart/bar-chart/bar-chart.js
var BarChart = class extends categorical_chart_default {
  render() {
    super.render();
    this.updateStackRange();
  }
  pointType() {
    return bar_default;
  }
  clusterType() {
    return cluster_layout_default;
  }
  stackType() {
    return stack_wrap_default;
  }
  stackLimits(axisName, stackName) {
    const limits = super.stackLimits(axisName, stackName);
    return limits;
  }
  createPoint(data, fields) {
    const { categoryIx, series, seriesIx } = fields;
    const { options, children } = this;
    const stackOrDefault = defined(series.stack) ? series.stack : options.defaultStack;
    const value2 = this.pointValue(data);
    let pointOptions = this.pointOptions(series, seriesIx);
    const labelOptions = pointOptions.labels;
    if (stackOrDefault) {
      if (labelOptions.position === OUTSIDE_END) {
        labelOptions.position = INSIDE_END;
      }
    }
    pointOptions.isStacked = stackOrDefault;
    let color = data.fields.color || series.color;
    if (value2 < 0 && pointOptions.negativeColor) {
      color = pointOptions.negativeColor;
    }
    pointOptions = this.evalPointOptions(pointOptions, value2, fields);
    if (isFunction(series.color)) {
      color = pointOptions.color;
    }
    const pointType = this.pointType();
    const point = new pointType(value2, pointOptions);
    point.color = color;
    let cluster = children[categoryIx];
    if (!cluster) {
      const clusterType = this.clusterType();
      cluster = new clusterType({
        vertical: options.invertAxes,
        gap: options.gap,
        spacing: options.spacing,
        rtl: !options.invertAxes && (this.chartService || {}).rtl
      });
      this.append(cluster);
    }
    if (options.isStacked) {
      const stackWrap = this.getStackWrap(stackOrDefault, cluster);
      stackWrap.append(point);
    } else {
      cluster.append(point);
    }
    return point;
  }
  getStackWrap(stack, cluster) {
    const stackGroup = typeof stack === OBJECT ? stack.group || true : stack;
    const wraps = cluster.children;
    let stackWrap;
    if (typeof stackGroup === STRING || stackGroup === true) {
      for (let i37 = 0; i37 < wraps.length; i37++) {
        if (wraps[i37]._stackGroup === stackGroup) {
          stackWrap = wraps[i37];
          break;
        }
      }
    }
    if (!stackWrap) {
      const stackType = this.stackType();
      stackWrap = new stackType({
        vertical: !this.options.invertAxes
      });
      stackWrap._stackGroup = stackGroup;
      cluster.append(stackWrap);
    }
    return stackWrap;
  }
  categorySlot(categoryAxis, categoryIx, valueAxis) {
    const options = this.options;
    const categorySlot = categoryAxis.getSlot(categoryIx);
    const startValue = valueAxis.startValue();
    if (options.isStacked) {
      const zeroSlot = valueAxis.getSlot(startValue, startValue, true);
      const stackAxis = options.invertAxes ? X : Y;
      categorySlot[stackAxis + 1] = categorySlot[stackAxis + 2] = zeroSlot[stackAxis + 1];
    }
    return categorySlot;
  }
  reflowCategories(categorySlots) {
    const children = this.children;
    const childrenLength = children.length;
    for (let i37 = 0; i37 < childrenLength; i37++) {
      children[i37].reflow(categorySlots[i37]);
    }
  }
  createAnimation() {
    this._setAnimationOptions();
    super.createAnimation();
    if (anyHasZIndex(this.options.series)) {
      this._setChildrenAnimation();
    }
  }
  _setChildrenAnimation() {
    const points = this.points;
    for (let idx = 0; idx < points.length; idx++) {
      const point = points[idx];
      const pointVisual = point.visual;
      if (pointVisual && defined(pointVisual.options.zIndex)) {
        point.options.animation = this.options.animation;
        point.createAnimation();
      }
    }
  }
  _setAnimationOptions() {
    const options = this.options;
    const animation = options.animation || {};
    let origin;
    if (options.isStacked) {
      const valueAxis = this.seriesValueAxis(options.series[0]);
      origin = valueAxis.getSlot(valueAxis.startValue());
    } else {
      origin = this.categoryAxis.getSlot(0);
    }
    animation.origin = new geometry_exports.Point(origin.x1, origin.y1);
    animation.vertical = !options.invertAxes;
  }
};
setDefaultOptions(BarChart, {
  animation: {
    type: BAR
  }
});
var bar_chart_default = BarChart;

// node_modules/@progress/kendo-charts/dist/es/chart/candlestick-chart/candlestick.js
var Candlestick = class extends chart_element_default {
  constructor(value2, options) {
    super(options);
    this.value = value2;
  }
  getLabelText(options) {
    return this.formatValue(options.format);
  }
  reflow(box) {
    const { options, value: value2, owner: chart } = this;
    const valueAxis = chart.seriesValueAxis(options);
    const ocSlot = valueAxis.getSlot(value2.open, value2.close);
    const lhSlot = valueAxis.getSlot(value2.low, value2.high);
    ocSlot.x1 = lhSlot.x1 = box.x1;
    ocSlot.x2 = lhSlot.x2 = box.x2;
    this.realBody = ocSlot;
    const mid = lhSlot.center().x;
    const points = [];
    points.push([[mid, lhSlot.y1], [mid, ocSlot.y1]]);
    points.push([[mid, ocSlot.y2], [mid, lhSlot.y2]]);
    this.lines = points;
    this.box = lhSlot.clone().wrap(ocSlot);
    if (!this._rendered) {
      this._rendered = true;
      this.createNote();
    }
    this.reflowNote();
  }
  reflowNote() {
    if (this.note) {
      this.note.reflow(this.box);
    }
  }
  createVisual() {
    super.createVisual();
    this.addAccessibilityAttributesToVisual();
    this._mainVisual = this.mainVisual(this.options);
    this.visual.append(
      this._mainVisual
    );
    this.createOverlay();
  }
  mainVisual(options) {
    const group = new drawing_exports.Group();
    this.createBody(group, options);
    this.createLines(group, options);
    return group;
  }
  createBody(container, options) {
    const body = drawing_exports.Path.fromRect(this.realBody.toRect(), {
      fill: createPatternFill(options.pattern, {
        color: this.color,
        opacity: options.opacity
      }),
      stroke: null
    });
    if (options.border.width > 0) {
      body.options.set("stroke", {
        color: this.getBorderColor(options),
        width: options.border.width,
        dashType: options.border.dashType,
        opacity: valueOrDefault(options.border.opacity, options.opacity)
      });
    }
    alignPathToPixel(body);
    container.append(body);
    if (hasGradientOverlay(options)) {
      container.append(this.createGradientOverlay(body, { baseColor: this.color }, deepExtend({
        end: !options.vertical ? [0, 1] : void 0
      }, options.overlay)));
    }
  }
  createLines(container, options) {
    this.drawLines(container, options, this.lines, options.line);
  }
  drawLines(container, options, lines, lineOptions) {
    if (!lines) {
      return;
    }
    const lineStyle = {
      stroke: {
        color: lineOptions.color || this.color,
        opacity: valueOrDefault(lineOptions.opacity, options.opacity),
        width: lineOptions.width,
        dashType: lineOptions.dashType,
        lineCap: "butt"
      }
    };
    for (let i37 = 0; i37 < lines.length; i37++) {
      const line = drawing_exports.Path.fromPoints(lines[i37], lineStyle);
      alignPathToPixel(line);
      container.append(line);
    }
  }
  getBorderColor(options) {
    const border = options.border;
    let borderColor = border.color;
    if (!defined(borderColor)) {
      borderColor = new color_default(this.color).brightness(this.options.border._brightness).toHex();
    }
    return borderColor;
  }
  createOverlay() {
    const overlay = drawing_exports.Path.fromRect(this.box.toRect(), {
      fill: {
        color: WHITE,
        opacity: 0
      },
      stroke: null
    });
    this.visual.append(overlay);
  }
  createHighlight() {
    const highlight = this.options.highlight;
    const normalColor = this.color;
    this.color = highlight.color || this.color;
    const overlay = this.mainVisual(
      deepExtend({}, this.options, {
        line: {
          color: this.getBorderColor(highlight)
        }
      }, highlight)
    );
    this.color = normalColor;
    return overlay;
  }
  highlightVisual() {
    return this._mainVisual;
  }
  highlightVisualArgs() {
    return {
      options: this.options,
      rect: this.box.toRect(),
      visual: this._mainVisual
    };
  }
  tooltipAnchor() {
    const box = this.box;
    const clipBox = this.owner.pane.clipBox() || box;
    return {
      point: new point_default(box.x2 + TOOLTIP_OFFSET, Math.max(box.y1, clipBox.y1) + TOOLTIP_OFFSET),
      align: {
        horizontal: LEFT,
        vertical: TOP
      }
    };
  }
  formatValue(format) {
    return this.owner.formatPointValue(this, format);
  }
  overlapsBox(box) {
    return this.box.overlaps(box);
  }
  pointData() {
    return {
      dataItem: this.dataItem,
      value: this.value,
      meanPoints: this.meanPoints,
      medianPoints: this.medianPoints,
      whiskerPoints: this.whiskerPoints,
      stackValue: this.stackValue,
      series: this.series
    };
  }
  getIndex() {
    return this.categoryIx;
  }
};
Candlestick.prototype.createFocusHighlight = bar_default.prototype.createFocusHighlight;
setDefaultOptions(Candlestick, {
  vertical: true,
  border: {
    _brightness: 0.8
  },
  line: {
    width: 2
  },
  overlay: {
    gradient: "glass"
  },
  tooltip: {
    format: "<table><tr><th colspan='2'>{4:d}</th></tr><tr><td>Open:</td><td>{0:C}</td></tr><tr><td>High:</td><td>{1:C}</td></tr><tr><td>Low:</td><td>{2:C}</td></tr><tr><td>Close:</td><td>{3:C}</td></tr></table>"
  },
  labels: {
    format: ""
  },
  highlight: {
    opacity: 1,
    border: {
      width: 1,
      opacity: 1
    },
    line: {
      width: 1,
      opacity: 1
    }
  },
  notes: {
    visible: true,
    label: {}
  },
  accessibility: {
    role: CHART_POINT_ROLE,
    className: CHART_POINT_CLASSNAME,
    ariaRoleDescription: CHART_POINT_ROLE_DESCRIPTION
  }
});
deepExtend(Candlestick.prototype, point_events_mixin_default);
deepExtend(Candlestick.prototype, note_mixin_default);
deepExtend(Candlestick.prototype, accessibility_attributes_mixin_default);
var candlestick_default = Candlestick;

// node_modules/@progress/kendo-charts/dist/es/chart/candlestick-chart/candlestick-chart.js
var CandlestickChart = class extends categorical_chart_default {
  reflowCategories(categorySlots) {
    const children = this.children;
    const childrenLength = children.length;
    for (let i37 = 0; i37 < childrenLength; i37++) {
      children[i37].reflow(categorySlots[i37]);
    }
  }
  addValue(data, fields) {
    const { categoryIx, category, series, seriesIx } = fields;
    const { children, options } = this;
    const value2 = data.valueFields;
    const valueParts = this.splitValue(value2);
    const hasValue4 = areNumbers(valueParts);
    const dataItem = series.data[categoryIx];
    let categoryPoints = this.categoryPoints[categoryIx];
    let point;
    if (!categoryPoints) {
      this.categoryPoints[categoryIx] = categoryPoints = [];
    }
    if (hasValue4) {
      point = this.createPoint(data, fields);
    }
    let cluster = children[categoryIx];
    if (!cluster) {
      cluster = new cluster_layout_default({
        vertical: options.invertAxes,
        gap: options.gap,
        spacing: options.spacing,
        rtl: !options.invertAxes && (this.chartService || {}).rtl
      });
      this.append(cluster);
    }
    if (point) {
      this.updateRange(value2, fields);
      cluster.append(point);
      point.categoryIx = categoryIx;
      point.category = category;
      point.series = series;
      point.seriesIx = seriesIx;
      point.owner = this;
      point.dataItem = dataItem;
      point.noteText = data.fields.noteText;
    }
    this.points.push(point);
    categoryPoints.push(point);
  }
  pointType() {
    return candlestick_default;
  }
  createPoint(data, fields) {
    const { series } = fields;
    const pointType = this.pointType();
    const value2 = data.valueFields;
    let pointOptions = deepExtend({}, series);
    let color = data.fields.color || series.color;
    pointOptions = this.evalPointOptions(pointOptions, value2, fields);
    if (series.type === CANDLESTICK || series.type === OHLC) {
      if (value2.open > value2.close) {
        color = data.fields.downColor || series.downColor || series.color;
      }
    }
    if (isFunction(series.color)) {
      color = pointOptions.color;
    }
    pointOptions.vertical = !this.options.invertAxes;
    const point = new pointType(value2, pointOptions);
    point.color = color;
    return point;
  }
  splitValue(value2) {
    return [value2.low, value2.open, value2.close, value2.high];
  }
  updateRange(value2, fields) {
    const axisName = fields.series.axis;
    const parts = this.splitValue(value2);
    let axisRange = this.valueAxisRanges[axisName] || { min: MAX_VALUE, max: MIN_VALUE };
    this.valueAxisRanges[axisName] = {
      min: Math.min.apply(Math, parts.concat([axisRange.min])),
      max: Math.max.apply(Math, parts.concat([axisRange.max]))
    };
  }
  formatPointValue(point, format) {
    const value2 = point.value;
    return this.chartService.format.auto(
      format,
      value2.open,
      value2.high,
      value2.low,
      value2.close,
      point.category
    );
  }
  animationPoints() {
    return this.points;
  }
};
deepExtend(CandlestickChart.prototype, clip_animation_mixin_default);
var candlestick_chart_default = CandlestickChart;

// node_modules/@progress/kendo-charts/dist/es/chart/box-plot-chart/box-plot.js
var BoxPlot = class extends candlestick_default {
  constructor(value2, options) {
    super(value2, options);
    this.createNote();
  }
  reflow(box) {
    const { options, value: value2, owner: chart } = this;
    const valueAxis = chart.seriesValueAxis(options);
    let whiskerSlot, boxSlot;
    this.boxSlot = boxSlot = valueAxis.getSlot(value2.q1, value2.q3);
    this.realBody = boxSlot;
    this.reflowBoxSlot(box);
    this.whiskerSlot = whiskerSlot = valueAxis.getSlot(value2.lower, value2.upper);
    this.reflowWhiskerSlot(box);
    const medianSlot = valueAxis.getSlot(value2.median);
    if (value2.mean) {
      const meanSlot = valueAxis.getSlot(value2.mean);
      this.meanPoints = this.calcMeanPoints(box, meanSlot);
    }
    this.whiskerPoints = this.calcWhiskerPoints(boxSlot, whiskerSlot);
    this.medianPoints = this.calcMedianPoints(box, medianSlot);
    this.box = whiskerSlot.clone().wrap(boxSlot);
    this.reflowNote();
  }
  reflowBoxSlot(box) {
    this.boxSlot.x1 = box.x1;
    this.boxSlot.x2 = box.x2;
  }
  reflowWhiskerSlot(box) {
    this.whiskerSlot.x1 = box.x1;
    this.whiskerSlot.x2 = box.x2;
  }
  calcMeanPoints(box, meanSlot) {
    return [
      [[box.x1, meanSlot.y1], [box.x2, meanSlot.y1]]
    ];
  }
  calcWhiskerPoints(boxSlot, whiskerSlot) {
    const mid = whiskerSlot.center().x;
    return [[
      [mid - 5, whiskerSlot.y1],
      [mid + 5, whiskerSlot.y1],
      [mid, whiskerSlot.y1],
      [mid, boxSlot.y1]
    ], [
      [mid - 5, whiskerSlot.y2],
      [mid + 5, whiskerSlot.y2],
      [mid, whiskerSlot.y2],
      [mid, boxSlot.y2]
    ]];
  }
  calcMedianPoints(box, medianSlot) {
    return [
      [[box.x1, medianSlot.y1], [box.x2, medianSlot.y1]]
    ];
  }
  renderOutliers(options) {
    const value2 = this.value;
    const outliers = value2.outliers || [];
    const outerFence = Math.abs(value2.q3 - value2.q1) * 3;
    const elements = [];
    let markers = options.markers || {};
    for (let i37 = 0; i37 < outliers.length; i37++) {
      const outlierValue = outliers[i37];
      if (outlierValue < value2.q3 + outerFence && outlierValue > value2.q1 - outerFence) {
        markers = options.outliers;
      } else {
        markers = options.extremes;
      }
      let markersBorder = deepExtend({}, markers.border);
      if (!defined(markersBorder.color)) {
        if (defined(this.color)) {
          markersBorder.color = this.color;
        } else {
          markersBorder.color = new color_default(markers.background).brightness(BORDER_BRIGHTNESS).toHex();
        }
      }
      const shape = new shape_element_default({
        type: markers.type,
        width: markers.size,
        height: markers.size,
        rotation: markers.rotation,
        background: markers.background,
        border: markersBorder,
        opacity: markers.opacity
      });
      shape.value = outlierValue;
      elements.push(shape);
    }
    this.reflowOutliers(elements);
    return elements;
  }
  reflowOutliers(outliers) {
    const valueAxis = this.owner.seriesValueAxis(this.options);
    const center = this.box.center();
    for (let i37 = 0; i37 < outliers.length; i37++) {
      const outlierValue = outliers[i37].value;
      const markerBox = valueAxis.getSlot(outlierValue);
      if (this.options.vertical) {
        markerBox.move(center.x);
      } else {
        markerBox.move(void 0, center.y);
      }
      this.box = this.box.wrap(markerBox);
      outliers[i37].reflow(markerBox);
    }
  }
  mainVisual(options) {
    const group = super.mainVisual(options);
    const outliers = this.renderOutliers(options);
    for (let i37 = 0; i37 < outliers.length; i37++) {
      const element = outliers[i37].getElement();
      if (element) {
        group.append(element);
      }
    }
    return group;
  }
  createLines(container, options) {
    this.drawLines(container, options, this.whiskerPoints, options.whiskers);
    this.drawLines(container, options, this.medianPoints, options.median);
    this.drawLines(container, options, this.meanPoints, options.mean);
  }
  getBorderColor() {
    if ((this.options.border || {}).color) {
      return this.options.border.color;
    }
    if (this.color) {
      return this.color;
    }
    return super.getBorderColor();
  }
};
setDefaultOptions(BoxPlot, {
  border: {
    _brightness: 0.8
  },
  line: {
    width: 2
  },
  median: {
    color: "#f6f6f6"
  },
  mean: {
    width: 2,
    dashType: "dash",
    color: "#f6f6f6"
  },
  overlay: {
    gradient: "glass"
  },
  tooltip: {
    format: "<table><tr><th colspan='2'>{6:d}</th></tr><tr><td>Lower:</td><td>{0:C}</td></tr><tr><td>Q1:</td><td>{1:C}</td></tr><tr><td>Median:</td><td>{2:C}</td></tr><tr><td>Mean:</td><td>{5:C}</td></tr><tr><td>Q3:</td><td>{3:C}</td></tr><tr><td>Upper:</td><td>{4:C}</td></tr></table>"
  },
  highlight: {
    opacity: 1,
    border: {
      width: 1,
      opacity: 1
    },
    line: {
      width: 1,
      opacity: 1
    }
  },
  notes: {
    visible: true,
    label: {}
  },
  outliers: {
    visible: true,
    size: LINE_MARKER_SIZE,
    type: CROSS,
    background: WHITE,
    border: {
      width: 2,
      opacity: 1
    },
    opacity: 0
  },
  extremes: {
    visible: true,
    size: LINE_MARKER_SIZE,
    type: CIRCLE,
    background: WHITE,
    border: {
      width: 2,
      opacity: 1
    },
    opacity: 0
  }
});
deepExtend(BoxPlot.prototype, point_events_mixin_default);
var box_plot_default = BoxPlot;

// node_modules/@progress/kendo-charts/dist/es/chart/box-plot-chart/vertical-box-plot.js
var VerticalBoxPlot = class extends box_plot_default {
  reflowBoxSlot(box) {
    this.boxSlot.y1 = box.y1;
    this.boxSlot.y2 = box.y2;
  }
  reflowWhiskerSlot(box) {
    this.whiskerSlot.y1 = box.y1;
    this.whiskerSlot.y2 = box.y2;
  }
  calcMeanPoints(box, meanSlot) {
    return [
      [[meanSlot.x1, box.y1], [meanSlot.x1, box.y2]]
    ];
  }
  calcWhiskerPoints(boxSlot, whiskerSlot) {
    const mid = whiskerSlot.center().y;
    return [[
      [whiskerSlot.x1, mid - 5],
      [whiskerSlot.x1, mid + 5],
      [whiskerSlot.x1, mid],
      [boxSlot.x1, mid]
    ], [
      [whiskerSlot.x2, mid - 5],
      [whiskerSlot.x2, mid + 5],
      [whiskerSlot.x2, mid],
      [boxSlot.x2, mid]
    ]];
  }
  calcMedianPoints(box, medianSlot) {
    return [
      [[medianSlot.x1, box.y1], [medianSlot.x1, box.y2]]
    ];
  }
};
var vertical_box_plot_default = VerticalBoxPlot;

// node_modules/@progress/kendo-charts/dist/es/chart/box-plot-chart/box-plot-chart.js
var BoxPlotChart = class extends candlestick_chart_default {
  addValue(data, fields) {
    const { categoryIx, category, series, seriesIx } = fields;
    const { children, options } = this;
    const value2 = data.valueFields;
    const valueParts = this.splitValue(value2);
    const hasValue4 = areNumbers(valueParts);
    const dataItem = series.data[categoryIx];
    let categoryPoints = this.categoryPoints[categoryIx];
    let point;
    if (!categoryPoints) {
      this.categoryPoints[categoryIx] = categoryPoints = [];
    }
    if (hasValue4) {
      point = this.createPoint(data, fields);
    }
    let cluster = children[categoryIx];
    if (!cluster) {
      cluster = new cluster_layout_default({
        vertical: options.invertAxes,
        gap: options.gap,
        spacing: options.spacing,
        rtl: !options.invertAxes && (this.chartService || {}).rtl
      });
      this.append(cluster);
    }
    if (point) {
      this.updateRange(value2, fields);
      cluster.append(point);
      point.categoryIx = categoryIx;
      point.category = category;
      point.series = series;
      point.seriesIx = seriesIx;
      point.owner = this;
      point.dataItem = dataItem;
    }
    this.points.push(point);
    categoryPoints.push(point);
  }
  pointType() {
    if (this.options.invertAxes) {
      return vertical_box_plot_default;
    }
    return box_plot_default;
  }
  splitValue(value2) {
    return [
      value2.lower,
      value2.q1,
      value2.median,
      value2.q3,
      value2.upper
    ];
  }
  updateRange(value2, fields) {
    const axisName = fields.series.axis;
    let parts = this.splitValue(value2).concat(this.filterOutliers(value2.outliers));
    if (defined(value2.mean)) {
      parts = parts.concat(value2.mean);
    }
    let axisRange = this.valueAxisRanges[axisName] || { min: MAX_VALUE, max: MIN_VALUE };
    this.valueAxisRanges[axisName] = {
      min: Math.min.apply(Math, parts.concat([axisRange.min])),
      max: Math.max.apply(Math, parts.concat([axisRange.max]))
    };
  }
  formatPointValue(point, format) {
    const value2 = point.value;
    return this.chartService.format.auto(
      format,
      value2.lower,
      value2.q1,
      value2.median,
      value2.q3,
      value2.upper,
      value2.mean,
      point.category
    );
  }
  filterOutliers(items) {
    const length = (items || []).length;
    const result = [];
    for (let i37 = 0; i37 < length; i37++) {
      const item = items[i37];
      if (defined(item) && item !== null) {
        result.push(item);
      }
    }
    return result;
  }
  supportsPointInactiveOpacity() {
    return false;
  }
};
var box_plot_chart_default = BoxPlotChart;

// node_modules/@progress/kendo-charts/dist/es/chart/error-bars/scatter-error-bar.js
var ScatterErrorBar = class extends error_bar_base_default {
  getAxis() {
    const axes = this.chart.seriesAxes(this.series);
    const axis = this.isVertical ? axes.y : axes.x;
    return axis;
  }
};
var scatter_error_bar_default = ScatterErrorBar;

// node_modules/@progress/kendo-charts/dist/es/chart/scatter-charts/scatter-chart.js
var ScatterChart = class extends chart_element_default {
  constructor(plotArea, options) {
    super(options);
    this.plotArea = plotArea;
    this.chartService = plotArea.chartService;
    this._initFields();
    this.render();
  }
  _initFields() {
    this.xAxisRanges = {};
    this.yAxisRanges = {};
    this.points = [];
    this.seriesPoints = [];
    this.seriesOptions = [];
    this._evalSeries = [];
  }
  render() {
    this.traverseDataPoints(this.addValue.bind(this));
  }
  addErrorBar(point, field, fields) {
    const value2 = point.value[field];
    const valueErrorField = field + "Value";
    const lowField = field + "ErrorLow";
    const highField = field + "ErrorHigh";
    const { seriesIx, series } = fields;
    const errorBars = point.options.errorBars;
    const lowValue = fields[lowField];
    const highValue = fields[highField];
    if (isNumber(value2)) {
      let errorRange;
      if (isNumber(lowValue) && isNumber(highValue)) {
        errorRange = { low: lowValue, high: highValue };
      }
      if (errorBars && defined(errorBars[valueErrorField])) {
        this.seriesErrorRanges = this.seriesErrorRanges || { x: [], y: [] };
        this.seriesErrorRanges[field][seriesIx] = this.seriesErrorRanges[field][seriesIx] || new error_range_calculator_default(errorBars[valueErrorField], series, field);
        errorRange = this.seriesErrorRanges[field][seriesIx].getErrorRange(value2, errorBars[valueErrorField]);
      }
      if (errorRange) {
        this.addPointErrorBar(errorRange, point, field);
      }
    }
  }
  addPointErrorBar(errorRange, point, field) {
    const { low, high } = errorRange;
    const { series, options: { errorBars: options } } = point;
    const isVertical = field === Y;
    const item = {};
    point[field + "Low"] = low;
    point[field + "High"] = high;
    point.errorBars = point.errorBars || [];
    const errorBar = new scatter_error_bar_default(low, high, isVertical, this, series, options);
    point.errorBars.push(errorBar);
    point.append(errorBar);
    item[field] = low;
    this.updateRange(item, series);
    item[field] = high;
    this.updateRange(item, series);
  }
  addValue(value2, fields) {
    const { x: x7, y: y2 } = value2;
    const seriesIx = fields.seriesIx;
    const series = this.options.series[seriesIx];
    const missingValues = this.seriesMissingValues(series);
    const seriesPoints = this.seriesPoints[seriesIx];
    let pointValue = value2;
    if (!(hasValue(x7) && hasValue(y2))) {
      pointValue = this.createMissingValue(pointValue, missingValues);
    }
    let point;
    if (pointValue) {
      point = this.createPoint(pointValue, fields);
      if (point) {
        Object.assign(point, fields);
        this.addErrorBar(point, X, fields);
        this.addErrorBar(point, Y, fields);
      }
      this.updateRange(pointValue, fields.series);
    }
    this.points.push(point);
    seriesPoints.push(point);
  }
  seriesMissingValues(series) {
    return series.missingValues;
  }
  createMissingValue() {
  }
  updateRange(value2, series) {
    const intlService = this.chartService.intl;
    const { xAxis: xAxisName, yAxis: yAxisName } = series;
    let { x: x7, y: y2 } = value2;
    let xAxisRange = this.xAxisRanges[xAxisName];
    let yAxisRange = this.yAxisRanges[yAxisName];
    if (hasValue(x7)) {
      xAxisRange = this.xAxisRanges[xAxisName] = xAxisRange || { min: MAX_VALUE, max: MIN_VALUE };
      if (isString(x7)) {
        x7 = parseDate(intlService, x7);
      }
      xAxisRange.min = Math.min(xAxisRange.min, x7);
      xAxisRange.max = Math.max(xAxisRange.max, x7);
    }
    if (hasValue(y2)) {
      yAxisRange = this.yAxisRanges[yAxisName] = yAxisRange || { min: MAX_VALUE, max: MIN_VALUE };
      if (isString(y2)) {
        y2 = parseDate(intlService, y2);
      }
      yAxisRange.min = Math.min(yAxisRange.min, y2);
      yAxisRange.max = Math.max(yAxisRange.max, y2);
    }
  }
  evalPointOptions(options, value2, fields) {
    const { series, seriesIx } = fields;
    const state = {
      defaults: series._defaults,
      excluded: [
        "data",
        "tooltip",
        "content",
        "template",
        "visual",
        "toggle",
        "_outOfRangeMinPoint",
        "_outOfRangeMaxPoint",
        "drilldownSeriesFactory",
        "ariaTemplate",
        "ariaContent"
      ]
    };
    let doEval = this._evalSeries[seriesIx];
    if (!defined(doEval)) {
      this._evalSeries[seriesIx] = doEval = evalOptions(options, {}, state, true);
    }
    let pointOptions = options;
    if (doEval) {
      pointOptions = deepExtend({}, options);
      evalOptions(pointOptions, {
        value: value2,
        series,
        dataItem: fields.dataItem
      }, state);
    }
    return pointOptions;
  }
  pointType() {
    return line_point_default;
  }
  pointOptions(series, seriesIx) {
    let options = this.seriesOptions[seriesIx];
    if (!options) {
      const defaults = this.pointType().prototype.defaults;
      this.seriesOptions[seriesIx] = options = deepExtend({}, defaults, {
        markers: {
          opacity: series.opacity
        },
        tooltip: {
          format: this.options.tooltip.format
        },
        labels: {
          format: this.options.labels.format
        }
      }, series);
    }
    return options;
  }
  createPoint(value2, fields) {
    const series = fields.series;
    let pointOptions = this.pointOptions(series, fields.seriesIx);
    let color = fields.color || series.color;
    pointOptions = this.evalPointOptions(pointOptions, value2, fields);
    if (isFunction(series.color)) {
      color = pointOptions.color;
    }
    const point = new line_point_default(value2, pointOptions);
    point.color = color;
    this.append(point);
    return point;
  }
  seriesAxes(series) {
    const { xAxis: xAxisName, yAxis: yAxisName } = series;
    const plotArea = this.plotArea;
    const xAxis = xAxisName ? plotArea.namedXAxes[xAxisName] : plotArea.axisX;
    const yAxis = yAxisName ? plotArea.namedYAxes[yAxisName] : plotArea.axisY;
    if (!xAxis) {
      throw new Error("Unable to locate X axis with name " + xAxisName);
    }
    if (!yAxis) {
      throw new Error("Unable to locate Y axis with name " + yAxisName);
    }
    return {
      x: xAxis,
      y: yAxis
    };
  }
  reflow(targetBox) {
    const chartPoints = this.points;
    const limit = !this.options.clip;
    let pointIx = 0;
    this.traverseDataPoints((value2, fields) => {
      const point = chartPoints[pointIx++];
      const seriesAxes = this.seriesAxes(fields.series);
      const slotX = seriesAxes.x.getSlot(value2.x, value2.x, limit);
      const slotY = seriesAxes.y.getSlot(value2.y, value2.y, limit);
      if (point) {
        if (slotX && slotY) {
          const pointSlot = this.pointSlot(slotX, slotY);
          point.reflow(pointSlot);
        } else {
          point.visible = false;
        }
      }
    });
    this.box = targetBox;
  }
  pointSlot(slotX, slotY) {
    return new box_default(slotX.x1, slotY.y1, slotX.x2, slotY.y2);
  }
  traverseDataPoints(callback) {
    const { options: { series }, seriesPoints } = this;
    for (let seriesIx = 0; seriesIx < series.length; seriesIx++) {
      const currentSeries = series[seriesIx];
      const currentSeriesPoints = seriesPoints[seriesIx];
      if (!currentSeriesPoints) {
        seriesPoints[seriesIx] = [];
      }
      for (let pointIx = 0; pointIx < currentSeries.data.length; pointIx++) {
        const { valueFields: value2, fields } = this.plotArea.bindPoint(currentSeries, pointIx);
        callback(value2, deepExtend({
          pointIx,
          series: currentSeries,
          seriesIx,
          dataItem: currentSeries.data[pointIx],
          owner: this
        }, fields));
      }
    }
  }
  formatPointValue(point, format) {
    const value2 = point.value;
    return this.chartService.format.auto(format, value2.x, value2.y);
  }
  animationPoints() {
    const points = this.points;
    const result = [];
    for (let idx = 0; idx < points.length; idx++) {
      result.push((points[idx] || {}).marker);
    }
    return result;
  }
};
setDefaultOptions(ScatterChart, {
  series: [],
  tooltip: {
    format: "{0}, {1}"
  },
  labels: {
    format: "{0}, {1}"
  },
  clip: true
});
deepExtend(ScatterChart.prototype, clip_animation_mixin_default);
var scatter_chart_default = ScatterChart;

// node_modules/@progress/kendo-charts/dist/es/chart/bubble-chart/bubble.js
var Bubble = class extends line_point_default {
  constructor(value2, options) {
    super(value2, options);
    this.category = value2.category;
  }
  createHighlight() {
    const highlight = this.options.highlight;
    const border = highlight.border;
    const markers = this.options.markers;
    const center = this.box.center();
    const radius = (markers.size + markers.border.width + border.width) / 2;
    const highlightGroup = new drawing_exports.Group();
    const shadow = new drawing_exports.Circle(new geometry_exports.Circle([center.x, center.y + radius / 5 + border.width / 2], radius + border.width / 2), {
      stroke: {
        color: "none"
      },
      fill: this.createGradient({
        gradient: "bubbleShadow",
        color: markers.background,
        stops: [{
          offset: 0,
          color: markers.background,
          opacity: 0.3
        }, {
          offset: 1,
          color: markers.background,
          opacity: 0
        }]
      })
    });
    const overlay = new drawing_exports.Circle(new geometry_exports.Circle([center.x, center.y], radius), {
      stroke: {
        color: border.color || new color_default(markers.background).brightness(BORDER_BRIGHTNESS).toHex(),
        width: border.width,
        opacity: border.opacity,
        dashType: border.dashType
      },
      fill: createPatternFill(this.options.pattern, {
        color: markers.background,
        opacity: highlight.opacity
      })
    });
    highlightGroup.append(shadow, overlay);
    return highlightGroup;
  }
  createFocusHighlight(style) {
    const highlightOptions2 = this.options.focusHighlight;
    const markers = this.options.markers;
    const center = this.box.center();
    const radius = (markers.size + markers.border.width) / 2 + highlightOptions2.border.width / 2;
    const highlight = new drawing_exports.Circle(new geometry_exports.Circle([center.x, center.y], radius), style);
    return highlight;
  }
};
Bubble.prototype.defaults = deepExtend({}, Bubble.prototype.defaults, {
  labels: {
    position: CENTER
  },
  highlight: {
    opacity: 1,
    border: {
      color: "#fff",
      width: 2,
      opacity: 1
    }
  }
});
Bubble.prototype.defaults.highlight.zIndex = void 0;
var bubble_default = Bubble;

// node_modules/@progress/kendo-charts/dist/es/chart/bubble-chart/bubble-chart.js
var BubbleChart = class extends scatter_chart_default {
  _initFields() {
    this._maxSize = MIN_VALUE;
    super._initFields();
  }
  addValue(value2, fields) {
    if (value2.size !== null && (value2.size > 0 || value2.size < 0 && fields.series.negativeValues.visible)) {
      this._maxSize = Math.max(this._maxSize, Math.abs(value2.size));
      super.addValue(value2, fields);
    } else {
      this.points.push(null);
      this.seriesPoints[fields.seriesIx].push(null);
    }
  }
  reflow(box) {
    this.updateBubblesSize(box);
    super.reflow(box);
  }
  pointType() {
    return bubble_default;
  }
  createPoint(value2, fields) {
    const series = fields.series;
    const pointsCount = series.data.length;
    const delay = fields.pointIx * (INITIAL_ANIMATION_DURATION / pointsCount);
    const animationOptions = {
      delay,
      duration: INITIAL_ANIMATION_DURATION - delay,
      type: BUBBLE
    };
    let color = fields.color || series.color;
    if (value2.size < 0 && series.negativeValues.visible) {
      color = valueOrDefault(
        series.negativeValues.color,
        color
      );
    }
    let pointOptions = deepExtend({
      labels: {
        animation: {
          delay,
          duration: INITIAL_ANIMATION_DURATION - delay
        }
      }
    }, this.pointOptions(series, fields.seriesIx), {
      markers: {
        type: CIRCLE,
        border: series.border,
        opacity: series.opacity,
        animation: animationOptions
      }
    });
    pointOptions = this.evalPointOptions(pointOptions, value2, fields);
    if (isFunction(series.color)) {
      color = pointOptions.color;
    }
    pointOptions.markers.background = color;
    const point = new bubble_default(value2, pointOptions);
    point.color = color;
    this.append(point);
    return point;
  }
  updateBubblesSize(box) {
    const { options: { series } } = this;
    const boxSize = Math.min(box.width(), box.height());
    for (let seriesIx = 0; seriesIx < series.length; seriesIx++) {
      const currentSeries = series[seriesIx];
      const seriesPoints = this.seriesPoints[seriesIx];
      const minSize = currentSeries.minSize || Math.max(boxSize * 0.02, 10);
      const maxSize = currentSeries.maxSize || boxSize * 0.2;
      const minR = minSize / 2;
      const maxR = maxSize / 2;
      const minArea = Math.PI * minR * minR;
      const maxArea = Math.PI * maxR * maxR;
      const areaRange = maxArea - minArea;
      const areaRatio = areaRange / this._maxSize;
      for (let pointIx = 0; pointIx < seriesPoints.length; pointIx++) {
        const point = seriesPoints[pointIx];
        if (point) {
          const area = Math.abs(point.value.size) * areaRatio;
          const radius = Math.sqrt((minArea + area) / Math.PI);
          const baseZIndex = valueOrDefault(point.options.zIndex, 0);
          const zIndex = baseZIndex + (1 - radius / maxR);
          deepExtend(point.options, {
            zIndex,
            markers: {
              size: radius * 2,
              zIndex
            },
            labels: {
              zIndex: zIndex + 1
            }
          });
        }
      }
    }
  }
  formatPointValue(point, format) {
    const value2 = point.value;
    return this.chartService.format.auto(format, value2.x, value2.y, value2.size, point.category);
  }
  createAnimation() {
  }
  createVisual() {
  }
};
setDefaultOptions(BubbleChart, {
  tooltip: {
    format: "{3}"
  },
  labels: {
    format: "{3}"
  }
});
var bubble_chart_default = BubbleChart;

// node_modules/@progress/kendo-charts/dist/es/chart/bullet-chart/target.js
var Target = class extends shape_element_default {
};
deepExtend(Target.prototype, point_events_mixin_default);
var target_default = Target;

// node_modules/@progress/kendo-charts/dist/es/chart/bullet-chart/bullet.js
var Bullet = class extends chart_element_default {
  constructor(value2, options) {
    super(options);
    this.aboveAxis = this.options.aboveAxis;
    this.color = options.color || WHITE;
    this.value = value2;
  }
  render() {
    const options = this.options;
    if (!this._rendered) {
      this._rendered = true;
      if (defined(this.value.target)) {
        this.target = new target_default({
          type: options.target.shape,
          background: options.target.color || this.color,
          opacity: options.opacity,
          zIndex: options.zIndex,
          border: options.target.border,
          vAlign: TOP,
          align: RIGHT
        });
        this.target.value = this.value;
        this.target.dataItem = this.dataItem;
        this.target.series = this.series;
        this.append(this.target);
      }
      this.createLabel();
      this.createNote();
    }
  }
  createLabel() {
    const options = this.options;
    const labels = options.labels;
    if (labels.visible) {
      this.label = this.createLabelElement(labels);
      this.append(this.label);
    }
  }
  createLabelElement(options) {
    return new bar_label_default(
      this.getLabelText(options),
      options,
      this.pointData()
    );
  }
  getLabelText(options) {
    let labelTemplate = getTemplate(options);
    if (labelTemplate) {
      return labelTemplate(this.pointData());
    }
    return this.formatValue(options.format);
  }
  reflow(box) {
    this.render();
    const { options, target, owner: chart } = this;
    const invertAxes = options.invertAxes;
    const valueAxis = chart.seriesValueAxis(this.options);
    const categorySlot = chart.categorySlot(chart.categoryAxis, options.categoryIx, valueAxis);
    const targetValueSlot = valueAxis.getSlot(this.value.target);
    const targetSlotX = invertAxes ? targetValueSlot : categorySlot;
    const targetSlotY = invertAxes ? categorySlot : targetValueSlot;
    if (target) {
      const targetSlot = new box_default(
        targetSlotX.x1,
        targetSlotY.y1,
        targetSlotX.x2,
        targetSlotY.y2
      );
      target.options.height = invertAxes ? targetSlot.height() : options.target.line.width;
      target.options.width = invertAxes ? options.target.line.width : targetSlot.width();
      target.reflow(targetSlot);
    }
    const label = this.label;
    if (label) {
      label.options.aboveAxis = this.aboveAxis;
      label.reflow(box);
    }
    if (this.note) {
      this.note.reflow(box);
    }
    this.box = box;
  }
  createVisual() {
    super.createVisual();
    this.addAccessibilityAttributesToVisual();
    const options = this.options;
    const body = drawing_exports.Path.fromRect(this.box.toRect(), {
      fill: createPatternFill(options.pattern, {
        color: this.color,
        opacity: options.opacity
      }),
      stroke: null
    });
    if (options.border.width > 0) {
      body.options.set("stroke", {
        color: options.border.color || this.color,
        width: options.border.width,
        dashType: options.border.dashType,
        opacity: valueOrDefault(options.border.opacity, options.opacity)
      });
    }
    this.bodyVisual = body;
    alignPathToPixel(body);
    this.visual.append(body);
  }
  createAnimation() {
    if (this.bodyVisual) {
      this.animation = drawing_exports.Animation.create(
        this.bodyVisual,
        this.options.animation
      );
    }
  }
  createHighlight(style) {
    return drawing_exports.Path.fromRect(this.box.toRect(), style);
  }
  highlightVisual() {
    return this.bodyVisual;
  }
  highlightVisualArgs() {
    return {
      rect: this.box.toRect(),
      visual: this.bodyVisual,
      options: this.options
    };
  }
  formatValue(format) {
    return this.owner.formatPointValue(this, format);
  }
  pointData() {
    return {
      dataItem: this.dataItem,
      category: this.category,
      value: this.value,
      series: this.series
    };
  }
  overlapsBox(box) {
    return this.box.overlaps(box);
  }
  getIndex() {
    return this.categoryIx;
  }
};
Bullet.prototype.tooltipAnchor = bar_default.prototype.tooltipAnchor;
Bullet.prototype.createFocusHighlight = bar_default.prototype.createFocusHighlight;
setDefaultOptions(Bullet, {
  border: {
    width: 1
  },
  vertical: false,
  opacity: 1,
  target: {
    shape: "",
    border: {
      width: 0,
      color: "green"
    },
    line: {
      width: 2
    }
  },
  labels: {
    visible: false
  },
  tooltip: {
    format: "Current: {0}<br />Target: {1}"
  },
  notes: {
    label: {}
  },
  accessibility: {
    role: CHART_POINT_ROLE,
    className: CHART_POINT_CLASSNAME,
    ariaRoleDescription: CHART_POINT_ROLE_DESCRIPTION
  }
});
deepExtend(Bullet.prototype, point_events_mixin_default);
deepExtend(Bullet.prototype, note_mixin_default);
deepExtend(Bullet.prototype, accessibility_attributes_mixin_default);
var bullet_default = Bullet;

// node_modules/@progress/kendo-charts/dist/es/chart/bullet-chart/bullet-chart.js
var BulletChart = class extends categorical_chart_default {
  constructor(plotArea, options) {
    wrapData(options);
    super(plotArea, options);
  }
  reflowCategories(categorySlots) {
    const children = this.children;
    const childrenLength = children.length;
    for (let i37 = 0; i37 < childrenLength; i37++) {
      children[i37].reflow(categorySlots[i37]);
    }
  }
  plotRange(point) {
    const series = point.series;
    const valueAxis = this.seriesValueAxis(series);
    const axisCrossingValue = this.categoryAxisCrossingValue(valueAxis);
    return [axisCrossingValue, point.value.current || axisCrossingValue];
  }
  createPoint(data, fields) {
    const { categoryIx, series } = fields;
    const { options, children } = this;
    const value2 = data.valueFields;
    let bulletOptions = deepExtend({
      vertical: !options.invertAxes,
      overlay: series.overlay,
      categoryIx,
      invertAxes: options.invertAxes
    }, series);
    let color = data.fields.color || series.color;
    bulletOptions = this.evalPointOptions(bulletOptions, value2, fields);
    if (isFunction(series.color)) {
      color = bulletOptions.color;
    }
    const bullet = new bullet_default(value2, bulletOptions);
    bullet.color = color;
    let cluster = children[categoryIx];
    if (!cluster) {
      cluster = new cluster_layout_default({
        vertical: options.invertAxes,
        gap: options.gap,
        spacing: options.spacing,
        rtl: !options.invertAxes && (this.chartService || {}).rtl
      });
      this.append(cluster);
    }
    cluster.append(bullet);
    return bullet;
  }
  updateRange(value2, fields) {
    const { current: current4, target } = value2;
    const axisName = fields.series.axis;
    let axisRange = this.valueAxisRanges[axisName];
    if (defined(current4) && !isNaN(current4) && defined(target && !isNaN(target))) {
      axisRange = this.valueAxisRanges[axisName] = axisRange || { min: MAX_VALUE, max: MIN_VALUE };
      axisRange.min = Math.min(axisRange.min, current4, target);
      axisRange.max = Math.max(axisRange.max, current4, target);
    }
  }
  formatPointValue(point, format) {
    return this.chartService.format.auto(format, point.value.current, point.value.target);
  }
  pointValue(data) {
    return data.valueFields.current;
  }
  aboveAxis(point) {
    const value2 = point.value.current;
    return value2 > 0;
  }
  createAnimation() {
    const points = this.points;
    this._setAnimationOptions();
    for (let idx = 0; idx < points.length; idx++) {
      const point = points[idx];
      point.options.animation = this.options.animation;
      point.createAnimation();
    }
  }
};
BulletChart.prototype._setAnimationOptions = bar_chart_default.prototype._setAnimationOptions;
setDefaultOptions(BulletChart, {
  animation: {
    type: BAR
  }
});
function wrapData(options) {
  const series = options.series;
  for (let i37 = 0; i37 < series.length; i37++) {
    const seriesItem = series[i37];
    const data = seriesItem.data;
    if (data && !isArray(data[0]) && !isObject(data[0])) {
      seriesItem.data = [data];
    }
  }
}
var bullet_chart_default = BulletChart;

// node_modules/@progress/kendo-charts/dist/es/chart/tooltip/base-tooltip.js
var BaseTooltip = class {
  constructor(chartService, options) {
    this.chartService = chartService;
    this.options = deepExtend({}, this.options, options);
  }
  getStyle(options, point) {
    let { background, border: { color: border } } = options;
    if (point) {
      const pointColor = point.color || point.options.color;
      background = valueOrDefault(background, pointColor);
      border = valueOrDefault(border, pointColor);
    }
    const padding = options.padding !== void 0 ? getSpacing(options.padding) : {};
    if (typeof options.padding === "object") {
      padding.top = options.padding.top !== void 0 ? padding.top : void 0;
      padding.right = options.padding.right !== void 0 ? padding.right : void 0;
      padding.bottom = options.padding.bottom !== void 0 ? padding.bottom : void 0;
      padding.left = options.padding.left !== void 0 ? padding.left : void 0;
    }
    return {
      backgroundColor: background,
      borderColor: border,
      font: options.font,
      color: options.color,
      opacity: options.opacity,
      borderWidth: styleValue(options.border.width),
      paddingTop: styleValue(padding.top),
      paddingBottom: styleValue(padding.bottom),
      paddingLeft: styleValue(padding.left),
      paddingRight: styleValue(padding.right)
    };
  }
  show(options, tooltipOptions, point) {
    if (!this.chartService) {
      return;
    }
    options.format = tooltipOptions.format;
    const style = this.getStyle(tooltipOptions, point);
    options.style = style;
    const background = new color_default(style.backgroundColor);
    if (!defined(tooltipOptions.color) && !background.isDark()) {
      options.className = "k-chart-tooltip-inverse";
    }
    this.chartService.notify(SHOW_TOOLTIP, options);
    this.visible = true;
  }
  hide() {
    if (this.chartService) {
      this.chartService.notify(HIDE_TOOLTIP);
    }
    this.visible = false;
  }
  destroy() {
    delete this.chartService;
  }
};
setDefaultOptions(BaseTooltip, {
  border: {
    width: 1
  },
  opacity: 1
});
var base_tooltip_default = BaseTooltip;

// node_modules/@progress/kendo-charts/dist/es/chart/crosshair/crosshair-tooltip.js
var CrosshairTooltip = class extends base_tooltip_default {
  constructor(chartService, crosshair, options) {
    super(chartService, options);
    this.crosshair = crosshair;
    this.formatService = chartService.format;
    this.initAxisName();
  }
  initAxisName() {
    const axis = this.crosshair.axis;
    const plotArea = axis.plotArea;
    let name;
    if (plotArea.categoryAxis) {
      name = axis.getCategory ? "categoryAxis" : "valueAxis";
    } else {
      name = axis.options.vertical ? "yAxis" : "xAxis";
    }
    this.axisName = name;
  }
  showAt(point) {
    const { crosshair: { axis }, options } = this;
    let value2 = axis[options.stickyMode ? "getCategory" : "getValue"](point);
    let formattedValue = value2;
    if (options.format) {
      formattedValue = this.formatService.auto(options.format, value2);
    } else if (axis.options.type === DATE) {
      formattedValue = this.formatService.auto(axis.options.labels.dateFormats[axis.options.baseUnit], value2);
    }
    this.show({
      point,
      anchor: this.getAnchor(),
      crosshair: this.crosshair,
      value: formattedValue,
      axisName: this.axisName,
      axisIndex: this.crosshair.axis.axisIndex
    }, this.options);
  }
  hide() {
    this.chartService.notify(HIDE_TOOLTIP, {
      crosshair: this.crosshair,
      axisName: this.axisName,
      axisIndex: this.crosshair.axis.axisIndex
    });
  }
  getAnchor() {
    const { crosshair, options: { position, padding } } = this;
    const vertical = !crosshair.axis.options.vertical;
    const lineBox = crosshair.line.bbox();
    let horizontalAlign, verticalAlign, point;
    if (vertical) {
      horizontalAlign = CENTER;
      if (position === BOTTOM) {
        verticalAlign = TOP;
        point = lineBox.bottomLeft().translate(0, padding);
      } else {
        verticalAlign = BOTTOM;
        point = lineBox.topLeft().translate(0, -padding);
      }
    } else {
      verticalAlign = CENTER;
      if (position === LEFT) {
        horizontalAlign = RIGHT;
        point = lineBox.topLeft().translate(-padding, 0);
      } else {
        horizontalAlign = LEFT;
        point = lineBox.topRight().translate(padding, 0);
      }
    }
    return {
      point,
      align: {
        horizontal: horizontalAlign,
        vertical: verticalAlign
      }
    };
  }
};
setDefaultOptions(CrosshairTooltip, {
  padding: 10
});
var crosshair_tooltip_default = CrosshairTooltip;

// node_modules/@progress/kendo-charts/dist/es/chart/crosshair/crosshair.js
var Crosshair = class extends chart_element_default {
  constructor(chartService, axis, options) {
    super(options);
    this.axis = axis;
    this.stickyMode = axis instanceof category_axis_default;
    const tooltipOptions = this.options.tooltip;
    if (tooltipOptions.visible) {
      this.tooltip = new crosshair_tooltip_default(
        chartService,
        this,
        deepExtend({}, tooltipOptions, { stickyMode: this.stickyMode })
      );
    }
  }
  showAt(point) {
    this.point = point;
    this.moveLine();
    this.line.visible(true);
    if (this.tooltip) {
      this.tooltip.showAt(point);
    }
  }
  hide() {
    this.line.visible(false);
    if (this.tooltip) {
      this.tooltip.hide();
    }
  }
  moveLine() {
    const { axis, point } = this;
    const vertical = axis.options.vertical;
    const box = this.getBox();
    const dim = vertical ? Y : X;
    const lineStart = new geometry_exports.Point(box.x1, box.y1);
    let lineEnd;
    if (vertical) {
      lineEnd = new geometry_exports.Point(box.x2, box.y1);
    } else {
      lineEnd = new geometry_exports.Point(box.x1, box.y2);
    }
    if (point) {
      if (this.stickyMode) {
        const slot = axis.getSlot(axis.pointCategoryIndex(point));
        lineStart[dim] = lineEnd[dim] = slot.center()[dim];
      } else {
        lineStart[dim] = lineEnd[dim] = point[dim];
      }
    }
    this.box = box;
    this.line.moveTo(lineStart).lineTo(lineEnd);
  }
  getBox() {
    const axis = this.axis;
    const axes = axis.pane.axes;
    const length = axes.length;
    const vertical = axis.options.vertical;
    const box = axis.lineBox().clone();
    const dim = vertical ? X : Y;
    let axisLineBox;
    for (let i37 = 0; i37 < length; i37++) {
      const currentAxis = axes[i37];
      if (currentAxis.options.vertical !== vertical) {
        if (!axisLineBox) {
          axisLineBox = currentAxis.lineBox().clone();
        } else {
          axisLineBox.wrap(currentAxis.lineBox());
        }
      }
    }
    box[dim + 1] = axisLineBox[dim + 1];
    box[dim + 2] = axisLineBox[dim + 2];
    return box;
  }
  createVisual() {
    super.createVisual();
    const options = this.options;
    this.line = new drawing_exports.Path({
      stroke: {
        color: options.color,
        width: options.width,
        opacity: options.opacity,
        dashType: options.dashType
      },
      visible: false
    });
    this.moveLine();
    this.visual.append(this.line);
  }
  destroy() {
    if (this.tooltip) {
      this.tooltip.destroy();
    }
    super.destroy();
  }
};
setDefaultOptions(Crosshair, {
  color: BLACK,
  width: 2,
  zIndex: -1,
  tooltip: {
    visible: false
  }
});
var crosshair_default = Crosshair;

// node_modules/@progress/kendo-charts/dist/es/chart/chart-container.js
var ChartContainer = class extends chart_element_default {
  constructor(options, pane) {
    super(options);
    this.pane = pane;
  }
  shouldClip() {
    const children = this.children;
    const length = children.length;
    for (let i37 = 0; i37 < length; i37++) {
      if (children[i37].options.clip === true) {
        return true;
      }
    }
    return false;
  }
  _clipBox() {
    return this.pane.chartsBox();
  }
  createVisual() {
    this.visual = new drawing_exports.Group({
      zIndex: 0
    });
    if (this.shouldClip()) {
      const clipBox = this.clipBox = this._clipBox();
      const clipRect = clipBox.toRect();
      const clipPath = drawing_exports.Path.fromRect(clipRect);
      alignPathToPixel(clipPath);
      this.visual.clip(clipPath);
      this.unclipLabels();
    }
  }
  stackRoot() {
    return this;
  }
  unclipLabels() {
    const { children: charts, clipBox } = this;
    for (let i37 = 0; i37 < charts.length; i37++) {
      const points = charts[i37].points || [];
      const length = points.length;
      for (let j = 0; j < length; j++) {
        const point = points[j];
        if (point && point.visible !== false && point.overlapsBox) {
          if (point.overlapsBox(clipBox)) {
            if (point.unclipElements) {
              point.unclipElements();
            } else {
              const { label, note } = point;
              if (label && label.options.visible) {
                if (label.alignToClipBox) {
                  label.alignToClipBox(clipBox);
                }
                label.options.noclip = true;
              }
              if (note && note.options.visible) {
                note.options.noclip = true;
              }
            }
          }
        }
      }
    }
  }
  unclipBox() {
    const { children: charts } = this;
    const clipBox = this._clipBox();
    const box = clipBox.clone();
    for (let i37 = 0; i37 < charts.length; i37++) {
      const points = charts[i37].points || [];
      const length = points.length;
      for (let j = 0; j < length; j++) {
        const point = points[j];
        if (point && point.unclipBox && point.overlapsBox && point.visible !== false) {
          if (!point.overlapsBox(clipBox)) {
            if (point.clipElements) {
              point.clipElements();
            }
            continue;
          }
          const unclipBox2 = point.unclipBox();
          if (box.overlaps(unclipBox2)) {
            const labelBox = point.labelBox ? point.labelBox() : new box_default();
            const noteBox = point.noteBox ? point.noteBox() : new box_default();
            const heightLimit = Math.max(labelBox.height(), noteBox.height());
            const widthLimit = Math.max(labelBox.width(), noteBox.width());
            box.wrapLimit(unclipBox2, widthLimit, heightLimit);
          }
        }
      }
    }
    return box;
  }
  destroy() {
    super.destroy();
    delete this.parent;
  }
};
ChartContainer.prototype.isStackRoot = true;
var chart_container_default = ChartContainer;

// node_modules/@progress/kendo-charts/dist/es/chart/pane.js
var Pane = class _Pane extends box_element_default {
  constructor(options) {
    super(options);
    this.id = paneID();
    this.createTitle();
    this.content = new chart_element_default();
    this.chartContainer = new chart_container_default({}, this);
    this.append(this.content);
    this.axes = [];
    this.charts = [];
  }
  createTitle() {
    let titleOptions = this.options.title;
    if (isObject(titleOptions)) {
      titleOptions = deepExtend({}, titleOptions, {
        align: titleOptions.position,
        position: TOP
      });
    }
    this.title = title_default.buildTitle(titleOptions, _Pane.prototype.options.title);
    if (this.title) {
      this.append(this.title);
    }
  }
  appendAxis(axis) {
    this.content.append(axis);
    this.axes.push(axis);
    axis.pane = this;
  }
  appendAxisAt(axis, pos) {
    this.content.append(axis);
    this.axes.splice(pos, 0, axis);
    axis.pane = this;
  }
  appendChart(chart) {
    if (this.chartContainer.parent !== this.content) {
      this.content.append(this.chartContainer);
    }
    this.charts.push(chart);
    this.chartContainer.append(chart);
    chart.pane = this;
  }
  empty() {
    const plotArea = this.parent;
    if (plotArea) {
      for (let i37 = 0; i37 < this.axes.length; i37++) {
        plotArea.removeAxis(this.axes[i37]);
      }
      for (let i37 = 0; i37 < this.charts.length; i37++) {
        plotArea.removeChart(this.charts[i37]);
      }
    }
    this.axes = [];
    this.charts = [];
    this.content.destroy();
    this.content.children = [];
    this.chartContainer.children = [];
  }
  reflow(targetBox) {
    let content;
    if (last(this.children) === this.content) {
      content = this.children.pop();
    }
    super.reflow(targetBox);
    if (content) {
      this.children.push(content);
    }
    if (this.title) {
      this.contentBox.y1 += this.title.box.height();
    }
  }
  // This is the box for the charts in the pane _and_ all the overflowing ("unclipped") labels.
  unclipBox() {
    return this.chartContainer.unclipBox();
  }
  visualStyle() {
    const style = super.visualStyle();
    style.zIndex = -10;
    return style;
  }
  renderComplete() {
    if (this.options.visible) {
      this.createGridLines();
    }
  }
  stackRoot() {
    return this;
  }
  clipRoot() {
    return this;
  }
  createGridLines() {
    const axes = this.axes;
    const allAxes = axes.concat(this.parent.axes);
    const vGridLines = [];
    const hGridLines = [];
    for (let i37 = 0; i37 < axes.length; i37++) {
      const axis = axes[i37];
      const vertical = axis.options.vertical;
      const gridLines = vertical ? vGridLines : hGridLines;
      for (let j = 0; j < allAxes.length; j++) {
        if (gridLines.length === 0) {
          const altAxis = allAxes[j];
          if (vertical !== altAxis.options.vertical) {
            append(gridLines, axis.createGridLines(altAxis));
          }
        }
      }
    }
  }
  refresh() {
    this.visual.clear();
    this.content.parent = null;
    this.content.createGradient = this.createGradient.bind(this);
    this.content.renderVisual();
    this.content.parent = this;
    if (this.title) {
      this.visual.append(this.title.visual);
    }
    this.visual.append(this.content.visual);
    this.renderComplete();
    this.notifyRender();
  }
  chartsBox() {
    const axes = this.axes;
    const length = axes.length;
    const chartsBox = new box_default();
    for (let idx = 0; idx < length; idx++) {
      const axis = axes[idx];
      const axisValueField = axis.options.vertical ? Y : X;
      const lineBox = axis.lineBox();
      chartsBox[axisValueField + 1] = lineBox[axisValueField + 1];
      chartsBox[axisValueField + 2] = lineBox[axisValueField + 2];
    }
    if (chartsBox.x2 === 0) {
      const allAxes = this.parent.axes;
      const length2 = allAxes.length;
      for (let idx = 0; idx < length2; idx++) {
        const axis = allAxes[idx];
        if (!axis.options.vertical) {
          const lineBox = axis.lineBox();
          chartsBox.x1 = lineBox.x1;
          chartsBox.x2 = lineBox.x2;
        }
      }
    }
    return chartsBox;
  }
  clipBox() {
    return this.chartContainer.clipBox;
  }
  notifyRender() {
    const service = this.getService();
    if (service) {
      service.notify(PANE_RENDER, {
        pane: new chart_pane_default(this),
        index: this.paneIndex,
        name: this.options.name
      });
    }
  }
};
var ID2 = 1;
function paneID() {
  return "pane" + ID2++;
}
Pane.prototype.isStackRoot = true;
setDefaultOptions(Pane, {
  zIndex: -1,
  shrinkToFit: true,
  title: {
    align: LEFT
  },
  visible: true
});
var pane_default = Pane;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/plotarea-base.js
var visiblePoint = (point) => point.options.visible !== false;
var PlotAreaBase = class extends chart_element_default {
  constructor(series, options, chartService) {
    super(options);
    this.initFields(series, options);
    this.series = series;
    this.initSeries();
    this.charts = [];
    this.options.legend = this.options.legend || {};
    this.options.legend.data = [];
    this.axes = [];
    this.crosshairs = [];
    this.chartService = chartService;
    this.originalOptions = options;
    this.originalSeries = series;
    this._bindCache = /* @__PURE__ */ new WeakMap();
    this.createPanes();
    this.render();
    this.createCrosshairs();
  }
  initFields() {
  }
  initSeries() {
    const series = this.series;
    for (let i37 = 0; i37 < series.length; i37++) {
      series[i37].index = i37;
    }
  }
  bindPoint(series, pointIx, item) {
    let cached = this._bindCache.get(series);
    if (!cached) {
      cached = [];
      this._bindCache.set(series, cached);
    }
    let data = cached[pointIx];
    if (!data) {
      data = cached[pointIx] = series_binder_default.current.bindPoint(series, pointIx, item);
    }
    return data;
  }
  createPanes() {
    const titleOptions = this.options.title || {};
    const paneDefaults = this.options.paneDefaults;
    const paneOptions = this.options.panes || [];
    const panesLength = Math.max(paneOptions.length, 1);
    const panes = [];
    const defaults = deepExtend({
      title: {
        color: titleOptions.color
      }
    }, paneDefaults);
    for (let i37 = 0; i37 < panesLength; i37++) {
      const options = deepExtend({}, defaults, paneOptions[i37]);
      if (isString(options.title)) {
        options.title = deepExtend({ text: options.title }, defaults.title);
      }
      const currentPane = new pane_default(options);
      currentPane.paneIndex = i37;
      panes.push(currentPane);
      this.append(currentPane);
    }
    this.panes = panes;
  }
  crosshairOptions(axis) {
    return axis.options.crosshair;
  }
  createCrosshairs(panes = this.panes) {
    for (let i37 = 0; i37 < panes.length; i37++) {
      const pane = panes[i37];
      for (let j = 0; j < pane.axes.length; j++) {
        const axis = pane.axes[j];
        const options = this.crosshairOptions(axis);
        if (options && options.visible) {
          const currentCrosshair = new crosshair_default(this.chartService, axis, options);
          this.crosshairs.push(currentCrosshair);
          pane.content.append(currentCrosshair);
        }
      }
    }
  }
  removeCrosshairs(pane) {
    const crosshairs = this.crosshairs;
    const axes = pane.axes;
    for (let i37 = crosshairs.length - 1; i37 >= 0; i37--) {
      for (let j = 0; j < axes.length; j++) {
        if (crosshairs[i37].axis === axes[j]) {
          crosshairs.splice(i37, 1);
          break;
        }
      }
    }
  }
  hideCrosshairs() {
    const crosshairs = this.crosshairs;
    for (let idx = 0; idx < crosshairs.length; idx++) {
      crosshairs[idx].hide();
    }
  }
  findPane(name) {
    const panes = this.panes;
    let matchingPane;
    for (let i37 = 0; i37 < panes.length; i37++) {
      if (panes[i37].options.name === name) {
        matchingPane = panes[i37];
        break;
      }
    }
    return matchingPane || panes[0];
  }
  findPointPane(point) {
    const panes = this.panes;
    let matchingPane;
    for (let i37 = 0; i37 < panes.length; i37++) {
      if (panes[i37].box.containsPoint(point)) {
        matchingPane = panes[i37];
        break;
      }
    }
    return matchingPane;
  }
  appendAxis(axis) {
    const pane = this.findPane(axis.options.pane);
    pane.appendAxis(axis);
    this.axes.push(axis);
    axis.plotArea = this;
  }
  removeAxis(axisToRemove) {
    const filteredAxes = [];
    for (let i37 = 0; i37 < this.axes.length; i37++) {
      const axis = this.axes[i37];
      if (axisToRemove !== axis) {
        filteredAxes.push(axis);
      } else {
        axis.destroy();
      }
    }
    this.axes = filteredAxes;
  }
  appendChart(chart, pane) {
    this.charts.push(chart);
    if (pane) {
      pane.appendChart(chart);
    } else {
      this.append(chart);
    }
  }
  removeChart(chartToRemove) {
    const filteredCharts = [];
    for (let i37 = 0; i37 < this.charts.length; i37++) {
      const chart = this.charts[i37];
      if (chart !== chartToRemove) {
        filteredCharts.push(chart);
      } else {
        chart.destroy();
      }
    }
    this.charts = filteredCharts;
  }
  addToLegend(series) {
    const count = series.length;
    const legend2 = this.options.legend;
    const labels = legend2.labels || {};
    const inactiveItems = legend2.inactiveItems || {};
    const inactiveItemsLabels = inactiveItems.labels || {};
    const data = [];
    for (let i37 = 0; i37 < count; i37++) {
      const currentSeries = series[i37];
      const seriesVisible = currentSeries.visible !== false;
      if (currentSeries.visibleInLegend === false) {
        continue;
      }
      let text = currentSeries.name;
      const labelTemplate = seriesVisible ? getTemplate(labels) : getTemplate(inactiveItemsLabels) || getTemplate(labels);
      if (labelTemplate) {
        text = labelTemplate({
          text: hasValue(text) ? text : "",
          series: currentSeries
        });
      }
      const defaults = currentSeries._defaults;
      let color = currentSeries.color;
      if (isFunction(color) && defaults) {
        color = defaults.color;
      }
      let itemLabelOptions, markerColor;
      if (seriesVisible) {
        itemLabelOptions = {};
        markerColor = color;
      } else {
        itemLabelOptions = {
          color: inactiveItemsLabels.color,
          font: inactiveItemsLabels.font
        };
        markerColor = inactiveItems.markers.color;
      }
      if (hasValue(text) && text !== "") {
        data.push({
          text,
          labels: itemLabelOptions,
          markerColor,
          series: currentSeries,
          active: seriesVisible
        });
      }
    }
    append(legend2.data, data);
  }
  groupAxes(panes) {
    const xAxes = [];
    const yAxes = [];
    for (let paneIx = 0; paneIx < panes.length; paneIx++) {
      const paneAxes = panes[paneIx].axes;
      for (let axisIx = 0; axisIx < paneAxes.length; axisIx++) {
        const axis = paneAxes[axisIx];
        if (axis.options.vertical) {
          yAxes.push(axis);
        } else {
          xAxes.push(axis);
        }
      }
    }
    return { x: xAxes, y: yAxes, any: xAxes.concat(yAxes) };
  }
  groupSeriesByPane() {
    const series = this.series;
    const seriesByPane = {};
    for (let i37 = 0; i37 < series.length; i37++) {
      const currentSeries = series[i37];
      const pane = this.seriesPaneName(currentSeries);
      if (seriesByPane[pane]) {
        seriesByPane[pane].push(currentSeries);
      } else {
        seriesByPane[pane] = [currentSeries];
      }
    }
    return seriesByPane;
  }
  filterVisibleSeries(series) {
    const result = [];
    for (let i37 = 0; i37 < series.length; i37++) {
      const currentSeries = series[i37];
      if (currentSeries.visible !== false) {
        result.push(currentSeries);
      }
    }
    return result;
  }
  reflow(targetBox) {
    const options = this.options.plotArea;
    const panes = this.panes;
    const margin = getSpacing(options.margin);
    this.box = targetBox.clone().unpad(margin);
    this.reflowArea(panes);
    if (this.ensureLabelsFit(panes)) {
      this.reflowArea(panes);
    }
  }
  reflowArea(panes) {
    this.reflowPanes();
    this.detachLabels();
    this.reflowAxes(panes);
    this.reflowCharts(panes);
  }
  ensureLabelsFit(panes) {
    let change = false;
    panes.forEach((pane) => {
      const unclipBox2 = pane.unclipBox();
      const clipBox = pane.chartContainer._clipBox();
      const padding = getSpacing(pane.options.padding || {});
      if (unclipBox2.y1 < clipBox.y1 + padding.top) {
        change = true;
        padding.top = clipBox.y1 - unclipBox2.y1 + padding.top;
      }
      if (unclipBox2.y2 > clipBox.y2 - padding.bottom) {
        change = true;
        padding.bottom = unclipBox2.y2 - clipBox.y2 + padding.bottom;
      }
      if (unclipBox2.x1 < clipBox.x1 + padding.left) {
        change = true;
        padding.left = clipBox.x1 - unclipBox2.x1 + padding.left;
      }
      if (unclipBox2.x2 > clipBox.x2 - padding.right) {
        change = true;
        padding.right = unclipBox2.x2 - clipBox.x2 + padding.right;
      }
      if (change) {
        pane.options.padding = padding;
      }
    });
    return change;
  }
  redraw(panes) {
    const panesArray = [].concat(panes);
    this.initSeries();
    const root = this.getRoot();
    if (root) {
      root.cleanGradients();
    }
    for (let i37 = 0; i37 < panesArray.length; i37++) {
      this.removeCrosshairs(panesArray[i37]);
      panesArray[i37].empty();
    }
    this._bindCache = /* @__PURE__ */ new WeakMap();
    this.render(panesArray);
    this.detachLabels();
    this.reflowAxes(this.panes);
    this.reflowCharts(panesArray);
    this.createCrosshairs(panesArray);
    for (let i37 = 0; i37 < panesArray.length; i37++) {
      panesArray[i37].refresh();
    }
  }
  axisCrossingValues(axis, crossingAxes) {
    const options = axis.options;
    const crossingValues = [].concat(
      options.axisCrossingValues || options.axisCrossingValue
    );
    const valuesToAdd = crossingAxes.length - crossingValues.length;
    const defaultValue = crossingValues[0] || 0;
    for (let i37 = 0; i37 < valuesToAdd; i37++) {
      crossingValues.push(defaultValue);
    }
    return crossingValues;
  }
  alignAxisTo(axis, targetAxis, crossingValue, targetCrossingValue) {
    const slot = axis.getSlot(crossingValue, crossingValue, true);
    const slotEdge = axis.options.reverse ? 2 : 1;
    const targetSlot = targetAxis.getSlot(targetCrossingValue, targetCrossingValue, true);
    const targetEdge = targetAxis.options.reverse ? 2 : 1;
    const axisBox = axis.box.translate(
      targetSlot[X + targetEdge] - slot[X + slotEdge],
      targetSlot[Y + targetEdge] - slot[Y + slotEdge]
    );
    if (axis.pane !== targetAxis.pane) {
      axisBox.translate(0, axis.pane.box.y1 - targetAxis.pane.box.y1);
    }
    axis.reflow(axisBox);
  }
  alignAxes(xAxes, yAxes) {
    const xAnchor = xAxes[0];
    const yAnchor = yAxes[0];
    const xAnchorCrossings = this.axisCrossingValues(xAnchor, yAxes);
    const yAnchorCrossings = this.axisCrossingValues(yAnchor, xAxes);
    const leftAnchors = {};
    const rightAnchors = {};
    const topAnchors = {};
    const bottomAnchors = {};
    for (let i37 = 0; i37 < yAxes.length; i37++) {
      const axis = yAxes[i37];
      const pane = axis.pane;
      const paneId = pane.id;
      const visible = axis.options.visible !== false;
      const anchor = paneAnchor(xAxes, pane) || xAnchor;
      let anchorCrossings = xAnchorCrossings;
      if (anchor !== xAnchor) {
        anchorCrossings = this.axisCrossingValues(anchor, yAxes);
      }
      this.alignAxisTo(axis, anchor, yAnchorCrossings[i37], anchorCrossings[i37]);
      if (axis.options._overlap) {
        continue;
      }
      if (round(axis.lineBox().x1) === round(anchor.lineBox().x1)) {
        if (leftAnchors[paneId]) {
          axis.reflow(
            axis.box.alignTo(leftAnchors[paneId].box, LEFT).translate(-axis.options.margin, 0)
          );
        }
        if (visible) {
          leftAnchors[paneId] = axis;
        }
      }
      if (round(axis.lineBox().x2) === round(anchor.lineBox().x2)) {
        if (!axis._mirrored) {
          axis.options.labels.mirror = !axis.options.labels.mirror;
          axis._mirrored = true;
        }
        this.alignAxisTo(axis, anchor, yAnchorCrossings[i37], anchorCrossings[i37]);
        if (rightAnchors[paneId]) {
          axis.reflow(
            axis.box.alignTo(rightAnchors[paneId].box, RIGHT).translate(axis.options.margin, 0)
          );
        }
        if (visible) {
          rightAnchors[paneId] = axis;
        }
      }
      const paneYAnchor = paneAnchor(yAxes, pane) || yAnchor;
      if (paneYAnchor !== axis) {
        axis.alignTo(paneYAnchor);
        axis.reflow(axis.box);
      }
    }
    for (let i37 = 0; i37 < xAxes.length; i37++) {
      const axis = xAxes[i37];
      const pane = axis.pane;
      const paneId = pane.id;
      const visible = axis.options.visible !== false;
      const anchor = paneAnchor(yAxes, pane) || yAnchor;
      let anchorCrossings = yAnchorCrossings;
      if (anchor !== yAnchor) {
        anchorCrossings = this.axisCrossingValues(anchor, xAxes);
      }
      this.alignAxisTo(axis, anchor, xAnchorCrossings[i37], anchorCrossings[i37]);
      if (axis.options._overlap) {
        continue;
      }
      if (round(axis.lineBox().y1) === round(anchor.lineBox().y1)) {
        if (!axis._mirrored) {
          axis.options.labels.mirror = !axis.options.labels.mirror;
          axis._mirrored = true;
        }
        this.alignAxisTo(axis, anchor, xAnchorCrossings[i37], anchorCrossings[i37]);
        if (topAnchors[paneId]) {
          axis.reflow(
            axis.box.alignTo(topAnchors[paneId].box, TOP).translate(0, -axis.options.margin)
          );
        }
        if (visible) {
          topAnchors[paneId] = axis;
        }
      }
      if (round(axis.lineBox().y2, COORD_PRECISION) === round(anchor.lineBox().y2, COORD_PRECISION)) {
        if (bottomAnchors[paneId]) {
          axis.reflow(
            axis.box.alignTo(bottomAnchors[paneId].box, BOTTOM).translate(0, axis.options.margin)
          );
        }
        if (visible) {
          bottomAnchors[paneId] = axis;
        }
      }
      if (i37 !== 0) {
        axis.alignTo(xAnchor);
        axis.reflow(axis.box);
      }
    }
  }
  shrinkAxisWidth(panes) {
    const axes = this.groupAxes(panes).any;
    const axisBox = axisGroupBox(axes);
    let overflowX = 0;
    for (let i37 = 0; i37 < panes.length; i37++) {
      const currentPane = panes[i37];
      if (currentPane.axes.length > 0) {
        overflowX = Math.max(
          overflowX,
          axisBox.width() - currentPane.contentBox.width()
        );
      }
    }
    if (overflowX !== 0) {
      for (let i37 = 0; i37 < axes.length; i37++) {
        const currentAxis = axes[i37];
        if (!currentAxis.options.vertical) {
          currentAxis.reflow(currentAxis.box.shrink(overflowX, 0));
        }
      }
    }
  }
  shrinkAxisHeight(panes) {
    let shrinked;
    for (let i37 = 0; i37 < panes.length; i37++) {
      const currentPane = panes[i37];
      const axes = currentPane.axes;
      const overflowY = Math.max(0, axisGroupBox(axes).height() - currentPane.contentBox.height());
      if (overflowY !== 0) {
        for (let j = 0; j < axes.length; j++) {
          const currentAxis = axes[j];
          if (currentAxis.options.vertical) {
            currentAxis.reflow(
              currentAxis.box.shrink(0, overflowY)
            );
          }
        }
        shrinked = true;
      }
    }
    return shrinked;
  }
  fitAxes(panes) {
    const axes = this.groupAxes(panes).any;
    let offsetX = 0;
    for (let i37 = 0; i37 < panes.length; i37++) {
      const currentPane = panes[i37];
      const paneAxes = currentPane.axes;
      const paneBox = currentPane.contentBox;
      if (paneAxes.length > 0) {
        const axisBox = axisGroupBox(paneAxes);
        const offsetY = Math.max(paneBox.y1 - axisBox.y1, paneBox.y2 - axisBox.y2);
        offsetX = Math.max(offsetX, paneBox.x1 - axisBox.x1);
        for (let j = 0; j < paneAxes.length; j++) {
          const currentAxis = paneAxes[j];
          currentAxis.reflow(
            currentAxis.box.translate(0, offsetY)
          );
        }
      }
    }
    for (let i37 = 0; i37 < axes.length; i37++) {
      const currentAxis = axes[i37];
      currentAxis.reflow(
        currentAxis.box.translate(offsetX, 0)
      );
    }
  }
  reflowAxes(panes) {
    const axes = this.groupAxes(panes);
    for (let i37 = 0; i37 < panes.length; i37++) {
      this.reflowPaneAxes(panes[i37]);
    }
    if (axes.x.length > 0 && axes.y.length > 0) {
      this.alignAxes(axes.x, axes.y);
      this.shrinkAxisWidth(panes);
      this.autoRotateAxisLabels(axes);
      this.alignAxes(axes.x, axes.y);
      if (this.shrinkAxisWidth(panes)) {
        this.alignAxes(axes.x, axes.y);
      }
      this.shrinkAxisHeight(panes);
      this.alignAxes(axes.x, axes.y);
      if (this.shrinkAxisHeight(panes)) {
        this.alignAxes(axes.x, axes.y);
      }
      this.fitAxes(panes);
    }
  }
  autoRotateAxisLabels(groupedAxes) {
    const { panes } = this;
    const axes = allPaneAxes(panes);
    let rotated;
    for (let idx = 0; idx < axes.length; idx++) {
      const axis = axes[idx];
      if (axis.autoRotateLabels()) {
        rotated = true;
      }
    }
    if (rotated) {
      for (let idx = 0; idx < panes.length; idx++) {
        this.reflowPaneAxes(panes[idx]);
      }
      if (groupedAxes.x.length > 0 && groupedAxes.y.length > 0) {
        this.alignAxes(groupedAxes.x, groupedAxes.y);
        this.shrinkAxisWidth(panes);
      }
    }
  }
  reflowPaneAxes(pane) {
    const axes = pane.axes;
    const length = axes.length;
    if (length > 0) {
      for (let i37 = 0; i37 < length; i37++) {
        axes[i37].reflow(pane.contentBox);
      }
    }
  }
  reflowCharts(panes) {
    const charts = this.charts;
    const count = charts.length;
    const box = this.box;
    for (let i37 = 0; i37 < count; i37++) {
      const chartPane = charts[i37].pane;
      if (!chartPane || inArray(chartPane, panes)) {
        charts[i37].reflow(box);
      }
    }
  }
  reflowPanes() {
    const { box, panes } = this;
    const panesLength = panes.length;
    let remainingHeight = box.height();
    let autoHeightPanes = 0;
    let top = box.y1;
    for (let i37 = 0; i37 < panesLength; i37++) {
      const currentPane = panes[i37];
      const height = currentPane.options.height;
      currentPane.options.width = box.width();
      if (!currentPane.options.height) {
        autoHeightPanes++;
      } else {
        if (height.indexOf && height.indexOf("%")) {
          const percents = parseInt(height, 10) / 100;
          currentPane.options.height = percents * box.height();
        }
        currentPane.reflow(box.clone());
        remainingHeight -= currentPane.options.height;
      }
    }
    for (let i37 = 0; i37 < panesLength; i37++) {
      const currentPane = panes[i37];
      if (!currentPane.options.height) {
        currentPane.options.height = remainingHeight / autoHeightPanes;
      }
    }
    for (let i37 = 0; i37 < panesLength; i37++) {
      const currentPane = panes[i37];
      const paneBox = box.clone().move(box.x1, top);
      currentPane.reflow(paneBox);
      top += currentPane.options.height;
    }
  }
  backgroundBox() {
    const axes = this.axes;
    const axesCount = axes.length;
    let box;
    for (let i37 = 0; i37 < axesCount; i37++) {
      const axisA = axes[i37];
      for (let j = 0; j < axesCount; j++) {
        const axisB = axes[j];
        if (axisA.options.vertical !== axisB.options.vertical) {
          const lineBox = axisA.lineBox().clone().wrap(axisB.lineBox());
          if (!box) {
            box = lineBox;
          } else {
            box = box.wrap(lineBox);
          }
        }
      }
    }
    return box || this.box;
  }
  chartsBoxes() {
    const panes = this.panes;
    const boxes = [];
    for (let idx = 0; idx < panes.length; idx++) {
      boxes.push(panes[idx].chartsBox());
    }
    return boxes;
  }
  addBackgroundPaths(multipath) {
    const boxes = this.chartsBoxes();
    for (let idx = 0; idx < boxes.length; idx++) {
      multipath.paths.push(drawing_exports.Path.fromRect(boxes[idx].toRect()));
    }
  }
  backgroundContainsPoint(point) {
    const boxes = this.chartsBoxes();
    for (let idx = 0; idx < boxes.length; idx++) {
      if (boxes[idx].containsPoint(point)) {
        return true;
      }
    }
  }
  createVisual() {
    super.createVisual();
    const options = this.options.plotArea;
    let { opacity, background, border = {} } = options;
    if (isTransparent(background)) {
      background = WHITE;
      opacity = 0;
    }
    const bg = this._bgVisual = new drawing_exports.MultiPath({
      fill: {
        color: background,
        opacity
      },
      stroke: {
        color: border.width ? border.color : "",
        width: border.width,
        dashType: border.dashType
      },
      zIndex: -1
    });
    this.addBackgroundPaths(bg);
    this.appendVisual(bg);
  }
  pointsByCategoryIndex(categoryIndex) {
    const charts = this.charts;
    const result = [];
    if (categoryIndex !== null) {
      for (let i37 = 0; i37 < charts.length; i37++) {
        const chart = charts[i37];
        if (chart.pane.options.name === "_navigator") {
          continue;
        }
        const points = charts[i37].categoryPoints[categoryIndex];
        if (points && points.length) {
          for (let j = 0; j < points.length; j++) {
            const point = points[j];
            if (point && defined(point.value) && point.value !== null) {
              result.push(point);
            }
          }
        }
      }
    }
    return result;
  }
  pointsBySeriesIndex(seriesIndex) {
    return this.filterPoints(function(point) {
      return point.series.index === seriesIndex;
    });
  }
  pointsByPointIndex(pointIndex) {
    return this.filterPoints(function(point) {
      return point.getIndex() === pointIndex;
    });
  }
  pointsBySeriesName(name) {
    return this.filterPoints(function(point) {
      return point.series.name === name;
    });
  }
  filterPoints(callback) {
    const charts = this.charts;
    const result = [];
    for (let i37 = 0; i37 < charts.length; i37++) {
      const chart = charts[i37];
      const points = chart.points;
      for (let j = 0; j < points.length; j++) {
        const point = points[j];
        if (point && point.visible !== false && callback(point)) {
          result.push(point);
        }
      }
    }
    return result;
  }
  findPoint(callback) {
    const charts = this.charts;
    for (let i37 = 0; i37 < charts.length; i37++) {
      const chart = charts[i37];
      const points = chart.points;
      for (let j = 0; j < points.length; j++) {
        const point = points[j];
        if (point && point.visible !== false && callback(point)) {
          return point;
        }
      }
    }
  }
  paneByPoint(point) {
    const panes = this.panes;
    for (let i37 = 0; i37 < panes.length; i37++) {
      const pane = panes[i37];
      if (pane.box.containsPoint(point)) {
        return pane;
      }
    }
  }
  detachLabels() {
    const axes = this.groupAxes(this.panes);
    const xAxes = axes.x;
    const yAxes = axes.y;
    this.detachAxisGroupLabels(yAxes, xAxes);
    this.detachAxisGroupLabels(xAxes, yAxes);
  }
  detachAxisGroupLabels(axes, crossingAxes) {
    let labelAxisCount = 0;
    for (let i37 = 0; i37 < axes.length; i37++) {
      const axis = axes[i37];
      const pane = axis.pane;
      const anchor = paneAnchor(crossingAxes, pane) || crossingAxes[0];
      const axisIndex = i37 + labelAxisCount;
      const labelAxis = this.createLabelAxis(axis, axisIndex, anchor);
      if (labelAxis) {
        labelAxisCount++;
        const pos = pane.axes.indexOf(axis) + labelAxisCount;
        pane.appendAxisAt(labelAxis, pos);
      }
    }
  }
  createLabelAxis(axis, axisIndex, anchor) {
    const labelOptions = axis.options.labels;
    const position = labelOptions.position;
    const onAxis = position !== END && position !== START;
    const visible = labelOptions.visible;
    if (onAxis || visible === false) {
      return null;
    }
    const allAxes = this.groupAxes(this.panes);
    const crossingAxes = anchor.options.vertical ? allAxes.x : allAxes.y;
    const anchorCrossings = this.axisCrossingValues(anchor, crossingAxes);
    const end = position === END;
    const range = anchor.range();
    const edge = end ? range.max : range.min;
    const crossingValue = limitValue(anchorCrossings[axisIndex], range.min, range.max);
    if (crossingValue - edge === 0) {
      return null;
    }
    anchorCrossings.splice(axisIndex + 1, 0, edge);
    anchor.options.axisCrossingValues = anchorCrossings;
    const labelAxis = axis.clone();
    axis.clear();
    labelAxis.options.name = void 0;
    labelAxis.options.line.visible = false;
    labelAxis.options.crosshair = void 0;
    labelAxis.options.notes = void 0;
    labelAxis.options.plotBands = void 0;
    return labelAxis;
  }
  isTrendline(series) {
    return series && inArray(series.type, TRENDLINE_SERIES);
  }
  trendlineFactory() {
  }
  createTrendlineSeries() {
    const modifiedSeries = [];
    this.series = this.series.map((series) => {
      if (!this.isTrendline(series)) {
        return series;
      }
      const forSeries = this.seriesByName(series.for);
      if (!forSeries) {
        throw new Error(`Invalid Configuration: Unable to locate linked series "${series.for}" for trendline "${series.name}".`);
      }
      const valueFields = series_binder_default.current.valueFields(forSeries);
      const field = last(valueFields);
      const trendlineSeries = this.trendlineFactory(Object.assign({}, { field }, series), forSeries);
      if (trendlineSeries) {
        if (forSeries.visible === false) {
          trendlineSeries.visible = false;
        }
        if (trendlineSeries.color === INHERIT) {
          trendlineSeries.color = forSeries.color;
        }
        modifiedSeries.push(trendlineSeries);
      }
      return trendlineSeries;
    }).filter((series) => series !== null);
    return modifiedSeries;
  }
  seriesByName(name) {
    return this.series.find((series) => series.name === name);
  }
  getFirstPoint() {
    for (let i37 = 0; i37 < this.series.length; i37++) {
      const points = this.pointsBySeriesIndex(i37);
      const point = points.find(visiblePoint);
      if (point) {
        return point;
      }
    }
  }
  getPointBelow(point) {
    return this._getNextPoint(point, this._pointsByVertical, 1);
  }
  getPointAbove(point) {
    return this._getNextPoint(point, this._pointsByVertical, -1);
  }
  getPointToTheRight(point) {
    return this._getNextPoint(point, this._pointsByHorizontal, 1);
  }
  getPointToTheLeft(point) {
    return this._getNextPoint(point, this._pointsByHorizontal, -1);
  }
  _getNextPoint(point, getPointsFunc, increment) {
    let points = getPointsFunc.call(this, point).filter(visiblePoint);
    const pointIndex = points.indexOf(point);
    let nextIndex = pointIndex + increment;
    const loopPoints = (direction) => {
      let result;
      let offset = 0;
      do {
        offset += direction;
        result = getPointsFunc.call(this, point, offset).filter(visiblePoint);
      } while (result.length === 0);
      return result;
    };
    if (nextIndex < 0) {
      points = loopPoints(-1);
      return points.at(-1);
    } else if (nextIndex >= points.length) {
      points = loopPoints(1);
      return points.at(0);
    }
    return points[nextIndex];
  }
  _pointsByVertical(basePoint) {
    return this.pointsByPointIndex(basePoint.getIndex());
  }
  _pointsByHorizontal(basePoint, offset = 0) {
    let index = cycleIndex(basePoint.series.index + offset, this.series.length);
    return this.pointsBySeriesIndex(index);
  }
};
function isSingleAxis(axis) {
  return !axis.pane.axes.some(
    (a50) => a50.options.vertical === axis.options.vertical && a50 !== axis && a50.options.visible !== false
  );
}
function axisGroupBox(axes) {
  const length = axes.length;
  let box;
  for (let i37 = 0; i37 < length; i37++) {
    const axis = axes[i37];
    const visible = axis.options.visible !== false;
    if (visible || isSingleAxis(axis)) {
      const axisBox = visible ? axis.contentBox() : axis.lineBox();
      if (!box) {
        box = axisBox.clone();
      } else {
        box.wrap(axisBox);
      }
    }
  }
  return box || new box_default();
}
function paneAnchor(axes, pane) {
  for (let i37 = 0; i37 < axes.length; i37++) {
    const anchor = axes[i37];
    if (anchor && anchor.pane === pane) {
      return anchor;
    }
  }
}
function isTransparent(color) {
  return color === "" || color === null || color === "none" || color === "transparent" || !defined(color);
}
var allPaneAxes = (panes) => panes.reduce((acc, pane) => acc.concat(pane.axes), []);
setDefaultOptions(PlotAreaBase, {
  series: [],
  plotArea: {
    margin: {}
  },
  background: "",
  border: {
    color: BLACK,
    width: 0
  },
  paneDefaults: {
    title: {}
  },
  legend: {
    inactiveItems: {
      labels: {
        color: "#919191"
      },
      markers: {
        color: "#919191"
      }
    }
  }
});
var plotarea_base_default = PlotAreaBase;

// node_modules/@progress/kendo-charts/dist/es/chart/mixins/plotarea-events-mixin.js
var PlotAreaEventsMixin = {
  hover: function(chart, e41) {
    this._dispatchEvent(chart, e41, PLOT_AREA_HOVER);
  },
  click: function(chart, e41) {
    this._dispatchEvent(chart, e41, PLOT_AREA_CLICK);
  }
};
var plotarea_events_mixin_default = PlotAreaEventsMixin;

// node_modules/@progress/kendo-charts/dist/es/chart/aggregates/series-aggregator.js
var SeriesAggregator = class {
  constructor(series, binder, defaultAggregates) {
    const canonicalFields = binder.canonicalFields(series);
    const valueFields = binder.valueFields(series);
    const sourceFields = binder.sourceFields(series, canonicalFields);
    const seriesFields = this._seriesFields = [];
    const defaults = defaultAggregates.query(series.type);
    const rootAggregate = series.aggregate || defaults;
    this._series = series;
    this._binder = binder;
    for (let i37 = 0; i37 < canonicalFields.length; i37++) {
      const field = canonicalFields[i37];
      let fieldAggregate;
      if (isObject(rootAggregate)) {
        fieldAggregate = rootAggregate[field];
      } else if (i37 === 0 || inArray(field, valueFields)) {
        fieldAggregate = rootAggregate;
      } else {
        break;
      }
      if (fieldAggregate) {
        seriesFields.push({
          canonicalName: field,
          name: sourceFields[i37],
          transform: isFunction(fieldAggregate) ? fieldAggregate : aggregates_default[fieldAggregate]
        });
      }
    }
  }
  aggregatePoints(srcPoints, group) {
    const { _series: series, _seriesFields: seriesFields } = this;
    const data = this._bindPoints(srcPoints || []);
    const firstDataItem = data.dataItems[0];
    let result = null;
    if (firstDataItem && !isNumber(firstDataItem) && !isArray(firstDataItem)) {
      const fn = function() {
      };
      fn.prototype = firstDataItem;
      result = new fn();
    }
    for (let i37 = 0; i37 < seriesFields.length; i37++) {
      const field = seriesFields[i37];
      const srcValues = this._bindField(data.values, field.canonicalName);
      const value2 = field.transform(srcValues, series, data.dataItems, group);
      if (value2 !== null && isObject(value2) && value2.length === void 0 && !(value2 instanceof Date)) {
        result = value2;
        break;
      } else {
        if (value2 !== void 0) {
          if (result === null) {
            result = {};
          }
          setValue(field.name, result, value2);
        }
      }
    }
    return result;
  }
  _bindPoints(points) {
    const { _binder: binder, _series: series } = this;
    const values = [];
    const dataItems = [];
    for (let i37 = 0; i37 < points.length; i37++) {
      const pointIx = points[i37];
      values.push(binder.bindPoint(series, pointIx));
      dataItems.push(series.data[pointIx]);
    }
    return {
      values,
      dataItems
    };
  }
  _bindField(data, field) {
    const values = [];
    const count = data.length;
    for (let i37 = 0; i37 < count; i37++) {
      const item = data[i37];
      const valueFields = item.valueFields;
      let value2;
      if (valueFields[field] !== void 0) {
        value2 = valueFields[field];
      } else {
        value2 = item.fields[field];
      }
      values.push(value2);
    }
    return values;
  }
};
function setValue(fieldName, target, value2) {
  let parentObj = target;
  let field = fieldName;
  if (fieldName.indexOf(".") > -1) {
    const parts = fieldName.split(".");
    while (parts.length > 1) {
      field = parts.shift();
      if (parentObj[field] === void 0) {
        parentObj[field] = {};
      }
      parentObj = parentObj[field];
    }
    field = parts.shift();
  }
  parentObj[field] = value2;
}
var series_aggregator_default = SeriesAggregator;

// node_modules/@progress/kendo-charts/dist/es/chart/aggregates/default-aggregates.js
var DefaultAggregates = class {
  constructor() {
    this._defaults = {};
  }
  register(seriesTypes, aggregates) {
    for (let i37 = 0; i37 < seriesTypes.length; i37++) {
      this._defaults[seriesTypes[i37]] = aggregates;
    }
  }
  query(seriesType) {
    return this._defaults[seriesType];
  }
};
DefaultAggregates.current = new DefaultAggregates();
var default_aggregates_default = DefaultAggregates;

// node_modules/@progress/kendo-charts/dist/es/chart/range-bar-chart/range-bar.js
var RangeBar = class extends bar_default {
  createLabel() {
    const labels = this.options.labels;
    const fromOptions = deepExtend({}, labels, labels.from);
    const toOptions = deepExtend({}, labels, labels.to);
    if (fromOptions.visible) {
      this.labelFrom = this.createLabelElement(fromOptions);
      this.append(this.labelFrom);
    }
    if (toOptions.visible) {
      this.labelTo = this.createLabelElement(toOptions);
      this.append(this.labelTo);
    }
  }
  reflow(targetBox) {
    this.render();
    const { labelFrom, labelTo, value: value2 } = this;
    this.box = targetBox;
    if (labelFrom) {
      labelFrom.options.aboveAxis = value2.from > value2.to;
      labelFrom.reflow(targetBox);
    }
    if (labelTo) {
      labelTo.options.aboveAxis = value2.to > value2.from;
      labelTo.reflow(targetBox);
    }
    if (this.note) {
      this.note.reflow(targetBox);
    }
  }
};
RangeBar.prototype.defaults = deepExtend({}, RangeBar.prototype.defaults, {
  labels: {
    format: "{0} - {1}"
  },
  tooltip: {
    format: "{1}"
  }
});
var range_bar_default = RangeBar;

// node_modules/@progress/kendo-charts/dist/es/chart/range-bar-chart/range-bar-chart.js
var RangeBarChart = class extends bar_chart_default {
  pointType() {
    return range_bar_default;
  }
  pointValue(data) {
    return data.valueFields;
  }
  formatPointValue(point, format) {
    if (point.value.from === null && point.value.to === null) {
      return "";
    }
    return this.chartService.format.auto(format, point.value.from, point.value.to);
  }
  plotRange(point) {
    if (!point) {
      return 0;
    }
    return [point.value.from, point.value.to];
  }
  updateRange(value2, fields) {
    const axisName = fields.series.axis;
    const { from, to } = value2;
    let axisRange = this.valueAxisRanges[axisName];
    if (value2 !== null && isNumber(from) && isNumber(to)) {
      axisRange = this.valueAxisRanges[axisName] = axisRange || { min: MAX_VALUE, max: MIN_VALUE };
      axisRange.min = Math.min(axisRange.min, from);
      axisRange.max = Math.max(axisRange.max, from);
      axisRange.min = Math.min(axisRange.min, to);
      axisRange.max = Math.max(axisRange.max, to);
    }
  }
  aboveAxis(point) {
    const value2 = point.value;
    return value2.from < value2.to;
  }
};
RangeBarChart.prototype.plotLimits = categorical_chart_default.prototype.plotLimits;
var range_bar_chart_default = RangeBarChart;

// node_modules/@progress/kendo-charts/dist/es/chart/range-area-chart/range-line-point.js
var RangeLinePoint = class extends line_point_default {
  aliasFor() {
    return this.parent;
  }
};
var range_line_point_default = RangeLinePoint;

// node_modules/@progress/kendo-charts/dist/es/chart/range-area-chart/range-area-point.js
var AUTO2 = "auto";
var DEFAULT_FROM_FORMAT = "{0}";
var DEFAULT_TO_FORMAT = "{1}";
var RangeAreaPoint = class extends chart_element_default {
  constructor(value2, options) {
    super();
    this.value = value2;
    this.options = options;
    this.aboveAxis = valueOrDefault(this.options.aboveAxis, true);
    this.tooltipTracking = true;
    this._id = guid();
    this.initLabelsFormat();
  }
  render() {
    if (this._rendered) {
      return;
    }
    this._rendered = true;
    const { markers, labels } = this.options;
    const value2 = this.value;
    const fromPoint = this.fromPoint = new range_line_point_default(value2, deepExtend({}, this.options, {
      labels: labels.from,
      markers: markers.from
    }));
    const toPoint = this.toPoint = new range_line_point_default(value2, deepExtend({}, this.options, {
      labels: labels.to,
      markers: markers.to
    }));
    this.copyFields(fromPoint);
    this.copyFields(toPoint);
    this.append(fromPoint);
    this.append(toPoint);
  }
  reflow(targetBox) {
    this.render();
    const { from: fromBox, to: toBox } = targetBox;
    this.positionLabels(fromBox, toBox);
    this.fromPoint.reflow(fromBox);
    this.toPoint.reflow(toBox);
    this.box = this.fromPoint.markerBox().clone().wrap(this.toPoint.markerBox());
  }
  createHighlight() {
    const group = new drawing_exports.Group();
    group.append(this.fromPoint.createHighlight());
    group.append(this.toPoint.createHighlight());
    return group;
  }
  highlightVisual() {
    return this.visual;
  }
  highlightVisualArgs() {
    return {
      options: this.options,
      from: this.fromPoint.highlightVisualArgs(),
      to: this.toPoint.highlightVisualArgs()
    };
  }
  createFocusHighlight() {
    const group = new drawing_exports.Group();
    group.append(this.fromPoint.createFocusHighlight());
    group.append(this.toPoint.createFocusHighlight());
    return group;
  }
  tooltipAnchor() {
    const clipBox = this.owner.pane.clipBox();
    const showTooltip = !clipBox || clipBox.overlaps(this.box);
    if (showTooltip) {
      const box = this.box;
      const center = box.center();
      const horizontalAlign = LEFT;
      let x7, y2, verticalAlign;
      if (this.options.vertical) {
        x7 = center.x;
        y2 = box.y1 - TOOLTIP_OFFSET;
        verticalAlign = BOTTOM;
      } else {
        x7 = box.x2 + TOOLTIP_OFFSET;
        y2 = center.y;
        verticalAlign = CENTER;
      }
      return {
        point: new point_default(x7, y2),
        align: {
          horizontal: horizontalAlign,
          vertical: verticalAlign
        }
      };
    }
  }
  formatValue(format) {
    return this.owner.formatPointValue(this, format);
  }
  overlapsBox(box) {
    return this.box.overlaps(box);
  }
  unclipElements() {
    this.fromPoint.unclipElements();
    this.toPoint.unclipElements();
  }
  initLabelsFormat() {
    const labels = this.options.labels;
    if (!labels.format) {
      if (!labels.from || !labels.from.format) {
        labels.from = Object.assign({}, labels.from, {
          format: DEFAULT_FROM_FORMAT
        });
      }
      if (!labels.to || !labels.to.format) {
        labels.to = Object.assign({}, labels.to, {
          format: DEFAULT_TO_FORMAT
        });
      }
    }
  }
  positionLabels(fromBox, toBox) {
    const { labels, vertical } = this.options;
    if (labels.position === AUTO2) {
      let fromLabelPosition, toLabelPosition;
      if (vertical) {
        if (toBox.y1 <= fromBox.y1) {
          toLabelPosition = ABOVE;
          fromLabelPosition = BELOW;
        } else {
          toLabelPosition = BELOW;
          fromLabelPosition = ABOVE;
        }
      } else {
        if (toBox.x1 <= fromBox.x1) {
          toLabelPosition = LEFT;
          fromLabelPosition = RIGHT;
        } else {
          toLabelPosition = RIGHT;
          fromLabelPosition = LEFT;
        }
      }
      if (!labels.from || !labels.from.position) {
        this.fromPoint.options.labels.position = fromLabelPosition;
      }
      if (!labels.to || !labels.to.position) {
        this.toPoint.options.labels.position = toLabelPosition;
      }
    }
  }
  copyFields(point) {
    point.dataItem = this.dataItem;
    point.category = this.category;
    point.series = this.series;
    point.color = this.color;
    point.owner = this.owner;
  }
  focusVisual() {
    this.fromPoint.focusVisual();
  }
  clearFocusFromVisual() {
    this.toPoint.clearFocusFromVisual();
  }
  getIndex() {
    return this.categoryIx;
  }
};
deepExtend(RangeAreaPoint.prototype, point_events_mixin_default);
deepExtend(RangeAreaPoint.prototype, note_mixin_default);
RangeAreaPoint.prototype.defaults = {
  markers: {
    visible: false,
    background: WHITE,
    size: LINE_MARKER_SIZE,
    type: CIRCLE,
    border: {
      width: 2
    },
    opacity: 1
  },
  labels: {
    visible: false,
    margin: getSpacing(3),
    padding: getSpacing(4),
    animation: {
      type: FADEIN,
      delay: INITIAL_ANIMATION_DURATION
    },
    position: AUTO2
  },
  notes: {
    label: {}
  },
  highlight: {
    markers: {
      border: {
        color: WHITE,
        width: 2
      }
    },
    zIndex: HIGHLIGHT_ZINDEX
  },
  tooltip: {
    format: "{0} - {1}"
  },
  accessibility: {
    role: CHART_POINT_ROLE,
    className: CHART_POINT_CLASSNAME,
    ariaRoleDescription: CHART_POINT_ROLE_DESCRIPTION
  }
};
var range_area_point_default = RangeAreaPoint;

// node_modules/@progress/kendo-charts/dist/es/chart/range-area-chart/range-area-segment.js
var RangeAreaSegment = class extends area_segment_default {
  createStrokeSegments() {
    return this.segmentsFromPoints(this.toGeometryPoints(this.toPoints()));
  }
  stackSegments() {
    let fromSegments = this.fromSegments;
    if (!this.fromSegments) {
      fromSegments = this.fromSegments = this.segmentsFromPoints(this.toGeometryPoints(this.fromPoints().reverse()));
    }
    return fromSegments;
  }
  createStroke(style) {
    const toPath = new drawing_exports.Path(style);
    const fromPath = new drawing_exports.Path(style);
    toPath.segments.push.apply(toPath.segments, this.strokeSegments());
    fromPath.segments.push.apply(fromPath.segments, this.stackSegments());
    this.visual.append(toPath);
    this.visual.append(fromPath);
  }
  hasStackSegment() {
    return true;
  }
  fromPoints() {
    return this.linePoints.map((point) => point.fromPoint);
  }
  toPoints() {
    return this.linePoints.map((point) => point.toPoint);
  }
};
var range_area_segment_default = RangeAreaSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/range-area-chart/spline-range-area-segment.js
var SplineRangeAreaSegment = class extends range_area_segment_default {
  createStrokeSegments() {
    return this.createCurveSegments(this.toPoints());
  }
  stackSegments() {
    let fromSegments = this.fromSegments;
    if (!this.fromSegments) {
      fromSegments = this.fromSegments = this.createCurveSegments(this.fromPoints().reverse());
    }
    return fromSegments;
  }
  createCurveSegments(points) {
    const curveProcessor = new curve_processor_default();
    return curveProcessor.process(this.toGeometryPoints(points));
  }
};
var spline_range_area_segment_default = SplineRangeAreaSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/range-area-chart/step-range-area-segment.js
var StepRangeAreaSegment = class extends range_area_segment_default {
  createStrokeSegments() {
    return this.segmentsFromPoints(this.calculateStepPoints(this.toPoints()));
  }
  stackSegments() {
    let fromSegments = this.fromSegments;
    if (!this.fromSegments) {
      fromSegments = this.fromSegments = this.segmentsFromPoints(this.calculateStepPoints(this.fromPoints()));
      fromSegments.reverse();
    }
    return fromSegments;
  }
};
deepExtend(StepRangeAreaSegment.prototype, step_line_mixin_default);
var step_range_area_segment_default = StepRangeAreaSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/range-area-chart/range-area-chart.js
var RangeAreaChart = class extends categorical_chart_default {
  render() {
    super.render();
    this.renderSegments();
  }
  pointType() {
    return range_area_point_default;
  }
  createPoint(data, fields) {
    const { series, seriesIx } = fields;
    let value2 = data.valueFields;
    if (!hasValue(value2.from) && !hasValue(value2.to)) {
      if (this.seriesMissingValues(series) === ZERO) {
        value2 = {
          from: 0,
          to: 0
        };
      } else {
        return null;
      }
    }
    let pointOptions = this.pointOptions(series, seriesIx);
    pointOptions = this.evalPointOptions(pointOptions, value2, fields);
    let color = data.fields.color || series.color;
    if (isFunction(series.color)) {
      color = pointOptions.color;
    }
    const point = new range_area_point_default(value2, pointOptions);
    point.color = color;
    this.append(point);
    return point;
  }
  createSegment(linePoints, currentSeries, seriesIx) {
    const style = (currentSeries.line || {}).style;
    let segmentType;
    if (style === "smooth") {
      segmentType = spline_range_area_segment_default;
    } else if (style === "step") {
      segmentType = step_range_area_segment_default;
    } else {
      segmentType = range_area_segment_default;
    }
    return new segmentType(linePoints, currentSeries, seriesIx);
  }
  plotRange(point, startValue) {
    if (!point) {
      return [startValue, startValue];
    }
    return [point.value.from, point.value.to];
  }
  valueSlot(valueAxis, plotRange) {
    const fromSlot = valueAxis.getSlot(plotRange[0], plotRange[0], !this.options.clip);
    const toSlot = valueAxis.getSlot(plotRange[1], plotRange[1], !this.options.clip);
    if (fromSlot && toSlot) {
      return {
        from: fromSlot,
        to: toSlot
      };
    }
  }
  pointSlot(categorySlot, valueSlot) {
    const { from, to } = valueSlot;
    let fromSlot, toSlot;
    if (this.options.invertAxes) {
      fromSlot = new box_default(from.x1, categorySlot.y1, from.x2, categorySlot.y2);
      toSlot = new box_default(to.x1, categorySlot.y1, to.x2, categorySlot.y2);
    } else {
      fromSlot = new box_default(categorySlot.x1, from.y1, categorySlot.x2, from.y2);
      toSlot = new box_default(categorySlot.x1, to.y1, categorySlot.x2, to.y2);
    }
    return {
      from: fromSlot,
      to: toSlot
    };
  }
  addValue(data, fields) {
    const valueFields = data.valueFields;
    if (!isNumber(valueFields.from)) {
      valueFields.from = valueFields.to;
    }
    if (!isNumber(valueFields.to)) {
      valueFields.to = valueFields.from;
    }
    super.addValue(data, fields);
  }
  updateRange(value2, fields) {
    if (value2 !== null && isNumber(value2.from) && isNumber(value2.to)) {
      const axisName = fields.series.axis;
      const axisRange = this.valueAxisRanges[axisName] = this.valueAxisRanges[axisName] || { min: MAX_VALUE, max: MIN_VALUE };
      const { from, to } = value2;
      axisRange.min = Math.min(axisRange.min, from, to);
      axisRange.max = Math.max(axisRange.max, from, to);
    }
  }
  formatPointValue(point, format) {
    const value2 = point.value;
    return this.chartService.format.auto(format, value2.from, value2.to);
  }
  animationPoints() {
    const points = this.points;
    const result = [];
    for (let idx = 0; idx < points.length; idx++) {
      const point = points[idx];
      if (point) {
        result.push((point.fromPoint || {}).marker);
        result.push((point.toPoint || {}).marker);
      }
    }
    return result.concat(this._segments);
  }
};
deepExtend(RangeAreaChart.prototype, line_chart_mixin_default, clip_animation_mixin_default);
var range_area_chart_default = RangeAreaChart;

// node_modules/@progress/kendo-charts/dist/es/chart/ohlc-chart/ohlc-point.js
var OHLCPoint = class extends candlestick_default {
  reflow(box) {
    const { options, value: value2, owner: chart } = this;
    const valueAxis = chart.seriesValueAxis(options);
    const oPoints = [];
    const cPoints = [];
    const lhPoints = [];
    const lhSlot = valueAxis.getSlot(value2.low, value2.high);
    const oSlot = valueAxis.getSlot(value2.open, value2.open);
    const cSlot = valueAxis.getSlot(value2.close, value2.close);
    oSlot.x1 = cSlot.x1 = lhSlot.x1 = box.x1;
    oSlot.x2 = cSlot.x2 = lhSlot.x2 = box.x2;
    const mid = lhSlot.center().x;
    oPoints.push([oSlot.x1, oSlot.y1]);
    oPoints.push([mid, oSlot.y1]);
    cPoints.push([mid, cSlot.y1]);
    cPoints.push([cSlot.x2, cSlot.y1]);
    lhPoints.push([mid, lhSlot.y1]);
    lhPoints.push([mid, lhSlot.y2]);
    this.lines = [
      oPoints,
      cPoints,
      lhPoints
    ];
    this.box = lhSlot.clone().wrap(oSlot.clone().wrap(cSlot));
    this.reflowNote();
  }
  createBody() {
  }
};
var ohlc_point_default = OHLCPoint;

// node_modules/@progress/kendo-charts/dist/es/chart/ohlc-chart/ohlc-chart.js
var OHLCChart = class extends candlestick_chart_default {
  pointType() {
    return ohlc_point_default;
  }
};
var ohlc_chart_default = OHLCChart;

// node_modules/@progress/kendo-charts/dist/es/chart/waterfall-chart/waterfall-segment.js
var WaterfallSegment = class extends chart_element_default {
  constructor(from, to, series) {
    super();
    this.from = from;
    this.to = to;
    this.series = series;
  }
  linePoints() {
    const from = this.from;
    const { from: { box: fromBox }, to: { box: toBox } } = this;
    const points = [];
    if (from.isVertical) {
      const y2 = from.aboveAxis ? fromBox.y1 : fromBox.y2;
      points.push(
        [fromBox.x1, y2],
        [toBox.x2, y2]
      );
    } else {
      const x7 = from.aboveAxis ? fromBox.x2 : fromBox.x1;
      points.push(
        [x7, fromBox.y1],
        [x7, toBox.y2]
      );
    }
    return points;
  }
  createVisual() {
    super.createVisual();
    const line = this.series.line || {};
    const path = drawing_exports.Path.fromPoints(this.linePoints(), {
      stroke: {
        color: line.color,
        width: line.width,
        opacity: line.opacity,
        dashType: line.dashType
      }
    });
    alignPathToPixel(path);
    this.visual.append(path);
  }
};
setDefaultOptions(WaterfallSegment, {
  animation: {
    type: FADEIN,
    delay: INITIAL_ANIMATION_DURATION
  }
});
var waterfall_segment_default = WaterfallSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/waterfall-chart/waterfall-chart.js
var WaterfallChart = class extends bar_chart_default {
  render() {
    super.render();
    this.createSegments();
  }
  traverseDataPoints(callback) {
    const series = this.options.series;
    const totalCategories = categoriesCount(series);
    const isVertical = !this.options.invertAxes;
    for (let seriesIx = 0; seriesIx < series.length; seriesIx++) {
      const currentSeries = series[seriesIx];
      let total = 0;
      let runningTotal = 0;
      for (let categoryIx = 0; categoryIx < totalCategories; categoryIx++) {
        const data = series_binder_default.current.bindPoint(currentSeries, categoryIx);
        const value2 = data.valueFields.value;
        const summary = data.fields.summary;
        let from = total;
        let to;
        if (summary) {
          if (summary.toLowerCase() === "total") {
            data.valueFields.value = total;
            from = 0;
            to = total;
          } else {
            data.valueFields.value = runningTotal;
            to = from - runningTotal;
            runningTotal = 0;
          }
        } else if (isNumber(value2)) {
          runningTotal += value2;
          total += value2;
          to = total;
        }
        callback(data, {
          category: this.categoryAxis.categoryAt(categoryIx),
          categoryIx,
          series: currentSeries,
          seriesIx,
          total,
          runningTotal,
          from,
          to,
          isVertical
        });
      }
    }
  }
  updateRange(value2, fields) {
    super.updateRange({ value: fields.to }, fields);
  }
  aboveAxis(point) {
    return point.value >= 0;
  }
  plotRange(point) {
    return [point.from, point.to];
  }
  createSegments() {
    const series = this.options.series;
    const seriesPoints = this.seriesPoints;
    const segments = this.segments = [];
    for (let seriesIx = 0; seriesIx < series.length; seriesIx++) {
      const currentSeries = series[seriesIx];
      const points = seriesPoints[seriesIx];
      if (points) {
        let prevPoint;
        for (let pointIx = 0; pointIx < points.length; pointIx++) {
          const point = points[pointIx];
          if (point && prevPoint) {
            const segment = new waterfall_segment_default(prevPoint, point, currentSeries);
            segments.push(segment);
            this.append(segment);
          }
          prevPoint = point;
        }
      }
    }
  }
};
var waterfall_chart_default = WaterfallChart;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/trendline-factory.js
function trendlineFactory(registry2, type, context) {
  const impl = registry2[String(type)];
  if (impl) {
    return impl(context);
  }
  return null;
}
var trendline_factory_default = trendlineFactory;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/calculate-slope.js
function calculateSlope(sourceValues, valueGetter10) {
  let x7 = 0;
  let y2 = 0;
  let x22 = 0;
  let xy = 0;
  let count = 0;
  let slope, intercept;
  let xMin = Number.MAX_VALUE;
  let xMax = Number.MIN_VALUE;
  for (let i37 = 0; i37 < sourceValues.length; i37++) {
    const value2 = sourceValues[i37];
    const { xValue, yValue } = valueGetter10(value2);
    if (isFinite(xValue) && xValue !== null && isFinite(yValue) && yValue !== null) {
      xMin = Math.min(xValue, xMin);
      xMax = Math.max(xValue, xMax);
      count++;
      x7 += xValue;
      y2 += yValue;
      x22 += Math.pow(xValue, 2);
      xy += xValue * yValue;
    }
  }
  if (count > 0) {
    slope = (count * xy - x7 * y2) / (count * x22 - Math.pow(x7, 2));
    intercept = (y2 - slope * x7) / count;
  }
  return { slope, intercept, count, xMin, xMax };
}
var calculate_slope_default = calculateSlope;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/check-all-positive.js
var checkAllPositive = (sourceValues, fieldName) => sourceValues.every(({ valueFields }) => !hasValue(valueFields[fieldName]) || valueFields[fieldName] > 0);
var check_all_positive_default = checkAllPositive;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/get-trendline-data.js
function getTrendlineData(valueMapper, categoryAxis) {
  const data = [];
  const totalRange = categoryAxis.totalRangeIndices();
  const currentRange = categoryAxis.currentRangeIndices();
  const range = {
    min: Math.floor(Math.max(currentRange.min - 1, totalRange.min)),
    max: Math.ceil(Math.min(currentRange.max + 2, totalRange.max))
  };
  for (let i37 = range.min; i37 < range.max; i37++) {
    const x7 = i37 + 1;
    data[i37] = {
      category: categoryAxis.categoryAt(i37, true),
      value: valueMapper(x7)
    };
  }
  return data;
}
var get_trendline_data_default = getTrendlineData;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/exponential-trendline.js
function exponentialTrendline(context) {
  const {
    options,
    categoryAxis,
    seriesValues
  } = context;
  const data = getData({ seriesValues, categoryAxis, options });
  if (data) {
    return Object.assign(
      {},
      options,
      {
        type: "line",
        data,
        categoryField: "category",
        field: "value"
      }
    );
  }
  return null;
}
var valueGetter = (fieldName) => ({ categoryIx, valueFields }) => ({ xValue: categoryIx + 1, yValue: Math.log(valueFields[fieldName]) });
function getData({ seriesValues, categoryAxis, options }) {
  const sourceValues = seriesValues();
  if (!check_all_positive_default(sourceValues, options.field)) {
    return null;
  }
  let { slope, intercept, count } = calculate_slope_default(sourceValues, valueGetter(options.field));
  if (count > 0) {
    const a50 = Math.exp(intercept);
    const b2 = slope;
    return get_trendline_data_default((x7) => a50 * Math.exp(b2 * x7), categoryAxis);
  }
  return null;
}
var exponential_trendline_default = exponentialTrendline;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/linear-trendline.js
function linearTrendline(context) {
  const {
    options,
    categoryAxis,
    seriesValues
  } = context;
  const data = getData2({ seriesValues, categoryAxis, options });
  if (data) {
    return Object.assign(
      {},
      options,
      {
        type: "line",
        data,
        categoryField: "category",
        field: "value"
      }
    );
  }
  return null;
}
var valueGetter2 = (fieldName) => ({ categoryIx, valueFields }) => ({ xValue: categoryIx + 1, yValue: valueFields[fieldName] });
function getData2({ seriesValues, categoryAxis, options }) {
  const { slope, intercept, count } = calculate_slope_default(seriesValues(), valueGetter2(options.field));
  if (count > 0) {
    return get_trendline_data_default((x7) => slope * x7 + intercept, categoryAxis);
  }
  return null;
}
var linear_trendline_default = linearTrendline;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/logarithmic-trendline.js
function logarithmicTrendline(context) {
  const {
    options,
    categoryAxis,
    seriesValues
  } = context;
  const data = getData3({ seriesValues, categoryAxis, options });
  if (data) {
    return Object.assign(
      {},
      options,
      {
        type: "line",
        data,
        categoryField: "category",
        field: "value"
      }
    );
  }
  return null;
}
var valueGetter3 = (fieldName) => ({ categoryIx, valueFields }) => ({ xValue: Math.log(categoryIx + 1), yValue: valueFields[fieldName] });
function getData3({ seriesValues, categoryAxis, options }) {
  let { slope, intercept, count } = calculate_slope_default(seriesValues(), valueGetter3(options.field));
  if (count > 0) {
    const a50 = slope;
    const b2 = intercept;
    return get_trendline_data_default((x7) => a50 * Math.log(x7) + b2, categoryAxis);
  }
  return null;
}
var logarithmic_trendline_default = logarithmicTrendline;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/calculate-moving-average.js
function calculateMovingAverage(sourceValues, valueGetter10, period) {
  const averagePoints = [];
  const values = [];
  const start = Math.max(MIN_MOVING_AVERAGE_PERIOD, period) - 1;
  let end = 0;
  let sum2 = 0;
  for (let i37 = 0; i37 < sourceValues.length; i37++) {
    const value2 = sourceValues[i37];
    const { xValue, yValue } = valueGetter10(value2);
    if (isFinite(yValue) && yValue !== null) {
      values.push(yValue);
      sum2 += yValue;
      end = Math.max(i37, end);
    } else {
      values.push(null);
    }
    if (i37 >= start) {
      const count = values.filter((value3) => value3 !== null).length;
      const lastValue = values.shift() || 0;
      if (count > 0) {
        const average = sum2 / count;
        averagePoints.push([xValue, average]);
        sum2 -= lastValue;
        continue;
      }
    }
    averagePoints.push([xValue, null]);
  }
  return averagePoints.slice(0, end + 1);
}
var calculate_moving_average_default = calculateMovingAverage;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/moving-average.js
function movingAverageTrendline(context) {
  const { options } = context;
  const data = getData4(context);
  if (data) {
    return Object.assign(
      {},
      options,
      {
        type: "line",
        data,
        categoryField: "category",
        field: "value"
      }
    );
  }
  return null;
}
var valueGetter4 = (fieldName) => ({ categoryIx, valueFields }) => ({ xValue: categoryIx, yValue: valueFields[fieldName] });
function calculatePoints({ options, categoryAxis, seriesValues }) {
  const period = (options.trendline || {}).period || MIN_MOVING_AVERAGE_PERIOD;
  const totalRange = categoryAxis.totalRangeIndices();
  const currentRange = categoryAxis.currentRangeIndices();
  const range = {
    min: Math.floor(Math.max(currentRange.min - period, totalRange.min)),
    max: Math.ceil(Math.min(currentRange.max + period + 2, totalRange.max))
  };
  return calculate_moving_average_default(seriesValues(range), valueGetter4(options.field), period);
}
function getData4(context) {
  const { categoryAxis } = context;
  const points = calculatePoints(context);
  const data = [];
  points.forEach(([categoryIx, value2]) => {
    data[categoryIx] = {
      category: categoryAxis.categoryAt(categoryIx, true),
      value: value2
    };
  });
  if (data.length > 0) {
    return data;
  }
  return null;
}
var moving_average_default = movingAverageTrendline;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/calculate-polynomial.js
var MIN_ORDER = 1;
var MAX_ORDER = 6;
function calculatePolynomial(sourceValues, valueGetter10, order) {
  let k2 = Math.min(Math.max(order || MIN_ORDER, MIN_ORDER), MAX_ORDER) + 1;
  let X2 = new matrix_default();
  let Y2 = new matrix_default();
  let count = 0;
  let xMin = Number.MAX_VALUE;
  let xMax = Number.MIN_VALUE;
  let valueMapper = (x7) => x7;
  let coefficients = [];
  for (let i37 = 0; i37 < sourceValues.length; i37++) {
    const value2 = sourceValues[i37];
    let { xValue, yValue } = valueGetter10(value2);
    if (isFinite(xValue) && xValue !== null && isFinite(yValue) && yValue !== null) {
      xMin = Math.min(xValue, xMin);
      xMax = Math.max(xValue, xMax);
      count++;
      Y2.set(i37, 0, yValue);
      X2.set(i37, 0, 1);
      X2.set(i37, 1, xValue);
      for (let pow3 = 2; pow3 <= k2; pow3++) {
        X2.set(i37, pow3, Math.pow(X2.get(i37, 1), pow3));
      }
    } else {
      X2.set(i37, 0, 0);
    }
  }
  X2.width = Math.min(k2, count);
  if (count > 0) {
    coefficients = linearRegression(X2, Y2);
    valueMapper = (x7) => coefficients.reduce((y2, a50, n21) => y2 + a50 * Math.pow(x7, n21), 0);
  }
  return {
    coefficients,
    count,
    valueMapper,
    xMin,
    xMax
  };
}
function linearRegression(X2, Y2) {
  const Xt = X2.transpose();
  const B = Xt.multiply(X2).inverse().multiply(Xt).multiply(Y2);
  const coefficients = [];
  for (let i37 = 0; i37 < B.height; i37++) {
    coefficients.push(B.get(i37, 0));
  }
  return coefficients;
}
var calculate_polynomial_default = calculatePolynomial;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/polynomial-trendline.js
function polynomialTrendline(context) {
  const {
    options,
    categoryAxis,
    seriesValues
  } = context;
  const data = getData5({ seriesValues, categoryAxis, options });
  if (data) {
    return Object.assign(
      {},
      options,
      {
        type: "line",
        data,
        categoryField: "category",
        field: "value"
      }
    );
  }
  return null;
}
var valueGetter5 = (fieldName) => ({ categoryIx, valueFields }) => ({ xValue: categoryIx + 1, yValue: valueFields[fieldName] });
function getData5({ seriesValues, categoryAxis, options }) {
  const order = (options.trendline || {}).order;
  const { count, valueMapper } = calculate_polynomial_default(seriesValues(), valueGetter5(options.field), order);
  if (count > 0) {
    return get_trendline_data_default((x7) => valueMapper(x7), categoryAxis);
  }
  return null;
}
var polynomial_trendline_default = polynomialTrendline;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/power-trendline.js
function powerTrendline(context) {
  const {
    options,
    categoryAxis,
    seriesValues
  } = context;
  const data = getData6({ seriesValues, categoryAxis, options });
  if (data) {
    return Object.assign(
      {},
      options,
      {
        type: "line",
        data,
        categoryField: "category",
        field: "value"
      }
    );
  }
  return null;
}
var valueGetter6 = (fieldName) => ({ categoryIx, valueFields }) => ({ xValue: Math.log(categoryIx + 1), yValue: Math.log(valueFields[fieldName]) });
function getData6({ seriesValues, categoryAxis, options }) {
  const sourceValues = seriesValues();
  if (!check_all_positive_default(sourceValues, options.field)) {
    return null;
  }
  let { slope, intercept, count } = calculate_slope_default(sourceValues, valueGetter6(options.field));
  if (count > 0) {
    const a50 = Math.exp(intercept);
    const b2 = slope;
    return get_trendline_data_default((x7) => a50 * Math.pow(x7, b2), categoryAxis);
  }
  return null;
}
var power_trendline_default = powerTrendline;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/trendline-registry.js
var registry = {};
registry[TRENDLINE_EXPONENTIAL] = exponential_trendline_default;
registry[TRENDLINE_LINEAR] = linear_trendline_default;
registry[TRENDLINE_LOGARITHMIC] = logarithmic_trendline_default;
registry[TRENDLINE_MOVING_AVERAGE] = moving_average_default;
registry[TRENDLINE_POLYNOMIAL] = polynomial_trendline_default;
registry[TRENDLINE_POWER] = power_trendline_default;
var trendline_registry_default = registry;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/categorical-plotarea.js
var AREA_SERIES = [AREA, VERTICAL_AREA, RANGE_AREA, VERTICAL_RANGE_AREA];
var OUT_OF_RANGE_SERIES = [LINE, VERTICAL_LINE].concat(AREA_SERIES);
var CategoricalPlotArea = class extends plotarea_base_default {
  initFields(series) {
    this.namedCategoryAxes = {};
    this.namedValueAxes = {};
    this.valueAxisRangeTracker = new axis_group_range_tracker_default();
    this._seriesPointsCache = {};
    this._currentPointsCache = {};
    if (series.length > 0) {
      this.invertAxes = inArray(
        series[0].type,
        [
          BAR,
          BULLET,
          VERTICAL_LINE,
          VERTICAL_AREA,
          VERTICAL_RANGE_AREA,
          RANGE_BAR,
          HORIZONTAL_WATERFALL,
          VERTICAL_BOX_PLOT
        ]
      );
      for (let i37 = 0; i37 < series.length; i37++) {
        const stack = series[i37].stack;
        if (stack && stack.type === "100%") {
          this.stack100 = true;
          break;
        }
      }
    }
  }
  render(panes = this.panes) {
    this.series = [...this.originalSeries];
    this.createCategoryAxes(panes);
    this.aggregateCategories(panes);
    this.createTrendlineSeries(panes);
    this.createCategoryAxesLabels(panes);
    this.createCharts(panes);
    this.createValueAxes(panes);
  }
  removeAxis(axis) {
    const axisName = axis.options.name;
    super.removeAxis(axis);
    if (axis instanceof category_axis_default) {
      delete this.namedCategoryAxes[axisName];
    } else {
      this.valueAxisRangeTracker.reset(axisName);
      delete this.namedValueAxes[axisName];
    }
    if (axis === this.categoryAxis) {
      delete this.categoryAxis;
    }
    if (axis === this.valueAxis) {
      delete this.valueAxis;
    }
  }
  trendlineFactory(options, series) {
    const categoryAxis = this.seriesCategoryAxis(options);
    const seriesValues = this.seriesValues.bind(this, series.index);
    const trendline = trendline_factory_default(trendline_registry_default, options.type, {
      options,
      categoryAxis,
      seriesValues
    });
    if (trendline) {
      trendline.categoryAxis = series.categoryAxis;
      trendline.valueAxis = series.valueAxis;
      return this.filterSeries(trendline, categoryAxis);
    }
    return trendline;
  }
  trendlineAggregateForecast() {
    return this.series.map((series) => (series.trendline || {}).forecast).filter((forecast) => forecast !== void 0).reduce((result, forecast) => ({
      before: Math.max(result.before, forecast.before || 0),
      after: Math.max(result.after, forecast.after || 0)
    }), { before: 0, after: 0 });
  }
  seriesValues(seriesIx, range) {
    const result = [];
    let series = this.srcSeries[seriesIx];
    const categoryAxis = this.seriesCategoryAxis(series);
    const dateAxis = equalsIgnoreCase(categoryAxis.options.type, DATE);
    if (dateAxis) {
      this._seriesPointsCache = {};
      this._currentPointsCache = {};
      categoryAxis.options.dataItems = [];
      series = this.aggregateSeries(series, categoryAxis, categoryAxis.totalRangeIndices());
    }
    const min4 = range ? range.min : 0;
    const max3 = range ? range.max : series.data.length;
    for (let categoryIx = min4; categoryIx < max3; categoryIx++) {
      const data = this.bindPoint(series, categoryIx);
      result.push({ categoryIx, category: data.fields.category, valueFields: data.valueFields });
    }
    return result;
  }
  createCharts(panes) {
    const seriesByPane = this.groupSeriesByPane();
    for (let i37 = 0; i37 < panes.length; i37++) {
      const pane = panes[i37];
      const paneSeries = seriesByPane[pane.options.name || "default"] || [];
      this.addToLegend(paneSeries);
      const visibleSeries = this.filterVisibleSeries(paneSeries);
      if (!visibleSeries) {
        continue;
      }
      const groups = this.groupSeriesByCategoryAxis(visibleSeries);
      for (let groupIx = 0; groupIx < groups.length; groupIx++) {
        this.createChartGroup(groups[groupIx], pane);
      }
    }
  }
  createChartGroup(series, pane) {
    this.createAreaChart(
      filterSeriesByType(series, [AREA, VERTICAL_AREA]),
      pane
    );
    this.createRangeAreaChart(
      filterSeriesByType(series, [RANGE_AREA, VERTICAL_RANGE_AREA]),
      pane
    );
    this.createBarChart(
      filterSeriesByType(series, [COLUMN, BAR]),
      pane
    );
    this.createRangeBarChart(
      filterSeriesByType(series, [RANGE_COLUMN, RANGE_BAR]),
      pane
    );
    this.createBulletChart(
      filterSeriesByType(series, [BULLET, VERTICAL_BULLET]),
      pane
    );
    this.createCandlestickChart(
      filterSeriesByType(series, CANDLESTICK),
      pane
    );
    this.createBoxPlotChart(
      filterSeriesByType(series, [BOX_PLOT, VERTICAL_BOX_PLOT]),
      pane
    );
    this.createOHLCChart(
      filterSeriesByType(series, OHLC),
      pane
    );
    this.createWaterfallChart(
      filterSeriesByType(series, [WATERFALL, HORIZONTAL_WATERFALL]),
      pane
    );
    this.createLineChart(
      filterSeriesByType(series, [LINE, VERTICAL_LINE]),
      pane
    );
  }
  aggregateCategories(panes) {
    const series = [...this.series];
    const processedSeries = [];
    this._currentPointsCache = {};
    this._seriesPointsCache = this._seriesPointsCache || {};
    for (let i37 = 0; i37 < series.length; i37++) {
      let currentSeries = series[i37];
      if (!this.isTrendline(currentSeries)) {
        const categoryAxis = this.seriesCategoryAxis(currentSeries);
        const axisPane = this.findPane(categoryAxis.options.pane);
        const dateAxis = equalsIgnoreCase(categoryAxis.options.type, DATE);
        if ((dateAxis || currentSeries.categoryField) && inArray(axisPane, panes)) {
          currentSeries = this.aggregateSeries(currentSeries, categoryAxis, categoryAxis.currentRangeIndices());
        } else {
          currentSeries = this.filterSeries(currentSeries, categoryAxis);
        }
      }
      processedSeries.push(currentSeries);
    }
    this._seriesPointsCache = this._currentPointsCache;
    this._currentPointsCache = null;
    this.srcSeries = series;
    this.series = processedSeries;
  }
  filterSeries(series, categoryAxis) {
    const dataLength = (series.data || {}).length;
    categoryAxis._seriesMax = Math.max(categoryAxis._seriesMax || 0, dataLength);
    if (!(defined(categoryAxis.options.min) || defined(categoryAxis.options.max))) {
      return series;
    }
    const range = categoryAxis.currentRangeIndices();
    const outOfRangePoints = inArray(series.type, OUT_OF_RANGE_SERIES);
    const currentSeries = deepExtend({}, series);
    currentSeries.data = (currentSeries.data || []).slice(range.min, range.max + 1);
    if (outOfRangePoints) {
      createOutOfRangePoints(currentSeries, range, dataLength, (idx) => ({
        item: series.data[idx],
        category: categoryAxis.categoryAt(idx, true),
        categoryIx: idx - range.min
      }), (idx) => defined(series.data[idx]));
    }
    return currentSeries;
  }
  clearSeriesPointsCache() {
    this._seriesPointsCache = {};
  }
  seriesSourcePoints(series, categoryAxis) {
    const key = `${series.index};${categoryAxis.categoriesHash()}`;
    if (this._seriesPointsCache && this._seriesPointsCache[key]) {
      this._currentPointsCache[key] = this._seriesPointsCache[key];
      return this._seriesPointsCache[key];
    }
    const axisOptions2 = categoryAxis.options;
    const srcCategories = axisOptions2.srcCategories;
    const dateAxis = equalsIgnoreCase(axisOptions2.type, DATE);
    const srcData = series.data;
    const result = [];
    if (!dateAxis) {
      categoryAxis.indexCategories();
    }
    for (let idx = 0; idx < srcData.length; idx++) {
      let category = series_binder_default.current.bindPoint(series, idx).fields.category;
      if (dateAxis) {
        category = parseDateCategory(category, srcData[idx], this.chartService.intl);
      }
      if (category === void 0) {
        category = srcCategories[idx];
      }
      if (category !== void 0 && category !== null) {
        const categoryIx = categoryAxis.totalIndex(category);
        result[categoryIx] = result[categoryIx] || { items: [], category };
        result[categoryIx].items.push(idx);
      }
    }
    this._currentPointsCache[key] = result;
    return result;
  }
  aggregateSeries(series, categoryAxis, range) {
    const srcData = series.data;
    if (!srcData.length) {
      return series;
    }
    const srcPoints = this.seriesSourcePoints(series, categoryAxis);
    const result = deepExtend({}, series);
    const aggregator = new series_aggregator_default(deepExtend({}, series), series_binder_default.current, default_aggregates_default.current);
    const data = result.data = [];
    const dataItems = categoryAxis.options.dataItems || [];
    const categoryItem = (idx) => {
      const categoryIdx = idx - range.min;
      let point = srcPoints[idx];
      if (!point) {
        point = srcPoints[idx] = {};
      }
      point.categoryIx = categoryIdx;
      if (!point.item) {
        const category = categoryAxis.categoryAt(idx, true);
        point.category = category;
        point.item = aggregator.aggregatePoints(point.items, category);
      }
      return point;
    };
    for (let idx = range.min; idx <= range.max; idx++) {
      const point = categoryItem(idx);
      data[point.categoryIx] = point.item;
      if (point.items && point.items.length) {
        dataItems[point.categoryIx] = point.item;
      }
    }
    if (inArray(result.type, OUT_OF_RANGE_SERIES)) {
      createOutOfRangePoints(result, range, categoryAxis.totalCount(), categoryItem, (idx) => srcPoints[idx]);
    }
    categoryAxis.options.dataItems = dataItems;
    return result;
  }
  appendChart(chart, pane) {
    const series = chart.options.series;
    const categoryAxis = this.seriesCategoryAxis(series[0]);
    let categories = categoryAxis.options.categories;
    let categoriesToAdd = Math.max(0, categoriesCount(series) - categories.length);
    if (categoriesToAdd > 0) {
      categories = categoryAxis.options.categories = categoryAxis.options.categories.slice(0);
      while (categoriesToAdd--) {
        categories.push("");
      }
    }
    this.valueAxisRangeTracker.update(chart.valueAxisRanges);
    super.appendChart(chart, pane);
  }
  // TODO: Refactor, optionally use series.pane option
  seriesPaneName(series) {
    const options = this.options;
    const axisName = series.axis;
    const axisOptions2 = [].concat(options.valueAxis);
    const axis = grep_default(axisOptions2, function(a50) {
      return a50.name === axisName;
    })[0];
    const panes = options.panes || [{}];
    const defaultPaneName = (panes[0] || {}).name || "default";
    const paneName = (axis || {}).pane || defaultPaneName;
    return paneName;
  }
  seriesCategoryAxis(series) {
    const axisName = series.categoryAxis;
    const axis = axisName ? this.namedCategoryAxes[axisName] : this.categoryAxis;
    if (!axis) {
      throw new Error("Unable to locate category axis with name " + axisName);
    }
    return axis;
  }
  stackableChartOptions(series, pane) {
    const anyStackedSeries = series.some((s10) => s10.stack);
    const isStacked100 = series.some((s10) => s10.stack && s10.stack.type === "100%");
    const clip = pane.options.clip;
    return {
      defaultStack: series[0].stack,
      isStacked: anyStackedSeries,
      isStacked100,
      clip
    };
  }
  groupSeriesByCategoryAxis(series) {
    const categoryAxes = [];
    const unique = {};
    for (let idx = 0; idx < series.length; idx++) {
      const name = series[idx].categoryAxis || "$$default$$";
      if (!hasOwnProperty(unique, name)) {
        unique[name] = true;
        categoryAxes.push(name);
      }
    }
    const groups = [];
    for (let axisIx = 0; axisIx < categoryAxes.length; axisIx++) {
      const axis = categoryAxes[axisIx];
      const axisSeries = groupSeries(series, axis, axisIx);
      if (axisSeries.length === 0) {
        continue;
      }
      groups.push(axisSeries);
    }
    return groups;
  }
  createBarChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    const firstSeries = series[0];
    const barChart = new bar_chart_default(this, Object.assign({
      series,
      invertAxes: this.invertAxes,
      gap: firstSeries.gap,
      spacing: firstSeries.spacing
    }, this.stackableChartOptions(series, pane)));
    this.appendChart(barChart, pane);
  }
  createRangeBarChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    const firstSeries = series[0];
    const rangeColumnChart = new range_bar_chart_default(this, {
      series,
      invertAxes: this.invertAxes,
      gap: firstSeries.gap,
      spacing: firstSeries.spacing
    });
    this.appendChart(rangeColumnChart, pane);
  }
  createBulletChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    const firstSeries = series[0];
    const bulletChart = new bullet_chart_default(this, {
      series,
      invertAxes: this.invertAxes,
      gap: firstSeries.gap,
      spacing: firstSeries.spacing,
      clip: pane.options.clip
    });
    this.appendChart(bulletChart, pane);
  }
  createLineChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    const lineChart = new line_chart_default(this, Object.assign({
      invertAxes: this.invertAxes,
      series
    }, this.stackableChartOptions(series, pane)));
    this.appendChart(lineChart, pane);
  }
  createAreaChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    const areaChart = new area_chart_default(this, Object.assign({
      invertAxes: this.invertAxes,
      series
    }, this.stackableChartOptions(series, pane)));
    this.appendChart(areaChart, pane);
  }
  createRangeAreaChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    const rangeAreaChart = new range_area_chart_default(this, {
      invertAxes: this.invertAxes,
      series,
      clip: pane.options.clip
    });
    this.appendChart(rangeAreaChart, pane);
  }
  createOHLCChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    const firstSeries = series[0];
    const chart = new ohlc_chart_default(this, {
      invertAxes: this.invertAxes,
      gap: firstSeries.gap,
      series,
      spacing: firstSeries.spacing,
      clip: pane.options.clip
    });
    this.appendChart(chart, pane);
  }
  createCandlestickChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    const firstSeries = series[0];
    const chart = new candlestick_chart_default(this, {
      invertAxes: this.invertAxes,
      gap: firstSeries.gap,
      series,
      spacing: firstSeries.spacing,
      clip: pane.options.clip
    });
    this.appendChart(chart, pane);
  }
  createBoxPlotChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    const firstSeries = series[0];
    const chart = new box_plot_chart_default(this, {
      invertAxes: this.invertAxes,
      gap: firstSeries.gap,
      series,
      spacing: firstSeries.spacing,
      clip: pane.options.clip
    });
    this.appendChart(chart, pane);
  }
  createWaterfallChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    const firstSeries = series[0];
    const waterfallChart = new waterfall_chart_default(this, {
      series,
      invertAxes: this.invertAxes,
      gap: firstSeries.gap,
      spacing: firstSeries.spacing
    });
    this.appendChart(waterfallChart, pane);
  }
  axisRequiresRounding(categoryAxisName, categoryAxisIndex) {
    const centeredSeries = filterSeriesByType(this.series, EQUALLY_SPACED_SERIES);
    for (let seriesIx = 0; seriesIx < this.series.length; seriesIx++) {
      const currentSeries = this.series[seriesIx];
      if (inArray(currentSeries.type, AREA_SERIES)) {
        const line = currentSeries.line;
        if (line && line.style === STEP) {
          centeredSeries.push(currentSeries);
        }
      }
    }
    for (let seriesIx = 0; seriesIx < centeredSeries.length; seriesIx++) {
      const seriesAxis = centeredSeries[seriesIx].categoryAxis || "";
      if (seriesAxis === categoryAxisName || !seriesAxis && categoryAxisIndex === 0) {
        return true;
      }
    }
  }
  aggregatedAxis(categoryAxisName, categoryAxisIndex) {
    const series = this.series;
    for (let seriesIx = 0; seriesIx < series.length; seriesIx++) {
      const seriesAxis = series[seriesIx].categoryAxis || "";
      if ((seriesAxis === categoryAxisName || !seriesAxis && categoryAxisIndex === 0) && series[seriesIx].categoryField) {
        return true;
      }
    }
  }
  createCategoryAxesLabels() {
    const axes = this.axes;
    for (let i37 = 0; i37 < axes.length; i37++) {
      if (axes[i37] instanceof category_axis_default) {
        axes[i37].createLabels();
      }
    }
  }
  createCategoryAxes(panes) {
    const invertAxes = this.invertAxes;
    const definitions = [].concat(this.options.categoryAxis);
    const axes = [];
    for (let i37 = 0; i37 < definitions.length; i37++) {
      let axisOptions2 = definitions[i37];
      const axisPane = this.findPane(axisOptions2.pane);
      if (inArray(axisPane, panes)) {
        const { name, categories = [] } = axisOptions2;
        axisOptions2 = deepExtend({
          vertical: invertAxes,
          reverse: !invertAxes && this.chartService.rtl,
          axisCrossingValue: invertAxes ? MAX_VALUE : 0
        }, axisOptions2);
        if (!defined(axisOptions2.justified)) {
          axisOptions2.justified = this.isJustified();
        }
        if (this.axisRequiresRounding(name, i37)) {
          axisOptions2.justified = false;
        }
        let categoryAxis;
        if (isDateAxis(axisOptions2, categories[0])) {
          axisOptions2._forecast = this.trendlineAggregateForecast();
          categoryAxis = new date_category_axis_default(axisOptions2, this.chartService);
        } else {
          categoryAxis = new category_axis_default(axisOptions2, this.chartService);
        }
        definitions[i37].categories = categoryAxis.options.srcCategories;
        if (name) {
          if (this.namedCategoryAxes[name]) {
            throw new Error(`Category axis with name ${name} is already defined`);
          }
          this.namedCategoryAxes[name] = categoryAxis;
        }
        categoryAxis.axisIndex = i37;
        axes.push(categoryAxis);
        this.appendAxis(categoryAxis);
      }
    }
    const primaryAxis = this.categoryAxis || axes[0];
    this.categoryAxis = primaryAxis;
    if (invertAxes) {
      this.axisY = primaryAxis;
    } else {
      this.axisX = primaryAxis;
    }
  }
  isJustified() {
    const series = this.series;
    for (let i37 = 0; i37 < series.length; i37++) {
      const currentSeries = series[i37];
      if (!inArray(currentSeries.type, AREA_SERIES)) {
        return false;
      }
    }
    return true;
  }
  createValueAxes(panes) {
    const tracker = this.valueAxisRangeTracker;
    const defaultRange = tracker.query();
    const definitions = [].concat(this.options.valueAxis);
    const invertAxes = this.invertAxes;
    const baseOptions = { vertical: !invertAxes, reverse: invertAxes && this.chartService.rtl };
    const axes = [];
    if (this.stack100) {
      baseOptions.roundToMajorUnit = false;
      baseOptions.labels = { format: "P0" };
    }
    for (let i37 = 0; i37 < definitions.length; i37++) {
      const axisOptions2 = definitions[i37];
      const axisPane = this.findPane(axisOptions2.pane);
      if (inArray(axisPane, panes)) {
        const name = axisOptions2.name;
        const defaultAxisRange = equalsIgnoreCase(axisOptions2.type, LOGARITHMIC) ? { min: 0.1, max: 1 } : { min: 0, max: 1 };
        const range = tracker.query(name) || defaultRange || defaultAxisRange;
        if (i37 === 0 && range && defaultRange) {
          range.min = Math.min(range.min, defaultRange.min);
          range.max = Math.max(range.max, defaultRange.max);
        }
        let axisType;
        if (equalsIgnoreCase(axisOptions2.type, LOGARITHMIC)) {
          axisType = logarithmic_axis_default;
        } else {
          axisType = numeric_axis_default;
        }
        const valueAxis = new axisType(
          range.min,
          range.max,
          deepExtend({}, baseOptions, axisOptions2),
          this.chartService
        );
        if (name) {
          if (this.namedValueAxes[name]) {
            throw new Error(`Value axis with name ${name} is already defined`);
          }
          this.namedValueAxes[name] = valueAxis;
        }
        valueAxis.axisIndex = i37;
        axes.push(valueAxis);
        this.appendAxis(valueAxis);
      }
    }
    const primaryAxis = this.valueAxis || axes[0];
    this.valueAxis = primaryAxis;
    if (invertAxes) {
      this.axisX = primaryAxis;
    } else {
      this.axisY = primaryAxis;
    }
  }
  _dispatchEvent(chart, e41, eventType) {
    const coords = chart._eventCoordinates(e41);
    const point = new point_default(coords.x, coords.y);
    const pane = this.pointPane(point);
    const categories = [];
    const values = [];
    if (!pane) {
      return;
    }
    const allAxes = pane.axes;
    for (let i37 = 0; i37 < allAxes.length; i37++) {
      const axis = allAxes[i37];
      if (axis.getValue) {
        appendIfNotNull(values, axis.getValue(point));
      } else {
        appendIfNotNull(categories, axis.getCategory(point));
      }
    }
    if (categories.length === 0) {
      appendIfNotNull(categories, this.categoryAxis.getCategory(point));
    }
    if (categories.length > 0 && values.length > 0) {
      chart.trigger(eventType, {
        element: eventElement(e41),
        originalEvent: e41,
        category: singleItemOrArray(categories),
        value: singleItemOrArray(values)
      });
    }
  }
  pointPane(point) {
    const panes = this.panes;
    for (let i37 = 0; i37 < panes.length; i37++) {
      const currentPane = panes[i37];
      if (currentPane.contentBox.containsPoint(point)) {
        return currentPane;
      }
    }
  }
  updateAxisOptions(axis, options) {
    updateAxisOptions(this.options, axis, options);
    updateAxisOptions(this.originalOptions, axis, options);
  }
  _pointsByVertical(basePoint, offset = 0) {
    if (this.invertAxes) {
      return this._siblingsBySeriesIndex(basePoint.series.index, offset);
    }
    return this._siblingsByPointIndex(basePoint.getIndex());
  }
  _pointsByHorizontal(basePoint, offset = 0) {
    if (this.invertAxes) {
      return this._siblingsByPointIndex(basePoint.getIndex());
    }
    const siblings = this._siblingsBySeriesIndex(basePoint.series.index, offset);
    if (this.chartService.rtl) {
      return siblings.reverse();
    }
    return siblings;
  }
  _siblingsByPointIndex(pointIndex) {
    const charts = this.charts;
    const result = [];
    for (let i37 = 0; i37 < charts.length; i37++) {
      let chart = charts[i37];
      if (chart.pane && chart.pane.options.name === "_navigator") {
        continue;
      }
      let chartPoints = chart.points.filter(
        (point) => point && point.visible !== false && point.getIndex() === pointIndex
      );
      result.push(...chartPoints.sort(this._getSeriesCompareFn(chartPoints[0])));
    }
    return result;
  }
  _siblingsBySeriesIndex(seriesIndex, offset) {
    const index = cycleIndex(seriesIndex + offset, this.series.length);
    return this.pointsBySeriesIndex(index);
  }
  _getSeriesCompareFn(point) {
    const isStacked = this._isInStackedSeries(point);
    if (isStacked && this.invertAxes || !isStacked && !this.invertAxes) {
      return (a50, b2) => a50.box.center().x - b2.box.center().x;
    }
    return (a50, b2) => a50.box.center().y - b2.box.center().y;
  }
  _isInStackedSeries(point) {
    const sortableSeries = inArray(
      point.series.type,
      [AREA, VERTICAL_AREA, RANGE_AREA, VERTICAL_RANGE_AREA, LINE, VERTICAL_LINE, RADAR_LINE, RADAR_AREA]
    );
    const stackableSeries = inArray(point.series.type, [COLUMN, BAR]);
    return sortableSeries || stackableSeries && point.options.isStacked;
  }
};
function updateAxisOptions(targetOptions, axis, options) {
  const axesOptions = axis instanceof category_axis_default ? [].concat(targetOptions.categoryAxis) : [].concat(targetOptions.valueAxis);
  deepExtend(axesOptions[axis.axisIndex], options);
}
function groupSeries(series, axis, axisIx) {
  return grep_default(series, function(s10) {
    return axisIx === 0 && !s10.categoryAxis || s10.categoryAxis === axis;
  });
}
setDefaultOptions(CategoricalPlotArea, {
  categoryAxis: {},
  valueAxis: {}
});
deepExtend(CategoricalPlotArea.prototype, plotarea_events_mixin_default);
var categorical_plotarea_default = CategoricalPlotArea;

// node_modules/@progress/kendo-charts/dist/es/chart/highlight.js
var Highlight = class {
  constructor() {
    this._points = [];
  }
  destroy() {
    this._points = [];
  }
  show(points, opacity) {
    const arrayPoints = [].concat(points);
    this.hide();
    for (let i37 = 0; i37 < arrayPoints.length; i37++) {
      const point = arrayPoints[i37];
      if (point && point.toggleHighlight && point.hasHighlight()) {
        this.togglePointHighlight(point, true, opacity);
        this._points.push(point);
      }
    }
  }
  togglePointHighlight(point, show2, opacity) {
    const toggleHandler = (point.options.highlight || {}).toggle;
    if (toggleHandler) {
      const eventArgs = {
        category: point.category,
        series: point.series,
        dataItem: point.dataItem,
        value: point.value,
        stackValue: point.stackValue,
        preventDefault: preventDefault3,
        visual: point.highlightVisual(),
        show: show2
      };
      toggleHandler(eventArgs);
      if (!eventArgs._defaultPrevented) {
        point.toggleHighlight(show2, opacity);
      }
    } else {
      point.toggleHighlight(show2, opacity);
    }
  }
  hide() {
    const points = this._points;
    while (points.length) {
      this.togglePointHighlight(points.pop(), false);
    }
  }
  isHighlighted(element) {
    const points = this._points;
    for (let i37 = 0; i37 < points.length; i37++) {
      const point = points[i37];
      if (element === point) {
        return true;
      }
    }
    return false;
  }
};
function preventDefault3() {
  this._defaultPrevented = true;
}
var highlight_default = Highlight;

// node_modules/@progress/kendo-charts/dist/es/chart/pan-and-zoom/accept-key.js
function acceptKey(e41, mouseKey) {
  const key = (mouseKey || "").toLowerCase();
  const event = e41.event;
  const accept = key === "none" && !(event.ctrlKey || event.shiftKey || event.altKey) || event[key + "Key"];
  return accept;
}

// node_modules/@progress/kendo-charts/dist/es/chart/pan-and-zoom/to-chart-axis-ranges.js
function toChartAxisRanges(axisRanges2) {
  const ranges = {};
  for (let idx = 0; idx < axisRanges2.length; idx++) {
    const axisRange = axisRanges2[idx];
    if (axisRange.axis.options.name) {
      ranges[axisRange.axis.options.name] = {
        min: axisRange.range.min,
        max: axisRange.range.max
      };
    }
  }
  return ranges;
}

// node_modules/@progress/kendo-charts/dist/es/chart/pan-and-zoom/pannable.js
var Pannable = class {
  constructor(plotArea, options) {
    this.plotArea = plotArea;
    this.options = deepExtend({}, this.options, options);
  }
  start(e41) {
    this._active = acceptKey(e41, this.options.key);
    return this._active;
  }
  move(e41) {
    if (this._active) {
      const axisRanges2 = this.axisRanges = this._panAxes(e41, X).concat(this._panAxes(e41, Y));
      if (axisRanges2.length) {
        this.axisRanges = axisRanges2;
        return toChartAxisRanges(axisRanges2);
      }
    }
  }
  end() {
    const active = this._active;
    this._active = false;
    return active;
  }
  pan() {
    const { plotArea, axisRanges: axisRanges2 } = this;
    if (axisRanges2.length) {
      for (let idx = 0; idx < axisRanges2.length; idx++) {
        const range = axisRanges2[idx];
        plotArea.updateAxisOptions(range.axis, range.range);
      }
      plotArea.redraw(plotArea.panes);
    }
  }
  destroy() {
    delete this.plotArea;
  }
  _panAxes(e41, position) {
    const plotArea = this.plotArea;
    const delta = -e41[position].delta;
    const lock = (this.options.lock || "").toLowerCase();
    const updatedAxes = [];
    if (delta !== 0 && (lock || "").toLowerCase() !== position) {
      const axes = plotArea.axes;
      for (let idx = 0; idx < axes.length; idx++) {
        const axis = axes[idx];
        if (position === X && !axis.options.vertical || position === Y && axis.options.vertical) {
          const range = axis.pan(delta);
          if (range) {
            range.limitRange = true;
            updatedAxes.push({
              axis,
              range
            });
          }
        }
      }
    }
    return updatedAxes;
  }
};
Pannable.prototype.options = {
  key: "none",
  lock: "none"
};
var pannable_default = Pannable;

// node_modules/@progress/kendo-charts/dist/es/chart/pan-and-zoom/zoom-selection.js
var ZoomSelection = class {
  constructor(chart, options) {
    this.chart = chart;
    this.options = deepExtend({}, this.options, options);
    this.createElement();
  }
  createElement() {
    const marquee = this._marquee = document.createElement("div");
    marquee.className = "k-marquee";
    const marqueeColor = document.createElement("div");
    marqueeColor.className = "k-marquee-color";
    marquee.appendChild(marqueeColor);
  }
  removeElement() {
    if (this._marquee.parentNode) {
      this._marquee.parentNode.removeChild(this._marquee);
    }
  }
  setStyles(styles) {
    elementStyles(this._marquee, styles);
  }
  start(e41) {
    if (acceptKey(e41, this.options.key)) {
      const chart = this.chart;
      const point = chart._eventCoordinates(e41);
      const zoomPane = this._zoomPane = chart._plotArea.paneByPoint(point);
      const clipBox = zoomPane ? zoomPane.chartsBox().clone() : null;
      if (zoomPane && clipBox) {
        const offset = this._elementOffset();
        clipBox.translate(offset.left, offset.top);
        this._zoomPaneClipBox = clipBox;
        document.body.appendChild(this._marquee);
        this.setStyles({
          left: e41.pageX + 1,
          top: e41.pageY + 1,
          width: 0,
          height: 0
        });
        return true;
      }
    }
    return false;
  }
  _elementOffset() {
    const chartElement = this.chart.element;
    const { paddingLeft, paddingTop } = elementStyles(chartElement, ["paddingLeft", "paddingTop"]);
    const offset = elementOffset(chartElement);
    return {
      left: paddingLeft + offset.left,
      top: paddingTop + offset.top
    };
  }
  move(e41) {
    const zoomPane = this._zoomPane;
    if (zoomPane) {
      this.setStyles(this._selectionPosition(e41));
    }
  }
  end(e41) {
    const zoomPane = this._zoomPane;
    if (zoomPane) {
      const elementOffset2 = this._elementOffset();
      const selectionPosition = this._selectionPosition(e41);
      selectionPosition.left -= elementOffset2.left;
      selectionPosition.top -= elementOffset2.top;
      const start = { x: selectionPosition.left, y: selectionPosition.top };
      const end = { x: selectionPosition.left + selectionPosition.width, y: selectionPosition.top + selectionPosition.height };
      this._updateAxisRanges(start, end);
      this.removeElement();
      delete this._zoomPane;
      return toChartAxisRanges(this.axisRanges);
    }
  }
  zoom() {
    const axisRanges2 = this.axisRanges;
    if (axisRanges2 && axisRanges2.length) {
      const plotArea = this.chart._plotArea;
      for (let idx = 0; idx < axisRanges2.length; idx++) {
        const axisRange = axisRanges2[idx];
        plotArea.updateAxisOptions(axisRange.axis, axisRange.range);
      }
      plotArea.redraw(plotArea.panes);
    }
  }
  destroy() {
    this.removeElement();
    delete this._marquee;
    delete this.chart;
  }
  _updateAxisRanges(start, end) {
    const lock = (this.options.lock || "").toLowerCase();
    const axisRanges2 = [];
    const axes = this._zoomPane.axes;
    for (let idx = 0; idx < axes.length; idx++) {
      const axis = axes[idx];
      const vertical = axis.options.vertical;
      if (!(lock === X && !vertical) && !(lock === Y && vertical) && defined(axis.axisIndex)) {
        const range = axis.pointsRange(start, end);
        if (range) {
          axisRanges2.push({
            axis,
            range
          });
        }
      }
    }
    this.axisRanges = axisRanges2;
  }
  _selectionPosition(e41) {
    const clipBox = this._zoomPaneClipBox;
    const startLocation = {
      x: e41.x.startLocation,
      y: e41.y.startLocation
    };
    const { x: { location: pageX }, y: { location: pageY } } = e41;
    const lock = (this.options.lock || "").toLowerCase();
    let left = Math.min(startLocation.x, pageX);
    let top = Math.min(startLocation.y, pageY);
    let width = Math.abs(startLocation.x - pageX);
    let height = Math.abs(startLocation.y - pageY);
    if (lock === X) {
      left = clipBox.x1;
      width = clipBox.width();
    }
    if (lock === Y) {
      top = clipBox.y1;
      height = clipBox.height();
    }
    if (pageX > clipBox.x2) {
      width = clipBox.x2 - startLocation.x;
    }
    if (pageX < clipBox.x1) {
      width = startLocation.x - clipBox.x1;
    }
    if (pageY > clipBox.y2) {
      height = clipBox.y2 - startLocation.y;
    }
    if (pageY < clipBox.y1) {
      height = startLocation.y - clipBox.y1;
    }
    return {
      left: Math.max(left, clipBox.x1),
      top: Math.max(top, clipBox.y1),
      width,
      height
    };
  }
};
ZoomSelection.prototype.options = {
  key: "shift",
  lock: "none"
};
var zoom_selection_default = ZoomSelection;

// node_modules/@progress/kendo-charts/dist/es/chart/pan-and-zoom/mousewheel-zoom.js
var MIN_RATE = 0.01;
var MAX_RATE = 0.9;
var DEFAULT_RATE = 0.3;
var MousewheelZoom = class {
  constructor(chart, options) {
    this.chart = chart;
    this.options = deepExtend({
      rate: DEFAULT_RATE
    }, this.options, options);
  }
  updateRanges(delta, coords) {
    const lock = (this.options.lock || "").toLowerCase();
    const axisRanges2 = [];
    const axes = this.chart._plotArea.axes;
    for (let idx = 0; idx < axes.length; idx++) {
      const axis = axes[idx];
      const vertical = axis.options.vertical;
      if (!(lock === X && !vertical) && !(lock === Y && vertical) && axis.zoomRange) {
        const rate = limitValue(this.options.rate, MIN_RATE, MAX_RATE);
        const range = axis.zoomRange(-delta * rate, coords);
        if (range) {
          axisRanges2.push({
            axis,
            range
          });
        }
      }
    }
    this.axisRanges = axisRanges2;
    return toChartAxisRanges(axisRanges2);
  }
  zoom() {
    const axisRanges2 = this.axisRanges;
    const plotArea = this.chart._plotArea;
    if (axisRanges2 && axisRanges2.length && plotArea.updateAxisOptions) {
      for (let idx = 0; idx < axisRanges2.length; idx++) {
        const axisRange = axisRanges2[idx];
        plotArea.updateAxisOptions(axisRange.axis, axisRange.range);
      }
      plotArea.redraw(plotArea.panes);
    }
  }
  destroy() {
    delete this.chart;
  }
};
var mousewheel_zoom_default = MousewheelZoom;

// node_modules/@progress/kendo-charts/dist/es/chart/legend/legend-layout.js
var alignItems = (rtl) => rtl ? END : START;
var LegendLayout = class extends chart_element_default {
  constructor(options, chartService) {
    super(options);
    this.chartService = chartService;
  }
  render() {
    const { children, options } = this;
    const vertical = options.vertical;
    this.visual = new drawing_exports.Layout(null, {
      spacing: vertical ? 0 : options.spacing,
      lineSpacing: vertical ? options.spacing : 0,
      orientation: vertical ? VERTICAL : HORIZONTAL,
      reverse: options.rtl,
      alignItems: vertical ? alignItems(options.rtl) : CENTER
    });
    for (let idx = 0; idx < children.length; idx++) {
      let legendItem = children[idx];
      legendItem.reflow(new box_default());
      legendItem.renderVisual();
    }
  }
  reflow(box) {
    this.visual.rect(box.toRect());
    this.visual.reflow();
    const bbox = this.visual.clippedBBox();
    if (bbox) {
      this.box = rectToBox(bbox);
    } else {
      this.box = new box_default();
    }
  }
  renderVisual() {
    this.addVisual();
  }
  createVisual() {
  }
};
var legend_layout_default = LegendLayout;

// node_modules/@progress/kendo-charts/dist/es/chart/legend/legend-item-marker.js
var DEFAULT_MARKER_SIZE = 10;
var DEFAULT_MARKER_BORDER_WIDTH = 2;
var LegendItemMarker = class extends shape_element_default {
  visualStyle() {
    const options = this.markerOptions();
    const border = options.border;
    return {
      stroke: {
        width: border.width,
        color: border.color,
        opacity: valueOrDefault(border.opacity, options.opacity),
        dashType: border.dashType
      },
      fill: {
        color: options.background,
        opacity: options.opacity
      },
      cursor: options.cursor
    };
  }
  markerOptions() {
    return this.options;
  }
  markerHighlightOptions() {
    const options = this.markerOptions();
    const borderWidth = options.highlight.border.width;
    return deepExtend(
      {},
      options,
      { background: options.border.color },
      options.highlight,
      options.type === CROSS ? {
        background: options.highlight.border.color,
        border: { color: options.highlight.background, width: borderWidth / 2 },
        width: options.width,
        height: options.height,
        margin: { top: 0, left: 0 }
      } : {}
    );
  }
  createHighlight() {
    const highlight = new shape_element_default(this.markerHighlightOptions());
    const box = this.paddingBox.clone();
    highlight.reflow(box.pad(highlight.options.border.width));
    this.highlight = [highlight.getElement()];
    return this.highlight;
  }
};
setDefaultOptions(LegendItemMarker, {
  border: {
    width: DEFAULT_MARKER_BORDER_WIDTH
  },
  width: DEFAULT_MARKER_SIZE - DEFAULT_MARKER_BORDER_WIDTH,
  height: DEFAULT_MARKER_SIZE - DEFAULT_MARKER_BORDER_WIDTH,
  background: WHITE,
  margin: {
    top: -1,
    left: -1
  },
  vAlign: TOP,
  align: LEFT,
  highlight: {
    width: DEFAULT_MARKER_SIZE,
    height: DEFAULT_MARKER_SIZE,
    border: {
      color: WHITE,
      width: DEFAULT_MARKER_BORDER_WIDTH
    }
  }
});
var legend_item_marker_default = LegendItemMarker;

// node_modules/@progress/kendo-charts/dist/es/chart/legend/legend-item-line-area.js
var MarkerLineArea = class extends shape_element_default {
  getElement() {
    const group = new drawing_exports.Group();
    const element = new drawing_exports.MultiPath(this.visualStyle());
    const { paddingBox: box } = this;
    const halfHeight = box.height() / 2;
    element.moveTo(box.x1, box.y1 + halfHeight).lineTo(box.x1, box.y2).lineTo(box.x2, box.y2);
    group.append(element);
    return group;
  }
};
setDefaultOptions(MarkerLineArea, {
  width: 15,
  height: 15,
  align: RIGHT,
  vAlign: BOTTOM,
  margin: {
    right: -2,
    bottom: 2
  }
});
var legend_item_line_area_default = MarkerLineArea;

// node_modules/@progress/kendo-charts/dist/es/chart/legend/legend-item-line.js
var LegendItemLine = class extends shape_element_default {
  getElement() {
    const group = new drawing_exports.Group();
    const element = new drawing_exports.MultiPath({
      stroke: {
        color: this.options.border.color,
        opacity: this.options.opacity,
        width: this.options.height,
        dashType: this.options.dashType
      }
    });
    const box = this.paddingBox;
    const centerY = box.center().y;
    element.moveTo(box.x1, centerY).lineTo(box.x2, centerY);
    group.append(element);
    return group;
  }
  createHighlight() {
    this.highlight = [this.createHighlightLine(), this.createHighlightMarker()];
    return this.highlight;
  }
  createHighlightLine() {
    const options = deepExtend({}, {
      border: {
        color: this.options.border.color,
        opacity: this.options.border.opacity,
        dashType: this.options.border.dashType
      }
    }, this.options.highlight);
    const highlightLine = new legend_item_line_area_default(options);
    highlightLine.reflow(this.parent.paddingBox.clone());
    this.highlightLine = highlightLine.getElement();
    return this.highlightLine;
  }
  createHighlightMarker() {
    const options = deepExtend({}, {
      background: this.options.background
    }, this.options.highlight.markers);
    const highlightMarker = new shape_element_default(options);
    const paddingBox = this.parent.paddingBox;
    const borderWidth = options.border.width;
    const box = this.parent.box.clone();
    box.pad({
      left: borderWidth - paddingBox.x1,
      top: borderWidth - paddingBox.y1
    });
    highlightMarker.reflow(box);
    this.highlightMarker = highlightMarker.getElement();
    return this.highlightMarker;
  }
};
setDefaultOptions(LegendItemLine, {
  border: {
    width: 0
  },
  type: RECT,
  align: LEFT,
  vAlign: CENTER,
  highlight: {
    border: {
      width: DEFAULT_MARKER_BORDER_WIDTH
    },
    markers: {
      type: CIRCLE,
      width: DEFAULT_MARKER_SIZE,
      height: DEFAULT_MARKER_SIZE,
      border: {
        width: DEFAULT_MARKER_BORDER_WIDTH,
        color: WHITE
      },
      align: LEFT,
      vAlign: TOP
    }
  }
});
var legend_item_line_default = LegendItemLine;

// node_modules/@progress/kendo-charts/dist/es/chart/legend/legend-item-square.js
var LegendItemSquare = class extends shape_element_default {
  createHighlight() {
    const options = deepExtend({}, {
      background: this.options.background
    }, this.options.highlight.markers);
    const highlight = new shape_element_default(options);
    const box = this.paddingBox.clone();
    const targetBox = this.parent.box.clone();
    box.align(targetBox, X, LEFT);
    box.align(targetBox, Y, TOP);
    highlight.reflow(box);
    this.highlight = [highlight.getElement()];
    return this.highlight;
  }
};
setDefaultOptions(LegendItemSquare, {
  highlight: {
    markers: {
      type: CIRCLE,
      width: DEFAULT_MARKER_SIZE,
      height: DEFAULT_MARKER_SIZE,
      border: {
        width: DEFAULT_MARKER_BORDER_WIDTH,
        color: WHITE
      },
      margin: {
        top: -3,
        left: -3
      }
    }
  }
});
var legend_item_square_default = LegendItemSquare;

// node_modules/@progress/kendo-charts/dist/es/chart/legend/legend-item.js
var LegendItem = class extends box_element_default {
  constructor(options) {
    super(options);
    this.createContainer();
    if (!options.rtl) {
      this.createMarker();
      this.createLabel();
    } else {
      this.createLabel();
      this.createMarker();
    }
    this._id = guid();
    this.options.accessibility.ariaChecked = options.active;
  }
  createContainer() {
    this.container = new float_element_default({ vertical: false, wrap: false, align: CENTER, spacing: this.options.spacing });
    this.append(this.container);
  }
  createMarker() {
    this.markerWrap = new box_element_default({ vertical: false, shrinkToFit: true, wrap: false, margin: 1, width: 22, height: 22 });
    this.container.append(this.markerWrap);
    this.createMarkerArea();
    if (this.options.markers.visible) {
      this._marker = this._createMarker();
      this.markerWrap.append(this._marker);
    }
  }
  createMarkerArea() {
    const options = this.options;
    const { markerColor, line = {} } = options;
    const lineOptions = {
      border: {
        color: line.color || markerColor,
        opacity: line.opacity,
        dashType: line.dashType
      }
    };
    return this._createLine(lineOptions) || this._createMarkerLine(lineOptions, line) || this._createSquare();
  }
  markerOptions() {
    const options = this.options;
    const { markers = {}, markerColor } = options;
    const { border = {} } = markers;
    markers.zIndex = void 0;
    return deepExtend({}, markers, {
      border: { color: border.color || markerColor },
      highlight: options.highlight.markers
    });
  }
  _highlightOptions() {
    const options = this.options;
    return deepExtend(
      { markers: { type: options.markers.type } },
      options.highlight
    );
  }
  _createLine(lineOptions) {
    const options = this.options;
    if (options.type === LINE && !options.markers.visible) {
      this._line = new legend_item_line_default(deepExtend({}, {
        background: options.markerColor,
        highlight: this._highlightOptions()
      }, lineOptions, options.line));
      this.markerWrap.append(this._line);
    }
    return this._line;
  }
  _createMarkerLine(lineOptions, line) {
    const options = this.options;
    if (options.type === LINE) {
      this._markerLineArea = new legend_item_line_area_default(deepExtend({}, {
        border: {
          width: line.height
        }
      }, lineOptions));
      this.markerWrap.append(this._markerLineArea);
    }
    return this._markerLineArea;
  }
  _reduceSize(object, prop, factor = 0.6) {
    if (typeof object[prop] === "number") {
      object[prop] = object[prop] * factor;
    }
  }
  _createSquare() {
    const options = this.options;
    if (options.type === AREA) {
      let pattern = options.pattern || (options.series || {}).pattern;
      if (pattern) {
        if (typeof pattern === "function") {
          pattern = pattern(options.series);
        }
        pattern = Object.assign({}, pattern);
        this._reduceSize(pattern, "gap");
        this._reduceSize(pattern, "width");
        this._reduceSize(pattern, "radius");
      }
      this._square = new legend_item_square_default(Object.assign(
        {},
        {
          border: options.border,
          vAlign: options.markers.visible ? BOTTOM : CENTER,
          highlight: this._highlightOptions()
        },
        options.area,
        {
          pattern,
          background: options.area.background || options.markerColor
        }
      ));
      this.markerWrap.append(this._square);
    }
    return this._square;
  }
  _createMarker() {
    return new legend_item_marker_default(this.markerOptions());
  }
  _highlightMarkers() {
    if (this.options.active) {
      this._toggleHighlight(true);
    }
  }
  _restoreMarkers() {
    this._toggleHighlight(false);
  }
  _toggleHighlight(show2) {
    if (!this.options.highlight.visible) {
      return;
    }
    const element = this._marker || this._square || this._line;
    if (element && element === this._line) {
      this._line.visual.visible(!show2);
    }
    if (element) {
      let highlight = element.highlight;
      if (!highlight) {
        highlight = element.createHighlight();
        highlight.forEach((h4) => h4 && this.markerWrap.appendVisual(h4));
      }
      highlight.forEach((h4) => h4 && h4.visible(show2));
    }
  }
  createLabel() {
    const options = this.options;
    const labelOptions = deepExtend({}, options.labels);
    this.container.append(new text_box_default(options.text, labelOptions));
  }
  getAriaLabelText() {
    return this.options.text;
  }
  focusVisual() {
    this.visual.options.set("id", this._id);
    this.toggleFocusHighlight(true);
    this._highlightMarkers();
  }
  clearFocusFromVisual() {
    this.visual.options.set("id", "");
    this.toggleFocusHighlight(false);
    this._restoreMarkers();
  }
  renderComplete() {
    super.renderComplete();
    const cursor = this.options.cursor || {};
    const eventSink = this._itemOverlay = drawing_exports.Path.fromRect(this.container.box.toRect(), {
      fill: {
        color: WHITE,
        opacity: 0
      },
      stroke: null,
      cursor: cursor.style || cursor
    });
    this.appendVisual(eventSink);
  }
  click(widget, e41) {
    const args = this.eventArgs(e41);
    if (!widget.trigger(LEGEND_ITEM_CLICK, args) && e41 && e41.type === "contextmenu") {
      e41.preventDefault();
    }
  }
  over(widget, e41) {
    const args = this.eventArgs(e41);
    if (!widget.trigger(LEGEND_ITEM_HOVER, args)) {
      widget._legendItemHover(args.seriesIndex, args.pointIndex);
      this._highlightMarkers();
    }
    return true;
  }
  out(widget, e41) {
    widget._unsetActivePoint();
    this._restoreMarkers();
    widget.trigger(LEGEND_ITEM_LEAVE, this.eventArgs(e41));
  }
  eventArgs(e41) {
    const options = this.options;
    return {
      element: eventElement(e41),
      text: options.text,
      series: options.series,
      seriesIndex: options.series.index,
      pointIndex: options.pointIndex
    };
  }
  createVisual() {
    super.createVisual();
    const options = this.options;
    if (this.options.visible) {
      const accessibilityOptions = deepExtend({
        ariaLabel: options.accessibility.ariaLabel !== void 0 ? options.accessibility.ariaLabel : options.text
      }, options.accessibility);
      addAccessibilityAttributesToVisual(this.visual, accessibilityOptions);
    }
  }
  renderVisual() {
    const options = this.options;
    const customVisual = options.visual;
    if (customVisual) {
      this.visual = customVisual({
        active: options.active,
        series: options.series,
        sender: this.getSender(),
        pointIndex: options.pointIndex,
        options: {
          type: options.type,
          // Passing the markerColor as a background option for backwards compatibility.
          // Example in jq docs - https://docs.telerik.com/kendo-ui/api/javascript/dataviz/ui/chart/configuration/legend.item#legenditemvisual
          markers: deepExtend({ background: this.options.markerColor }, this.markerOptions()),
          labels: options.labels
        },
        createVisual: () => {
          this.createVisual();
          this.renderChildren();
          this.renderComplete();
          const defaultVisual = this.visual;
          delete this.visual;
          return defaultVisual;
        }
      });
      this._marker = this._markerLineArea = this._square = this._line = null;
      this.addVisual();
    } else {
      super.renderVisual();
    }
  }
  createFocusHighlight(style) {
    const borderWidth = style.stroke.width;
    return drawing_exports.Path.fromRect(this.container.box.pad(borderWidth / 2).toRect(), style);
  }
};
setDefaultOptions(LegendItem, {
  accessibility: {
    role: LEGEND_ITEM_ROLE,
    className: LEGEND_ITEM_CLASSNAME,
    ariaRoleDescription: LEGEND_ITEM_ARIA_ROLE_DESCRIPTION
  },
  markers: {},
  highlight: {
    visible: true,
    markers: {}
  }
});
var legend_item_default = LegendItem;

// node_modules/@progress/kendo-charts/dist/es/chart/legend/legend.js
var CUSTOM = "custom";
var Legend = class extends chart_element_default {
  constructor(options, chartService = {}) {
    super(options);
    this.chartService = chartService;
    if (!inArray(this.options.position, [TOP, RIGHT, BOTTOM, LEFT, CUSTOM])) {
      this.options.position = RIGHT;
    }
    this.createContainers();
    this.createLegendTitle(options.title);
    this.createItems();
  }
  createContainers() {
    const options = this.options;
    const { position, align: userAlign } = options;
    let align = position;
    let vAlign = CENTER;
    if (position === CUSTOM) {
      align = LEFT;
    } else if (inArray(position, [TOP, BOTTOM])) {
      if (userAlign === START) {
        align = LEFT;
      } else if (userAlign === END) {
        align = RIGHT;
      } else {
        align = CENTER;
      }
      vAlign = position;
    } else if (userAlign) {
      if (userAlign === START) {
        vAlign = TOP;
      } else if (userAlign === END) {
        vAlign = BOTTOM;
      }
    }
    this.container = new box_element_default({
      margin: options.margin,
      padding: options.padding,
      background: options.background,
      border: options.border,
      vAlign,
      align,
      zIndex: options.zIndex,
      shrinkToFit: true
    });
    if (this.hasTitle()) {
      this.itemsContainer = new box_element_default({
        vAlign,
        align,
        zIndex: options.zIndex,
        shrinkToFit: true
      });
    } else {
      this.itemsContainer = this.container;
    }
    this.append(this.container);
  }
  createItems() {
    const chartService = this.getService();
    const options = this.options;
    const vertical = this.isVertical();
    const innerElement = new legend_layout_default({
      vertical,
      spacing: options.spacing,
      rtl: chartService.rtl
    }, chartService);
    let data = options.data;
    if (options.reverse) {
      data = data.slice(0).reverse();
    }
    const count = data.length;
    for (let i37 = 0; i37 < count; i37++) {
      let dataItem = data[i37];
      const { markers = {}, dashType, legendItem, opacity } = dataItem.series || {};
      const markersOptions = deepExtend({ visible: markers.visible !== false, type: CIRCLE }, markers);
      delete markersOptions.size;
      const itemOptions = deepExtend(
        {},
        {
          markers: markersOptions,
          labels: options.labels,
          rtl: chartService.rtl,
          line: Object.assign(
            {},
            { dashType },
            options.line
          ),
          area: Object.assign(
            {},
            { opacity },
            options.area
          ),
          opacity,
          accessibility: options.accessibility,
          focusHighlight: options.focusHighlight
        },
        options.item,
        legendItem,
        dataItem,
        { markers: options.markers }
      );
      innerElement.append(new legend_item_default(itemOptions));
    }
    innerElement.render();
    this.itemsContainer.append(innerElement);
  }
  isVertical() {
    const { orientation, position } = this.options;
    const vertical = position === CUSTOM && orientation !== HORIZONTAL || (defined(orientation) ? orientation !== HORIZONTAL : inArray(position, [LEFT, RIGHT]));
    return vertical;
  }
  hasItems() {
    return this.container.children[0].children.length > 0;
  }
  getItems() {
    return this.itemsContainer.children[0].children;
  }
  reflow(targetBox) {
    const options = this.options;
    const legendBox = targetBox.clone();
    if (!this.hasItems()) {
      this.box = legendBox;
      return;
    }
    if (options.position === CUSTOM) {
      this.containerCustomReflow(legendBox);
      this.box = legendBox;
    } else {
      this.containerReflow(legendBox);
    }
    if (this.hasTitle()) {
      this.title.reflow(new box_default(this.container.box.x1, this.title.box.y1, this.container.box.x2, this.title.box.y2));
    }
  }
  containerReflow(targetBox) {
    const { options, container } = this;
    const { position, width, height } = options;
    const pos = position === TOP || position === BOTTOM ? X : Y;
    const vertical = this.isVertical();
    const alignTarget = targetBox.clone();
    let containerBox = targetBox.clone();
    if (position === LEFT || position === RIGHT) {
      containerBox.y1 = alignTarget.y1 = 0;
    }
    if (vertical && height) {
      containerBox.y2 = containerBox.y1 + height;
      containerBox.align(alignTarget, Y, container.options.vAlign);
    } else if (!vertical && width) {
      containerBox.x2 = containerBox.x1 + width;
      containerBox.align(alignTarget, X, container.options.align);
    }
    container.reflow(containerBox);
    containerBox = container.box;
    const box = containerBox.clone();
    if (options.offsetX || options.offsetY) {
      containerBox.translate(options.offsetX, options.offsetY);
      container.reflow(containerBox);
    }
    box[pos + 1] = targetBox[pos + 1];
    box[pos + 2] = targetBox[pos + 2];
    this.box = box;
  }
  containerCustomReflow(targetBox) {
    const { options, container } = this;
    const { offsetX, offsetY, width, height } = options;
    const vertical = this.isVertical();
    let containerBox = targetBox.clone();
    if (vertical && height) {
      containerBox.y2 = containerBox.y1 + height;
    } else if (!vertical && width) {
      containerBox.x2 = containerBox.x1 + width;
    }
    container.reflow(containerBox);
    containerBox = container.box;
    container.reflow(new box_default(
      offsetX,
      offsetY,
      offsetX + containerBox.width(),
      offsetY + containerBox.height()
    ));
  }
  renderVisual() {
    if (this.hasItems()) {
      super.renderVisual();
    }
  }
  createLegendTitle(title3) {
    let titleOptions = deepExtend({}, {
      color: BLACK,
      position: TOP,
      align: CENTER
    }, title3);
    let text = titleOptions.text;
    if (!title3 || title3.visible === false || !title3.text) {
      return;
    }
    if (defined(titleOptions) && titleOptions.visible) {
      const labelTemplate = getTemplate(titleOptions);
      if (labelTemplate) {
        text = labelTemplate({ text });
      } else if (titleOptions.format) {
        text = this.chartService.format.auto(titleOptions.format, text);
      }
    }
    this.title = new text_box_default(text, titleOptions);
    this.createTitleLayout();
    this.appendTitleLayoutContent();
  }
  createTitleLayout() {
    this.layout = new float_element_default({
      vertical: true,
      wrap: false
    });
    this.container.append(this.layout);
  }
  hasTitle() {
    return Boolean(this.options.title && this.options.title.visible !== false && this.options.title.text);
  }
  appendTitleLayoutContent() {
    const options = this.options;
    if (options.title.position === BOTTOM) {
      this.layout.append(this.itemsContainer);
      this.layout.append(this.title);
    } else {
      this.layout.append(this.title);
      this.layout.append(this.itemsContainer);
    }
  }
};
setDefaultOptions(Legend, {
  position: RIGHT,
  data: [],
  offsetX: 0,
  offsetY: 0,
  margin: getSpacing(2),
  padding: getSpacing(5),
  border: {
    color: BLACK,
    width: 0
  },
  item: {
    cursor: POINTER,
    spacing: 6
  },
  spacing: 6,
  background: "",
  zIndex: 1,
  markers: {},
  line: {
    width: 20,
    height: 2,
    cursor: POINTER,
    opacity: 1
  },
  area: {
    type: SQUARE,
    align: RIGHT,
    width: 15,
    height: 15
  }
});
var legend_default = Legend;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/plotarea-factory.js
var PlotAreaFactory = class {
  constructor() {
    this._registry = [];
  }
  register(type, seriesTypes) {
    this._registry.push({
      type,
      seriesTypes
    });
  }
  create(srcSeries, options, chartService) {
    const registry2 = this._registry;
    let match = registry2[0];
    let series;
    for (let idx = 0; idx < registry2.length; idx++) {
      const entry = registry2[idx];
      series = filterSeriesByType(srcSeries, entry.seriesTypes);
      const trendlines = filterSeriesByType(srcSeries, TRENDLINE_SERIES);
      if (series.length - trendlines.length > 0) {
        match = entry;
        break;
      }
    }
    return new match.type(series, options, chartService);
  }
};
PlotAreaFactory.current = new PlotAreaFactory();
var plotarea_factory_default = PlotAreaFactory;

// node_modules/@progress/kendo-charts/dist/es/chart/selection.js
var ZOOM_ACCELERATION = 3;
var SELECTOR_HEIGHT_ADJUST = 0.1;
function createDiv(classNames) {
  const element = document.createElement("div");
  if (classNames) {
    element.className = classNames;
  }
  return element;
}
function closestHandle(element) {
  let current4 = element;
  while (current4 && !hasClasses(current4, "k-handle")) {
    current4 = current4.parentNode;
  }
  return current4;
}
var Selection = class {
  constructor(chart, categoryAxis, options, observer) {
    const chartElement = chart.element;
    this.options = deepExtend({}, this.options, options);
    this.chart = chart;
    this.observer = observer;
    this.chartElement = chartElement;
    this.categoryAxis = categoryAxis;
    this._dateAxis = this.categoryAxis instanceof date_category_axis_default;
    this.initOptions();
    this.visible = this.options.visible && chartElement.offsetHeight;
    if (this.visible) {
      this.createElements();
      this.set(this._index(this.options.from), this._index(this.options.to));
      this.bindEvents();
    }
  }
  onPane(pane) {
    return this.categoryAxis.pane === pane;
  }
  createElements() {
    const options = this.options;
    const wrapper = this.wrapper = createDiv("k-selector k-pointer-events-none");
    elementStyles(wrapper, {
      top: options.offset.top,
      left: options.offset.left,
      width: options.width,
      height: options.height,
      direction: "ltr"
    });
    const selection = this.selection = createDiv("k-selection k-pointer-events-none");
    this.leftMask = createDiv("k-mask k-pointer-events-none");
    this.rightMask = createDiv("k-mask k-pointer-events-none");
    wrapper.appendChild(this.leftMask);
    wrapper.appendChild(this.rightMask);
    wrapper.appendChild(selection);
    const body = this.body = createDiv("k-selection-bg k-pointer-events-none");
    selection.appendChild(body);
    const leftHandle = this.leftHandle = createDiv("k-handle k-left-handle k-pointer-events-auto");
    const rightHandle = this.rightHandle = createDiv("k-handle k-right-handle k-pointer-events-auto");
    leftHandle.appendChild(createDiv());
    rightHandle.appendChild(createDiv());
    selection.appendChild(leftHandle);
    selection.appendChild(rightHandle);
    this.chartElement.appendChild(wrapper);
    const selectionStyles = elementStyles(selection, ["borderLeftWidth", "borderRightWidth", "height"]);
    const leftHandleHeight = elementStyles(leftHandle, "height").height;
    const rightHandleHeight = elementStyles(rightHandle, "height").height;
    options.selection = {
      border: {
        left: selectionStyles.borderLeftWidth,
        right: selectionStyles.borderRightWidth
      }
    };
    elementStyles(leftHandle, {
      top: (selectionStyles.height - leftHandleHeight) / 2
    });
    elementStyles(rightHandle, {
      top: (selectionStyles.height - rightHandleHeight) / 2
    });
    wrapper.style.cssText = wrapper.style.cssText;
  }
  bindEvents() {
    if (this.options.mousewheel !== false) {
      this._mousewheelHandler = this._mousewheel.bind(this);
      bindEvents(this.chartElement, {
        [MOUSEWHEEL]: this._mousewheelHandler
      });
    }
    this._domEvents = dom_events_builder_default.create(this.chartElement, {
      stopPropagation: true,
      // applicable for the jQuery UserEvents
      start: this._start.bind(this),
      move: this._move.bind(this),
      end: this._end.bind(this),
      tap: this._tap.bind(this),
      press: this._press.bind(this),
      gesturestart: this._gesturestart.bind(this),
      gesturechange: this._gesturechange.bind(this),
      gestureend: this._gestureend.bind(this)
    });
  }
  initOptions() {
    const { options, categoryAxis } = this;
    const box = categoryAxis.pane.chartsBox();
    const intlService = this.chart.chartService.intl;
    if (this._dateAxis) {
      deepExtend(options, {
        min: parseDate(intlService, options.min),
        max: parseDate(intlService, options.max),
        from: parseDate(intlService, options.from),
        to: parseDate(intlService, options.to)
      });
    }
    const { paddingLeft, paddingTop } = elementStyles(this.chartElement, ["paddingLeft", "paddingTop"]);
    this.options = deepExtend({}, {
      width: box.width(),
      height: box.height() + SELECTOR_HEIGHT_ADJUST,
      //workaround for sub-pixel hover on the paths in chrome
      padding: {
        left: paddingLeft,
        top: paddingTop
      },
      offset: {
        left: box.x1 + paddingLeft,
        top: box.y1 + paddingTop
      },
      from: options.min,
      to: options.max
    }, options);
  }
  destroy() {
    if (this._domEvents) {
      this._domEvents.destroy();
      delete this._domEvents;
    }
    clearTimeout(this._mwTimeout);
    this._state = null;
    if (this.wrapper) {
      if (this._mousewheelHandler) {
        unbindEvents(this.chartElement, {
          [MOUSEWHEEL]: this._mousewheelHandler
        });
        this._mousewheelHandler = null;
      }
      this.chartElement.removeChild(this.wrapper);
      this.wrapper = null;
    }
  }
  _rangeEventArgs(range) {
    return {
      axis: this.categoryAxis.options,
      from: this._value(range.from),
      to: this._value(range.to)
    };
  }
  _pointInPane(x7, y2) {
    const paneBox = this.categoryAxis.pane.box;
    const modelCoords = this.chart._toModelCoordinates(x7, y2);
    return paneBox.containsPoint(modelCoords);
  }
  _start(e41) {
    const options = this.options;
    const target = eventElement(e41);
    if (this._state || !target) {
      return;
    }
    const coords = eventCoordinates(e41);
    const inPane = this._pointInPane(coords.x, coords.y);
    if (!inPane) {
      return;
    }
    const handle = closestHandle(target);
    const bodyRect = this.body.getBoundingClientRect();
    const inBody = !handle && coords.x >= bodyRect.x && coords.x <= bodyRect.x + bodyRect.width && coords.y >= bodyRect.y && coords.y <= bodyRect.y + bodyRect.height;
    this.chart._unsetActivePoint();
    this._state = {
      moveTarget: handle,
      startLocation: e41.x ? e41.x.location : 0,
      inBody,
      range: {
        from: this._index(options.from),
        to: this._index(options.to)
      }
    };
    const args = this._rangeEventArgs({
      from: this._index(options.from),
      to: this._index(options.to)
    });
    if (this.trigger(SELECT_START, args)) {
      this._state = null;
    }
  }
  _press(e41) {
    let handle;
    if (this._state) {
      handle = this._state.moveTarget;
    } else {
      handle = closestHandle(eventElement(e41));
    }
    if (handle) {
      addClass(handle, "k-handle-active");
    }
  }
  _move(e41) {
    if (!this._state) {
      return;
    }
    const { _state: state, options, categoryAxis } = this;
    const { range, moveTarget: target } = state;
    const reverse = categoryAxis.options.reverse;
    const from = this._index(options.from);
    const to = this._index(options.to);
    const min4 = this._index(options.min);
    const max3 = this._index(options.max);
    const delta = state.startLocation - e41.x.location;
    const oldRange = { from: range.from, to: range.to };
    const span = range.to - range.from;
    const scale = elementStyles(this.wrapper, "width").width / (categoryAxis.categoriesCount() - 1);
    const offset = Math.round(delta / scale) * (reverse ? -1 : 1);
    if (!target && !state.inBody) {
      return;
    }
    const leftHandle = target && hasClasses(target, "k-left-handle");
    const rightHandle = target && hasClasses(target, "k-right-handle");
    if (state.inBody) {
      range.from = Math.min(
        Math.max(min4, from - offset),
        max3 - span
      );
      range.to = Math.min(
        range.from + span,
        max3
      );
    } else if (leftHandle && !reverse || rightHandle && reverse) {
      range.from = Math.min(
        Math.max(min4, from - offset),
        max3 - 1
      );
      range.to = Math.max(range.from + 1, range.to);
    } else if (leftHandle && reverse || rightHandle && !reverse) {
      range.to = Math.min(
        Math.max(min4 + 1, to - offset),
        max3
      );
      range.from = Math.min(range.to - 1, range.from);
    }
    if (range.from !== oldRange.from || range.to !== oldRange.to) {
      this.move(range.from, range.to);
      this.trigger(SELECT2, this._rangeEventArgs(range));
    }
  }
  _end() {
    if (this._state) {
      const moveTarget = this._state.moveTarget;
      if (moveTarget) {
        removeClass(moveTarget, "k-handle-active");
      }
      const range = this._state.range;
      this.set(range.from, range.to);
      this.trigger(SELECT_END, this._rangeEventArgs(range));
      delete this._state;
    }
  }
  _tap(e41) {
    const { options, categoryAxis } = this;
    const coords = this.chart._eventCoordinates(e41);
    const categoryIx = categoryAxis.pointCategoryIndex(new point_default(coords.x, categoryAxis.box.y1));
    const from = this._index(options.from);
    const to = this._index(options.to);
    const min4 = this._index(options.min);
    const max3 = this._index(options.max);
    const span = to - from;
    const mid = from + span / 2;
    const range = {};
    const rightClick = e41.event.which === 3;
    let offset = Math.round(mid - categoryIx);
    if (this._state || rightClick) {
      return;
    }
    this.chart._unsetActivePoint();
    if (!categoryAxis.options.justified) {
      offset--;
    }
    range.from = Math.min(
      Math.max(min4, from - offset),
      max3 - span
    );
    range.to = Math.min(range.from + span, max3);
    this._start(e41);
    if (this._state) {
      this._state.range = range;
      this.trigger(SELECT2, this._rangeEventArgs(range));
      this._end();
    }
  }
  _mousewheel(e41) {
    let delta = mousewheelDelta(e41);
    this._start(e41);
    if (this._state) {
      const range = this._state.range;
      e41.preventDefault();
      e41.stopPropagation();
      if (Math.abs(delta) > 1) {
        delta *= ZOOM_ACCELERATION;
      }
      if (this.options.mousewheel.reverse) {
        delta *= -1;
      }
      if (this.expand(delta)) {
        this.trigger(SELECT2, {
          axis: this.categoryAxis.options,
          delta,
          originalEvent: e41,
          from: this._value(range.from),
          to: this._value(range.to)
        });
      }
      if (this._mwTimeout) {
        clearTimeout(this._mwTimeout);
      }
      this._mwTimeout = setTimeout(() => {
        this._end();
      }, MOUSEWHEEL_DELAY);
    }
  }
  _gesturestart(e41) {
    const options = this.options;
    const touch = e41.touches[0];
    const inPane = this._pointInPane(touch.pageX, touch.pageY);
    if (!inPane) {
      return;
    }
    this._state = {
      range: {
        from: this._index(options.from),
        to: this._index(options.to)
      }
    };
    const args = this._rangeEventArgs(this._state.range);
    if (this.trigger(SELECT_START, args)) {
      this._state = null;
    } else {
      e41.preventDefault();
    }
  }
  _gestureend() {
    if (this._state) {
      this.trigger(SELECT_END, this._rangeEventArgs(this._state.range));
      delete this._state;
    }
  }
  _gesturechange(e41) {
    if (!this._state) {
      return;
    }
    const { chart, _state: state, options, categoryAxis } = this;
    const range = state.range;
    const p0 = chart._toModelCoordinates(e41.touches[0].x.location).x;
    const p1 = chart._toModelCoordinates(e41.touches[1].x.location).x;
    const left = Math.min(p0, p1);
    const right = Math.max(p0, p1);
    e41.preventDefault();
    range.from = categoryAxis.pointCategoryIndex(new point_default(left)) || options.min;
    range.to = categoryAxis.pointCategoryIndex(new point_default(right)) || options.max;
    this.move(range.from, range.to);
    this.trigger(SELECT2, this._rangeEventArgs(range));
  }
  _index(value2) {
    let index = value2;
    if (value2 instanceof Date) {
      index = this.categoryAxis.categoryIndex(value2);
    }
    return index;
  }
  _value(index) {
    let value2 = index;
    if (this._dateAxis) {
      value2 = this.categoryAxis.categoryAt(index);
      if (value2 > this.options.max) {
        value2 = this.options.max;
      }
    }
    return value2;
  }
  _slot(value2) {
    const categoryAxis = this.categoryAxis;
    const index = this._index(value2);
    return categoryAxis.getSlot(index, index, true);
  }
  move(from, to) {
    const options = this.options;
    const reverse = this.categoryAxis.options.reverse;
    const { offset, padding, selection: { border } } = options;
    const left = reverse ? to : from;
    const right = reverse ? from : to;
    const edge = "x" + (reverse ? 2 : 1);
    let box = this._slot(left);
    const leftMaskWidth = round(box[edge] - offset.left + padding.left);
    elementStyles(this.leftMask, {
      width: leftMaskWidth
    });
    elementStyles(this.selection, {
      left: leftMaskWidth
    });
    box = this._slot(right);
    const rightMaskWidth = round(options.width - (box[edge] - offset.left + padding.left));
    elementStyles(this.rightMask, {
      width: rightMaskWidth
    });
    let distance = options.width - rightMaskWidth;
    if (distance !== options.width) {
      distance += border.right;
    }
    elementStyles(this.rightMask, {
      left: distance
    });
    elementStyles(this.selection, {
      width: Math.max(options.width - (leftMaskWidth + rightMaskWidth) - border.right, 0)
    });
  }
  set(from, to) {
    const options = this.options;
    const min4 = this._index(options.min);
    const max3 = this._index(options.max);
    const fromValue = limitValue(this._index(from), min4, max3);
    const toValue = limitValue(this._index(to), fromValue + 1, max3);
    if (options.visible) {
      this.move(fromValue, toValue);
    }
    options.from = this._value(fromValue);
    options.to = this._value(toValue);
  }
  expand(delta) {
    const options = this.options;
    const min4 = this._index(options.min);
    const max3 = this._index(options.max);
    const zDir = options.mousewheel.zoom;
    const from = this._index(options.from);
    const to = this._index(options.to);
    let range = { from, to };
    const oldRange = deepExtend({}, range);
    if (this._state) {
      range = this._state.range;
    }
    if (zDir !== RIGHT) {
      range.from = limitValue(
        limitValue(from - delta, 0, to - 1),
        min4,
        max3
      );
    }
    if (zDir !== LEFT) {
      range.to = limitValue(
        limitValue(to + delta, range.from + 1, max3),
        min4,
        max3
      );
    }
    if (range.from !== oldRange.from || range.to !== oldRange.to) {
      this.set(range.from, range.to);
      return true;
    }
  }
  zoom(delta, coords) {
    const options = this.options;
    const min4 = this._index(options.min);
    const max3 = this._index(options.max);
    const from = this._index(options.from);
    const to = this._index(options.to);
    let range = { from, to };
    const oldRange = deepExtend({}, range);
    const { reverse } = this.categoryAxis.options;
    const origin = X + (reverse ? "2" : "1");
    const lineBox = this.categoryAxis.lineBox();
    const relative = Math.abs(lineBox[origin] - coords[X]);
    const size = lineBox.width();
    const position = round(relative / size, 2);
    const minDelta = round(position * delta);
    const maxDelta = round((1 - position) * delta);
    if (this._state) {
      range = this._state.range;
    }
    range.from = limitValue(
      limitValue(from - minDelta, 0, to - 1),
      min4,
      max3
    );
    range.to = limitValue(
      limitValue(to + maxDelta, range.from + 1, max3),
      min4,
      max3
    );
    if (range.from !== oldRange.from || range.to !== oldRange.to) {
      this.set(range.from, range.to);
      return true;
    }
  }
  trigger(name, args) {
    return (this.observer || this.chart).trigger(name, args);
  }
};
setDefaultOptions(Selection, {
  visible: true,
  mousewheel: {
    zoom: "both"
  },
  min: MIN_VALUE,
  max: MAX_VALUE
});
var selection_default = Selection;

// node_modules/@progress/kendo-charts/dist/es/chart/tooltip/tooltip.js
var Tooltip = class extends base_tooltip_default {
  show(point) {
    if (!point || !point.tooltipAnchor || this._current && this._current === point) {
      return;
    }
    const options = deepExtend({}, this.options, point.options.tooltip);
    const anchor = point.tooltipAnchor();
    if (anchor) {
      this._current = point;
      super.show({
        point,
        anchor
      }, options, point);
    } else {
      this.hide();
    }
  }
  hide() {
    delete this._current;
    super.hide();
  }
};
var tooltip_default = Tooltip;

// node_modules/@progress/kendo-charts/dist/es/chart/tooltip/shared-tooltip.js
var SharedTooltip = class extends base_tooltip_default {
  constructor(plotArea, options) {
    super(plotArea.chartService, options);
    this.plotArea = plotArea;
    this.formatService = plotArea.chartService.format;
  }
  showAt(points, coords) {
    const tooltipPoints = grep_default(points, function(point) {
      const tooltip = point.series.tooltip;
      const excluded = tooltip && tooltip.visible === false;
      return !excluded;
    });
    if (tooltipPoints.length > 0) {
      const point = tooltipPoints[0];
      const slot = this.plotArea.categoryAxis.getSlot(point.categoryIx);
      const anchor = coords ? this._slotAnchor(coords, slot) : this._defaultAnchor(point, slot);
      this.show({
        anchor,
        shared: true,
        points,
        category: point.category,
        categoryText: this.formatService.auto(this.options.categoryFormat, point.category),
        series: this.plotArea.series
      }, this.options);
    }
  }
  _slotAnchor(point, slot) {
    const axis = this.plotArea.categoryAxis;
    const align = {
      horizontal: "left",
      vertical: "center"
    };
    if (!axis.options.vertical) {
      point.x = slot.center().x;
    }
    return {
      point,
      align
    };
  }
  _defaultAnchor(point, slot) {
    const box = point.owner.pane.chartsBox();
    const vertical = this.plotArea.categoryAxis.options.vertical;
    const center = box.center();
    const slotCenter = slot.center();
    const align = {
      horizontal: "center",
      vertical: "center"
    };
    let centerPoint;
    if (vertical) {
      centerPoint = new point_default(center.x, slotCenter.y);
    } else {
      centerPoint = new point_default(slotCenter.x, center.y);
    }
    return {
      point: centerPoint,
      align
    };
  }
};
setDefaultOptions(SharedTooltip, {
  categoryFormat: "{0:d}"
});
var shared_tooltip_default = SharedTooltip;

// node_modules/@progress/kendo-charts/dist/es/chart/animations/bar-chart-animation.js
var BarChartAnimation = class extends drawing_exports.Animation {
  setup() {
    const { element, options } = this;
    const bbox = element.bbox();
    if (bbox) {
      this.origin = options.origin;
      const axis = options.vertical ? Y : X;
      const fromScale = this.fromScale = new geometry_exports.Point(1, 1);
      fromScale[axis] = START_SCALE;
      element.transform(
        geometry_exports.transform().scale(fromScale.x, fromScale.y)
      );
    } else {
      this.abort();
    }
  }
  step(pos) {
    const scaleX = interpolateValue(this.fromScale.x, 1, pos);
    const scaleY = interpolateValue(this.fromScale.y, 1, pos);
    this.element.transform(
      geometry_exports.transform().scale(scaleX, scaleY, this.origin)
    );
  }
  abort() {
    super.abort();
    this.element.transform(null);
  }
};
setDefaultOptions(BarChartAnimation, {
  duration: INITIAL_ANIMATION_DURATION
});
drawing_exports.AnimationFactory.current.register(BAR, BarChartAnimation);

// node_modules/@progress/kendo-charts/dist/es/chart/animations/bubble-animation.js
var BubbleAnimation = class extends drawing_exports.Animation {
  setup() {
    const center = this.center = this.element.bbox().center();
    this.element.transform(
      geometry_exports.transform().scale(START_SCALE, START_SCALE, center)
    );
  }
  step(pos) {
    this.element.transform(
      geometry_exports.transform().scale(pos, pos, this.center)
    );
  }
};
setDefaultOptions(BubbleAnimation, {
  easing: "easeOutElastic"
});
drawing_exports.AnimationFactory.current.register(BUBBLE, BubbleAnimation);

// node_modules/@progress/kendo-charts/dist/es/chart/animations/fade-in-animation.js
var FadeInAnimation = class extends drawing_exports.Animation {
  setup() {
    this.fadeTo = this.element.opacity();
    this.element.opacity(0);
  }
  step(pos) {
    this.element.opacity(pos * this.fadeTo);
  }
};
setDefaultOptions(FadeInAnimation, {
  duration: 200,
  easing: "linear"
});
drawing_exports.AnimationFactory.current.register(FADEIN, FadeInAnimation);

// node_modules/@progress/kendo-charts/dist/es/chart/animations/pie-animation.js
var PieAnimation = class extends drawing_exports.Animation {
  setup() {
    this.element.transform(
      geometry_exports.transform().scale(START_SCALE, START_SCALE, this.options.center)
    );
  }
  step(pos) {
    this.element.transform(
      geometry_exports.transform().scale(pos, pos, this.options.center)
    );
  }
};
setDefaultOptions(PieAnimation, {
  easing: "easeOutElastic",
  duration: INITIAL_ANIMATION_DURATION
});
drawing_exports.AnimationFactory.current.register(PIE, PieAnimation);

// node_modules/@progress/kendo-charts/dist/es/chart/scatter-charts/scatter-line-chart.js
var ScatterLineChart = class extends scatter_chart_default {
  render() {
    super.render();
    this.renderSegments();
  }
  createSegment(linePoints, currentSeries, seriesIx) {
    const style = currentSeries.style;
    let pointType;
    if (style === SMOOTH) {
      pointType = spline_segment_default;
    } else {
      pointType = line_segment_default;
    }
    return new pointType(linePoints, currentSeries, seriesIx);
  }
  animationPoints() {
    const points = super.animationPoints();
    return points.concat(this._segments);
  }
  createMissingValue(value2, missingValues) {
    if (missingValues === ZERO) {
      const missingValue = {
        x: value2.x,
        y: value2.y
      };
      if (!hasValue(missingValue.x)) {
        missingValue.x = 0;
      }
      if (!hasValue(missingValue.y)) {
        missingValue.y = 0;
      }
      return missingValue;
    }
  }
};
deepExtend(ScatterLineChart.prototype, line_chart_mixin_default);
var scatter_line_chart_default = ScatterLineChart;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/get-scatter-trendline-data.js
function getScatterTrendlineData(valueMapper, range, options) {
  const data = [];
  let { xMin, xMax } = range;
  const forecast = (options || {}).forecast;
  if (forecast) {
    if (forecast.before > 0) {
      xMin -= forecast.before;
    }
    if (forecast.after > 0) {
      xMax += forecast.after;
    }
  }
  const samplingInterval = (options || {}).samplingInterval;
  let delta = valueOrDefault(samplingInterval, autoMajorUnit(xMin, xMax) / 10);
  if (samplingInterval <= 0) {
    delta = xMax - xMin;
  }
  for (let x7 = xMin; x7 <= xMax; x7 += delta) {
    data.push([
      x7,
      valueMapper(x7)
    ]);
  }
  return data;
}
var get_scatter_trendline_data_default = getScatterTrendlineData;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/scatter-exponential-trendline.js
function scatterExponentialTrendline(context) {
  const {
    options,
    seriesValues
  } = context;
  const data = getData7({ seriesValues, options });
  if (data) {
    return Object.assign(
      {},
      options,
      {
        type: "scatterLine",
        data
      }
    );
  }
  return null;
}
var valueGetter7 = (fieldName) => ({ valueFields }) => ({ xValue: valueFields.x, yValue: Math.log(valueFields[fieldName]) });
function getData7({ seriesValues, options }) {
  const sourceValues = seriesValues();
  if (!check_all_positive_default(sourceValues, options.field)) {
    return null;
  }
  let { slope, intercept, count, xMin, xMax } = calculate_slope_default(sourceValues, valueGetter7(options.field));
  const range = { xMin, xMax };
  if (count > 0) {
    const a50 = Math.exp(intercept);
    const b2 = slope;
    return get_scatter_trendline_data_default((x7) => a50 * Math.exp(b2 * x7), range, options.trendline);
  }
  return null;
}
var scatter_exponential_trendline_default = scatterExponentialTrendline;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/scatter-value-getter.js
var scatterValueGetter = (fieldName) => ({ valueFields }) => ({ xValue: valueFields.x, yValue: valueFields[fieldName] });
var scatter_value_getter_default = scatterValueGetter;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/scatter-linear-trendline.js
function scatterLinearTrendline(context) {
  const {
    options,
    seriesValues
  } = context;
  const data = getData8({ seriesValues, options });
  if (data) {
    return Object.assign(
      {},
      options,
      {
        type: "scatterLine",
        data
      }
    );
  }
  return null;
}
function getData8({ seriesValues, options }) {
  let { slope, intercept, count, xMin, xMax } = calculate_slope_default(seriesValues(), scatter_value_getter_default(options.field));
  const range = { xMin, xMax };
  if (count > 0) {
    return get_scatter_trendline_data_default((x7) => slope * x7 + intercept, range, options.trendline);
  }
  return null;
}
var scatter_linear_trendline_default = scatterLinearTrendline;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/x-value-limits.js
function xValueLimits(sourceValues, valueGetter10) {
  let xMin = Number.MAX_VALUE;
  let xMax = Number.MIN_VALUE;
  for (let i37 = 0; i37 < sourceValues.length; i37++) {
    const value2 = sourceValues[i37];
    const { xValue, yValue } = valueGetter10(value2);
    if (isFinite(xValue) && xValue !== null && isFinite(yValue) && yValue !== null) {
      xMin = Math.min(xValue, xMin);
      xMax = Math.max(xValue, xMax);
    }
  }
  return { xMin, xMax };
}
var x_value_limits_default = xValueLimits;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/scatter-logarithmic-trendline.js
function scatterLogarithmicTrendline(context) {
  const {
    options,
    seriesValues
  } = context;
  const data = getData9({ seriesValues, options });
  if (data) {
    return Object.assign(
      {},
      options,
      {
        type: "scatterLine",
        data
      }
    );
  }
  return null;
}
var valueGetter8 = (fieldName) => ({ valueFields }) => ({ xValue: valueFields.x, yValue: valueFields[fieldName] });
var logValueGetter = (fieldName) => ({ valueFields }) => ({ xValue: Math.log(valueFields.x), yValue: valueFields[fieldName] });
function getData9({ seriesValues, options }) {
  const sourceValues = seriesValues();
  if (!check_all_positive_default(sourceValues, "x")) {
    return null;
  }
  let { slope, intercept, count } = calculate_slope_default(sourceValues, logValueGetter(options.field));
  let range = x_value_limits_default(sourceValues, valueGetter8(options.field));
  if (count > 0) {
    const a50 = slope;
    const b2 = intercept;
    return get_scatter_trendline_data_default((x7) => a50 * Math.log(x7) + b2, range, options.trendline);
  }
  return null;
}
var scatter_logarithmic_trendline_default = scatterLogarithmicTrendline;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/scatter-moving-average.js
function scatterMovingAverageTrendline(context) {
  const { options } = context;
  const data = getData10(context);
  if (data) {
    return Object.assign(
      {},
      options,
      {
        type: "scatterLine",
        data
      }
    );
  }
  return null;
}
function getData10({ options, seriesValues }) {
  const period = (options.trendline || {}).period || MIN_MOVING_AVERAGE_PERIOD;
  const range = { before: period, after: period };
  const data = calculate_moving_average_default(seriesValues(range), scatter_value_getter_default(options.field), period);
  if (data.length > 0) {
    return data;
  }
  return null;
}
var scatter_moving_average_default = scatterMovingAverageTrendline;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/scatter-polynomial-trendline.js
function scatterPolynomialTrendline(context) {
  const {
    options,
    seriesValues
  } = context;
  const data = getData11({ seriesValues, options });
  if (data) {
    return Object.assign(
      {},
      options,
      {
        type: "scatterLine",
        data
      }
    );
  }
  return null;
}
function getData11({ seriesValues, options }) {
  const order = (options.trendline || {}).order;
  const valueGetter10 = scatter_value_getter_default(options.field);
  const { count, valueMapper, xMin, xMax } = calculate_polynomial_default(seriesValues(), valueGetter10, order);
  const range = { xMin, xMax };
  if (count > 0) {
    return get_scatter_trendline_data_default(valueMapper, range, options.trendline);
  }
  return null;
}
var scatter_polynomial_trendline_default = scatterPolynomialTrendline;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/scatter-power-trendline.js
function scatterPowerTrendline(context) {
  const {
    options,
    seriesValues
  } = context;
  const data = getData12({ seriesValues, options });
  if (data) {
    return Object.assign(
      {},
      options,
      {
        type: "scatterLine",
        data
      }
    );
  }
  return null;
}
var valueGetter9 = (fieldName) => ({ valueFields }) => ({ xValue: Math.log(valueFields.x), yValue: Math.log(valueFields[fieldName]) });
function getData12({ seriesValues, options }) {
  const sourceValues = seriesValues();
  if (!check_all_positive_default(sourceValues, "x")) {
    return null;
  }
  let { slope, intercept, count } = calculate_slope_default(sourceValues, valueGetter9(options.field));
  let range = x_value_limits_default(sourceValues, scatter_value_getter_default(options.field));
  if (count > 0) {
    const a50 = Math.exp(intercept);
    const b2 = slope;
    return get_scatter_trendline_data_default((x7) => a50 * Math.pow(x7, b2), range, options.trendline);
  }
  return null;
}
var scatter_power_trendline_default = scatterPowerTrendline;

// node_modules/@progress/kendo-charts/dist/es/chart/trendlines/scatter-trendline-registry.js
var scatterRegistry = {};
scatterRegistry[TRENDLINE_EXPONENTIAL] = scatter_exponential_trendline_default;
scatterRegistry[TRENDLINE_LINEAR] = scatter_linear_trendline_default;
scatterRegistry[TRENDLINE_LOGARITHMIC] = scatter_logarithmic_trendline_default;
scatterRegistry[TRENDLINE_MOVING_AVERAGE] = scatter_moving_average_default;
scatterRegistry[TRENDLINE_POLYNOMIAL] = scatter_polynomial_trendline_default;
scatterRegistry[TRENDLINE_POWER] = scatter_power_trendline_default;
var scatter_trendline_registry_default = scatterRegistry;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/xy-plotarea.js
var XYPlotArea = class extends plotarea_base_default {
  initFields() {
    this.namedXAxes = {};
    this.namedYAxes = {};
    this.xAxisRangeTracker = new axis_group_range_tracker_default();
    this.yAxisRangeTracker = new axis_group_range_tracker_default();
  }
  render(panes = this.panes) {
    this.series = [...this.originalSeries];
    this.createTrendlineSeries();
    const seriesByPane = this.groupSeriesByPane();
    for (let i37 = 0; i37 < panes.length; i37++) {
      const pane = panes[i37];
      const paneSeries = seriesByPane[pane.options.name || "default"] || [];
      this.addToLegend(paneSeries);
      const filteredSeries = this.filterVisibleSeries(paneSeries);
      if (!filteredSeries) {
        continue;
      }
      this.createScatterChart(
        filterSeriesByType(filteredSeries, SCATTER),
        pane
      );
      this.createScatterLineChart(
        filterSeriesByType(filteredSeries, SCATTER_LINE),
        pane
      );
      this.createBubbleChart(
        filterSeriesByType(filteredSeries, BUBBLE),
        pane
      );
    }
    this.createAxes(panes);
  }
  appendChart(chart, pane) {
    this.xAxisRangeTracker.update(chart.xAxisRanges);
    this.yAxisRangeTracker.update(chart.yAxisRanges);
    super.appendChart(chart, pane);
  }
  removeAxis(axis) {
    const axisName = axis.options.name;
    super.removeAxis(axis);
    if (axis.options.vertical) {
      this.yAxisRangeTracker.reset(axisName);
      delete this.namedYAxes[axisName];
    } else {
      this.xAxisRangeTracker.reset(axisName);
      delete this.namedXAxes[axisName];
    }
    if (axis === this.axisX) {
      delete this.axisX;
    }
    if (axis === this.axisY) {
      delete this.axisY;
    }
  }
  // TODO: Refactor, optionally use series.pane option
  seriesPaneName(series) {
    const options = this.options;
    const xAxisName = series.xAxis;
    const xAxisOptions = [].concat(options.xAxis);
    const xAxis = grep_default(xAxisOptions, function(a50) {
      return a50.name === xAxisName;
    })[0];
    const yAxisName = series.yAxis;
    const yAxisOptions = [].concat(options.yAxis);
    const yAxis = grep_default(yAxisOptions, function(a50) {
      return a50.name === yAxisName;
    })[0];
    const panes = options.panes || [{}];
    const defaultPaneName = panes[0].name || "default";
    const paneName = (xAxis || {}).pane || (yAxis || {}).pane || defaultPaneName;
    return paneName;
  }
  createScatterChart(series, pane) {
    if (series.length > 0) {
      this.appendChart(
        new scatter_chart_default(this, { series, clip: pane.options.clip }),
        pane
      );
    }
  }
  createScatterLineChart(series, pane) {
    if (series.length > 0) {
      this.appendChart(
        new scatter_line_chart_default(this, { series, clip: pane.options.clip }),
        pane
      );
    }
  }
  createBubbleChart(series, pane) {
    if (series.length > 0) {
      this.appendChart(
        new bubble_chart_default(this, { series, clip: pane.options.clip }),
        pane
      );
    }
  }
  createXYAxis(options, vertical, axisIndex) {
    const axisName = options.name;
    const namedAxes = vertical ? this.namedYAxes : this.namedXAxes;
    const tracker = vertical ? this.yAxisRangeTracker : this.xAxisRangeTracker;
    const axisOptions2 = deepExtend({ reverse: !vertical && this.chartService.rtl }, options, { vertical });
    const isLog = equalsIgnoreCase(axisOptions2.type, LOGARITHMIC);
    const defaultRange = tracker.query();
    const defaultAxisRange = isLog ? { min: 0.1, max: 1 } : { min: 0, max: 1 };
    const range = tracker.query(axisName) || defaultRange || defaultAxisRange;
    const typeSamples = [axisOptions2.min, axisOptions2.max];
    const series = this.series;
    for (let seriesIx = 0; seriesIx < series.length; seriesIx++) {
      const currentSeries = series[seriesIx];
      const seriesAxisName = currentSeries[vertical ? "yAxis" : "xAxis"];
      if (seriesAxisName === axisOptions2.name || axisIndex === 0 && !seriesAxisName) {
        const firstPointValue = series_binder_default.current.bindPoint(currentSeries, 0).valueFields;
        typeSamples.push(firstPointValue[vertical ? "y" : "x"]);
        break;
      }
    }
    if (axisIndex === 0 && defaultRange) {
      range.min = Math.min(range.min, defaultRange.min);
      range.max = Math.max(range.max, defaultRange.max);
    }
    let inferredDate;
    for (let i37 = 0; i37 < typeSamples.length; i37++) {
      if (typeSamples[i37] instanceof Date) {
        inferredDate = true;
        break;
      }
    }
    let axisType;
    if (equalsIgnoreCase(axisOptions2.type, DATE) || !axisOptions2.type && inferredDate) {
      axisType = date_value_axis_default;
    } else if (isLog) {
      axisType = logarithmic_axis_default;
    } else {
      axisType = numeric_axis_default;
    }
    const axis = new axisType(range.min, range.max, axisOptions2, this.chartService);
    axis.axisIndex = axisIndex;
    if (axisName) {
      if (namedAxes[axisName]) {
        throw new Error(`${vertical ? "Y" : "X"} axis with name ${axisName} is already defined`);
      }
      namedAxes[axisName] = axis;
    }
    this.appendAxis(axis);
    return axis;
  }
  createAxes(panes) {
    const options = this.options;
    const xAxesOptions = [].concat(options.xAxis);
    const xAxes = [];
    const yAxesOptions = [].concat(options.yAxis);
    const yAxes = [];
    for (let idx = 0; idx < xAxesOptions.length; idx++) {
      const axisPane = this.findPane(xAxesOptions[idx].pane);
      if (inArray(axisPane, panes)) {
        xAxes.push(this.createXYAxis(xAxesOptions[idx], false, idx));
      }
    }
    for (let idx = 0; idx < yAxesOptions.length; idx++) {
      const axisPane = this.findPane(yAxesOptions[idx].pane);
      if (inArray(axisPane, panes)) {
        yAxes.push(this.createXYAxis(yAxesOptions[idx], true, idx));
      }
    }
    this.axisX = this.axisX || xAxes[0];
    this.axisY = this.axisY || yAxes[0];
  }
  _dispatchEvent(chart, e41, eventType) {
    const coords = chart._eventCoordinates(e41);
    const point = new point_default(coords.x, coords.y);
    const allAxes = this.axes;
    const length = allAxes.length;
    const xValues = [];
    const yValues = [];
    for (let i37 = 0; i37 < length; i37++) {
      const axis = allAxes[i37];
      const values = axis.options.vertical ? yValues : xValues;
      const currentValue = axis.getValue(point);
      if (currentValue !== null) {
        values.push(currentValue);
      }
    }
    if (xValues.length > 0 && yValues.length > 0) {
      chart.trigger(eventType, {
        element: eventElement(e41),
        originalEvent: e41,
        x: singleItemOrArray(xValues),
        y: singleItemOrArray(yValues)
      });
    }
  }
  updateAxisOptions(axis, options) {
    const vertical = axis.options.vertical;
    const axes = this.groupAxes(this.panes);
    const index = (vertical ? axes.y : axes.x).indexOf(axis);
    updateAxisOptions2(this.options, index, vertical, options);
    updateAxisOptions2(this.originalOptions, index, vertical, options);
  }
  trendlineFactory(options, series) {
    const seriesValues = this.seriesValues.bind(this, series.index);
    const trendline = trendline_factory_default(scatter_trendline_registry_default, options.type, {
      options,
      seriesValues
    });
    if (trendline) {
      trendline.xAxis = series.xAxis;
      trendline.yAxis = series.yAxis;
    }
    return trendline;
  }
  seriesValues(seriesIx) {
    const result = [];
    const currentSeries = this.series[seriesIx];
    for (let pointIx = 0; pointIx < currentSeries.data.length; pointIx++) {
      const data = this.bindPoint(currentSeries, pointIx);
      result.push({ pointIx, valueFields: data.valueFields });
    }
    return result;
  }
};
function updateAxisOptions2(targetOptions, axisIndex, vertical, options) {
  const axisOptions2 = [].concat(vertical ? targetOptions.yAxis : targetOptions.xAxis)[axisIndex];
  deepExtend(axisOptions2, options);
}
setDefaultOptions(XYPlotArea, {
  xAxis: {},
  yAxis: {}
});
deepExtend(XYPlotArea.prototype, plotarea_events_mixin_default);
var xy_plotarea_default = XYPlotArea;

// node_modules/@progress/kendo-charts/dist/es/chart/pie-chart/pie-segment.js
var PieSegment = class extends chart_element_default {
  constructor(value2, sector, options) {
    super(options);
    this.value = value2;
    this.sector = sector;
  }
  render() {
    if (this._rendered || this.visible === false) {
      return;
    }
    this._rendered = true;
    this.createLabel();
  }
  createLabel() {
    const labels = this.options.labels;
    const chartService = this.owner.chartService;
    let labelText = this.getLabelText(labels);
    if (labels.visible && (labelText || labelText === 0)) {
      if (labels.position === CENTER || labels.position === INSIDE_END) {
        if (!labels.color) {
          labels.color = auto_text_color_default(this.options.color);
        }
        if (!labels.background) {
          labels.background = this.options.color;
        }
      } else {
        const themeLabels = chartService.theme.seriesDefaults.labels;
        labels.color = labels.color || themeLabels.color;
        labels.background = labels.background || themeLabels.background;
      }
      this.label = new text_box_default(labelText, deepExtend({}, labels, {
        align: CENTER,
        vAlign: "",
        animation: {
          type: FADEIN,
          delay: this.animationDelay
        }
      }), this.pointData());
      this.append(this.label);
    }
  }
  getLabelText(options) {
    let labelTemplate = getTemplate(options);
    if (labelTemplate) {
      return labelTemplate(this.pointData());
    }
    return this.owner.chartService.format.auto(options.format, this.value);
  }
  reflow(targetBox) {
    this.render();
    this.box = targetBox;
    this.reflowLabel();
  }
  reflowLabel() {
    const { options: { labels: labelsOptions }, label } = this;
    const sector = this.sector.clone();
    const labelsDistance = labelsOptions.distance;
    const angle = sector.middle();
    if (label) {
      const labelHeight = label.box.height();
      const labelWidth = label.box.width();
      let lp;
      if (labelsOptions.position === CENTER) {
        sector.radius = Math.abs((sector.radius - labelHeight) / 2) + labelHeight;
        lp = sector.point(angle);
        label.reflow(new box_default(lp.x, lp.y - labelHeight / 2, lp.x, lp.y));
      } else if (labelsOptions.position === INSIDE_END) {
        sector.radius = sector.radius - labelHeight / 2;
        lp = sector.point(angle);
        label.reflow(new box_default(lp.x, lp.y - labelHeight / 2, lp.x, lp.y));
      } else {
        let x1;
        lp = sector.clone().expand(labelsDistance).point(angle);
        if (lp.x >= sector.center.x) {
          x1 = lp.x + labelWidth;
          label.orientation = RIGHT;
        } else {
          x1 = lp.x - labelWidth;
          label.orientation = LEFT;
        }
        label.reflow(new box_default(x1, lp.y - labelHeight, lp.x, lp.y));
      }
    }
  }
  createVisual() {
    const { sector, options } = this;
    super.createVisual();
    this.addAccessibilityAttributesToVisual();
    if (this.value) {
      if (options.visual) {
        const startAngle = (sector.startAngle + 180) % 360;
        const visual = options.visual({
          category: this.category,
          dataItem: this.dataItem,
          value: this.value,
          series: this.series,
          percentage: this.percentage,
          center: new geometry_exports.Point(sector.center.x, sector.center.y),
          radius: sector.radius,
          innerRadius: sector.innerRadius,
          startAngle,
          endAngle: startAngle + sector.angle,
          options,
          sender: this.getSender(),
          createVisual: () => {
            const group = new drawing_exports.Group();
            this.createSegmentVisual(group);
            return group;
          }
        });
        if (visual) {
          this.visual.append(visual);
        }
      } else {
        this.createSegmentVisual(this.visual);
      }
    }
  }
  createSegmentVisual(group) {
    const { sector, options } = this;
    const borderOptions = options.border || {};
    const border = borderOptions.width > 0 ? {
      stroke: {
        color: borderOptions.color,
        width: borderOptions.width,
        opacity: borderOptions.opacity,
        dashType: borderOptions.dashType
      }
    } : {};
    const color = options.color;
    const fill = createPatternFill(options.pattern, {
      color,
      opacity: options.opacity
    });
    const visual = this.createSegment(sector, deepExtend({
      fill,
      stroke: {
        opacity: options.opacity
      },
      zIndex: options.zIndex
    }, border));
    group.append(visual);
    if (hasGradientOverlay(options)) {
      group.append(this.createGradientOverlay(visual, {
        baseColor: color,
        fallbackFill: fill
      }, deepExtend({
        center: [sector.center.x, sector.center.y],
        innerRadius: sector.innerRadius,
        radius: sector.radius,
        userSpace: true
      }, options.overlay)));
    }
  }
  createSegment(sector, options) {
    if (options.singleSegment) {
      return new drawing_exports.Circle(new geometry_exports.Circle(new geometry_exports.Point(sector.center.x, sector.center.y), sector.radius), options);
    }
    return shape_builder_default.current.createRing(sector, options);
  }
  createAnimation() {
    const { options, sector: { center } } = this;
    deepExtend(options, {
      animation: {
        center: [center.x, center.y],
        delay: this.animationDelay
      }
    });
    super.createAnimation();
  }
  createHighlight(options) {
    const highlight = this.options.highlight || {};
    const border = highlight.border || {};
    return this.createSegment(this.sector, deepExtend({}, options, {
      fill: {
        color: highlight.color,
        opacity: highlight.opacity
      },
      stroke: {
        opacity: border.opacity,
        width: border.width,
        color: border.color,
        dashType: border.dashType
      }
    }));
  }
  highlightVisual() {
    return this.visual.children[0];
  }
  highlightVisualArgs() {
    const sector = this.sector;
    return {
      options: this.options,
      radius: sector.radius,
      innerRadius: sector.innerRadius,
      center: new geometry_exports.Point(sector.center.x, sector.center.y),
      startAngle: sector.startAngle,
      endAngle: sector.angle + sector.startAngle,
      visual: this.visual
    };
  }
  createFocusHighlight(style) {
    const borderWidth = this.options.focusHighlight.border.width;
    const result = this.createSegment(this.sector, deepExtend({}, style, {
      stroke: {
        width: borderWidth * 2
      }
    }));
    const clipPath = new drawing_exports.MultiPath();
    clipPath.paths.push(drawing_exports.Path.fromRect(result.bbox()));
    clipPath.paths.push(this.createSegment(this.sector, {}));
    result.clip(clipPath);
    return result;
  }
  tooltipAnchor() {
    const sector = this.sector.clone().expand(TOOLTIP_OFFSET);
    const midAndle = sector.middle();
    const midPoint = sector.point(midAndle);
    return {
      point: midPoint,
      align: tooltipAlignment(midAndle + 180)
    };
  }
  formatValue(format) {
    return this.owner.formatPointValue(this, format);
  }
  pointData() {
    return {
      dataItem: this.dataItem,
      category: this.category,
      value: this.value,
      series: this.series,
      percentage: this.percentage
    };
  }
  getIndex() {
    return this.index;
  }
};
var RAD_30 = round(rad(30), DEFAULT_PRECISION);
var RAD_60 = round(rad(60), DEFAULT_PRECISION);
function tooltipAlignment(angle) {
  const radians = rad(angle);
  const sine = round(Math.sin(radians), DEFAULT_PRECISION);
  const cosine = round(Math.cos(radians), DEFAULT_PRECISION);
  let horizontal;
  if (Math.abs(sine) > RAD_60) {
    horizontal = CENTER;
  } else if (cosine < 0) {
    horizontal = RIGHT;
  } else {
    horizontal = LEFT;
  }
  let vertical;
  if (Math.abs(sine) < RAD_30) {
    vertical = CENTER;
  } else if (sine < 0) {
    vertical = BOTTOM;
  } else {
    vertical = TOP;
  }
  return {
    horizontal,
    vertical
  };
}
setDefaultOptions(PieSegment, {
  color: WHITE,
  overlay: {
    gradient: "roundedBevel"
  },
  border: {
    width: 0.5
  },
  labels: {
    visible: false,
    distance: 35,
    font: DEFAULT_FONT,
    margin: getSpacing(0.5),
    align: CIRCLE,
    zIndex: 1,
    position: OUTSIDE_END
  },
  animation: {
    type: PIE
  },
  highlight: {
    visible: true,
    border: {
      width: 1
    }
  },
  visible: true,
  accessibility: {
    role: CHART_POINT_ROLE,
    className: CHART_POINT_CLASSNAME,
    ariaRoleDescription: CHART_POINT_ROLE_DESCRIPTION
  }
});
deepExtend(PieSegment.prototype, point_events_mixin_default);
deepExtend(PieSegment.prototype, accessibility_attributes_mixin_default);
var pie_segment_default = PieSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/mixins/pie-chart-mixin.js
var PieChartMixin = {
  createLegendItem: function(value2, point, options) {
    const legendOptions = this.options.legend || {};
    const labelsOptions = legendOptions.labels || {};
    const inactiveItems = legendOptions.inactiveItems || {};
    const inactiveItemsLabels = inactiveItems.labels || {};
    if (options && options.visibleInLegend !== false) {
      const pointVisible = options.visible !== false;
      const labelTemplate = pointVisible ? getTemplate(labelsOptions) : getTemplate(inactiveItemsLabels) || getTemplate(labelsOptions);
      let text = options.category;
      if (labelTemplate) {
        text = labelTemplate({
          text,
          series: options.series,
          dataItem: options.dataItem,
          percentage: options.percentage,
          value: value2
        });
      }
      let itemLabelOptions, markerColor;
      if (pointVisible) {
        itemLabelOptions = {};
        markerColor = point.color;
      } else {
        itemLabelOptions = {
          color: inactiveItemsLabels.color,
          font: inactiveItemsLabels.font
        };
        markerColor = (inactiveItems.markers || {}).color;
      }
      if (hasValue(text) && text !== "") {
        this.legendItems.push({
          active: pointVisible,
          pointIndex: options.index,
          text,
          series: options.series,
          markerColor,
          pattern: point.pattern,
          labels: itemLabelOptions
        });
      }
    }
  }
};
var pie_chart_mixin_default = PieChartMixin;

// node_modules/@progress/kendo-charts/dist/es/chart/pie-chart/pie-chart.js
var PIE_SECTOR_ANIM_DELAY = 70;
var PieChart = class extends chart_element_default {
  constructor(plotArea, options) {
    super(options);
    this.plotArea = plotArea;
    this.chartService = plotArea.chartService;
    this.points = [];
    this.legendItems = [];
    this.render();
  }
  render() {
    this.traverseDataPoints(this.addValue.bind(this));
  }
  traverseDataPoints(callback) {
    const { options, plotArea: { options: { seriesColors = [] } } } = this;
    const colorsCount = seriesColors.length;
    const series = options.series;
    const seriesCount = series.length;
    for (let seriesIx = 0; seriesIx < seriesCount; seriesIx++) {
      const currentSeries = series[seriesIx];
      const data = currentSeries.data;
      const { total, points, count } = bindSegments(currentSeries);
      const anglePerValue = 360 / total;
      let constantAngle;
      if (!isFinite(anglePerValue)) {
        constantAngle = 360 / count;
      }
      let currentAngle;
      if (defined(currentSeries.startAngle)) {
        currentAngle = currentSeries.startAngle;
      } else {
        currentAngle = options.startAngle;
      }
      if (seriesIx !== seriesCount - 1) {
        if (currentSeries.labels.position === OUTSIDE_END) {
          currentSeries.labels.position = CENTER;
        }
      }
      for (let i37 = 0; i37 < points.length; i37++) {
        const pointData = points[i37];
        if (!pointData) {
          continue;
        }
        const { fields, value: value2, visible } = pointData;
        const angle = value2 !== 0 ? constantAngle || value2 * anglePerValue : 0;
        const explode = data.length !== 1 && Boolean(fields.explode);
        if (!isFunction(currentSeries.color)) {
          currentSeries.color = fields.color || seriesColors[i37 % colorsCount];
        }
        callback(value2, new ring_default(null, 0, 0, currentAngle, angle), {
          owner: this,
          category: defined(fields.category) ? fields.category : "",
          pattern: defined(fields.pattern) ? fields.pattern : currentSeries.pattern,
          index: i37,
          series: currentSeries,
          seriesIx,
          dataItem: data[i37],
          percentage: total !== 0 ? value2 / total : 0,
          explode,
          visibleInLegend: fields.visibleInLegend,
          visible,
          zIndex: seriesCount - seriesIx,
          animationDelay: this.animationDelay(i37, seriesIx, seriesCount)
        });
        if (visible !== false) {
          currentAngle += angle;
        }
      }
    }
  }
  evalSegmentOptions(options, value2, fields) {
    const series = fields.series;
    evalOptions(options, {
      value: value2,
      series,
      dataItem: fields.dataItem,
      category: fields.category,
      percentage: fields.percentage
    }, { defaults: series._defaults, excluded: [
      "data",
      "content",
      "template",
      "visual",
      "toggle",
      "ariaTemplate",
      "ariaContent"
    ] });
  }
  addValue(value2, sector, fields) {
    const segmentOptions = deepExtend({}, fields.series, { index: fields.index });
    segmentOptions.pattern = fields.pattern || segmentOptions.pattern;
    this.evalSegmentOptions(segmentOptions, value2, fields);
    this.createLegendItem(value2, segmentOptions, fields);
    if (fields.visible === false) {
      return;
    }
    const segment = new pie_segment_default(value2, sector, segmentOptions);
    Object.assign(segment, fields);
    this.append(segment);
    this.points.push(segment);
  }
  reflow(targetBox) {
    const { options, points, seriesConfigs = [] } = this;
    const count = points.length;
    const box = targetBox.clone();
    const space = 5;
    const minWidth = Math.min(box.width(), box.height());
    const halfMinWidth = minWidth / 2;
    const defaultPadding = minWidth - minWidth * 0.85;
    const newBox = new box_default(box.x1, box.y1, box.x1 + minWidth, box.y1 + minWidth);
    const newBoxCenter = newBox.center();
    const boxCenter = box.center();
    const seriesCount = options.series.length;
    const leftSideLabels = [];
    const rightSideLabels = [];
    let padding = valueOrDefault(options.padding, defaultPadding);
    this.targetBox = targetBox;
    padding = padding > halfMinWidth - space ? halfMinWidth - space : padding;
    newBox.translate(boxCenter.x - newBoxCenter.x, boxCenter.y - newBoxCenter.y);
    const radius = halfMinWidth - padding;
    const center = new point_default(
      radius + newBox.x1 + padding,
      radius + newBox.y1 + padding
    );
    for (let i37 = 0; i37 < count; i37++) {
      const segment = points[i37];
      const sector = segment.sector;
      const seriesIndex = segment.seriesIx;
      sector.radius = radius;
      sector.center = center;
      if (seriesConfigs.length) {
        const seriesConfig = seriesConfigs[seriesIndex];
        sector.innerRadius = seriesConfig.innerRadius;
        sector.radius = seriesConfig.radius;
      }
      if (seriesIndex === seriesCount - 1 && segment.explode) {
        sector.center = sector.clone().setRadius(sector.radius * 0.15).point(sector.middle());
      }
      segment.reflow(newBox);
      const label = segment.label;
      if (label) {
        if (label.options.position === OUTSIDE_END) {
          if (seriesIndex === seriesCount - 1) {
            if (label.orientation === RIGHT) {
              rightSideLabels.push(label);
            } else {
              leftSideLabels.push(label);
            }
          }
        }
      }
    }
    if (leftSideLabels.length > 0) {
      leftSideLabels.sort(this.labelComparator(true));
      this.leftLabelsReflow(leftSideLabels);
    }
    if (rightSideLabels.length > 0) {
      rightSideLabels.sort(this.labelComparator(false));
      this.rightLabelsReflow(rightSideLabels);
    }
    this.box = newBox;
  }
  leftLabelsReflow(labels) {
    const distances = this.distanceBetweenLabels(labels);
    this.distributeLabels(distances, labels);
  }
  rightLabelsReflow(labels) {
    const distances = this.distanceBetweenLabels(labels);
    this.distributeLabels(distances, labels);
  }
  distanceBetweenLabels(labels) {
    const segment = last(this.points);
    const sector = segment.sector;
    const count = labels.length - 1;
    const lr = sector.radius + segment.options.labels.distance;
    const distances = [];
    let firstBox = labels[0].box;
    let distance = round(firstBox.y1 - (sector.center.y - lr - firstBox.height() - firstBox.height() / 2));
    distances.push(distance);
    for (let i37 = 0; i37 < count; i37++) {
      const secondBox = labels[i37 + 1].box;
      firstBox = labels[i37].box;
      distance = round(secondBox.y1 - firstBox.y2);
      distances.push(distance);
    }
    distance = round(sector.center.y + lr - labels[count].box.y2 - labels[count].box.height() / 2);
    distances.push(distance);
    return distances;
  }
  distributeLabels(distances, labels) {
    const count = distances.length;
    let left, right, remaining;
    for (let i37 = 0; i37 < count; i37++) {
      remaining = -distances[i37];
      left = right = i37;
      while (remaining > 0 && (left >= 0 || right < count)) {
        remaining = this._takeDistance(distances, i37, --left, remaining);
        remaining = this._takeDistance(distances, i37, ++right, remaining);
      }
    }
    this.reflowLabels(distances, labels);
  }
  _takeDistance(distances, anchor, position, amount) {
    let result = amount;
    if (distances[position] > 0) {
      const available = Math.min(distances[position], result);
      result -= available;
      distances[position] -= available;
      distances[anchor] += available;
    }
    return result;
  }
  reflowLabels(distances, labels) {
    const segment = last(this.points);
    const sector = segment.sector;
    const labelOptions = segment.options.labels;
    const labelsCount = labels.length;
    const labelDistance = labelOptions.distance;
    let boxY = sector.center.y - (sector.radius + labelDistance) - labels[0].box.height();
    let boxX;
    distances[0] += 2;
    for (let i37 = 0; i37 < labelsCount; i37++) {
      const label = labels[i37];
      const box = label.box;
      boxY += distances[i37];
      boxX = this.hAlignLabel(
        box.x2,
        sector.clone().expand(labelDistance),
        boxY,
        boxY + box.height(),
        label.orientation === RIGHT
      );
      if (label.orientation === RIGHT) {
        if (labelOptions.align !== CIRCLE) {
          boxX = sector.radius + sector.center.x + labelDistance;
        }
        label.reflow(new box_default(boxX + box.width(), boxY, boxX, boxY));
      } else {
        if (labelOptions.align !== CIRCLE) {
          boxX = sector.center.x - sector.radius - labelDistance;
        }
        label.reflow(new box_default(boxX - box.width(), boxY, boxX, boxY));
      }
      boxY += box.height();
    }
  }
  createVisual() {
    const { options: { connectors }, points } = this;
    const count = points.length;
    const space = 4;
    super.createVisual();
    this._connectorLines = [];
    for (let i37 = 0; i37 < count; i37++) {
      const segment = points[i37];
      const { sector, label } = segment;
      const angle = sector.middle();
      const connectorsColor = (segment.options.connectors || {}).color || connectors.color;
      if (label) {
        const connectorLine = new drawing_exports.Path({
          stroke: {
            color: connectorsColor,
            width: connectors.width
          },
          animation: {
            type: FADEIN,
            delay: segment.animationDelay
          }
        });
        if (label.options.position === OUTSIDE_END) {
          const box = label.box;
          const centerPoint = sector.center;
          let start = sector.point(angle);
          let middle = new point_default(box.x1, box.center().y);
          let sr, end, crossing;
          start = sector.clone().expand(connectors.padding).point(angle);
          connectorLine.moveTo(start.x, start.y);
          if (label.orientation === RIGHT) {
            end = new point_default(box.x1 - connectors.padding, box.center().y);
            crossing = intersection(centerPoint, start, middle, end);
            middle = new point_default(end.x - space, end.y);
            crossing = crossing || middle;
            crossing.x = Math.min(crossing.x, middle.x);
            if (this.pointInCircle(crossing, sector.center, sector.radius + space) || crossing.x < sector.center.x) {
              sr = sector.center.x + sector.radius + space;
              if (segment.options.labels.align !== COLUMN) {
                if (sr < middle.x) {
                  connectorLine.lineTo(sr, start.y);
                } else {
                  connectorLine.lineTo(start.x + space * 2, start.y);
                }
              } else {
                connectorLine.lineTo(sr, start.y);
              }
              connectorLine.lineTo(middle.x, end.y);
            } else {
              crossing.y = end.y;
              connectorLine.lineTo(crossing.x, crossing.y);
            }
          } else {
            end = new point_default(box.x2 + connectors.padding, box.center().y);
            crossing = intersection(centerPoint, start, middle, end);
            middle = new point_default(end.x + space, end.y);
            crossing = crossing || middle;
            crossing.x = Math.max(crossing.x, middle.x);
            if (this.pointInCircle(crossing, sector.center, sector.radius + space) || crossing.x > sector.center.x) {
              sr = sector.center.x - sector.radius - space;
              if (segment.options.labels.align !== COLUMN) {
                if (sr > middle.x) {
                  connectorLine.lineTo(sr, start.y);
                } else {
                  connectorLine.lineTo(start.x - space * 2, start.y);
                }
              } else {
                connectorLine.lineTo(sr, start.y);
              }
              connectorLine.lineTo(middle.x, end.y);
            } else {
              crossing.y = end.y;
              connectorLine.lineTo(crossing.x, crossing.y);
            }
          }
          connectorLine.lineTo(end.x, end.y);
          this._connectorLines.push(connectorLine);
          this.visual.append(connectorLine);
        }
      }
    }
  }
  renderVisual() {
    super.renderVisual();
    if (find(this.options.series, (options) => options.autoFit)) {
      const targetBox = this.targetBox;
      const pieCenter = this.box.center();
      const bbox = this.visual.bbox();
      if (!bbox) {
        return;
      }
      const bboxBottom = bbox.bottomRight();
      const scale = Math.min(
        (pieCenter.y - targetBox.y1) / (pieCenter.y - bbox.origin.y),
        (targetBox.y2 - pieCenter.y) / (bboxBottom.y - pieCenter.y),
        (pieCenter.x - targetBox.x1) / (pieCenter.x - bbox.origin.x),
        (targetBox.x2 - pieCenter.x) / (bboxBottom.x - pieCenter.x)
      );
      if (scale < 1) {
        this.visual.transform(geometry_exports.transform().scale(scale, scale, [pieCenter.x, pieCenter.y]));
      }
    }
  }
  labelComparator(reverse) {
    const reverseValue = reverse ? -1 : 1;
    return function(a50, b2) {
      const first = (a50.parent.sector.middle() + 270) % 360;
      const second = (b2.parent.sector.middle() + 270) % 360;
      return (first - second) * reverseValue;
    };
  }
  hAlignLabel(originalX, sector, y1, y2, direction) {
    const { radius, center: { x: cx, y: cy } } = sector;
    const t43 = Math.min(Math.abs(cy - y1), Math.abs(cy - y2));
    if (t43 > radius) {
      return originalX;
    }
    return cx + Math.sqrt(radius * radius - t43 * t43) * (direction ? 1 : -1);
  }
  pointInCircle(point, center, radius) {
    return Math.pow(center.x - point.x, 2) + Math.pow(center.y - point.y, 2) < Math.pow(radius, 2);
  }
  formatPointValue(point, format) {
    return this.chartService.format.auto(format, point.value);
  }
  animationDelay(categoryIndex) {
    return categoryIndex * PIE_SECTOR_ANIM_DELAY;
  }
  stackRoot() {
    return this;
  }
};
function intersection(a1, a210, b1, b2) {
  const uat = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x);
  const ub = (b2.y - b1.y) * (a210.x - a1.x) - (b2.x - b1.x) * (a210.y - a1.y);
  let result;
  if (ub !== 0) {
    const ua = uat / ub;
    result = new point_default(
      a1.x + ua * (a210.x - a1.x),
      a1.y + ua * (a210.y - a1.y)
    );
  }
  return result;
}
setDefaultOptions(PieChart, {
  startAngle: 90,
  connectors: {
    width: 2,
    color: "#939393",
    padding: 8
  },
  inactiveItems: {
    markers: {},
    labels: {}
  }
});
deepExtend(PieChart.prototype, pie_chart_mixin_default);
PieChart.prototype.isStackRoot = true;
var pie_chart_default = PieChart;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/pie-plotarea.js
var PiePlotArea = class extends plotarea_base_default {
  render() {
    this.createPieChart(this.series);
  }
  createPieChart(series) {
    const firstSeries = series[0];
    const pieChart = new pie_chart_default(this, {
      series,
      padding: firstSeries.padding,
      startAngle: firstSeries.startAngle,
      connectors: firstSeries.connectors,
      legend: this.options.legend
    });
    this.appendChart(pieChart);
  }
  appendChart(chart, pane) {
    super.appendChart(chart, pane);
    append(this.options.legend.data, chart.legendItems);
  }
  getPointBelow(point) {
    return this.getPointToTheRight(point);
  }
  getPointAbove(point) {
    return this.getPointToTheLeft(point);
  }
};
var pie_plotarea_default = PiePlotArea;

// node_modules/@progress/kendo-charts/dist/es/chart/donut-chart/donut-segment.js
var DonutSegment = class extends pie_segment_default {
  reflowLabel() {
    const { options: { labels: labelsOptions }, label } = this;
    const sector = this.sector.clone();
    const angle = sector.middle();
    if (label) {
      const labelHeight = label.box.height();
      if (labelsOptions.position === CENTER) {
        sector.radius -= (sector.radius - sector.innerRadius) / 2;
        const lp = sector.point(angle);
        label.reflow(new box_default(lp.x, lp.y - labelHeight / 2, lp.x, lp.y));
      } else {
        super.reflowLabel();
      }
    }
  }
  createSegment(sector, options) {
    return shape_builder_default.current.createRing(sector, options);
  }
};
setDefaultOptions(DonutSegment, {
  overlay: {
    gradient: "roundedGlass"
  },
  labels: {
    position: CENTER
  },
  animation: {
    type: PIE
  }
});
deepExtend(DonutSegment.prototype, point_events_mixin_default);
var donut_segment_default = DonutSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/donut-chart/donut-chart.js
var DONUT_SECTOR_ANIM_DELAY = 50;
var DonutChart = class extends pie_chart_default {
  addValue(value2, sector, fields) {
    const segmentOptions = deepExtend({}, fields.series, { index: fields.index });
    segmentOptions.pattern = fields.pattern || segmentOptions.pattern;
    this.evalSegmentOptions(segmentOptions, value2, fields);
    this.createLegendItem(value2, segmentOptions, fields);
    if (fields.visible === false) {
      return;
    }
    const segment = new donut_segment_default(value2, sector, segmentOptions);
    Object.assign(segment, fields);
    this.append(segment);
    this.points.push(segment);
  }
  reflow(targetBox) {
    const options = this.options;
    const box = targetBox.clone();
    const space = 5;
    const minWidth = Math.min(box.width(), box.height());
    const halfMinWidth = minWidth / 2;
    const defaultPadding = minWidth - minWidth * 0.85;
    const series = options.series;
    const seriesCount = series.length;
    let padding = valueOrDefault(options.padding, defaultPadding);
    padding = padding > halfMinWidth - space ? halfMinWidth - space : padding;
    let totalSize = halfMinWidth - padding;
    let seriesWithoutSize = 0;
    let holeSize;
    for (let i37 = 0; i37 < seriesCount; i37++) {
      const currentSeries = series[i37];
      if (i37 === 0) {
        if (defined(currentSeries.holeSize)) {
          holeSize = currentSeries.holeSize;
          totalSize -= currentSeries.holeSize;
        }
      }
      if (defined(currentSeries.size)) {
        totalSize -= currentSeries.size;
      } else {
        seriesWithoutSize++;
      }
      if (defined(currentSeries.margin) && i37 !== seriesCount - 1) {
        totalSize -= currentSeries.margin;
      }
    }
    if (!defined(holeSize)) {
      const currentSize = (halfMinWidth - padding) / (seriesCount + 0.75);
      holeSize = currentSize * 0.75;
      totalSize -= holeSize;
    }
    let innerRadius = holeSize;
    let margin = 0;
    let size, radius;
    this.seriesConfigs = [];
    for (let i37 = 0; i37 < seriesCount; i37++) {
      const currentSeries = series[i37];
      size = valueOrDefault(currentSeries.size, totalSize / seriesWithoutSize);
      innerRadius += margin;
      radius = innerRadius + size;
      this.seriesConfigs.push({ innerRadius, radius });
      margin = currentSeries.margin || 0;
      innerRadius = radius;
    }
    super.reflow(targetBox);
  }
  animationDelay(categoryIndex, seriesIndex, seriesCount) {
    return categoryIndex * DONUT_SECTOR_ANIM_DELAY + INITIAL_ANIMATION_DURATION * (seriesIndex + 1) / (seriesCount + 1);
  }
};
setDefaultOptions(DonutChart, {
  startAngle: 90,
  connectors: {
    width: 2,
    color: "#939393",
    padding: 8
  }
});
var donut_chart_default = DonutChart;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/donut-plotarea.js
var DonutPlotArea = class extends pie_plotarea_default {
  render() {
    this.createDonutChart(this.series);
  }
  createDonutChart(series) {
    const firstSeries = series[0];
    const donutChart = new donut_chart_default(this, {
      series,
      padding: firstSeries.padding,
      connectors: firstSeries.connectors,
      legend: this.options.legend
    });
    this.appendChart(donutChart);
  }
  // These were overriden in the Pie, so revert to original behavior
  getPointBelow(point) {
    return this._getNextPoint(point, this._pointsByVertical, -1);
  }
  getPointAbove(point) {
    return this._getNextPoint(point, this._pointsByVertical, 1);
  }
};
var donut_plotarea_default = DonutPlotArea;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/polar-plotarea-base.js
var DEFAULT_PADDING = 0.15;
var PolarPlotAreaBase = class extends plotarea_base_default {
  initFields() {
    this.valueAxisRangeTracker = new axis_group_range_tracker_default();
  }
  render() {
    this.addToLegend(this.series);
    this.createPolarAxis();
    this.createCharts();
    this.createValueAxis();
  }
  alignAxes() {
    const axis = this.valueAxis;
    const range = axis.range();
    const crossingValue = axis.options.reverse ? range.max : range.min;
    const slot = axis.getSlot(crossingValue);
    const center = this.polarAxis.getSlot(0).center;
    const axisBox = axis.box.translate(
      center.x - slot.x1,
      center.y - slot.y1
    );
    axis.reflow(axisBox);
  }
  createValueAxis() {
    const tracker = this.valueAxisRangeTracker;
    const defaultRange = tracker.query();
    const axisOptions2 = this.valueAxisOptions({
      roundToMajorUnit: false,
      zIndex: -1
    });
    let axisType, axisDefaultRange;
    if (axisOptions2.type === LOGARITHMIC) {
      axisType = radar_logarithmic_axis_default;
      axisDefaultRange = { min: 0.1, max: 1 };
    } else {
      axisType = radar_numeric_axis_default;
      axisDefaultRange = { min: 0, max: 1 };
    }
    const range = defaultRange || axisDefaultRange;
    const valueAxis = new axisType(
      range.min,
      range.max,
      axisOptions2,
      this.chartService
    );
    this.valueAxis = valueAxis;
    this.appendAxis(valueAxis);
  }
  reflowAxes() {
    const { options: { plotArea: options }, valueAxis, polarAxis, box } = this;
    const defaultPadding = Math.min(box.width(), box.height()) * DEFAULT_PADDING;
    const padding = getSpacing(options.padding || {}, defaultPadding);
    const paddingBox = box.clone().unpad(padding);
    const axisBox = paddingBox.clone();
    axisBox.y2 = axisBox.y1 + Math.min(axisBox.width(), axisBox.height());
    axisBox.align(paddingBox, Y, CENTER);
    const valueAxisBox = axisBox.clone().shrink(0, axisBox.height() / 2);
    polarAxis.reflow(axisBox);
    valueAxis.reflow(valueAxisBox);
    const heightDiff = valueAxis.lineBox().height() - valueAxis.box.height();
    valueAxis.reflow(valueAxis.box.unpad({ top: heightDiff }));
    this.axisBox = axisBox;
    this.alignAxes(axisBox);
  }
  backgroundBox() {
    return this.box;
  }
  detachLabels() {
  }
};
var polar_plotarea_base_default = PolarPlotAreaBase;

// node_modules/@progress/kendo-charts/dist/es/chart/polar-scatter-chart/polar-scatter-chart.js
var PolarScatterChart = class extends scatter_chart_default {
  pointSlot(slotX, slotY) {
    const valueRadius = slotX.center.y - slotY.y1;
    const slot = point_default.onCircle(slotX.center, slotX.startAngle, valueRadius);
    return new box_default(slot.x, slot.y, slot.x, slot.y);
  }
};
setDefaultOptions(PolarScatterChart, {
  clip: false
});
var polar_scatter_chart_default = PolarScatterChart;

// node_modules/@progress/kendo-charts/dist/es/chart/polar-line-chart/polar-line-chart.js
var PolarLineChart = class extends scatter_line_chart_default {
};
PolarLineChart.prototype.pointSlot = polar_scatter_chart_default.prototype.pointSlot;
setDefaultOptions(PolarLineChart, {
  clip: false
});
var polar_line_chart_default = PolarLineChart;

// node_modules/@progress/kendo-charts/dist/es/chart/polar-area-chart/spline-polar-area-segment.js
var SplinePolarAreaSegment = class extends spline_area_segment_default {
  fillToAxes(fillPath) {
    const center = this._polarAxisCenter();
    fillPath.lineTo(center.x, center.y);
  }
  _polarAxisCenter() {
    const polarAxis = this.parent.plotArea.polarAxis;
    const center = polarAxis.box.center();
    return center;
  }
  strokeSegments() {
    let segments = this._strokeSegments;
    if (!segments) {
      const center = this._polarAxisCenter();
      const curveProcessor = new curve_processor_default(false);
      const linePoints = this.points();
      linePoints.push(center);
      segments = this._strokeSegments = curveProcessor.process(linePoints);
      segments.pop();
    }
    return segments;
  }
};
var spline_polar_area_segment_default = SplinePolarAreaSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/polar-area-chart/polar-area-segment.js
var PolarAreaSegment = class extends area_segment_default {
  fillToAxes(fillPath) {
    const polarAxis = this.parent.plotArea.polarAxis;
    const center = polarAxis.box.center();
    const centerSegment = new geometry_exports.Segment([center.x, center.y]);
    fillPath.segments.unshift(centerSegment);
    fillPath.segments.push(centerSegment);
  }
};
var polar_area_segment_default = PolarAreaSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/polar-area-chart/polar-area-chart.js
var PolarAreaChart = class extends polar_line_chart_default {
  createSegment(linePoints, currentSeries, seriesIx) {
    const style = (currentSeries.line || {}).style;
    let segment;
    if (style === SMOOTH) {
      segment = new spline_polar_area_segment_default(linePoints, currentSeries, seriesIx);
    } else {
      segment = new polar_area_segment_default(linePoints, currentSeries, seriesIx);
    }
    return segment;
  }
  createMissingValue(value2, missingValues) {
    let missingValue;
    if (hasValue(value2.x) && missingValues !== INTERPOLATE) {
      missingValue = {
        x: value2.x,
        y: value2.y
      };
      if (missingValues === ZERO) {
        missingValue.y = 0;
      }
    }
    return missingValue;
  }
  seriesMissingValues(series) {
    return series.missingValues || ZERO;
  }
  _hasMissingValuesGap() {
    const series = this.options.series;
    for (let idx = 0; idx < series.length; idx++) {
      if (this.seriesMissingValues(series[idx]) === GAP) {
        return true;
      }
    }
  }
  sortPoints(points) {
    points.sort(xComparer);
    if (this._hasMissingValuesGap()) {
      for (let idx = 0; idx < points.length; idx++) {
        const point = points[idx];
        if (point) {
          const value2 = point.value;
          if (!hasValue(value2.y) && this.seriesMissingValues(point.series) === GAP) {
            delete points[idx];
          }
        }
      }
    }
    return points;
  }
};
function xComparer(a50, b2) {
  return a50.value.x - b2.value.x;
}
var polar_area_chart_default = PolarAreaChart;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/polar-plotarea.js
var PolarPlotArea = class extends polar_plotarea_base_default {
  createPolarAxis() {
    const polarAxis = new polar_axis_default(this.options.xAxis, this.chartService);
    this.polarAxis = polarAxis;
    this.axisX = polarAxis;
    this.appendAxis(polarAxis);
  }
  render() {
    this.series = [...this.originalSeries];
    this.createTrendlineSeries();
    super.render();
  }
  valueAxisOptions(defaults) {
    return deepExtend(defaults, {
      majorGridLines: { type: ARC },
      minorGridLines: { type: ARC }
    }, this.options.yAxis);
  }
  createValueAxis() {
    super.createValueAxis();
    this.axisY = this.valueAxis;
  }
  trendlineFactory(options, series) {
    const trendline = xy_plotarea_default.prototype.trendlineFactory.call(this, options, series);
    if (trendline) {
      trendline.type = POLAR_LINE;
    }
    return trendline;
  }
  appendChart(chart, pane) {
    this.valueAxisRangeTracker.update(chart.yAxisRanges);
    plotarea_base_default.prototype.appendChart.call(this, chart, pane);
  }
  createCharts() {
    const series = this.filterVisibleSeries(this.series);
    const pane = this.panes[0];
    this.createLineChart(
      filterSeriesByType(series, [POLAR_LINE]),
      pane
    );
    this.createScatterChart(
      filterSeriesByType(series, [POLAR_SCATTER]),
      pane
    );
    this.createAreaChart(
      filterSeriesByType(series, [POLAR_AREA]),
      pane
    );
  }
  createLineChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    const lineChart = new polar_line_chart_default(this, { series });
    this.appendChart(lineChart, pane);
  }
  createScatterChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    const scatterChart = new polar_scatter_chart_default(this, { series });
    this.appendChart(scatterChart, pane);
  }
  createAreaChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    const areaChart = new polar_area_chart_default(this, { series });
    this.appendChart(areaChart, pane);
  }
  _dispatchEvent(chart, e41, eventType) {
    const coords = chart._eventCoordinates(e41);
    const point = new point_default(coords.x, coords.y);
    const xValue = this.axisX.getValue(point);
    const yValue = this.axisY.getValue(point);
    if (xValue !== null && yValue !== null) {
      chart.trigger(eventType, {
        element: eventElement(e41),
        x: xValue,
        y: yValue
      });
    }
  }
  createCrosshairs() {
  }
};
setDefaultOptions(PolarPlotArea, {
  xAxis: {},
  yAxis: {}
});
deepExtend(PolarPlotArea.prototype, plotarea_events_mixin_default, {
  seriesValues: xy_plotarea_default.prototype.seriesValues
});
var polar_plotarea_default = PolarPlotArea;

// node_modules/@progress/kendo-charts/dist/es/chart/radar-line-chart/radar-line-chart.js
function groupBySeriesIx(segments) {
  const seriesSegments = [];
  for (let idx = 0; idx < segments.length; idx++) {
    const segment = segments[idx];
    seriesSegments[segment.seriesIx] = seriesSegments[segment.seriesIx] || [];
    seriesSegments[segment.seriesIx].push(segment);
  }
  return seriesSegments;
}
var RadarLineChart = class extends line_chart_default {
  pointSlot(categorySlot, valueSlot) {
    const valueRadius = categorySlot.center.y - valueSlot.y1;
    const slot = point_default.onCircle(categorySlot.center, categorySlot.middle(), valueRadius);
    return new box_default(slot.x, slot.y, slot.x, slot.y);
  }
  renderSegments() {
    super.renderSegments();
    if (this._segments && this._segments.length > 1) {
      const seriesSegments = groupBySeriesIx(this._segments);
      for (let idx = 0; idx < seriesSegments.length; idx++) {
        const segments = seriesSegments[idx];
        if (segments && segments.length > 1) {
          const firstPoint = segments[0].linePoints[0];
          const lastSegment = last(segments);
          const lastPoint = last(lastSegment.linePoints);
          const isFirstDataPoint = firstPoint.categoryIx === 0;
          const isLastDataPoint = lastPoint.categoryIx === lastPoint.categoriesCount - 1;
          if (isFirstDataPoint && isLastDataPoint) {
            last(segments).linePoints.push(firstPoint);
          }
        }
      }
    }
  }
  createSegment(linePoints, currentSeries, seriesIx) {
    const style = currentSeries.style;
    let pointType;
    if (style === SMOOTH) {
      pointType = spline_segment_default;
    } else {
      pointType = line_segment_default;
    }
    const segment = new pointType(linePoints, currentSeries, seriesIx);
    const missingValues = this.seriesMissingValues(currentSeries);
    if (linePoints.length === currentSeries.data.length || missingValues === INTERPOLATE) {
      segment.options.closed = true;
    }
    return segment;
  }
};
setDefaultOptions(RadarLineChart, {
  clip: false,
  limitPoints: false
});
var radar_line_chart_default = RadarLineChart;

// node_modules/@progress/kendo-charts/dist/es/chart/radar-area-chart/spline-radar-area-segment.js
var SplineRadarAreaSegment = class extends spline_area_segment_default {
  fillToAxes() {
  }
};
var spline_radar_area_segment_default = SplineRadarAreaSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/radar-area-chart/radar-area-segment.js
var RadarAreaSegment = class extends area_segment_default {
  fillToAxes() {
  }
};
var radar_area_segment_default = RadarAreaSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/radar-area-chart/radar-area-chart.js
var RadarAreaChart = class extends radar_line_chart_default {
  createSegment(linePoints, currentSeries, seriesIx, prevSegment) {
    const isStacked = this.options.isStacked;
    const style = (currentSeries.line || {}).style;
    let previousSegment;
    let stackPoints;
    let segment;
    if (isStacked && seriesIx > 0 && prevSegment) {
      stackPoints = prevSegment.linePoints.slice(0);
      previousSegment = prevSegment;
    }
    if (style === SMOOTH) {
      segment = new spline_radar_area_segment_default(linePoints, currentSeries, seriesIx, previousSegment, stackPoints);
      segment.options.closed = true;
    } else {
      linePoints.push(linePoints[0]);
      segment = new radar_area_segment_default(linePoints, currentSeries, seriesIx, previousSegment, stackPoints);
    }
    return segment;
  }
  seriesMissingValues(series) {
    return series.missingValues || ZERO;
  }
};
var radar_area_chart_default = RadarAreaChart;

// node_modules/@progress/kendo-charts/dist/es/chart/radar-bar-chart/radar-segment.js
var RadarSegment = class extends donut_segment_default {
  constructor(value2, options) {
    super(value2, null, options);
  }
  getIndex() {
    return this.categoryIx;
  }
};
setDefaultOptions(RadarSegment, {
  overlay: {
    gradient: "none"
  },
  labels: {
    distance: 10
  }
});
var radar_segment_default = RadarSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/layout/radar-cluster-layout.js
var RadarClusterLayout = class extends chart_element_default {
  constructor(options) {
    super(options);
    this.forEach = options.rtl ? forEachReverse : forEach;
  }
  reflow(sector) {
    const { options, children } = this;
    const { gap, spacing } = options;
    const count = children.length;
    const slots = count + gap + spacing * (count - 1);
    const slotAngle = sector.angle / slots;
    let angle = sector.startAngle + slotAngle * (gap / 2);
    this.forEach(children, (child) => {
      const slotSector = sector.clone();
      slotSector.startAngle = angle;
      slotSector.angle = slotAngle;
      if (child.sector) {
        slotSector.radius = child.sector.radius;
      }
      child.reflow(slotSector);
      child.sector = slotSector;
      angle += slotAngle + slotAngle * spacing;
    });
  }
};
setDefaultOptions(RadarClusterLayout, {
  gap: 1,
  spacing: 0
});
var radar_cluster_layout_default = RadarClusterLayout;

// node_modules/@progress/kendo-charts/dist/es/chart/layout/radar-stack-layout.js
var RadarStackLayout = class extends chart_element_default {
  reflow(sector) {
    const { options: { reverse }, children } = this;
    const childrenCount = children.length;
    const first = reverse ? childrenCount - 1 : 0;
    const step = reverse ? -1 : 1;
    this.box = new box_default();
    for (let i37 = first; i37 >= 0 && i37 < childrenCount; i37 += step) {
      const childSector = children[i37].sector;
      childSector.startAngle = sector.startAngle;
      childSector.angle = sector.angle;
    }
  }
};
var radar_stack_layout_default = RadarStackLayout;

// node_modules/@progress/kendo-charts/dist/es/chart/radar-bar-chart/radar-bar-chart.js
var RadarBarChart = class extends bar_chart_default {
  pointType() {
    return radar_segment_default;
  }
  clusterType() {
    return radar_cluster_layout_default;
  }
  stackType() {
    return radar_stack_layout_default;
  }
  categorySlot(categoryAxis, categoryIx) {
    return categoryAxis.getSlot(categoryIx);
  }
  pointSlot(categorySlot, valueSlot) {
    const slot = categorySlot.clone();
    const y2 = categorySlot.center.y;
    slot.radius = y2 - valueSlot.y1;
    slot.innerRadius = y2 - valueSlot.y2;
    return slot;
  }
  reflowPoint(point, pointSlot) {
    point.sector = pointSlot;
    point.reflow();
  }
  createAnimation() {
    this.options.animation.center = this.box.toRect().center();
    super.createAnimation();
  }
};
RadarBarChart.prototype.reflow = categorical_chart_default.prototype.reflow;
setDefaultOptions(RadarBarChart, {
  clip: false,
  limitPoints: false,
  animation: {
    type: "pie"
  }
});
var radar_bar_chart_default = RadarBarChart;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/radar-plotarea.js
var RadarPlotArea = class extends polar_plotarea_base_default {
  createPolarAxis() {
    const categoryAxis = new radar_category_axis_default(this.options.categoryAxis, this.chartService);
    this.polarAxis = categoryAxis;
    this.categoryAxis = categoryAxis;
    this.appendAxis(categoryAxis);
    this.aggregateCategories();
    this.createTrendlineSeries();
    this.createCategoryAxesLabels();
  }
  valueAxisOptions(defaults) {
    if (this._hasBarCharts) {
      deepExtend(defaults, {
        majorGridLines: { type: ARC },
        minorGridLines: { type: ARC }
      });
    }
    if (this._isStacked100) {
      deepExtend(defaults, {
        roundToMajorUnit: false,
        labels: { format: "P0" }
      });
    }
    return deepExtend(defaults, this.options.valueAxis);
  }
  aggregateCategories() {
    categorical_plotarea_default.prototype.aggregateCategories.call(this, this.panes);
  }
  createCategoryAxesLabels() {
    categorical_plotarea_default.prototype.createCategoryAxesLabels.call(this, this.panes);
  }
  filterSeries(currentSeries) {
    return currentSeries;
  }
  trendlineFactory(options, series) {
    const trendline = categorical_plotarea_default.prototype.trendlineFactory.call(this, options, series);
    if (trendline) {
      trendline.type = RADAR_LINE;
    }
    return trendline;
  }
  createCharts() {
    const series = this.filterVisibleSeries(this.series);
    const pane = this.panes[0];
    this.createAreaChart(
      filterSeriesByType(series, [RADAR_AREA]),
      pane
    );
    this.createLineChart(
      filterSeriesByType(series, [RADAR_LINE]),
      pane
    );
    this.createBarChart(
      filterSeriesByType(series, [RADAR_COLUMN]),
      pane
    );
  }
  chartOptions(series) {
    const options = { series };
    const firstSeries = series[0];
    if (firstSeries) {
      const filteredSeries = this.filterVisibleSeries(series);
      const stack = firstSeries.stack;
      options.isStacked = stack && filteredSeries.length > 1;
      options.isStacked100 = stack && stack.type === "100%" && filteredSeries.length > 1;
      if (options.isStacked100) {
        this._isStacked100 = true;
      }
    }
    return options;
  }
  createAreaChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    const areaChart = new radar_area_chart_default(this, this.chartOptions(series));
    this.appendChart(areaChart, pane);
  }
  createLineChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    const lineChart = new radar_line_chart_default(this, this.chartOptions(series));
    this.appendChart(lineChart, pane);
  }
  createBarChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    const firstSeries = series[0];
    const options = this.chartOptions(series);
    const filteredSeries = this.filterVisibleSeries(series);
    const anyStackedSeries = filteredSeries.some((s10) => s10.stack);
    const isStacked100 = filteredSeries.some((s10) => s10.stack && s10.stack.type === "100%");
    options.gap = firstSeries.gap;
    options.spacing = firstSeries.spacing;
    options.defaultStack = firstSeries.stack && filteredSeries.length > 1;
    options.isStacked = anyStackedSeries && filteredSeries.length > 1;
    options.isStacked100 = isStacked100 && filteredSeries.length > 1;
    const barChart = new radar_bar_chart_default(this, options);
    this.appendChart(barChart, pane);
    this._hasBarCharts = true;
  }
  seriesCategoryAxis() {
    return this.categoryAxis;
  }
  _dispatchEvent(chart, e41, eventType) {
    const coords = chart._eventCoordinates(e41);
    const point = new point_default(coords.x, coords.y);
    const category = this.categoryAxis.getCategory(point);
    const value2 = this.valueAxis.getValue(point);
    if (category !== null && value2 !== null) {
      chart.trigger(eventType, {
        element: eventElement(e41),
        category,
        value: value2
      });
    }
  }
  createCrosshairs() {
  }
  _pointsByVertical(basePoint) {
    return super._pointsByVertical(basePoint).sort(this._getSeriesCompareFn());
  }
  _getSeriesCompareFn() {
    return (a50, b2) => b2.value - a50.value;
  }
};
deepExtend(RadarPlotArea.prototype, plotarea_events_mixin_default, {
  appendChart: categorical_plotarea_default.prototype.appendChart,
  aggregateSeries: categorical_plotarea_default.prototype.aggregateSeries,
  seriesSourcePoints: categorical_plotarea_default.prototype.seriesSourcePoints,
  seriesValues: categorical_plotarea_default.prototype.seriesValues
});
setDefaultOptions(RadarPlotArea, {
  categoryAxis: {
    categories: []
  },
  valueAxis: {}
});
var radar_plotarea_default = RadarPlotArea;

// node_modules/@progress/kendo-charts/dist/es/chart/funnel-chart/funnel-segment.js
var FunnelSegment = class extends chart_element_default {
  constructor(value2, options, segmentOptions) {
    super(options);
    this.value = value2;
    this.options.index = segmentOptions.index;
  }
  getLabelText(options) {
    let labelTemplate = getTemplate(options);
    if (labelTemplate) {
      return labelTemplate(this.pointData());
    } else if (options.format) {
      return this.formatValue(options.format);
    }
    return this.value;
  }
  reflow(chartBox) {
    const points = this.points;
    const label = this.children[0];
    const x1 = Math.min(points[0].x, points[3].x);
    const x22 = Math.max(points[1].x, points[2].x);
    this.box = new box_default(x1, points[0].y, x22, points[2].y);
    if (label) {
      label.reflow(new box_default(chartBox.x1, points[0].y, chartBox.x2, points[2].y));
    }
  }
  createVisual() {
    const options = this.options;
    let visual;
    super.createVisual();
    this.addAccessibilityAttributesToVisual();
    if (options.visual) {
      visual = options.visual({
        category: this.category,
        dataItem: this.dataItem,
        value: this.value,
        series: this.series,
        percentage: this.percentage,
        points: this.points,
        options,
        sender: this.getSender(),
        createVisual: () => this.createPath()
      });
    } else {
      visual = this.createPath();
    }
    if (visual) {
      this.visual.append(visual);
    }
  }
  createPath() {
    const options = this.options;
    const border = options.border;
    const path = drawing_exports.Path.fromPoints(this.points, {
      fill: createPatternFill(options.pattern, {
        color: options.color,
        opacity: options.opacity
      }),
      stroke: {
        color: border.color,
        opacity: border.opacity,
        width: border.width
      }
    }).close();
    return path;
  }
  createHighlight(style) {
    return drawing_exports.Path.fromPoints(this.points, style);
  }
  highlightVisual() {
    return this.visual.children[0];
  }
  highlightVisualArgs() {
    const path = drawing_exports.Path.fromPoints(this.points).close();
    return {
      options: this.options,
      path
    };
  }
  createFocusHighlight(style) {
    const borderWidth = this.options.focusHighlight.border.width;
    const result = drawing_exports.Path.fromPoints(this.points, deepExtend({}, style, {
      stroke: {
        width: borderWidth * 2
      }
    })).close();
    const clipPath = new drawing_exports.MultiPath();
    clipPath.paths.push(drawing_exports.Path.fromRect(this.box.clone().pad(borderWidth).toRect()));
    clipPath.paths.push(drawing_exports.Path.fromPoints(this.points));
    result.clip(clipPath);
    return result;
  }
  tooltipAnchor() {
    const box = this.box;
    return {
      point: new point_default(box.center().x, box.y1),
      align: {
        horizontal: "center",
        vertical: "top"
      }
    };
  }
  formatValue(format) {
    const point = this;
    return point.owner.formatPointValue(point, format);
  }
  pointData() {
    return {
      dataItem: this.dataItem,
      category: this.category,
      value: this.value,
      series: this.series,
      percentage: this.percentage
    };
  }
  getIndex() {
    return this.index;
  }
};
setDefaultOptions(FunnelSegment, {
  color: WHITE,
  border: {
    width: 1
  },
  labels: {
    format: ""
  },
  accessibility: {
    role: CHART_POINT_ROLE,
    className: CHART_POINT_CLASSNAME,
    ariaRoleDescription: CHART_POINT_ROLE_DESCRIPTION
  }
});
deepExtend(FunnelSegment.prototype, point_events_mixin_default);
deepExtend(FunnelSegment.prototype, accessibility_attributes_mixin_default);
var funnel_segment_default = FunnelSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/funnel-chart/funnel-chart.js
var FunnelChart = class extends chart_element_default {
  constructor(plotArea, options) {
    super(options);
    this.plotArea = plotArea;
    this.chartService = plotArea.chartService;
    this.points = [];
    this.labels = [];
    this.legendItems = [];
    this.render();
  }
  formatPointValue(point, format) {
    return this.plotArea.chartService.format.auto(format, point.value);
  }
  render() {
    const seriesIx = 0;
    const { options, plotArea: { options: { seriesColors = [] } } } = this;
    const series = options.series[seriesIx];
    const data = series.data;
    if (!data) {
      return;
    }
    const { total, points } = bindSegments(series);
    for (let i37 = 0; i37 < points.length; i37++) {
      const pointData = points[i37];
      if (!pointData) {
        continue;
      }
      let fields = pointData.fields;
      if (!isFunction(series.color)) {
        series.color = fields.color || seriesColors[i37 % seriesColors.length];
      }
      fields = deepExtend({
        index: i37,
        owner: this,
        series,
        seriesIx,
        dataItem: data[i37],
        percentage: pointData.value / total
      }, fields, { visible: pointData.visible });
      const value2 = pointData.valueFields.value;
      const segment = this.createSegment(value2, fields);
      const label = this.createLabel(value2, fields);
      if (segment && label) {
        segment.append(label);
      }
    }
  }
  evalSegmentOptions(options, value2, fields) {
    const series = fields.series;
    evalOptions(options, {
      value: value2,
      series,
      dataItem: fields.dataItem,
      index: fields.index
    }, { defaults: series._defaults, excluded: [
      "data",
      "content",
      "template",
      "toggle",
      "visual",
      "ariaTemplate",
      "ariaContent"
    ] });
  }
  createSegment(value2, fields) {
    const seriesOptions = deepExtend({}, fields.series);
    seriesOptions.pattern = fields.pattern || seriesOptions.pattern;
    this.evalSegmentOptions(seriesOptions, value2, fields);
    this.createLegendItem(value2, seriesOptions, fields);
    if (fields.visible !== false) {
      const segment = new funnel_segment_default(value2, seriesOptions, fields);
      Object.assign(segment, fields);
      this.append(segment);
      this.points.push(segment);
      return segment;
    }
  }
  createLabel(value2, fields) {
    const { series, dataItem } = fields;
    const labels = deepExtend({}, this.options.labels, series.labels);
    let text = value2;
    if (labels.visible) {
      const labelTemplate = getTemplate(labels);
      const data = {
        dataItem,
        value: value2,
        percentage: fields.percentage,
        category: fields.category,
        series
      };
      if (labelTemplate) {
        text = labelTemplate(data);
      } else if (labels.format) {
        text = this.chartService.format.auto(labels.format, text);
      }
      if (!labels.color) {
        labels.color = auto_text_color_default(series.color);
        if (!labels.background) {
          labels.background = series.color;
        }
      }
      this.evalSegmentOptions(labels, value2, fields);
      const textBox = new text_box_default(text, deepExtend({
        vAlign: labels.position
      }, labels), data);
      this.labels.push(textBox);
      return textBox;
    }
  }
  labelPadding() {
    const labels = this.labels;
    const padding = { left: 0, right: 0 };
    for (let i37 = 0; i37 < labels.length; i37++) {
      const label = labels[i37];
      const align = label.options.align;
      if (align !== CENTER) {
        const width = labels[i37].box.width();
        if (align === LEFT) {
          padding.left = Math.max(padding.left, width);
        } else {
          padding.right = Math.max(padding.right, width);
        }
      }
    }
    return padding;
  }
  dynamicSlopeReflow(box, width, totalHeight) {
    const { options, points: segments } = this;
    const count = segments.length;
    const firstSegment = segments[0];
    let maxSegment = firstSegment;
    for (let idx = 0; idx < segments.length; idx++) {
      if (segments[idx].percentage > maxSegment.percentage) {
        maxSegment = segments[idx];
      }
    }
    let lastUpperSide = firstSegment.percentage / maxSegment.percentage * width;
    let previousOffset = (width - lastUpperSide) / 2;
    let previousHeight = 0;
    for (let idx = 0; idx < count; idx++) {
      const percentage = segments[idx].percentage;
      const nextSegment = segments[idx + 1];
      const nextPercentage = nextSegment ? nextSegment.percentage : percentage;
      const points = segments[idx].points = [];
      const height = options.dynamicHeight ? totalHeight * percentage : totalHeight / count;
      let offset;
      if (!percentage) {
        offset = nextPercentage ? 0 : width / 2;
      } else {
        offset = (width - lastUpperSide * (nextPercentage / percentage)) / 2;
      }
      offset = limitValue(offset, 0, width);
      points.push(new geometry_exports.Point(box.x1 + previousOffset, box.y1 + previousHeight));
      points.push(new geometry_exports.Point(box.x1 + width - previousOffset, box.y1 + previousHeight));
      points.push(new geometry_exports.Point(box.x1 + width - offset, box.y1 + height + previousHeight));
      points.push(new geometry_exports.Point(box.x1 + offset, box.y1 + height + previousHeight));
      previousOffset = offset;
      previousHeight += height + options.segmentSpacing;
      lastUpperSide = limitValue(width - 2 * offset, 0, width);
    }
  }
  constantSlopeReflow(box, width, totalHeight) {
    const { options, points: segments } = this;
    const count = segments.length;
    const decreasingWidth = options.neckRatio <= 1;
    const neckRatio = decreasingWidth ? options.neckRatio * width : width;
    let previousOffset = decreasingWidth ? 0 : (width - width / options.neckRatio) / 2;
    const topMostWidth = decreasingWidth ? width : width - previousOffset * 2;
    const finalNarrow = (topMostWidth - neckRatio) / 2;
    let previousHeight = 0;
    for (let idx = 0; idx < count; idx++) {
      const points = segments[idx].points = [];
      const percentage = segments[idx].percentage;
      const offset = options.dynamicHeight ? finalNarrow * percentage : finalNarrow / count;
      const height = options.dynamicHeight ? totalHeight * percentage : totalHeight / count;
      points.push(new geometry_exports.Point(box.x1 + previousOffset, box.y1 + previousHeight));
      points.push(new geometry_exports.Point(box.x1 + width - previousOffset, box.y1 + previousHeight));
      points.push(new geometry_exports.Point(box.x1 + width - previousOffset - offset, box.y1 + height + previousHeight));
      points.push(new geometry_exports.Point(box.x1 + previousOffset + offset, box.y1 + height + previousHeight));
      previousOffset += offset;
      previousHeight += height + options.segmentSpacing;
    }
  }
  reflow(chartBox) {
    const points = this.points;
    const count = points.length;
    if (!count) {
      return;
    }
    const options = this.options;
    const box = chartBox.clone().unpad(this.labelPadding());
    const totalHeight = box.height() - options.segmentSpacing * (count - 1);
    const width = box.width();
    if (options.dynamicSlope) {
      this.dynamicSlopeReflow(box, width, totalHeight);
    } else {
      this.constantSlopeReflow(box, width, totalHeight);
    }
    for (let idx = 0; idx < count; idx++) {
      points[idx].reflow(chartBox);
    }
  }
};
setDefaultOptions(FunnelChart, {
  neckRatio: 0.3,
  width: 300,
  dynamicSlope: false,
  dynamicHeight: true,
  segmentSpacing: 0,
  labels: {
    visible: false,
    align: CENTER,
    position: CENTER,
    zIndex: 1
  }
});
deepExtend(FunnelChart.prototype, pie_chart_mixin_default);
var funnel_chart_default = FunnelChart;

// node_modules/@progress/kendo-charts/dist/es/chart/funnel-chart/pyramid-chart.js
var MAX_NECK_RATIO = 1e6;
var PyramidChart = class extends funnel_chart_default {
  constructor(plotArea, options) {
    options.dynamicSlope = false;
    options.neckRatio = MAX_NECK_RATIO;
    super(plotArea, options);
  }
};
var pyramid_chart_default = PyramidChart;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/funnel-plotarea.js
var FunnelPlotArea = class extends plotarea_base_default {
  render() {
    this.createChart(funnel_chart_default, filterSeriesByType(this.series, [FUNNEL]));
    this.createChart(pyramid_chart_default, filterSeriesByType(this.series, [PYRAMID]));
  }
  createChart(chartType, series) {
    const firstSeries = series[0];
    if (!firstSeries) {
      return;
    }
    const chart = new chartType(this, {
      series,
      legend: this.options.legend,
      neckRatio: firstSeries.neckRatio,
      dynamicHeight: firstSeries.dynamicHeight,
      dynamicSlope: firstSeries.dynamicSlope,
      segmentSpacing: firstSeries.segmentSpacing,
      highlight: firstSeries.highlight
    });
    this.appendChart(chart);
  }
  appendChart(chart, pane) {
    super.appendChart(chart, pane);
    append(this.options.legend.data, chart.legendItems);
  }
  _pointsByVertical(basePoint) {
    return this.pointsBySeriesIndex(basePoint.series.index);
  }
  getPointToTheRight(point) {
    return this.getPointBelow(point);
  }
  getPointToTheLeft(point) {
    return this.getPointAbove(point);
  }
};
var funnel_plotarea_default = FunnelPlotArea;

// node_modules/@progress/kendo-charts/dist/es/chart/heatmap-chart/color-scale.js
var colorScale = (color, minLightnessOffset = 0.05) => {
  const baseColor = parseColor(color);
  const offset = 1 - minLightnessOffset;
  return (value2) => {
    const hsl = baseColor.toHSL();
    const range = 100 - hsl.l;
    const point = offset - value2;
    hsl.l += Math.min(point * range, range);
    return hsl.toCss();
  };
};
var color_scale_default = colorScale;

// node_modules/@progress/kendo-charts/dist/es/chart/heatmap-chart/heatmap-point.js
var HeatmapPoint = class extends chart_element_default {
  constructor(value2, options) {
    super();
    this.options = options;
    this.color = options.color || WHITE;
    this.value = value2;
  }
  render() {
    if (this._rendered) {
      return;
    }
    this._rendered = true;
    this.createMarker();
    this.createLabel();
    this.createNote();
  }
  createLabel() {
    const options = this.options;
    const labels = options.labels;
    if (labels.visible) {
      this.label = this.createLabelElement(labels);
      this.append(this.label);
    }
  }
  createLabelElement(options) {
    let labelColor = options.color;
    if (!labelColor) {
      labelColor = auto_text_color_default(this.color);
    }
    return new text_box_default(
      this.getLabelText(options),
      deepExtend(
        {
          align: CENTER,
          vAlign: CENTER,
          margin: {
            left: 5,
            right: 5
          },
          zIndex: valueOrDefault(options.zIndex, this.series.zIndex)
        },
        options,
        {
          color: labelColor
        }
      ),
      this.pointData()
    );
  }
  getLabelText(options) {
    let labelTemplate = getTemplate(options);
    if (labelTemplate) {
      return labelTemplate(this.pointData());
    }
    return this.formatValue(options.format);
  }
  formatValue(format) {
    return this.owner.formatPointValue(this, format);
  }
  reflow(targetBox) {
    this.render();
    const label = this.label;
    this.box = targetBox;
    if (label) {
      label.reflow(this.markerBox());
    }
    if (this.note) {
      this.note.reflow(targetBox);
    }
    this.marker.reflow(this.markerBox());
  }
  createVisual() {
    super.createVisual();
    this.addAccessibilityAttributesToVisual();
  }
  markerBox() {
    const options = this.options;
    const markers = options.markers;
    const border = markers.border;
    const rect = this.box.toRect();
    const type = valueOrDefault(markers.type, "rect");
    const isRoundRect = type === ROUNDED_RECT;
    let borderWidth = valueOrDefault(border.width, isRoundRect ? 1 : 0);
    const halfBorderWidth = Math.round(borderWidth / 2);
    if (markers.size) {
      const center = rect.center();
      rect.size.width = rect.size.height = markers.size;
      rect.origin.x = Math.round(center.x - rect.size.width / 2);
      rect.origin.y = Math.round(center.y - rect.size.height / 2);
    }
    rect.size.width -= borderWidth;
    rect.size.height -= borderWidth;
    rect.origin.y += halfBorderWidth + 0.5;
    rect.origin.x += halfBorderWidth + 0.5;
    return rectToBox(rect);
  }
  markerBorder() {
    const options = this.options;
    const markers = options.markers;
    const border = markers.border;
    const opacity = valueOrDefault(border.opacity, options.opacity);
    return {
      color: border.color || this.color,
      width: border.width,
      opacity,
      dashType: border.dashType
    };
  }
  createMarker() {
    const options = this.options;
    const markerOptions = options.markers;
    const marker = new shape_element_default({
      type: valueOrDefault(markerOptions.type, "rect"),
      width: markerOptions.size,
      height: markerOptions.size,
      rotation: markerOptions.rotation,
      background: this.color,
      border: this.markerBorder(),
      pattern: options.pattern,
      borderRadius: markerOptions.borderRadius,
      opacity: this.series.opacity || options.opacity,
      zIndex: valueOrDefault(options.zIndex, this.series.zIndex),
      animation: options.animation,
      visual: options.visual
    }, {
      dataItem: this.dataItem,
      value: this.value,
      series: this.series,
      category: this.category
    });
    this.marker = marker;
    this.append(marker);
  }
  createHighlight(style) {
    const options = this.options;
    const markerOptions = this.options.highlight.markers || this.options.markers;
    const highlight = new shape_element_default({
      type: valueOrDefault(markerOptions.type, "rect"),
      width: markerOptions.size,
      height: markerOptions.size,
      rotation: markerOptions.rotation,
      background: markerOptions.color || this.color,
      border: this.markerBorder(),
      borderRadius: markerOptions.borderRadius,
      opacity: this.series.opacity || options.opacity,
      zIndex: valueOrDefault(options.zIndex, this.series.zIndex)
    });
    highlight.reflow(this.markerBox());
    const visual = highlight.getElement();
    visual.options.fill = style.fill;
    visual.options.stroke = style.stroke;
    return visual;
  }
  highlightVisual() {
    return this.rectVisual;
  }
  highlightVisualArgs() {
    return {
      options: this.options,
      rect: this.box.toRect(),
      visual: this.rectVisual
    };
  }
  createFocusHighlight() {
    const markerOptions = this.options.markers;
    const highlightOptions2 = this.options.focusHighlight;
    const highlight = new shape_element_default({
      type: valueOrDefault(markerOptions.type, "rect"),
      width: markerOptions.size,
      height: markerOptions.size,
      rotation: markerOptions.rotation,
      background: highlightOptions2.color,
      border: highlightOptions2.border,
      borderRadius: markerOptions.borderRadius,
      padding: highlightOptions2.border.width / 2,
      zIndex: highlightOptions2.zIndex
    });
    highlight.reflow(this.markerBox());
    return highlight.getElement();
  }
  tooltipAnchor() {
    const left = this.box.center().x;
    const top = this.box.y1 - TOOLTIP_OFFSET;
    return {
      point: new point_default(left, top),
      align: {
        horizontal: CENTER,
        vertical: BOTTOM
      }
    };
  }
  overlapsBox(box) {
    return this.box.overlaps(box);
  }
  unclipElements() {
  }
  pointData() {
    return {
      x: this.value.x,
      y: this.value.y,
      value: this.value.value,
      dataItem: this.dataItem,
      series: this.series
    };
  }
};
deepExtend(HeatmapPoint.prototype, point_events_mixin_default);
deepExtend(HeatmapPoint.prototype, note_mixin_default);
deepExtend(HeatmapPoint.prototype, accessibility_attributes_mixin_default);
HeatmapPoint.prototype.defaults = {
  markers: {
    type: "rect",
    borderRadius: 4,
    border: {
      color: "transparent"
    }
  },
  padding: { top: 1 },
  labels: {
    visible: false,
    padding: 3
  },
  opacity: 1,
  notes: {
    label: {}
  },
  accessibility: {
    role: CHART_POINT_ROLE,
    className: CHART_POINT_CLASSNAME,
    ariaRoleDescription: CHART_POINT_ROLE_DESCRIPTION
  }
};
var heatmap_point_default = HeatmapPoint;

// node_modules/@progress/kendo-charts/dist/es/chart/heatmap-chart/heatmap-chart.js
var HeatmapChart = class extends chart_element_default {
  constructor(plotArea, options) {
    super(options);
    this.plotArea = plotArea;
    this.chartService = plotArea.chartService;
    this._initFields();
    this.render();
  }
  _initFields() {
    this.points = [];
    this.seriesOptions = [];
    this.valueRange = { min: MAX_VALUE, max: MIN_VALUE };
    this._evalSeries = [];
  }
  render() {
    this.setRange();
    this.traverseDataPoints(this.addValue.bind(this));
  }
  setRange() {
    const { options: { series } } = this;
    for (let seriesIx = 0; seriesIx < series.length; seriesIx++) {
      const currentSeries = series[seriesIx];
      for (let pointIx = 0; pointIx < currentSeries.data.length; pointIx++) {
        const { valueFields } = this.plotArea.bindPoint(currentSeries, pointIx);
        if (defined(valueFields.value) && valueFields.value !== null) {
          this.valueRange.min = Math.min(this.valueRange.min, valueFields.value);
          this.valueRange.max = Math.max(this.valueRange.max, valueFields.value);
        }
      }
    }
  }
  addValue(value2, fields) {
    let point;
    if (value2 && defined(value2.value) && value2.value !== null) {
      point = this.createPoint(value2, fields);
      if (point) {
        Object.assign(point, fields);
      }
    }
    this.points.push(point);
  }
  evalPointOptions(options, value2, fields) {
    const { series, seriesIx } = fields;
    const state = {
      defaults: series._defaults,
      excluded: [
        "data",
        "tooltip",
        "content",
        "template",
        "visual",
        "toggle",
        "drilldownSeriesFactory",
        "ariaTemplate",
        "ariaContent"
      ]
    };
    let doEval = this._evalSeries[seriesIx];
    if (!defined(doEval)) {
      this._evalSeries[seriesIx] = doEval = evalOptions(options, {}, state, true);
    }
    let pointOptions = options;
    if (doEval) {
      pointOptions = deepExtend({}, options);
      evalOptions(pointOptions, {
        value: value2,
        series,
        dataItem: fields.dataItem,
        min: this.valueRange.min,
        max: this.valueRange.max
      }, state);
    }
    return pointOptions;
  }
  pointType() {
    return heatmap_point_default;
  }
  pointOptions(series, seriesIx) {
    let options = this.seriesOptions[seriesIx];
    if (!options) {
      const defaults = this.pointType().prototype.defaults;
      this.seriesOptions[seriesIx] = options = deepExtend({}, defaults, {
        markers: {
          opacity: series.opacity
        },
        tooltip: {
          format: this.options.tooltip.format
        },
        labels: {
          format: this.options.labels.format
        }
      }, series);
    }
    return Object.assign({}, options);
  }
  createPoint(value2, fields) {
    const series = fields.series;
    let pointOptions = this.pointOptions(series, fields.seriesIx);
    let color = fields.color || series.color;
    pointOptions.pattern = fields.pattern || pointOptions.pattern;
    pointOptions = this.evalPointOptions(pointOptions, value2, fields);
    if (isFunction(series.color)) {
      color = pointOptions.color;
    } else if (this.valueRange.max !== 0) {
      const scale = color_scale_default(color);
      color = scale(value2.value / this.valueRange.max);
    }
    const point = new heatmap_point_default(value2, pointOptions);
    point.color = color;
    this.append(point);
    return point;
  }
  seriesAxes(series) {
    const { xAxis: xAxisName, yAxis: yAxisName } = series;
    const plotArea = this.plotArea;
    const xAxis = xAxisName ? plotArea.namedXAxes[xAxisName] : plotArea.axisX;
    const yAxis = yAxisName ? plotArea.namedYAxes[yAxisName] : plotArea.axisY;
    if (!xAxis) {
      throw new Error("Unable to locate X axis with name " + xAxisName);
    }
    if (!yAxis) {
      throw new Error("Unable to locate Y axis with name " + yAxisName);
    }
    return { xAxis, yAxis };
  }
  reflow(targetBox) {
    const chartPoints = this.points;
    const limit = !this.options.clip;
    let pointIx = 0;
    this.traverseDataPoints((value2, fields) => {
      const point = chartPoints[pointIx++];
      const { xAxis, yAxis } = this.seriesAxes(fields.series);
      const indexX = xAxis.categoryIndex(value2.x);
      const indexY = yAxis.categoryIndex(value2.y);
      const slotX = xAxis.getSlot(indexX, indexX, limit);
      const slotY = yAxis.getSlot(indexY, indexY, limit);
      if (point) {
        if (slotX && slotY) {
          const pointSlot = this.pointSlot(slotX, slotY);
          point.reflow(pointSlot);
        } else {
          point.visible = false;
        }
      }
    });
    this.box = targetBox;
  }
  pointSlot(slotX, slotY) {
    return new box_default(slotX.x1, slotY.y1, slotX.x2, slotY.y2);
  }
  traverseDataPoints(callback) {
    const { options: { series } } = this;
    for (let seriesIx = 0; seriesIx < series.length; seriesIx++) {
      const currentSeries = series[seriesIx];
      const { xAxis, yAxis } = this.seriesAxes(currentSeries);
      const xRange = xAxis.currentRangeIndices();
      const yRange = yAxis.currentRangeIndices();
      for (let pointIx = 0; pointIx < currentSeries.data.length; pointIx++) {
        const { valueFields: value2, fields } = this.plotArea.bindPoint(currentSeries, pointIx);
        const xIndex = xAxis.totalIndex(value2.x);
        const yIndex = yAxis.totalIndex(value2.y);
        const xIn = xRange.min <= xIndex && xIndex <= xRange.max;
        const yIn = yRange.min <= yIndex && yIndex <= yRange.max;
        if (xIn && yIn) {
          callback(value2, deepExtend({
            pointIx,
            series: currentSeries,
            seriesIx,
            dataItem: currentSeries.data[pointIx],
            owner: this
          }, fields));
        }
      }
    }
  }
  formatPointValue(point, format) {
    const value2 = point.value;
    return this.chartService.format.auto(format, value2.x, value2.y, value2.value);
  }
  animationPoints() {
    const points = this.points;
    const result = [];
    for (let idx = 0; idx < points.length; idx++) {
      result.push((points[idx] || {}).marker);
    }
    return result;
  }
};
setDefaultOptions(HeatmapChart, {
  series: [],
  tooltip: {
    format: "{0}, {1}: {2}"
  },
  labels: {
    format: "{2}"
  },
  clip: true
});
var heatmap_chart_default = HeatmapChart;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/heatmap-plotarea.js
var HeatmapPlotArea = class extends plotarea_base_default {
  initFields() {
    this.namedXAxes = {};
    this.namedYAxes = {};
  }
  render(panes = this.panes) {
    this.bindCategories();
    this.createAxes(panes);
    this.createCharts(panes);
    this.createAxisLabels();
  }
  bindCategories() {
    const series = this.srcSeries || this.series;
    for (let i37 = 0; i37 < series.length; i37++) {
      const currentSeries = series[i37];
      const data = currentSeries.data || [];
      const { xAxis, yAxis } = this.seriesAxes(currentSeries);
      const xCategories = createHashSet(xAxis.categories || []);
      const yCategories = createHashSet(yAxis.categories || []);
      for (let pointIndex = 0; pointIndex < data.length; pointIndex++) {
        const { x: x7, y: y2 } = series_binder_default.current.bindPoint(currentSeries, pointIndex).valueFields;
        if (!xCategories.has(x7)) {
          xCategories.add(x7);
        }
        if (!yCategories.has(y2)) {
          yCategories.add(y2);
        }
      }
      xAxis.categories = xCategories.values();
      yAxis.categories = yCategories.values();
    }
  }
  createCharts(panes) {
    const seriesByPane = this.groupSeriesByPane();
    for (let i37 = 0; i37 < panes.length; i37++) {
      const pane = panes[i37];
      const paneSeries = seriesByPane[pane.options.name || "default"] || [];
      this.addToLegend(paneSeries);
      const filteredSeries = this.filterVisibleSeries(paneSeries);
      if (!filteredSeries) {
        continue;
      }
      this.createHeatmapChart(
        filterSeriesByType(filteredSeries, [HEATMAP]),
        pane
      );
    }
  }
  createHeatmapChart(series, pane) {
    const chart = new heatmap_chart_default(this, {
      series
    });
    this.appendChart(chart, pane);
  }
  seriesPaneName(series) {
    const options = this.options;
    const xAxisName = series.xAxis;
    const xAxisOptions = [].concat(options.xAxis);
    const xAxis = grep_default(xAxisOptions, function(a50) {
      return a50.name === xAxisName;
    })[0];
    const yAxisName = series.yAxis;
    const yAxisOptions = [].concat(options.yAxis);
    const yAxis = grep_default(yAxisOptions, function(a50) {
      return a50.name === yAxisName;
    })[0];
    const panes = options.panes || [{}];
    const defaultPaneName = panes[0].name || "default";
    const paneName = (xAxis || {}).pane || (yAxis || {}).pane || defaultPaneName;
    return paneName;
  }
  seriesAxes(series) {
    let xAxis;
    let yAxis;
    const options = this.options;
    const xAxisOptions = [].concat(options.xAxis);
    const xAxisName = series.xAxis;
    if (xAxisName) {
      xAxis = xAxisOptions.find((axis) => axis.name === xAxisName);
    } else {
      xAxis = xAxisOptions[0];
    }
    const yAxisOptions = [].concat(options.yAxis);
    const yAxisName = series.yAxis;
    if (yAxisName) {
      yAxis = yAxisOptions.find((axis) => axis.name === yAxisName);
    } else {
      yAxis = yAxisOptions[0];
    }
    if (!xAxis) {
      throw new Error("Unable to locate X axis with name " + xAxisName);
    }
    if (!yAxis) {
      throw new Error("Unable to locate Y axis with name " + yAxisName);
    }
    return { xAxis, yAxis };
  }
  createAxisLabels() {
    const axes = this.axes;
    for (let i37 = 0; i37 < axes.length; i37++) {
      axes[i37].createLabels();
    }
  }
  createXYAxis(options, vertical, axisIndex) {
    const axisName = options.name;
    const namedAxes = vertical ? this.namedYAxes : this.namedXAxes;
    const axisOptions2 = Object.assign({
      axisCrossingValue: 0
    }, options, {
      vertical,
      reverse: vertical || this.chartService.rtl ? !options.reverse : options.reverse,
      justified: false
    });
    const firstCategory = axisOptions2.categories ? axisOptions2.categories[0] : null;
    const typeSamples = [axisOptions2.min, axisOptions2.max, firstCategory];
    const series = this.series;
    for (let seriesIx = 0; seriesIx < series.length; seriesIx++) {
      const currentSeries = series[seriesIx];
      const seriesAxisName = currentSeries[vertical ? "yAxis" : "xAxis"];
      if (seriesAxisName === axisOptions2.name || axisIndex === 0 && !seriesAxisName) {
        const firstPointValue = series_binder_default.current.bindPoint(currentSeries, 0).valueFields;
        typeSamples.push(firstPointValue[vertical ? "y" : "x"]);
        break;
      }
    }
    let inferredDate;
    for (let i37 = 0; i37 < typeSamples.length; i37++) {
      if (typeSamples[i37] instanceof Date) {
        inferredDate = true;
        break;
      }
    }
    let axisType;
    if (equalsIgnoreCase(axisOptions2.type, DATE) || !axisOptions2.type && inferredDate) {
      axisType = date_category_axis_default;
    } else {
      axisType = category_axis_default;
    }
    const axis = new axisType(axisOptions2, this.chartService);
    axis.axisIndex = axisIndex;
    if (axisName) {
      if (namedAxes[axisName]) {
        throw new Error(`${vertical ? "Y" : "X"} axis with name ${axisName} is already defined`);
      }
      namedAxes[axisName] = axis;
    }
    this.appendAxis(axis);
    axis.indexCategories();
    return axis;
  }
  createAxes(panes) {
    const options = this.options;
    const xAxesOptions = [].concat(options.xAxis);
    const xAxes = [];
    const yAxesOptions = [].concat(options.yAxis);
    const yAxes = [];
    for (let idx = 0; idx < xAxesOptions.length; idx++) {
      const axisPane = this.findPane(xAxesOptions[idx].pane);
      if (inArray(axisPane, panes)) {
        xAxes.push(this.createXYAxis(xAxesOptions[idx], false, idx));
      }
    }
    for (let idx = 0; idx < yAxesOptions.length; idx++) {
      const axisPane = this.findPane(yAxesOptions[idx].pane);
      if (inArray(axisPane, panes)) {
        yAxes.push(this.createXYAxis(yAxesOptions[idx], true, idx));
      }
    }
    this.axisX = this.axisX || xAxes[0];
    this.axisY = this.axisY || yAxes[0];
  }
  removeAxis(axis) {
    const axisName = axis.options.name;
    super.removeAxis(axis);
    if (axis.options.vertical) {
      delete this.namedYAxes[axisName];
    } else {
      delete this.namedXAxes[axisName];
    }
    if (axis === this.axisX) {
      delete this.axisX;
    }
    if (axis === this.axisY) {
      delete this.axisY;
    }
  }
  _dispatchEvent(chart, e41, eventType) {
    const coords = chart._eventCoordinates(e41);
    const point = new point_default(coords.x, coords.y);
    const allAxes = this.axes;
    const length = allAxes.length;
    const xValues = [];
    const yValues = [];
    for (let i37 = 0; i37 < length; i37++) {
      const axis = allAxes[i37];
      const values = axis.options.vertical ? yValues : xValues;
      appendIfNotNull(values, axis.getCategory(point));
    }
    if (xValues.length > 0 && yValues.length > 0) {
      chart.trigger(eventType, {
        element: eventElement(e41),
        originalEvent: e41,
        x: singleItemOrArray(xValues),
        y: singleItemOrArray(yValues)
      });
    }
  }
  updateAxisOptions(axis, options) {
    const vertical = axis.options.vertical;
    const axes = this.groupAxes(this.panes);
    const index = (vertical ? axes.y : axes.x).indexOf(axis);
    updateAxisOptions3(this.options, index, vertical, options);
    updateAxisOptions3(this.originalOptions, index, vertical, options);
  }
  crosshairOptions(axis) {
    return Object.assign({}, axis.options.crosshair, { zIndex: 0 });
  }
  _pointsByVertical(basePoint, offset = 0) {
    const normalizedOffset = this.axisX.options.reverse ? offset * -1 : offset;
    const axisXItems = this.axisX.children;
    let xIndex = this._getPointAxisXIndex(basePoint) + normalizedOffset;
    xIndex = cycleIndex(xIndex, axisXItems.length);
    const targetXValue = axisXItems[xIndex].value;
    const points = this.filterPoints((point) => compareValues(point.pointData().x, targetXValue)).sort((a50, b2) => this._getPointAxisYIndex(a50) - this._getPointAxisYIndex(b2));
    if (this.axisY.options.reverse) {
      return points.reverse();
    }
    return points;
  }
  _pointsByHorizontal(basePoint, offset = 0) {
    const normalizedOffset = this.axisY.options.reverse ? offset * -1 : offset;
    const axisYItems = this.axisY.children;
    let yIndex = this._getPointAxisYIndex(basePoint) + normalizedOffset;
    yIndex = cycleIndex(yIndex, axisYItems.length);
    const targetYValue = axisYItems[yIndex].value;
    const points = this.filterPoints((point) => compareValues(point.pointData().y, targetYValue)).sort((a50, b2) => this._getPointAxisXIndex(a50) - this._getPointAxisXIndex(b2));
    if (this.axisX.options.reverse) {
      return points.reverse();
    }
    return points;
  }
  _getPointAxisXIndex(point) {
    return this._getPointAxisIndex(this.axisX, point.pointData().x);
  }
  _getPointAxisYIndex(point) {
    return this._getPointAxisIndex(this.axisY, point.pointData().y);
  }
  _getPointAxisIndex(axis, pointValue) {
    return axis.children.findIndex((axisItem) => compareValues(pointValue, axisItem.value));
  }
};
function compareValues(a50, b2) {
  if (a50 instanceof Date && b2 instanceof Date) {
    return dateEquals(a50, b2);
  }
  return a50 === b2;
}
function updateAxisOptions3(targetOptions, axisIndex, vertical, options) {
  const axisOptions2 = [].concat(vertical ? targetOptions.yAxis : targetOptions.xAxis)[axisIndex];
  deepExtend(axisOptions2, options);
}
setDefaultOptions(HeatmapPlotArea, {
  xAxis: {},
  yAxis: {}
});
deepExtend(HeatmapPlotArea.prototype, plotarea_events_mixin_default);
var heatmap_plotarea_default = HeatmapPlotArea;

// node_modules/@progress/kendo-charts/dist/es/chart/register-charts.js
var COLOR = "color";
var FIRST = "first";
var FROM = "from";
var MAX = "max";
var MIN = "min";
var NOTE_TEXT = "noteText";
var SUMMARY_FIELD = "summary";
var TO = "to";
plotarea_factory_default.current.register(categorical_plotarea_default, [
  BAR,
  COLUMN,
  LINE,
  VERTICAL_LINE,
  AREA,
  VERTICAL_AREA,
  CANDLESTICK,
  OHLC,
  BULLET,
  VERTICAL_BULLET,
  BOX_PLOT,
  VERTICAL_BOX_PLOT,
  RANGE_COLUMN,
  RANGE_BAR,
  WATERFALL,
  HORIZONTAL_WATERFALL,
  RANGE_AREA,
  VERTICAL_RANGE_AREA,
  ...TRENDLINE_SERIES
]);
plotarea_factory_default.current.register(xy_plotarea_default, [
  SCATTER,
  SCATTER_LINE,
  BUBBLE,
  ...TRENDLINE_SERIES
]);
plotarea_factory_default.current.register(pie_plotarea_default, [PIE]);
plotarea_factory_default.current.register(donut_plotarea_default, [DONUT]);
plotarea_factory_default.current.register(funnel_plotarea_default, [FUNNEL, PYRAMID]);
plotarea_factory_default.current.register(polar_plotarea_default, [
  POLAR_AREA,
  POLAR_LINE,
  POLAR_SCATTER,
  ...TRENDLINE_SERIES
]);
plotarea_factory_default.current.register(radar_plotarea_default, [
  RADAR_AREA,
  RADAR_COLUMN,
  RADAR_LINE,
  ...TRENDLINE_SERIES
]);
plotarea_factory_default.current.register(heatmap_plotarea_default, [HEATMAP]);
series_binder_default.current.register(
  [BAR, COLUMN, LINE, VERTICAL_LINE, AREA, VERTICAL_AREA],
  [VALUE],
  [CATEGORY, COLOR, NOTE_TEXT, ERROR_LOW_FIELD, ERROR_HIGH_FIELD, DRILLDOWN_FIELD, PATTERN_FIELD]
);
series_binder_default.current.register(
  [RANGE_COLUMN, RANGE_BAR, RANGE_AREA, VERTICAL_RANGE_AREA],
  [FROM, TO],
  [CATEGORY, COLOR, NOTE_TEXT, DRILLDOWN_FIELD, PATTERN_FIELD]
);
series_binder_default.current.register(
  [WATERFALL, HORIZONTAL_WATERFALL],
  [VALUE],
  [CATEGORY, COLOR, NOTE_TEXT, SUMMARY_FIELD, DRILLDOWN_FIELD, PATTERN_FIELD]
);
series_binder_default.current.register([POLAR_AREA, POLAR_LINE, POLAR_SCATTER], [X, Y], [COLOR, DRILLDOWN_FIELD, PATTERN_FIELD]);
series_binder_default.current.register([RADAR_AREA, RADAR_COLUMN, RADAR_LINE], [VALUE], [CATEGORY, COLOR, DRILLDOWN_FIELD, PATTERN_FIELD]);
series_binder_default.current.register(
  [FUNNEL, PYRAMID],
  [VALUE],
  [CATEGORY, COLOR, "visibleInLegend", "visible", DRILLDOWN_FIELD, PATTERN_FIELD]
);
default_aggregates_default.current.register(
  [BAR, COLUMN, LINE, VERTICAL_LINE, AREA, VERTICAL_AREA, WATERFALL, HORIZONTAL_WATERFALL],
  { value: MAX, color: FIRST, noteText: FIRST, errorLow: MIN, errorHigh: MAX }
);
default_aggregates_default.current.register(
  [RANGE_COLUMN, RANGE_BAR, RANGE_AREA, VERTICAL_RANGE_AREA],
  { from: MIN, to: MAX, color: FIRST, noteText: FIRST }
);
default_aggregates_default.current.register(
  [RADAR_AREA, RADAR_COLUMN, RADAR_LINE],
  { value: MAX, color: FIRST }
);
series_binder_default.current.register(
  [SCATTER, SCATTER_LINE, BUBBLE],
  [X, Y],
  [COLOR, NOTE_TEXT, X_ERROR_LOW_FIELD, X_ERROR_HIGH_FIELD, Y_ERROR_LOW_FIELD, Y_ERROR_HIGH_FIELD]
);
series_binder_default.current.register(
  [BUBBLE],
  [X, Y, "size"],
  [COLOR, CATEGORY, NOTE_TEXT, PATTERN_FIELD]
);
series_binder_default.current.register(
  [HEATMAP],
  [X, Y, VALUE],
  [COLOR, NOTE_TEXT, PATTERN_FIELD]
);
series_binder_default.current.register(
  [CANDLESTICK, OHLC],
  ["open", "high", "low", "close"],
  [CATEGORY, COLOR, "downColor", NOTE_TEXT, PATTERN_FIELD]
);
default_aggregates_default.current.register(
  [CANDLESTICK, OHLC],
  {
    open: MAX,
    high: MAX,
    low: MIN,
    close: MAX,
    color: FIRST,
    downColor: FIRST,
    noteText: FIRST
  }
);
series_binder_default.current.register(
  [BOX_PLOT, VERTICAL_BOX_PLOT],
  ["lower", "q1", "median", "q3", "upper", "mean", "outliers"],
  [CATEGORY, COLOR, NOTE_TEXT, DRILLDOWN_FIELD, PATTERN_FIELD]
);
default_aggregates_default.current.register(
  [BOX_PLOT, VERTICAL_BOX_PLOT],
  {
    lower: MAX,
    q1: MAX,
    median: MAX,
    q3: MAX,
    upper: MAX,
    mean: MAX,
    outliers: FIRST,
    color: FIRST,
    noteText: FIRST
  }
);
series_binder_default.current.register(
  [BULLET, VERTICAL_BULLET],
  ["current", "target"],
  [CATEGORY, COLOR, "visibleInLegend", NOTE_TEXT, DRILLDOWN_FIELD, PATTERN_FIELD]
);
default_aggregates_default.current.register(
  [BULLET, VERTICAL_BULLET],
  { current: MAX, target: MAX, color: FIRST, noteText: FIRST }
);
series_binder_default.current.register(
  [PIE, DONUT],
  [VALUE],
  [CATEGORY, COLOR, "explode", "visibleInLegend", "visible", DRILLDOWN_FIELD, PATTERN_FIELD]
);

// node_modules/@progress/kendo-charts/dist/es/chart/chart.js
var AXIS_NAMES = [CATEGORY, VALUE, X, Y];
var MOUSEDOWN = "mousedown";
var MOUSEMOVE = "mousemove";
var CONTEXTMENU = "contextmenu";
var MOUSELEAVE = "mouseleave";
var KEYDOWN = "keydown";
var FOCUS = "focus";
var BLUR = "blur";
var MOUSEMOVE_DELAY = 20;
var NO_DATA_OVERLAY_TOP_CLASS = "k-chart-overlay-top";
var Chart = class {
  constructor(element, userOptions, themeOptions, context = {}) {
    this.observers = [];
    this.addObserver(context.observer);
    this.chartService = new chart_service_default(this, context);
    this.chartService.theme = themeOptions;
    this._initElement(element);
    const options = deepExtend({}, this.options, userOptions);
    this._originalOptions = deepExtend({}, options);
    this._theme = themeOptions;
    this._initTheme(options, themeOptions);
    this._focusState = {};
    this._initHandlers();
    this._createSurface = context.createSurface || drawing_exports.Surface.create.bind(drawing_exports.Surface);
    this._initSurface();
    this.bindCategories();
    font_loader_default.preloadFonts(userOptions, () => {
      this.fontLoaded = true;
      if (!this._destroyed) {
        this.trigger("init");
        this._redraw();
        this._attachEvents();
        this._restoreOverlayElement();
      }
    });
  }
  _initElement(element) {
    this._setElementClass(element);
    element.style.position = "relative";
    element.tabIndex = element.getAttribute("tabindex") ? element.getAttribute("tabindex") : 0;
    element.setAttribute("role", "graphics-document document");
    for (let i37 = element.childNodes.length - 1; i37 >= 0; i37--) {
      const child = element.childNodes[i37];
      if (!hasClasses(child, "k-chart-overlay")) {
        element.removeChild(child);
      } else {
        this.overlayElement = child;
      }
    }
    this.element = element;
  }
  _setElementClass(element) {
    addClass(element, "k-chart");
  }
  _restoreOverlayElement() {
    if (!this.overlayElement) {
      return;
    }
    if (this._hasSeriesData()) {
      this.overlayElement.style.display = "none";
    } else {
      if (!this.options.title || this.options.title && this.options.title.position !== BOTTOM) {
        addClass(this.overlayElement, NO_DATA_OVERLAY_TOP_CLASS);
      } else {
        removeClass(this.overlayElement, NO_DATA_OVERLAY_TOP_CLASS);
      }
      this.overlayElement.style.display = "";
    }
    if (this.overlayElement.parentElement !== this.element) {
      this.element.appendChild(this.overlayElement);
    }
  }
  _hasSeriesData() {
    const series = this.options.series || [];
    const hasData = series.length > 0 && series.some((x7) => x7.data && x7.data.length > 0);
    return hasData;
  }
  _initTheme(options, themeOptions) {
    const seriesCopies = [];
    const series = options.series || [];
    for (let i37 = 0; i37 < series.length; i37++) {
      seriesCopies.push(Object.assign({}, series[i37]));
    }
    options.series = seriesCopies;
    resolveAxisAliases(options);
    this.applyDefaults(options, themeOptions);
    if (options.seriesColors === null) {
      delete options.seriesColors;
    }
    if (isString(options.title)) {
      options.title = { text: options.title };
    }
    this.options = deepExtend({}, themeOptions, options);
    this.applySeriesColors();
  }
  getSize() {
    const chartArea = this.options.chartArea || {};
    const width = chartArea.width ? parseInt(chartArea.width, 10) : Math.floor(this.element.offsetWidth);
    const height = chartArea.height ? parseInt(chartArea.height, 10) : Math.floor(this.element.offsetHeight);
    return {
      width,
      height
    };
  }
  resize(force) {
    const size = this.getSize();
    const currentSize = this._size;
    const hasSize = size.width > 0 || size.height > 0;
    if (force || hasSize && (!currentSize || size.width !== currentSize.width || size.height !== currentSize.height)) {
      this._size = size;
      this._resize(size, force);
      this.trigger("resize", size);
    } else if (hasSize && this._selections && find(this._selections, (s10) => !s10.visible)) {
      this._destroySelections();
      this._setupSelection();
    }
  }
  _resize() {
    this._noTransitionsRedraw();
  }
  redraw(paneName) {
    this.applyDefaults(this.options);
    this.applySeriesColors();
    if (paneName) {
      const plotArea = this._model._plotArea;
      const pane = plotArea.findPane(paneName);
      plotArea.redraw(pane);
    } else {
      this._redraw();
    }
  }
  getAxis(name) {
    return findAxisByName(name, this._plotArea.axes);
  }
  findAxisByName(name) {
    return this.getAxis(name);
  }
  findPaneByName(name) {
    const panes = this._plotArea.panes;
    for (let idx = 0; idx < panes.length; idx++) {
      if (panes[idx].options.name === name) {
        return new chart_pane_default(panes[idx]);
      }
    }
  }
  findPaneByIndex(idx) {
    const panes = this._plotArea.panes;
    if (panes[idx]) {
      return new chart_pane_default(panes[idx]);
    }
  }
  plotArea() {
    return new chart_plotarea_default(this._plotArea);
  }
  toggleHighlight(show2, filter) {
    const plotArea = this._plotArea;
    const firstSeries = (plotArea.srcSeries || plotArea.series || [])[0];
    let points;
    if (isFunction(filter)) {
      points = plotArea.filterPoints(filter);
    } else {
      let seriesName, categoryName;
      if (isObject(filter)) {
        seriesName = filter.series;
        categoryName = filter.category;
      } else {
        seriesName = categoryName = filter;
      }
      if (firstSeries.type === DONUT) {
        points = pointByCategoryName(plotArea.pointsBySeriesName(seriesName), categoryName);
      } else if (inArray(firstSeries.type, [PIE, FUNNEL, PYRAMID])) {
        points = pointByCategoryName((plotArea.charts[0] || {}).points, categoryName);
      } else {
        points = plotArea.pointsBySeriesName(seriesName);
      }
    }
    if (points) {
      this.togglePointsHighlight(show2, points);
    }
  }
  togglePointsHighlight(show2, points) {
    const highlight = this._highlight;
    for (let idx = 0; idx < points.length; idx++) {
      highlight.togglePointHighlight(points[idx], show2);
    }
  }
  showTooltip(filter) {
    const shared = this._sharedTooltip();
    const { _tooltip: tooltip, _plotArea: plotArea } = this;
    let point, categoryIndex;
    if (isFunction(filter)) {
      point = plotArea.findPoint(filter);
      if (point && shared) {
        categoryIndex = point.categoryIx;
      }
    } else if (shared && defined(filter)) {
      categoryIndex = plotArea.categoryAxis.categoryIndex(filter);
    }
    if (shared) {
      if (categoryIndex >= 0) {
        const points = this._plotArea.pointsByCategoryIndex(categoryIndex);
        tooltip.showAt(points);
      }
    } else if (point) {
      tooltip.show(point);
    }
  }
  hideTooltip() {
    this._tooltip.hide();
  }
  _initSurface() {
    const surface = this.surface;
    const wrap = this._surfaceWrap();
    const chartArea = this.options.chartArea || {};
    if (chartArea.width) {
      elementSize(wrap, { width: chartArea.width });
    }
    if (chartArea.height) {
      elementSize(wrap, { height: chartArea.height });
    }
    if (!surface || surface.options.type !== this.options.renderAs) {
      this._destroySurface();
      this.surface = this._createSurface(wrap, {
        type: this.options.renderAs
      });
      this.surface.bind("mouseenter", this._surfaceMouseenterHandler);
      this.surface.bind("mouseleave", this._surfaceMouseleaveHandler);
    } else {
      this.surface.clear();
      this.surface.resize();
    }
    this.element._kendoExportVisual = this._kendoExportVisual.bind(this);
  }
  _surfaceWrap() {
    return this.element;
  }
  _redraw() {
    const model = this._getModel();
    this._size = {
      width: model.options.width,
      height: model.options.height
    };
    this._destroyView();
    this._setElementAccessibilityAttributes();
    this._model = model;
    this._plotArea = model._plotArea;
    this._legend = model._legend;
    model.renderVisual();
    const transitions = this.options.transitions;
    if (transitions !== false) {
      model.traverse(function(element) {
        if (element.animation) {
          const loading = transitions && transitions !== true ? transitions.loading : transitions;
          element.animation.options = Object.assign({}, element.animation.options, loading);
          element.animation.setup();
        }
      });
    }
    this._initSurface();
    this.surface.draw(model.visual);
    if (transitions !== false) {
      model.traverse(function(element) {
        if (element.animation) {
          element.animation.play();
        }
      });
    }
    this._tooltip = this._createTooltip();
    this._highlight = new highlight_default();
    this._setupSelection();
    this._createPannable();
    this._createZoomSelection();
    this._createMousewheelZoom();
    this._setComputedStyles();
    this.trigger(RENDER);
    triggerPaneRender(this._plotArea.panes);
    if (!this._navState) {
      this._cancelDomEvents();
    }
    this._redrawFocusHighlight();
  }
  _setComputedStyles() {
    const titleHeight = this.titleHeight();
    this.element.style.setProperty("--kendo-chart-computed-title-height", `${titleHeight}px`);
  }
  _redrawFocusHighlight() {
    if (this._destroyed) {
      return;
    }
    const { _focusState: { legendInFocus, preserveHighlight } } = this;
    if (legendInFocus && preserveHighlight) {
      this._focusElement(this._getFocusedLegendItem(), false);
      this._focusState.preserveHighlight = false;
    }
  }
  _setElementAccessibilityAttributes() {
    let titleOptions = this.options.title;
    let title3 = isString(titleOptions) ? titleOptions : titleOptions.description || titleOptions.text;
    if (title3) {
      this.element.setAttribute("aria-roledescription", title3);
    }
  }
  _kendoExportVisual(size) {
    if (size && size.width && size.height) {
      const chartArea = this._originalOptions.chartArea || {};
      const exportOptions = {
        width: chartArea.width || size.width,
        height: chartArea.height || size.height
      };
      return this.exportVisual(exportOptions);
    }
    return this.exportVisual();
  }
  exportVisual(exportOptions) {
    let visual;
    if (exportOptions && (exportOptions.width || exportOptions.height || exportOptions.options)) {
      const currentOptions = this.options;
      const options = deepExtend({}, exportOptions.options, {
        chartArea: {
          width: exportOptions.width,
          height: exportOptions.height
        }
      });
      clearMissingValues(this._originalOptions, options);
      this.options = deepExtend({}, this._originalOptions, options);
      this._initTheme(this.options, this._theme);
      this.bindCategories();
      const model = this._getModel();
      model.renderVisual();
      triggerPaneRender(model._plotArea.panes);
      visual = model.visual;
      this.options = currentOptions;
    } else {
      visual = this.surface.exportVisual();
    }
    return visual;
  }
  _sharedTooltip() {
    return this._plotArea instanceof categorical_plotarea_default && this.options.tooltip && this.options.tooltip.shared;
  }
  _createPannable() {
    const options = this.options;
    if (options.pannable !== false) {
      this._pannable = new pannable_default(this._plotArea, options.pannable);
    }
  }
  _createZoomSelection() {
    const zoomable = this.options.zoomable;
    const selection = (zoomable || {}).selection;
    if (zoomable !== false && selection !== false) {
      this._zoomSelection = new zoom_selection_default(this, selection);
    }
  }
  _createMousewheelZoom() {
    const zoomable = this.options.zoomable;
    const mousewheel = (zoomable || {}).mousewheel;
    if (zoomable !== false && mousewheel !== false) {
      this._mousewheelZoom = new mousewheel_zoom_default(this, mousewheel);
    }
  }
  _toggleDragZoomEvents() {
    const pannable = this.options.pannable;
    const zoomable = this.options.zoomable;
    const selection = (zoomable || {}).selection;
    const mousewheel = (zoomable || {}).mousewheel;
    const allowDrag = !pannable && (zoomable === false || selection === false) && !this.requiresHandlers([DRAG_START, DRAG, DRAG_END]);
    const allowZoom = (zoomable === false || mousewheel === false) && !this.requiresHandlers([ZOOM_START, ZOOM, ZOOM_END]);
    const element = this.element;
    if (this._dragZoomEnabled && allowDrag && allowZoom) {
      element.style.touchAction = this._touchAction || "";
      this._dragZoomEnabled = false;
    } else if (!this._dragZoomEnabled && !(allowDrag && allowZoom)) {
      element.style.touchAction = "none";
      this._dragZoomEnabled = true;
    }
    this._toggleDomEvents(!allowDrag, !allowZoom);
  }
  _toggleDomEvents(drag, zoom) {
    const domEvents = this.domEvents;
    if (!domEvents) {
      return;
    }
    if (domEvents.toggleDrag) {
      domEvents.toggleDrag(drag);
    }
    if (domEvents.toggleZoom) {
      domEvents.toggleZoom(zoom);
    }
  }
  _createTooltip() {
    const { options: { tooltip: tooltipOptions } } = this;
    let tooltip;
    if (this._sharedTooltip()) {
      tooltip = this._createSharedTooltip(tooltipOptions);
    } else {
      tooltip = new tooltip_default(this.chartService, tooltipOptions);
    }
    return tooltip;
  }
  _createSharedTooltip(options) {
    return new shared_tooltip_default(this._plotArea, options);
  }
  applyDefaults(options, themeOptions) {
    applyAxisDefaults(options, themeOptions);
    applySeriesDefaults(options, themeOptions);
  }
  applySeriesColors() {
    const options = this.options;
    const series = options.series;
    const colors = options.seriesColors || [];
    for (let i37 = 0; i37 < series.length; i37++) {
      const currentSeries = series[i37];
      const seriesColor = colors[i37 % colors.length];
      const defaults = currentSeries._defaults;
      currentSeries.color = currentSeries.color || seriesColor;
      if (defaults) {
        defaults.color = defaults.color || seriesColor;
      }
    }
  }
  _getModel() {
    const options = this.options;
    const plotArea = this._createPlotArea();
    const model = new root_element_default(this._modelOptions());
    model.chart = this;
    model._plotArea = plotArea;
    const title3 = title_default.buildTitle(options.title);
    const subtitle2 = title_default.buildTitle(options.subtitle, {
      align: options.title.align,
      position: options.title.position
    });
    model.append.apply(model, title_default.orderTitles([title3, subtitle2]));
    if (options.legend && options.legend.visible) {
      const legend2 = new legend_default(plotArea.options.legend, this.chartService);
      model.append(legend2);
      model._legend = legend2;
    }
    model.append(plotArea);
    model.reflow();
    this._setTitleBox(title3, subtitle2);
    return model;
  }
  _setTitleBox(title3, subtitle2) {
    if (!title3 && !subtitle2) {
      return;
    }
    this._titleBox = (title3 || subtitle2).box.clone();
    const titlePosition = title3 ? title3.options.position : "";
    const subtitlePosition = subtitle2 ? subtitle2.options.position : "";
    const samePosition = titlePosition === subtitlePosition;
    const subtitleAtTop = subtitlePosition !== BOTTOM;
    if (samePosition && subtitle2) {
      this._titleBox.wrap(subtitle2.box);
    } else if (title3 && subtitle2 && subtitleAtTop) {
      this._titleBox = subtitle2.box.clone();
    }
  }
  _modelOptions() {
    const options = this.options;
    const size = this.getSize();
    return deepExtend({
      transitions: options.transitions,
      width: size.width || DEFAULT_WIDTH,
      height: size.height || DEFAULT_HEIGHT
    }, options.chartArea);
  }
  _createPlotArea(skipSeries) {
    const options = this.options;
    const plotArea = plotarea_factory_default.current.create(skipSeries ? [] : options.series, options, this.chartService);
    return plotArea;
  }
  _setupSelection() {
    const { _plotArea: { axes } } = this;
    const selections = this._selections = [];
    for (let i37 = 0; i37 < axes.length; i37++) {
      const axis = axes[i37];
      const options = axis.options;
      if (axis instanceof category_axis_default && options.select && !options.vertical) {
        const range = axis.range();
        const selection = new selection_default(
          this,
          axis,
          deepExtend({ min: range.min, max: range.max }, options.select)
        );
        selections.push(selection);
      }
    }
  }
  _selectStart(e41) {
    return this.trigger(SELECT_START, e41);
  }
  _select(e41) {
    return this.trigger(SELECT2, e41);
  }
  _selectEnd(e41) {
    return this.trigger(SELECT_END, e41);
  }
  _initHandlers() {
    this._clickHandler = this._click.bind(this);
    this._keydownHandler = this._keydown.bind(this);
    this._focusHandler = this._focus.bind(this);
    this._blurHandler = this._blur.bind(this);
    this._mousedownHandler = this._mousedown.bind(this);
    this._mousewheelHandler = this._mousewheel.bind(this);
    this._mouseleaveHandler = this._mouseleave.bind(this);
    this._surfaceMouseenterHandler = this._mouseover.bind(this);
    this._surfaceMouseleaveHandler = this._mouseout.bind(this);
    this._mousemoveThrottled = throttle(
      this._mousemove.bind(this),
      MOUSEMOVE_DELAY
    );
  }
  addObserver(observer) {
    if (observer) {
      this.observers.push(observer);
    }
  }
  removeObserver(observer) {
    const index = this.observers.indexOf(observer);
    if (index >= 0) {
      this.observers.splice(index, 1);
    }
  }
  requiresHandlers(eventNames) {
    const observers = this.observers;
    for (let idx = 0; idx < observers.length; idx++) {
      if (observers[idx].requiresHandlers(eventNames)) {
        return true;
      }
    }
  }
  trigger(name, args = {}) {
    args.sender = this;
    if (name === SHOW_TOOLTIP) {
      args.anchor.point = this._toDocumentCoordinates(args.anchor.point);
    } else if (name === SERIES_OVER) {
      this._updateDrilldownPoint(args.point);
    } else if (name === SERIES_LEAVE) {
      this._resetDrilldownPoint();
    } else if (name === SERIES_CLICK) {
      this._focusPoint(args.point);
      this._startDrilldown(args.point);
    } else if (name === LEGEND_ITEM_CLICK) {
      this._focusLegendItem(args);
    }
    const observers = this.observers;
    let isDefaultPrevented2 = false;
    for (let idx = 0; idx < observers.length; idx++) {
      if (observers[idx].trigger(name, args)) {
        isDefaultPrevented2 = true;
      }
    }
    return isDefaultPrevented2;
  }
  titleHeight() {
    if (!this._titleBox) {
      return 0;
    }
    return this._titleBox.height();
  }
  _attachEvents() {
    const element = this.element;
    this._touchAction = element.style.touchAction;
    bindEvents(element, {
      [CONTEXTMENU]: this._clickHandler,
      [MOUSEWHEEL]: this._mousewheelHandler,
      [MOUSELEAVE]: this._mouseleaveHandler,
      [KEYDOWN]: this._keydownHandler,
      [MOUSEDOWN]: this._mousedownHandler,
      [FOCUS]: this._focusHandler,
      [BLUR]: this._blurHandler
    });
    if (this._shouldAttachMouseMove()) {
      bindEvents(element, { [MOUSEMOVE]: this._mousemoveThrottled });
    }
    this.domEvents = dom_events_builder_default.create(this.element, {
      start: this._start.bind(this),
      move: this._move.bind(this),
      end: this._end.bind(this),
      tap: this._tap.bind(this),
      gesturestart: this._gesturestart.bind(this),
      gesturechange: this._gesturechange.bind(this),
      gestureend: this._gestureend.bind(this)
    });
    this._toggleDragZoomEvents();
  }
  _mouseleave(e41) {
    if (this._hoveredPoint) {
      this._hoveredPoint.out(this, e41);
      this._hoveredPoint = null;
    }
    if (this._plotAreaHovered) {
      this._plotAreaHovered = false;
      this.trigger(PLOT_AREA_LEAVE);
    }
    if (this._hasInactiveOpacity() && this._activeChartInstance) {
      this._applySeriesOpacity(this._activeChartInstance.children, null, true);
      this._updateSeriesOpacity(null, true);
    }
  }
  _cancelDomEvents() {
    if (this.domEvents && this.domEvents.cancel) {
      this.domEvents.cancel();
    }
  }
  _gesturestart(e41) {
    if (this._mousewheelZoom && !this._stopChartHandlers(e41)) {
      this._gestureDistance = e41.distance;
      this._unsetActivePoint();
      this._clearFocusedElement();
      this.surface.suspendTracking();
    }
  }
  _gestureend(e41) {
    if (this._zooming && !this._stopChartHandlers(e41)) {
      if (this.surface) {
        this.surface.resumeTracking();
      }
      this._zooming = false;
      this.trigger(ZOOM_END, {});
    }
  }
  _gesturechange(e41) {
    const mousewheelZoom = this._mousewheelZoom;
    if (mousewheelZoom && !this._stopChartHandlers(e41)) {
      e41.preventDefault();
      const previousGestureDistance = this._gestureDistance;
      let scaleDelta = -e41.distance / previousGestureDistance + 1;
      if (Math.abs(scaleDelta) >= 0.1) {
        scaleDelta = Math.round(scaleDelta * 10);
        this._gestureDistance = e41.distance;
        const args = { delta: scaleDelta, axisRanges: axisRanges(this._plotArea.axes), originalEvent: e41 };
        if (this._zooming || !this.trigger(ZOOM_START, args)) {
          const coords = this._eventCoordinates(e41);
          if (!this._zooming) {
            this._zooming = true;
          }
          const ranges = args.axisRanges = mousewheelZoom.updateRanges(scaleDelta, coords);
          if (ranges && !this.trigger(ZOOM, args)) {
            mousewheelZoom.zoom();
          }
        }
      }
    }
  }
  _mouseout(e41) {
    if (e41.element) {
      const element = this._drawingChartElement(e41.element, e41);
      if (element && element.leave) {
        element.leave(this, e41.originalEvent);
      }
    }
  }
  _start(e41) {
    const coords = this._eventCoordinates(e41);
    if (this._stopChartHandlers(e41) || !this._plotArea.backgroundContainsPoint(coords)) {
      return;
    }
    if (this.requiresHandlers([DRAG_START, DRAG, DRAG_END])) {
      this._startNavigation(e41, coords, DRAG_START);
    }
    if (this._pannable && this._pannable.start(e41)) {
      this.surface.suspendTracking();
      this._unsetActivePoint();
      this._clearFocusedElement();
      this._suppressHover = true;
      this.chartService.panning = true;
    }
    if (this._zoomSelection) {
      if (this._zoomSelection.start(e41)) {
        this.trigger(ZOOM_START, { axisRanges: axisRanges(this._plotArea.axes), originalEvent: e41 });
      }
    }
  }
  _move(e41) {
    let { _navState: state, _pannable: pannable } = this;
    if (this._stopChartHandlers(e41)) {
      return;
    }
    if (pannable) {
      const ranges = pannable.move(e41);
      if (ranges && !this.trigger(DRAG, { axisRanges: ranges, originalEvent: e41 })) {
        pannable.pan();
      }
    } else if (state) {
      const ranges = {};
      const axes = state.axes;
      for (let i37 = 0; i37 < axes.length; i37++) {
        const currentAxis = axes[i37];
        const axisName = currentAxis.options.name;
        if (axisName) {
          const axis = currentAxis.options.vertical ? e41.y : e41.x;
          const delta = axis.startLocation - axis.location;
          if (delta !== 0) {
            ranges[currentAxis.options.name] = currentAxis.translateRange(delta);
          }
        }
      }
      state.axisRanges = ranges;
      this.trigger(DRAG, {
        axisRanges: ranges,
        originalEvent: e41
      });
    }
    if (this._zoomSelection) {
      this._zoomSelection.move(e41);
    }
  }
  _end(e41) {
    if (this._stopChartHandlers(e41)) {
      return;
    }
    const pannable = this._pannable;
    if (pannable && pannable.end(e41)) {
      this.surface.resumeTracking();
      this.trigger(DRAG_END, {
        axisRanges: axisRanges(this._plotArea.axes),
        originalEvent: e41
      });
      this._suppressHover = false;
      this.chartService.panning = false;
    } else {
      this._endNavigation(e41, DRAG_END);
    }
    if (this._zoomSelection) {
      const ranges = this._zoomSelection.end(e41);
      if (ranges && !this.trigger(ZOOM, { axisRanges: ranges, originalEvent: e41 })) {
        this._zoomSelection.zoom();
        this.trigger(ZOOM_END, { axisRanges: ranges, originalEvent: e41 });
      }
    }
  }
  _stopChartHandlers(e41) {
    const selections = this._selections || [];
    if (!selections.length) {
      return false;
    }
    const coords = this._eventCoordinates(e41);
    const pane = this._plotArea.paneByPoint(coords);
    if (pane) {
      for (let idx = 0; idx < selections.length; idx++) {
        if (selections[idx].onPane(pane)) {
          return true;
        }
      }
    }
  }
  _mousewheelZoomRate() {
    const zoomable = this.options.zoomable;
    const mousewheel = (zoomable || {}).mousewheel || {};
    return valueOrDefault(mousewheel.rate, MOUSEWHEEL_ZOOM_RATE);
  }
  _mousewheel(e41) {
    const delta = mousewheelDelta(e41);
    const mousewheelZoom = this._mousewheelZoom;
    const coords = this._eventCoordinates(e41);
    if (this._stopChartHandlers(e41) || !this._plotArea.backgroundContainsPoint(coords)) {
      return;
    }
    if (mousewheelZoom) {
      const args = { delta, axisRanges: axisRanges(this._plotArea.axes), originalEvent: e41 };
      if (this._zooming || !this.trigger(ZOOM_START, args)) {
        e41.preventDefault();
        if (!this._zooming) {
          this._unsetActivePoint();
          this._clearFocusedElement();
          this.surface.suspendTracking();
          this._zooming = true;
        }
        if (this._mwTimeout) {
          clearTimeout(this._mwTimeout);
        }
        args.axisRanges = mousewheelZoom.updateRanges(delta, coords);
        if (args.axisRanges && !this.trigger(ZOOM, args)) {
          mousewheelZoom.zoom();
        }
        this._mwTimeout = setTimeout(() => {
          this.trigger(ZOOM_END, args);
          this._zooming = false;
          if (this.surface) {
            this.surface.resumeTracking();
          }
        }, MOUSEWHEEL_DELAY);
      }
    } else {
      let state = this._navState;
      if (!state) {
        const prevented = this._startNavigation(e41, coords, ZOOM_START);
        if (!prevented) {
          state = this._navState;
        }
      }
      if (state) {
        const totalDelta = state.totalDelta || delta;
        state.totalDelta = totalDelta + delta;
        const axes = this._navState.axes;
        const ranges = {};
        for (let i37 = 0; i37 < axes.length; i37++) {
          const currentAxis = axes[i37];
          const axisName = currentAxis.options.name;
          if (axisName) {
            ranges[axisName] = currentAxis.scaleRange(-totalDelta * this._mousewheelZoomRate(), coords);
          }
        }
        this.trigger(ZOOM, {
          delta,
          axisRanges: ranges,
          originalEvent: e41
        });
        if (this._mwTimeout) {
          clearTimeout(this._mwTimeout);
        }
        this._mwTimeout = setTimeout(() => {
          this._endNavigation(e41, ZOOM_END);
        }, MOUSEWHEEL_DELAY);
      }
    }
  }
  _startNavigation(e41, coords, chartEvent) {
    const plotArea = this._model._plotArea;
    const pane = plotArea.findPointPane(coords);
    const axes = plotArea.axes.slice(0);
    if (!pane) {
      return;
    }
    const ranges = axisRanges(axes);
    const prevented = this.trigger(chartEvent, {
      axisRanges: ranges,
      originalEvent: e41
    });
    if (prevented) {
      this._cancelDomEvents();
    } else {
      this._suppressHover = true;
      this._unsetActivePoint();
      this._clearFocusedElement();
      this._navState = {
        axisRanges: ranges,
        pane,
        axes
      };
    }
  }
  _endNavigation(e41, chartEvent) {
    if (this._navState) {
      this.trigger(chartEvent, {
        axisRanges: this._navState.axisRanges,
        originalEvent: e41
      });
      this._suppressHover = false;
      this._navState = null;
    }
  }
  _getChartElement(e41, match) {
    const element = this.surface.eventTarget(e41);
    if (element) {
      return this._drawingChartElement(element, e41, match);
    }
  }
  _drawingChartElement(element, e41, match) {
    let current4 = element;
    let chartElement;
    while (current4 && !chartElement) {
      chartElement = current4.chartElement;
      current4 = current4.parent;
    }
    if (chartElement) {
      if (chartElement.aliasFor) {
        chartElement = chartElement.aliasFor(e41, this._eventCoordinates(e41));
      }
      if (match) {
        chartElement = chartElement.closest(match);
        if (chartElement && chartElement.aliasFor) {
          chartElement = chartElement.aliasFor();
        }
      }
      return chartElement;
    }
  }
  _eventCoordinates(e41) {
    const coordinates = eventCoordinates(e41);
    return this._toModelCoordinates(coordinates.x, coordinates.y);
  }
  _elementPadding() {
    if (!this._padding) {
      const { paddingLeft, paddingTop } = elementStyles(this.element, ["paddingLeft", "paddingTop"]);
      this._padding = {
        top: paddingTop,
        left: paddingLeft
      };
    }
    return this._padding;
  }
  _toDocumentCoordinates(point) {
    const padding = this._elementPadding();
    const offset = elementOffset(this.element);
    return {
      left: round(point.x + padding.left + offset.left),
      top: round(point.y + padding.top + offset.top)
    };
  }
  // TODO: Breaking change due to peer version change
  // Reuse by exposing _surfacePoint on Surface
  _toModelCoordinates(clientX, clientY) {
    const element = this.element;
    const offset = elementOffset(element);
    const padding = this._elementPadding();
    const inverseTransform = elementScale(element).invert();
    const point = new geometry_exports.Point(
      clientX - offset.left - padding.left,
      clientY - offset.top - padding.top
    ).transform(inverseTransform);
    return new point_default(point.x, point.y);
  }
  _tap(e41) {
    const drawingElement = this.surface.eventTarget(e41);
    const element = this._drawingChartElement(drawingElement, e41);
    const sharedTooltip = this._sharedTooltip();
    if (!this._startHover(drawingElement, e41) && !sharedTooltip) {
      this._unsetActivePoint();
    }
    if (sharedTooltip) {
      this._trackSharedTooltip(this._eventCoordinates(e41), e41, true);
    }
    this._propagateClick(element, e41);
    this.handlingTap = true;
    setTimeout(() => {
      this.handlingTap = false;
    }, 0);
  }
  _click(e41) {
    const element = this._getChartElement(e41);
    this._propagateClick(element, e41);
  }
  _propagateClick(element, e41) {
    let current4 = element;
    while (current4) {
      if (current4.click) {
        current4.click(this, e41);
      }
      current4 = current4.parent;
    }
  }
  _isLegendBeforeChart() {
    const { options: { legend: { position: legendPosition } }, _legend: legend2 } = this;
    return legend2 && legend2.hasItems() && (legendPosition === TOP || legendPosition === LEFT);
  }
  _focus() {
    if (!this._preventInitialPointFocus) {
      if (this._isLegendBeforeChart()) {
        this._focusFirstLegendItem();
      } else {
        this._focusFirstPoint();
      }
    }
    this._preventInitialPointFocus = false;
  }
  _keydown(e41) {
    const { _focusState: { legendInFocus, focusedElement }, _legend: legend2 } = this;
    if (e41.key === TAB) {
      this._clearFocusedElement();
      const isLegendBeforeChart = this._isLegendBeforeChart();
      if (legendInFocus && isLegendBeforeChart !== e41.shiftKey) {
        this._navigatePoints(e41);
      } else if (!legendInFocus && isLegendBeforeChart === e41.shiftKey && legend2.hasItems()) {
        this._navigateLegend(e41);
      }
    } else if (e41.key === ESCAPE) {
      if (focusedElement) {
        e41.stopPropagation();
      }
      if (this._tooltip && this._tooltip.visible) {
        this._hideTooltip();
      } else {
        this._blur();
      }
    } else if (e41.key === ENTER) {
      if (focusedElement) {
        this._focusState.preserveHighlight = true;
        this._propagateClick(focusedElement, e41);
        this._focusElement(focusedElement);
      }
    } else if (!legendInFocus) {
      this._navigatePoints(e41);
    } else {
      this._navigateLegend(e41);
    }
  }
  _navigatePoints(e41) {
    const { _focusState: focusState, _plotArea: plotArea } = this;
    focusState.legendInFocus = false;
    if (!focusState.focusedElement) {
      this._focusFirstPoint();
      e41.preventDefault();
      return;
    }
    const moveFocus = (point) => {
      focusState.focusedPoint = point;
      this._focusElement(focusState.focusedPoint);
      this._displayTooltip(point);
      e41.preventDefault();
    };
    switch (e41.key) {
      case ARROW_RIGHT:
        moveFocus(plotArea.getPointToTheRight(focusState.focusedPoint));
        break;
      case ARROW_LEFT:
        moveFocus(plotArea.getPointToTheLeft(focusState.focusedPoint));
        break;
      case ARROW_DOWN:
        moveFocus(plotArea.getPointBelow(focusState.focusedPoint));
        break;
      case ARROW_UP:
        moveFocus(plotArea.getPointAbove(focusState.focusedPoint));
        break;
      default:
        break;
    }
  }
  _navigateLegend(e41) {
    const { _focusState: focusState, _legend: legend2, chartService: { rtl } } = this;
    focusState.legendInFocus = true;
    if (!focusState.focusedElement) {
      this._focusFirstLegendItem();
      e41.preventDefault();
      return;
    }
    const itemsLength = legend2.getItems().length;
    const moveFocus = (cycleFunc) => {
      focusState.focusedLegendItemIndex = cycleFunc(
        focusState.focusedLegendItemIndex,
        itemsLength
      );
      this._focusElement(this._getFocusedLegendItem());
      e41.preventDefault();
    };
    switch (e41.key) {
      case ARROW_UP:
      case ARROW_LEFT:
        moveFocus(rtl ? cycleUp : cycleDown);
        break;
      case ARROW_DOWN:
      case ARROW_RIGHT:
        moveFocus(rtl ? cycleDown : cycleUp);
        break;
      default:
        break;
    }
  }
  _focusFirstPoint() {
    const point = this._focusState.focusedPoint = this._plotArea.getFirstPoint();
    if (point) {
      this._focusElement(point);
      this._displayTooltip(point);
    }
  }
  _hasFocus() {
    return this.element.ownerDocument.activeElement === this.element;
  }
  _mousedown() {
    if (!this._hasFocus()) {
      this._preventInitialPointFocus = true;
    }
  }
  _focusChart() {
    if (!this._hasFocus()) {
      this._preventInitialPointFocus = true;
      this.element.focus();
    }
  }
  _focusPoint(point) {
    this._focusState.focusedPoint = point;
    this._focusChart();
    this._focusElement(point, true);
  }
  _focusFirstLegendItem() {
    const { _focusState: focusState } = this;
    focusState.focusedLegendItemIndex = 0;
    this._focusElement(this._getFocusedLegendItem());
    focusState.legendInFocus = true;
    this._hideTooltip();
  }
  _focusLegendItem(args) {
    const { _focusState: focusState } = this;
    focusState.focusedLegendItemIndex = this._legend.getItems().findIndex((x7) => x7.options.series.index === args.seriesIndex && x7.options.pointIndex === args.pointIndex);
    focusState.legendInFocus = true;
    this._focusChart();
    this._focusElement(this._getFocusedLegendItem(), true);
  }
  _getFocusedLegendItem() {
    const { _focusState: focusState, _legend: legend2 } = this;
    return legend2.getItems()[focusState.focusedLegendItemIndex];
  }
  _focusElement(element, omitHighlight) {
    const { _focusState: focusState } = this;
    this._clearFocusedElement();
    if (!element) {
      return;
    }
    focusState.focusedElement = element;
    this._setElementActiveDescendant(element);
    if (!omitHighlight) {
      element.focusVisual();
      if (focusState.legendInFocus) {
        const options = element.options;
        this._showSeriesInactiveOpacity(options.series.index, options.pointIndex);
      } else {
        this._showInactiveOpacity(element);
      }
    }
  }
  _clearFocusedElement() {
    const { _focusState: focusState } = this;
    if (!focusState) {
      return;
    }
    if (focusState.focusedElement && focusState.focusedElement.clearFocusFromVisual) {
      focusState.focusedElement.clearFocusFromVisual();
      this._clearElementActiveDescendant();
    }
    focusState.focusedElement = null;
  }
  _setElementActiveDescendant(element) {
    if (this.options.renderAs === "canvas") {
      this._pseudoFocusedElement = this._createPseudoFocusedElement(element);
      this.element.append(this._pseudoFocusedElement);
    }
    this.element.setAttribute(ARIA_ACTIVE_DESCENDANT, element._id);
  }
  _clearElementActiveDescendant() {
    if (this._pseudoFocusedElement) {
      this._pseudoFocusedElement.remove();
      this._pseudoFocusedElement = null;
    }
    this.element.removeAttribute(ARIA_ACTIVE_DESCENDANT);
  }
  _createPseudoFocusedElement(element) {
    const pseudoElement = document.createElement("div");
    const accessibilityOptions = element.options.accessibility;
    pseudoElement.id = element._id;
    pseudoElement.setAttribute("aria-label", element.getAriaLabelText());
    pseudoElement.setAttribute("role", accessibilityOptions.role);
    pseudoElement.setAttribute("aria-roledescription", accessibilityOptions.ariaRoleDescription);
    const checked = accessibilityOptions.ariaChecked;
    if (defined(checked)) {
      pseudoElement.setAttribute("aria-checked", checked);
    }
    return pseudoElement;
  }
  _blur() {
    this._focusState.legendInFocus = false;
    this._clearFocusedElement();
    this._hideInactiveOpacity();
  }
  _startHover(element, e41) {
    if (this._suppressHover) {
      return false;
    }
    let point = this._drawingChartElement(element, e41, function(element2) {
      return (element2.hover || element2.over) && !(element2 instanceof plotarea_base_default);
    });
    const activePoint = this._activePoint;
    this._updateHoveredPoint(point, e41);
    if (point && activePoint !== point && point.hover) {
      this._activePoint = point;
      if (!this._sharedTooltip() && !point.hover(this, e41)) {
        this._displayTooltip(point);
        this._showInactiveOpacity(point);
      }
    }
    return point;
  }
  _displayTooltip(point) {
    const tooltipOptions = deepExtend({}, this.options.tooltip, point.options.tooltip);
    if (tooltipOptions.visible) {
      if (this._sharedTooltip() && point.box) {
        this._trackSharedTooltip(point.box.center(), {});
      } else {
        this._tooltip.show(point);
      }
    }
  }
  _hideTooltip() {
    if (this._tooltip) {
      this._tooltip.hide();
    }
  }
  _displayInactiveOpacity(activePoint, multipleSeries, highlightPoints) {
    const chartInstance = this._activeChartInstance = this._chartInstanceFromPoint(activePoint);
    if (!chartInstance) {
      return;
    }
    if (multipleSeries) {
      this._updateSeriesOpacity(activePoint);
      this._applySeriesOpacity(chartInstance.children, null, true);
      this._applySeriesOpacity(chartInstance.children, activePoint.series);
      this._highlight.show(highlightPoints || activePoint);
    } else {
      let inactivePoints;
      if (!chartInstance.supportsPointInactiveOpacity()) {
        this._highlight.show(activePoint);
        return;
      }
      inactivePoints = this._getInactivePoints(activePoint, chartInstance);
      if (inactivePoints && inactivePoints.length) {
        this._highlight.show(inactivePoints, 1 - this._getInactiveOpacityForSeries(activePoint.series));
      }
    }
  }
  _getInactivePoints(activePoint, chartInstance) {
    let allPoints = this._getAllPointsOfType(chartInstance, activePoint.constructor);
    return allPoints.filter((point) => point !== activePoint);
  }
  _getAllPointsOfType(container, type) {
    let points = [];
    for (let i37 = 0; i37 < container.children.length; i37++) {
      const element = container.children[i37];
      if (element.constructor === type) {
        points.push(element);
      } else if (element.children && element.children.length) {
        points = points.concat(this._getAllPointsOfType(element, type));
      }
    }
    return points;
  }
  _updateHoveredPoint(point, e41) {
    const hoveredPoint = this._hoveredPoint;
    if (hoveredPoint && hoveredPoint !== point) {
      hoveredPoint.out(this, e41);
      this._hoveredPoint = null;
    }
    if (point && hoveredPoint !== point && point.over) {
      this._hoveredPoint = point;
      point.over(this, e41);
    }
  }
  _updateDrilldownPoint(point) {
    if (!point || !point.series) {
      return;
    }
    const { fields } = series_binder_default.current.bindPoint(point.series, null, point.dataItem);
    if (fields.drilldown) {
      this._drilldownState = { cursor: this.element.style.cursor };
      this.element.style.cursor = "pointer";
    }
  }
  _resetDrilldownPoint() {
    if (this._drilldownState) {
      this.element.style.cursor = this._drilldownState.cursor;
      this._drilldownState = null;
    }
  }
  _startDrilldown(point) {
    if (!point || !point.series) {
      return;
    }
    const series = point.series;
    const { fields } = series_binder_default.current.bindPoint(series, null, point.dataItem);
    const value2 = fields.drilldown;
    if (value2) {
      const args = { series, point, value: value2, sender: this };
      this.trigger(DRILLDOWN, args);
    }
  }
  _updateSeriesOpacity(point, resetOpacity) {
    const plotArea = this._plotArea;
    const length = plotArea.series.length;
    for (let i37 = 0; i37 < length; i37++) {
      const currSeries = plotArea.series[i37];
      const defaultOpacity = this._getDefaultOpacityForSeries(currSeries);
      const inactiveOpacity = this._getInactiveOpacityForSeries(currSeries);
      if (!resetOpacity && currSeries !== point.series) {
        currSeries.defaultOpacity = defaultOpacity;
        currSeries.opacity = inactiveOpacity;
        if (currSeries.line) {
          currSeries.line.opacity = inactiveOpacity;
        }
      } else {
        currSeries.opacity = defaultOpacity;
        if (currSeries.line) {
          currSeries.line.opacity = defaultOpacity;
        }
      }
    }
  }
  _applySeriesOpacity(elements, activeSeries, reset, series) {
    for (let i37 = 0; i37 < elements.length; i37++) {
      const element = elements[i37];
      const currSeries = element.series || series;
      const shouldHighlight = currSeries && (currSeries.highlight || {}).visible;
      if (shouldHighlight && element.visual) {
        const opacity = series ? series.opacity : element.series.opacity;
        if (currSeries !== activeSeries || reset) {
          element.visual.opacity(reset ? 1 : opacity);
        }
      }
      if (element.children && element.children.length) {
        this._applySeriesOpacity(element.children, activeSeries, reset, element.series);
      }
    }
  }
  _chartInstanceFromPoint(point) {
    let chartInstance = point.parent;
    while (chartInstance && !chartInstance.plotArea) {
      chartInstance = chartInstance.parent;
    }
    return chartInstance;
  }
  _showInactiveOpacity(point) {
    const multipleSeries = this._plotArea.series.length > 1;
    const hasInactiveOpacity = this._hasInactiveOpacity();
    if (hasInactiveOpacity) {
      this._displayInactiveOpacity(point, multipleSeries);
    } else {
      this._highlight.show(point);
    }
  }
  _hideInactiveOpacity(point) {
    const multipleSeries = this._plotArea.series.length > 1;
    const hasInactiveOpacity = this._hasInactiveOpacity();
    if (hasInactiveOpacity) {
      if (multipleSeries && this._activeChartInstance) {
        this._updateSeriesOpacity(point, true);
        this._applySeriesOpacity(this._activeChartInstance.children, null, true);
        this._activeChartInstance = null;
      }
      this._highlight && this._highlight.hide();
      this._activePoint = null;
    }
  }
  _hasInactiveOpacity() {
    let hasDefaultInactiveOpacity = this.options.seriesDefaults.highlight.inactiveOpacity !== void 0;
    let hasInactiveOpacity = this.options.series.filter((s10) => s10.highlight.inactiveOpacity !== void 0).length > 0;
    return hasDefaultInactiveOpacity || hasInactiveOpacity;
  }
  _getInactiveOpacityForSeries(series) {
    let defaultInactiveOpacity = this.options.seriesDefaults.highlight.inactiveOpacity;
    let seriesInactiveOpacity = series.highlight.inactiveOpacity;
    return seriesInactiveOpacity || defaultInactiveOpacity || series.opacity || DEFAULT_SERIES_OPACITY;
  }
  _getDefaultOpacityForSeries(series) {
    return series.defaultOpacity || series.opacity || DEFAULT_SERIES_OPACITY;
  }
  _mouseover(e41) {
    const point = this._startHover(e41.element, e41.originalEvent);
    if (point && point.tooltipTracking && !this._mouseMoveTrackHandler && !this._sharedTooltip()) {
      this._mouseMoveTrackHandler = this._mouseMoveTracking.bind(this);
      bindEvents(document, {
        [MOUSEMOVE]: this._mouseMoveTrackHandler
      });
    }
  }
  _mouseMoveTracking(e41) {
    const { options, _tooltip: tooltip, _highlight: highlight, _activePoint: point } = this;
    const coords = this._eventCoordinates(e41);
    if (this._plotArea.box.containsPoint(coords)) {
      if (point && point.tooltipTracking && point.series && point.parent.getNearestPoint) {
        const seriesPoint = point.parent.getNearestPoint(coords.x, coords.y, point.seriesIx);
        if (seriesPoint && seriesPoint !== point) {
          this._activePoint = seriesPoint;
          if (!seriesPoint.hover(this, e41)) {
            const tooltipOptions = deepExtend({}, options.tooltip, seriesPoint.options.tooltip);
            if (tooltipOptions.visible) {
              tooltip.show(seriesPoint);
            }
            highlight.show(seriesPoint);
          }
        }
      }
    } else {
      unbindEvents(document, {
        [MOUSEMOVE]: this._mouseMoveTrackHandler
      });
      this._unsetActivePoint();
      this._clearFocusedElement();
      this._mouseMoveTrackHandler = null;
      this._hideInactiveOpacity(point);
    }
  }
  _mousemove(e41) {
    const coords = this._eventCoordinates(e41);
    const plotArea = this._plotArea;
    this._trackCrosshairs(coords);
    if (plotArea.hover) {
      const overPlotArea = plotArea.backgroundContainsPoint(coords);
      if (overPlotArea) {
        this._plotAreaHovered = true;
        this._plotArea.hover(this, e41);
      } else if (this._plotAreaHovered && !overPlotArea) {
        this._plotAreaHovered = false;
        this.trigger(PLOT_AREA_LEAVE);
      }
    }
    if (this._sharedTooltip()) {
      this._trackSharedTooltip(coords, e41);
    }
  }
  _trackCrosshairs(coords) {
    const crosshairs = this._plotArea.crosshairs;
    for (let i37 = 0; i37 < crosshairs.length; i37++) {
      const current4 = crosshairs[i37];
      if (current4.box.containsPoint(coords)) {
        current4.showAt(coords);
      } else {
        current4.hide();
      }
    }
  }
  _trackSharedTooltip(coords, e41, toggle) {
    if (this._suppressHover) {
      return;
    }
    const { options: { tooltip: tooltipOptions }, _plotArea: plotArea, _plotArea: { categoryAxis }, _tooltip: tooltip, _highlight: highlight } = this;
    if (plotArea.backgroundContainsPoint(coords)) {
      const index = categoryAxis.pointCategoryIndex(coords);
      if (index !== this._tooltipCategoryIx || !this._sharedHighlight && toggle) {
        const points = plotArea.pointsByCategoryIndex(index);
        const pointArgs = points.map(function(point) {
          return point.eventArgs(e41);
        });
        const hoverArgs = pointArgs[0] || {};
        hoverArgs.categoryPoints = pointArgs;
        if (points.length > 0 && !this.trigger(SERIES_HOVER, hoverArgs)) {
          if (tooltipOptions.visible) {
            tooltip.showAt(points, coords);
          }
          highlight.show(points);
          this._sharedHighlight = true;
        } else {
          tooltip.hide();
        }
        this._tooltipCategoryIx = index;
      } else if (toggle && this._sharedHighlight) {
        highlight.hide();
        tooltip.hide();
        this._sharedHighlight = false;
      }
    } else if (this._sharedHighlight) {
      highlight.hide();
      tooltip.hide();
      this._tooltipCategoryIx = null;
      this._sharedHighlight = false;
    }
  }
  hideElements(options) {
    const plotArea = this._plotArea;
    this._mousemoveThrottled.cancel();
    plotArea.hideCrosshairs();
    this._unsetActivePoint(options);
  }
  _unsetActivePoint(options) {
    const { _highlight: highlight } = this;
    this._activePoint = null;
    this._hoveredPoint = null;
    if (!options || !options.keepTooltipOpen) {
      this._hideTooltip();
    }
    this._tooltipCategoryIx = null;
    this._sharedHighlight = false;
    if (highlight) {
      highlight.hide();
    }
  }
  _deferRedraw() {
    this._redraw();
  }
  _clearRedrawTimeout() {
    if (this._redrawTimeout) {
      clearInterval(this._redrawTimeout);
      this._redrawTimeout = null;
    }
  }
  bindCategories() {
    const options = this.options;
    const definitions = [].concat(options.categoryAxis);
    for (let axisIx = 0; axisIx < definitions.length; axisIx++) {
      const axis = definitions[axisIx];
      if (axis.autoBind !== false) {
        this.bindCategoryAxisFromSeries(axis, axisIx);
      }
    }
  }
  bindCategoryAxisFromSeries(axis, axisIx) {
    const uniqueCategories = /* @__PURE__ */ new Set();
    const seriesOnAxis = this.options.series.filter((series) => series.categoryAxis === axis.name || !series.categoryAxis && axisIx === 0);
    const hasCategoryBinding = seriesOnAxis.some((series) => Boolean(series.categoryField));
    const seriesWithData = seriesOnAxis.filter((series) => series.data && series.data.length > 0);
    const categorySamples = seriesWithData.map((series) => series_binder_default.current.bindPoint(series, 0).fields.category);
    const dateAxis = categorySamples.reduce((result, firstCategory) => result || isDateAxis(axis, firstCategory), false);
    const seriesWithBinding = seriesWithData.filter((series, seriesIx) => series.categoryField || defined(categorySamples[seriesIx]));
    seriesWithBinding.forEach((series) => series.data.forEach((row, index) => {
      let category = series_binder_default.current.bindPoint(series, index).fields.category;
      if (dateAxis) {
        const date = parseDateCategory(category, row, this.chartService.intl);
        category = date ? date.getTime() : void 0;
      }
      uniqueCategories.add(category);
    }));
    if (uniqueCategories.size > 0) {
      let categories = Array.from(uniqueCategories.values());
      if (dateAxis) {
        categories = categories.sort().map((time) => time && new Date(time));
      }
      axis.categories = categories;
    } else if (hasCategoryBinding) {
      axis.categories = [];
    }
  }
  _isBindable(series) {
    const valueFields = series_binder_default.current.valueFields(series);
    let result = true;
    for (let i37 = 0; i37 < valueFields.length; i37++) {
      let field = valueFields[i37];
      if (field === VALUE) {
        field = "field";
      } else {
        field = field + "Field";
      }
      if (!defined(series[field])) {
        result = false;
        break;
      }
    }
    return result;
  }
  _noTransitionsRedraw() {
    const options = this.options;
    let transitionsState;
    if (options.transitions !== false) {
      transitionsState = options.transitions;
      options.transitions = false;
    }
    this._redraw();
    if (transitionsState) {
      options.transitions = transitionsState;
    }
  }
  _legendItemHover(seriesIndex, pointIndex) {
    this._showSeriesInactiveOpacity(seriesIndex, pointIndex);
  }
  _showSeriesInactiveOpacity(seriesIndex, pointIndex) {
    const { _plotArea: plotArea, _highlight: highlight } = this;
    const currentSeries = (plotArea.srcSeries || plotArea.series)[seriesIndex];
    let items;
    if (inArray(currentSeries.type, [PIE, DONUT, FUNNEL, PYRAMID])) {
      items = plotArea.findPoint(function(point) {
        return point.series.index === seriesIndex && point.index === pointIndex;
      });
    } else {
      items = plotArea.pointsBySeriesIndex(seriesIndex);
    }
    if (this._hasInactiveOpacity() && currentSeries.visible && items) {
      const multipleSeries = plotArea.series.length > 1;
      const point = items.length ? items[0] : items;
      this._displayInactiveOpacity(point, multipleSeries, items);
    } else {
      highlight.show(items);
    }
  }
  _shouldAttachMouseMove() {
    return this._plotArea.crosshairs.length || this._tooltip && this._sharedTooltip() || this.requiresHandlers([PLOT_AREA_HOVER, PLOT_AREA_LEAVE]);
  }
  updateMouseMoveHandler() {
    unbindEvents(this.element, {
      [MOUSEMOVE]: this._mousemoveThrottled
    });
    if (this._shouldAttachMouseMove()) {
      bindEvents(this.element, {
        [MOUSEMOVE]: this._mousemoveThrottled
      });
    }
  }
  applyOptions(options, theme) {
    clearMissingValues(this._originalOptions, options);
    this._originalOptions = deepExtend(this._originalOptions, options);
    this.options = deepExtend({}, this._originalOptions);
    if (theme) {
      this._theme = theme;
      this.chartService.theme = theme;
    }
    this._initTheme(this.options, this._theme);
    this._toggleDragZoomEvents();
  }
  setOptions(options, theme) {
    this.applyOptions(options, theme);
    this.bindCategories();
    this.redraw();
    this.updateMouseMoveHandler();
    this._restoreOverlayElement();
  }
  setDirection(rtl) {
    this.chartService.rtl = Boolean(rtl);
    if (this.surface && this.surface.type === "svg") {
      this._destroySurface();
    }
  }
  setIntlService(intl) {
    this.chartService.intl = intl;
  }
  noTransitionsRedraw() {
    this._noTransitionsRedraw();
  }
  destroy() {
    this._destroyed = true;
    unbindEvents(this.element, {
      [CONTEXTMENU]: this._clickHandler,
      [MOUSEWHEEL]: this._mousewheelHandler,
      [MOUSEMOVE]: this._mousemoveThrottled,
      [MOUSELEAVE]: this._mouseleaveHandler,
      [MOUSEDOWN]: this._mousedownHandler,
      [KEYDOWN]: this._keydownHandler,
      [FOCUS]: this._focusHandler,
      [BLUR]: this._blurHandler
    });
    if (this.domEvents) {
      this.domEvents.destroy();
      delete this.domEvents;
    }
    if (this._mouseMoveTrackHandler) {
      unbindEvents(document, {
        [MOUSEMOVE]: this._mouseMoveTrackHandler
      });
    }
    this._focusState = null;
    this.element._kendoExportVisual = null;
    this._destroyView();
    this._destroySurface();
    this._clearRedrawTimeout();
  }
  _destroySurface() {
    const surface = this.surface;
    if (surface) {
      surface.unbind("mouseenter", this._surfaceMouseenterHandler);
      surface.unbind("mouseleave", this._surfaceMouseleaveHandler);
      surface.destroy();
      this.surface = null;
    }
  }
  _destroySelections() {
    const selections = this._selections;
    if (selections) {
      while (selections.length > 0) {
        selections.shift().destroy();
      }
    }
  }
  _destroyView() {
    const model = this._model;
    if (model) {
      model.destroy();
      this._model = null;
    }
    this._unsetActivePoint();
    this._clearFocusedElement();
    this._resetDrilldownPoint();
    this._destroySelections();
    if (this._tooltip) {
      this._tooltip.destroy();
    }
    if (this._highlight) {
      this._highlight.destroy();
    }
    if (this._zoomSelection) {
      this._zoomSelection.destroy();
      delete this._zoomSelection;
    }
    if (this._pannable) {
      this._pannable.destroy();
      delete this._pannable;
    }
    if (this._mousewheelZoom) {
      this._mousewheelZoom.destroy();
      delete this._mousewheelZoom;
    }
  }
};
function resolveAxisAliases(options) {
  const aliases = AXIS_NAMES;
  for (let idx = 0; idx < aliases.length; idx++) {
    const alias = aliases[idx] + "Axes";
    if (options[alias]) {
      options[aliases[idx] + "Axis"] = options[alias];
      delete options[alias];
    }
  }
}
function pointByCategoryName(points, name) {
  if (points) {
    for (let idx = 0; idx < points.length; idx++) {
      if (points[idx].category === name) {
        return [points[idx]];
      }
    }
  }
}
function applyAxisDefaults(options, themeOptions) {
  const themeAxisDefaults = (themeOptions || {}).axisDefaults || {};
  let axisName, axisDefaults2, axes;
  function mapAxisOptions(axisOptions2) {
    const axisColor = (axisOptions2 || {}).color || axisDefaults2.color;
    const result = deepExtend(
      {},
      themeAxisDefaults,
      themeAxisDefaults[axisName],
      axisDefaults2,
      axisDefaults2[axisName],
      {
        line: { color: axisColor },
        labels: { color: axisColor },
        title: { color: axisColor }
      },
      axisOptions2
    );
    delete result[axisName];
    return result;
  }
  for (let idx = 0; idx < AXIS_NAMES.length; idx++) {
    axisName = AXIS_NAMES[idx] + "Axis";
    axisDefaults2 = options.axisDefaults || {};
    axes = [].concat(options[axisName]);
    axes = axes.map(mapAxisOptions);
    options[axisName] = axes.length > 1 ? axes : axes[0];
  }
}
function applySeriesDefaults(options, themeOptions) {
  const series = options.series;
  const seriesLength = series.length;
  const seriesDefaults2 = options.seriesDefaults;
  const commonDefaults = deepExtend({}, options.seriesDefaults);
  const themeSeriesDefaults = themeOptions ? deepExtend({}, themeOptions.seriesDefaults) : {};
  const commonThemeDefaults = deepExtend({}, themeSeriesDefaults);
  cleanupNestedSeriesDefaults(commonDefaults);
  cleanupNestedSeriesDefaults(commonThemeDefaults);
  for (let i37 = 0; i37 < seriesLength; i37++) {
    const seriesType = series[i37].type || options.seriesDefaults.type;
    const baseOptions = deepExtend(
      { data: [] },
      commonThemeDefaults,
      themeSeriesDefaults[seriesType],
      { tooltip: options.tooltip },
      commonDefaults,
      seriesDefaults2[seriesType]
    );
    series[i37]._defaults = baseOptions;
    series[i37] = deepExtend({}, baseOptions, series[i37]);
    series[i37].data = series[i37].data || [];
  }
}
function cleanupNestedSeriesDefaults(seriesDefaults2) {
  delete seriesDefaults2.bar;
  delete seriesDefaults2.column;
  delete seriesDefaults2.rangeColumn;
  delete seriesDefaults2.line;
  delete seriesDefaults2.verticalLine;
  delete seriesDefaults2.pie;
  delete seriesDefaults2.donut;
  delete seriesDefaults2.area;
  delete seriesDefaults2.verticalArea;
  delete seriesDefaults2.scatter;
  delete seriesDefaults2.scatterLine;
  delete seriesDefaults2.bubble;
  delete seriesDefaults2.candlestick;
  delete seriesDefaults2.ohlc;
  delete seriesDefaults2.boxPlot;
  delete seriesDefaults2.bullet;
  delete seriesDefaults2.verticalBullet;
  delete seriesDefaults2.polarArea;
  delete seriesDefaults2.polarLine;
  delete seriesDefaults2.radarArea;
  delete seriesDefaults2.radarLine;
  delete seriesDefaults2.waterfall;
}
function axisRanges(axes) {
  const ranges = {};
  for (let i37 = 0; i37 < axes.length; i37++) {
    const axis = axes[i37];
    const axisName = axis.options.name;
    if (axisName) {
      ranges[axisName] = axis.range();
    }
  }
  return ranges;
}
var DATA_FIELDS = ["data", "categories"];
function clearMissingValues(originalOptions, options) {
  for (let field in options) {
    if (!inArray(field, DATA_FIELDS) && hasOwnProperty(options, field)) {
      const fieldValue = options[field];
      const originalValue = originalOptions[field];
      if (defined(originalValue)) {
        const nullValue = fieldValue === null;
        if (nullValue || !defined(fieldValue)) {
          delete originalOptions[field];
          if (nullValue) {
            delete options[field];
          }
        } else if (originalValue && isObject(fieldValue)) {
          if (isObject(originalValue)) {
            clearMissingValues(originalValue, fieldValue);
          }
        }
      }
    }
  }
}
function triggerPaneRender(panes) {
  for (let idx = 0; idx < panes.length; idx++) {
    panes[idx].notifyRender();
  }
}
setDefaultOptions(Chart, {
  renderAs: "",
  chartArea: {},
  legend: {
    visible: true,
    labels: {},
    accessibility: {},
    focusHighlight: {
      border: {
        opacity: 1,
        color: BLACK,
        width: 2
      }
    }
  },
  categoryAxis: {},
  seriesDefaults: {
    type: COLUMN,
    data: [],
    highlight: {
      visible: true
    },
    labels: {},
    negativeValues: {
      visible: false
    },
    accessibility: {},
    focusHighlight: {
      border: {
        opacity: 1,
        width: 2
      },
      zIndex: 200
    }
  },
  series: [],
  seriesColors: null,
  tooltip: {
    visible: false
  },
  transitions: true,
  valueAxis: {
    narrowRange: false
  },
  plotArea: {},
  title: {},
  xAxis: {},
  yAxis: {},
  panes: [{}],
  pannable: false,
  zoomable: false
});
var chart_default = Chart;

// node_modules/@progress/kendo-charts/dist/es/sparkline/shared-tooltip.js
var TOP_OFFSET = -2;
var SharedTooltip2 = class extends shared_tooltip_default {
  _slotAnchor(coords, slot) {
    const axis = this.plotArea.categoryAxis;
    const vertical = axis.options.vertical;
    const align = vertical ? {
      horizontal: "left",
      vertical: "center"
    } : {
      horizontal: "center",
      vertical: "bottom"
    };
    let point;
    if (vertical) {
      point = new point_default(this.plotArea.box.x2, slot.center().y);
    } else {
      point = new point_default(slot.center().x, TOP_OFFSET);
    }
    return {
      point,
      align
    };
  }
  _defaultAnchor(point, slot) {
    return this._slotAnchor({}, slot);
  }
};
var shared_tooltip_default2 = SharedTooltip2;

// node_modules/@progress/kendo-charts/dist/es/sparkline/sparkline.js
var DEAULT_BAR_WIDTH = 150;
var DEAULT_BULLET_WIDTH = 150;
var NO_CROSSHAIR = [BAR, BULLET];
function hide(children) {
  const state = [];
  for (let idx = 0; idx < children.length; idx++) {
    const child = children[idx];
    state[idx] = child.style.display;
    child.style.display = "none";
  }
  return state;
}
function show(children, state) {
  for (let idx = 0; idx < children.length; idx++) {
    children[idx].style.display = state[idx];
  }
}
function wrapNumber(value2) {
  return isNumber(value2) ? [value2] : value2;
}
var Sparkline = class extends chart_default {
  _setElementClass(element) {
    addClass(element, "k-sparkline");
  }
  _initElement(element) {
    super._initElement(element);
    this._initialWidth = Math.floor(elementSize(element).width);
  }
  _resize() {
    const element = this.element;
    const state = hide(element.childNodes);
    this._initialWidth = Math.floor(elementSize(element).width);
    show(element.childNodes, state);
    super._resize();
  }
  _modelOptions() {
    const chartOptions = this.options;
    const stage = this._surfaceWrap();
    const displayState = hide(stage.childNodes);
    const space = document.createElement("span");
    space.innerHTML = "&nbsp;";
    stage.appendChild(space);
    const options = deepExtend({
      width: this._autoWidth,
      height: elementSize(stage).height,
      transitions: chartOptions.transitions
    }, chartOptions.chartArea, {
      inline: true,
      align: false
    });
    elementSize(stage, {
      width: options.width,
      height: options.height
    });
    stage.removeChild(space);
    show(stage.childNodes, displayState);
    if (this.surface) {
      this.surface.resize();
    }
    return options;
  }
  _surfaceWrap() {
    if (!this.stage) {
      const stage = this.stage = document.createElement("span");
      this.element.appendChild(stage);
    }
    return this.stage;
  }
  _createPlotArea(skipSeries) {
    const plotArea = super._createPlotArea(skipSeries);
    this._autoWidth = this._initialWidth || this._calculateWidth(plotArea);
    return plotArea;
  }
  _calculateWidth(plotArea) {
    const options = this.options;
    const margin = getSpacing(options.chartArea.margin);
    const charts = plotArea.charts;
    const stage = this._surfaceWrap();
    let total = 0;
    for (let i37 = 0; i37 < charts.length; i37++) {
      const currentChart = charts[i37];
      const firstSeries = (currentChart.options.series || [])[0];
      if (!firstSeries) {
        continue;
      }
      if (firstSeries.type === BAR) {
        return DEAULT_BAR_WIDTH;
      }
      if (firstSeries.type === BULLET) {
        return DEAULT_BULLET_WIDTH;
      }
      if (firstSeries.type === PIE) {
        return elementSize(stage).height;
      }
      const categoryAxis = currentChart.categoryAxis;
      if (categoryAxis) {
        const pointsCount = categoryAxis.categoriesCount() * (!currentChart.options.isStacked && inArray(firstSeries.type, [COLUMN, VERTICAL_BULLET]) ? currentChart.seriesOptions.length : 1);
        total = Math.max(total, pointsCount);
      }
    }
    let size = total * options.pointWidth;
    if (size > 0) {
      size += margin.left + margin.right;
    }
    return size;
  }
  _createSharedTooltip(options) {
    return new shared_tooltip_default2(this._plotArea, options);
  }
  static normalizeOptions(userOptions) {
    let options = wrapNumber(userOptions);
    if (isArray(options)) {
      options = { seriesDefaults: { data: options } };
    } else {
      options = deepExtend({}, options);
    }
    if (!options.series) {
      options.series = [{ data: wrapNumber(options.data) }];
    }
    deepExtend(options, {
      seriesDefaults: {
        type: options.type
      }
    });
    if (inArray(options.series[0].type, NO_CROSSHAIR) || inArray(options.seriesDefaults.type, NO_CROSSHAIR)) {
      options = deepExtend({}, {
        categoryAxis: {
          crosshair: {
            visible: false
          }
        }
      }, options);
    }
    return options;
  }
};
setDefaultOptions(Sparkline, {
  chartArea: {
    margin: 2
  },
  axisDefaults: {
    visible: false,
    majorGridLines: {
      visible: false
    },
    valueAxis: {
      narrowRange: true
    }
  },
  seriesDefaults: {
    type: "line",
    area: {
      line: {
        width: 0.5
      }
    },
    bar: {
      stack: true
    },
    padding: 2,
    width: 0.5,
    overlay: {
      gradient: null
    },
    highlight: {
      visible: false
    },
    border: {
      width: 0
    },
    markers: {
      size: 2,
      visible: false
    }
  },
  tooltip: {
    visible: true,
    shared: true
  },
  categoryAxis: {
    crosshair: {
      visible: true,
      tooltip: {
        visible: false
      }
    }
  },
  legend: {
    visible: false
  },
  transitions: false,
  pointWidth: 5,
  panes: [{ clip: false }]
});
var sparkline_default = Sparkline;

// node_modules/@progress/kendo-charts/dist/es/stock/fade-out-animation.js
var FadeOutAnimation = class extends drawing_exports.Animation {
  setup() {
    this._initialOpacity = parseFloat(elementStyles(this.element, "opacity").opacity);
  }
  step(pos) {
    elementStyles(this.element, {
      opacity: String(interpolateValue(this._initialOpacity, 0, pos))
    });
  }
  abort() {
    super.abort();
    elementStyles(this.element, {
      display: "none",
      opacity: String(this._initialOpacity)
    });
  }
  cancel() {
    super.abort();
    elementStyles(this.element, {
      opacity: String(this._initialOpacity)
    });
  }
};
var fade_out_animation_default = FadeOutAnimation;

// node_modules/@progress/kendo-charts/dist/es/stock/navigator-hint.js
function createDiv2(className, style) {
  const div = document.createElement("div");
  div.className = className;
  if (style) {
    div.style.cssText = style;
  }
  return div;
}
var NavigatorHint = class {
  constructor(container, chartService, options) {
    this.options = deepExtend({}, this.options, options);
    this.container = container;
    this.chartService = chartService;
    const padding = elementStyles(container, ["paddingLeft", "paddingTop"]);
    this.chartPadding = {
      top: padding.paddingTop,
      left: padding.paddingLeft
    };
    this.createElements();
    container.appendChild(this.element);
  }
  createElements() {
    const element = this.element = createDiv2("k-navigator-hint", "display: none; position: absolute; top: 1px; left: 1px;");
    const tooltip = this.tooltip = createDiv2("k-tooltip k-chart-tooltip");
    const scroll = this.scroll = createDiv2("k-scroll");
    tooltip.innerHTML = "&nbsp;";
    element.appendChild(tooltip);
    element.appendChild(scroll);
  }
  show(from, to, bbox) {
    const { element, options, scroll, tooltip } = this;
    const middle = toDate(toTime(from) + toTime(to - from) / 2);
    const scrollWidth = bbox.width() * 0.4;
    const minPos = bbox.center().x - scrollWidth;
    const maxPos = bbox.center().x;
    const posRange = maxPos - minPos;
    const range = options.max - options.min;
    const scale = posRange / range;
    const offset = middle - options.min;
    let text = this.chartService.intl.format(options.format, from, to);
    const template = getTemplate(options);
    this.clearHideTimeout();
    if (!this._visible) {
      elementStyles(element, {
        visibility: "hidden",
        display: "block"
      });
      this._visible = true;
    }
    if (template) {
      text = template({
        from,
        to
      });
    }
    tooltip.innerHTML = text;
    elementStyles(tooltip, {
      left: bbox.center().x - tooltip.offsetWidth / 2,
      top: bbox.y1
    });
    const tooltipStyle = elementStyles(tooltip, ["marginTop", "borderTopWidth", "height"]);
    elementStyles(scroll, {
      width: scrollWidth,
      left: minPos + offset * scale,
      top: bbox.y1 + tooltipStyle.marginTop + tooltipStyle.borderTopWidth + tooltipStyle.height / 2
    });
    elementStyles(element, {
      visibility: "visible"
    });
  }
  clearHideTimeout() {
    if (this._hideTimeout) {
      clearTimeout(this._hideTimeout);
    }
    if (this._hideAnimation) {
      this._hideAnimation.cancel();
    }
  }
  hide() {
    this.clearHideTimeout();
    this._hideTimeout = setTimeout(() => {
      this._visible = false;
      this._hideAnimation = new fade_out_animation_default(this.element);
      this._hideAnimation.setup();
      this._hideAnimation.play();
    }, this.options.hideDelay);
  }
  destroy() {
    this.clearHideTimeout();
    if (this.container) {
      this.container.removeChild(this.element);
    }
    delete this.container;
    delete this.chartService;
    delete this.element;
    delete this.tooltip;
    delete this.scroll;
  }
};
setDefaultOptions(NavigatorHint, {
  format: "{0:d} - {1:d}",
  hideDelay: 500
});
var navigator_hint_default = NavigatorHint;

// node_modules/@progress/kendo-charts/dist/es/stock/constants.js
var NAVIGATOR_PANE = "_navigator";
var NAVIGATOR_AXIS = NAVIGATOR_PANE;
var DEFAULT_PANE = "_default";

// node_modules/@progress/kendo-charts/dist/es/stock/navigator.js
var ZOOM_ACCELERATION2 = 3;
var Navigator = class _Navigator {
  constructor(chart) {
    this.chart = chart;
    const options = this.options = deepExtend({}, this.options, chart.options.navigator);
    const select = options.select;
    if (select) {
      select.from = this.parseDate(select.from);
      select.to = this.parseDate(select.to);
    }
    if (!defined(options.hint.visible)) {
      options.hint.visible = options.visible;
    }
    this.chartObserver = new instance_observer_default(this, {
      [DRAG]: "_drag",
      [DRAG_END]: "_dragEnd",
      [ZOOM]: "_zoom",
      [ZOOM_END]: "_zoomEnd"
    });
    chart.addObserver(this.chartObserver);
  }
  parseDate(value2) {
    return parseDate(this.chart.chartService.intl, value2);
  }
  clean() {
    if (this.selection) {
      this.selection.destroy();
      this.selection = null;
    }
    if (this.hint) {
      this.hint.destroy();
      this.hint = null;
    }
  }
  destroy() {
    if (this.chart) {
      this.chart.removeObserver(this.chartObserver);
      delete this.chart;
    }
    this.clean();
  }
  redraw() {
    this._redrawSelf();
    this.initSelection();
  }
  initSelection() {
    const { chart, options } = this;
    const axis = this.mainAxis();
    const { min: min4, max: max3 } = axis.roundedRange();
    const { from, to, mousewheel } = options.select;
    const axisClone = clone(axis);
    if (axis.categoriesCount() === 0) {
      return;
    }
    this.clean();
    axisClone.box = axis.box;
    this.selection = new selection_default(chart, axisClone, {
      min: min4,
      max: max3,
      from: from || min4,
      to: to || max3,
      mousewheel: valueOrDefault(mousewheel, { zoom: "left" }),
      visible: options.visible
    }, new instance_observer_default(this, {
      selectStart: "_selectStart",
      select: "_select",
      selectEnd: "_selectEnd"
    }));
    if (options.hint.visible) {
      this.hint = new navigator_hint_default(chart.element, chart.chartService, {
        min: min4,
        max: max3,
        template: getTemplate(options.hint),
        format: options.hint.format
      });
    }
  }
  setRange() {
    const plotArea = this.chart._createPlotArea(true);
    const axis = plotArea.namedCategoryAxes[NAVIGATOR_AXIS];
    const { min: min4, max: max3 } = axis.roundedRange();
    const select = this.options.select || {};
    let from = select.from || min4;
    if (from < min4) {
      from = min4;
    }
    let to = select.to || max3;
    if (to > max3) {
      to = max3;
    }
    this.options.select = deepExtend({}, select, {
      from,
      to
    });
    this.filterAxes();
  }
  _redrawSelf(silent) {
    const plotArea = this.chart._plotArea;
    if (plotArea) {
      plotArea.redraw(last(plotArea.panes), silent);
    }
  }
  redrawSlaves() {
    const chart = this.chart;
    const plotArea = chart._plotArea;
    const slavePanes = plotArea.panes.filter((pane) => pane.options.name !== NAVIGATOR_PANE);
    plotArea.srcSeries = chart.options.series;
    plotArea.options.categoryAxis = chart.options.categoryAxis;
    plotArea.clearSeriesPointsCache();
    plotArea.redraw(slavePanes);
  }
  _drag(e41) {
    const { chart, selection } = this;
    const coords = chart._eventCoordinates(e41.originalEvent);
    const navigatorAxis = this.mainAxis();
    const naviRange = navigatorAxis.roundedRange();
    const inNavigator = navigatorAxis.pane.box.containsPoint(coords);
    const axis = chart._plotArea.categoryAxis;
    const range = e41.axisRanges[axis.options.name];
    const select = this.options.select;
    let duration2;
    if (!range || inNavigator || !selection) {
      return;
    }
    if (select.from && select.to) {
      duration2 = toTime(select.to) - toTime(select.from);
    } else {
      duration2 = toTime(selection.options.to) - toTime(selection.options.from);
    }
    const from = toDate(limitValue(
      toTime(range.min),
      naviRange.min,
      toTime(naviRange.max) - duration2
    ));
    const to = toDate(limitValue(
      toTime(from) + duration2,
      toTime(naviRange.min) + duration2,
      naviRange.max
    ));
    this.options.select = { from, to };
    if (this.options.liveDrag) {
      this.filterAxes();
      this.redrawSlaves();
    }
    selection.set(from, to);
    this.showHint(from, to);
  }
  _dragEnd() {
    this.filterAxes();
    this.filter();
    this.redrawSlaves();
    if (this.hint) {
      this.hint.hide();
    }
  }
  readSelection() {
    const { selection: { options: { from, to } }, options: { select } } = this;
    select.from = from;
    select.to = to;
  }
  filterAxes() {
    const { options: { select = {} }, chart } = this;
    const allAxes = chart.options.categoryAxis;
    const { from, to } = select;
    for (let idx = 0; idx < allAxes.length; idx++) {
      const axis = allAxes[idx];
      if (axis.pane !== NAVIGATOR_PANE) {
        axis.min = from;
        axis.max = to;
      }
    }
  }
  filter() {
    const { chart, options: { select } } = this;
    if (!chart.requiresHandlers(["navigatorFilter"])) {
      return;
    }
    const mainAxis = this.mainAxis();
    const args = {
      from: select.from,
      to: select.to
    };
    if (mainAxis.options.type !== "category") {
      const axisOptions2 = new date_category_axis_default(deepExtend({
        baseUnit: "fit"
      }, chart.options.categoryAxis[0], {
        categories: [select.from, select.to]
      }), chart.chartService).options;
      args.from = addDuration(axisOptions2.min, -axisOptions2.baseUnitStep, axisOptions2.baseUnit);
      args.to = addDuration(axisOptions2.max, axisOptions2.baseUnitStep, axisOptions2.baseUnit);
    }
    this.chart.trigger("navigatorFilter", args);
  }
  _zoom(e41) {
    const { chart: { _plotArea: { categoryAxis: axis } }, selection, options: { select, liveDrag } } = this;
    const mainAxis = this.mainAxis();
    let delta = e41.delta;
    if (!selection) {
      return;
    }
    const fromIx = mainAxis.categoryIndex(selection.options.from);
    const toIx = mainAxis.categoryIndex(selection.options.to);
    const coords = this.chart._eventCoordinates(e41.originalEvent);
    e41.originalEvent.preventDefault();
    if (Math.abs(delta) > 1) {
      delta *= ZOOM_ACCELERATION2;
    }
    if (toIx - fromIx > 1) {
      selection.zoom(delta, coords);
      this.readSelection();
    } else {
      axis.options.min = select.from;
      select.from = axis.scaleRange(-e41.delta * this.chart._mousewheelZoomRate(), coords).min;
    }
    if (liveDrag) {
      this.filterAxes();
      this.redrawSlaves();
    }
    selection.set(select.from, select.to);
    this.showHint(this.options.select.from, this.options.select.to);
  }
  _zoomEnd(e41) {
    this._dragEnd(e41);
  }
  showHint(from, to) {
    const plotArea = this.chart._plotArea;
    if (this.hint) {
      this.hint.show(from, to, plotArea.backgroundBox());
    }
  }
  _selectStart(e41) {
    return this.chart._selectStart(e41);
  }
  _select(e41) {
    this.showHint(e41.from, e41.to);
    return this.chart._select(e41);
  }
  _selectEnd(e41) {
    if (this.hint) {
      this.hint.hide();
    }
    this.readSelection();
    this.filterAxes();
    this.filter();
    this.redrawSlaves();
    return this.chart._selectEnd(e41);
  }
  mainAxis() {
    const plotArea = this.chart._plotArea;
    if (plotArea) {
      return plotArea.namedCategoryAxes[NAVIGATOR_AXIS];
    }
  }
  select(from, to) {
    const select = this.options.select;
    if (from && to) {
      select.from = this.parseDate(from);
      select.to = this.parseDate(to);
      this.filterAxes();
      this.filter();
      this.redrawSlaves();
      this.selection.set(from, to);
    }
    return {
      from: select.from,
      to: select.to
    };
  }
  static setup(options = {}, themeOptions = {}) {
    if (options.__navi) {
      return;
    }
    options.__navi = true;
    const naviOptions = deepExtend({}, themeOptions.navigator, options.navigator);
    const panes = options.panes = [].concat(options.panes);
    const paneOptions = deepExtend({}, naviOptions.pane, { name: NAVIGATOR_PANE });
    if (!naviOptions.visible) {
      paneOptions.visible = false;
      paneOptions.height = 0.1;
    }
    if (options.navigator.position !== "top") {
      panes.push(paneOptions);
    } else {
      panes.unshift(paneOptions);
    }
    panes.forEach((pane) => {
      pane.name = pane.name || DEFAULT_PANE;
    });
    _Navigator.attachAxes(options, naviOptions);
    _Navigator.attachSeries(options, naviOptions, themeOptions);
  }
  static attachAxes(options, naviOptions) {
    const series = naviOptions.series || [];
    const categoryAxes = options.categoryAxis = [].concat(options.categoryAxis);
    const valueAxes = options.valueAxis = [].concat(options.valueAxis);
    const allAxes = categoryAxes.concat(valueAxes);
    allAxes.forEach((axis) => {
      axis.pane = axis.pane || DEFAULT_PANE;
    });
    const equallySpacedSeries = filterSeriesByType(series, EQUALLY_SPACED_SERIES);
    const justifyAxis = equallySpacedSeries.length === 0;
    const base = deepExtend({
      type: "date",
      pane: NAVIGATOR_PANE,
      roundToBaseUnit: !justifyAxis,
      justified: justifyAxis,
      _collapse: false,
      majorTicks: { visible: true },
      tooltip: { visible: false },
      labels: { step: 1 },
      autoBind: naviOptions.autoBindElements,
      autoBaseUnitSteps: {
        minutes: [1],
        hours: [1, 2],
        days: [1, 2],
        weeks: [],
        months: [1],
        years: [1]
      }
    });
    const user = naviOptions.categoryAxis;
    categoryAxes.push(
      deepExtend({}, base, {
        maxDateGroups: 200
      }, user, {
        name: NAVIGATOR_AXIS,
        title: null,
        baseUnit: "fit",
        baseUnitStep: "auto",
        labels: { visible: false },
        majorTicks: { visible: false }
      }),
      deepExtend({}, base, user, {
        name: NAVIGATOR_AXIS + "_labels",
        maxDateGroups: 20,
        baseUnitStep: "auto",
        labels: { position: "" },
        plotBands: [],
        autoBaseUnitSteps: {
          minutes: []
        },
        _overlap: true
      }),
      deepExtend({}, base, user, {
        name: NAVIGATOR_AXIS + "_ticks",
        maxDateGroups: 200,
        majorTicks: {
          width: 0.5
        },
        plotBands: [],
        title: null,
        labels: { visible: false, mirror: true },
        _overlap: true
      })
    );
    valueAxes.push(deepExtend({
      name: NAVIGATOR_AXIS,
      pane: NAVIGATOR_PANE,
      majorGridLines: {
        visible: false
      },
      visible: false
    }, naviOptions.valueAxis));
  }
  static attachSeries(options, naviOptions, themeOptions) {
    const series = options.series = options.series || [];
    const navigatorSeries = [].concat(naviOptions.series || []);
    const seriesColors = themeOptions.seriesColors;
    const defaults = naviOptions.seriesDefaults;
    for (let idx = 0; idx < navigatorSeries.length; idx++) {
      series.push(
        deepExtend({
          color: seriesColors[idx % seriesColors.length],
          categoryField: naviOptions.dateField,
          visibleInLegend: false,
          tooltip: {
            visible: false
          }
        }, defaults, navigatorSeries[idx], {
          axis: NAVIGATOR_AXIS,
          categoryAxis: NAVIGATOR_AXIS,
          autoBind: naviOptions.autoBindElements
        })
      );
    }
  }
};
function ClonedObject() {
}
function clone(obj) {
  ClonedObject.prototype = obj;
  return new ClonedObject();
}
var navigator_default = Navigator;

// node_modules/@progress/kendo-charts/dist/es/stock/stock-chart.js
var AUTO_CATEGORY_WIDTH = 28;
var StockChart = class extends chart_default {
  applyDefaults(options, themeOptions) {
    const width = elementSize(this.element).width || DEFAULT_WIDTH;
    let theme = themeOptions;
    const stockDefaults = {
      seriesDefaults: {
        categoryField: options.dateField
      },
      axisDefaults: {
        categoryAxis: {
          name: "default",
          majorGridLines: {
            visible: false
          },
          labels: {
            step: 2
          },
          majorTicks: {
            visible: false
          },
          maxDateGroups: Math.floor(width / AUTO_CATEGORY_WIDTH)
        }
      }
    };
    if (theme) {
      theme = deepExtend({}, theme, stockDefaults);
    }
    navigator_default.setup(options, theme);
    super.applyDefaults(options, theme);
  }
  _setElementClass(element) {
    addClass(element, "k-chart k-stockchart");
  }
  setOptions(options) {
    this.destroyNavigator();
    super.setOptions(options);
  }
  noTransitionsRedraw() {
    const transitions = this.options.transitions;
    this.options.transitions = false;
    this._fullRedraw();
    this.options.transitions = transitions;
  }
  _resize() {
    this.noTransitionsRedraw();
  }
  _redraw() {
    const navigator2 = this.navigator;
    if (!this._dirty() && navigator2 && navigator2.options.partialRedraw) {
      navigator2.redrawSlaves();
    } else {
      this._fullRedraw();
    }
  }
  _dirty() {
    const options = this.options;
    const series = [].concat(options.series, options.navigator.series);
    const seriesCount = grep_default(series, function(s10) {
      return s10 && s10.visible;
    }).length;
    const dirty = this._seriesCount !== seriesCount;
    this._seriesCount = seriesCount;
    return dirty;
  }
  _fullRedraw() {
    let navigator2 = this.navigator;
    if (!navigator2) {
      navigator2 = this.navigator = new navigator_default(this);
      this.trigger("navigatorCreated", { navigator: navigator2 });
    }
    navigator2.clean();
    navigator2.setRange();
    super._redraw();
    navigator2.initSelection();
  }
  _trackSharedTooltip(coords) {
    const plotArea = this._plotArea;
    const pane = plotArea.paneByPoint(coords);
    if (pane && pane.options.name === NAVIGATOR_PANE) {
      this._unsetActivePoint();
    } else {
      super._trackSharedTooltip(coords);
    }
  }
  bindCategories() {
    super.bindCategories();
    this.copyNavigatorCategories();
  }
  copyNavigatorCategories() {
    const definitions = [].concat(this.options.categoryAxis);
    let categories;
    for (let axisIx = 0; axisIx < definitions.length; axisIx++) {
      const axis = definitions[axisIx];
      if (axis.name === NAVIGATOR_AXIS) {
        categories = axis.categories;
      } else if (categories && axis.pane === NAVIGATOR_PANE) {
        axis.categories = categories;
      }
    }
  }
  destroyNavigator() {
    if (this.navigator) {
      this.navigator.destroy();
      this.navigator = null;
    }
  }
  destroy() {
    this.destroyNavigator();
    super.destroy();
  }
  _stopChartHandlers(e41) {
    const coords = this._eventCoordinates(e41);
    const pane = this._plotArea.paneByPoint(coords);
    return super._stopChartHandlers(e41) || pane && pane.options.name === NAVIGATOR_PANE;
  }
  _toggleDragZoomEvents() {
    if (!this._dragZoomEnabled) {
      this.element.style.touchAction = "none";
      this._dragZoomEnabled = true;
    }
  }
};
setDefaultOptions(StockChart, {
  dateField: "date",
  axisDefaults: {
    categoryAxis: {
      type: "date",
      baseUnit: "fit",
      justified: true
    },
    valueAxis: {
      narrowRange: true,
      labels: {
        format: "C"
      }
    }
  },
  navigator: {
    select: {},
    seriesDefaults: {
      markers: {
        visible: false
      },
      tooltip: {
        visible: false
      },
      highlight: {
        visible: false
      },
      line: {
        width: 2
      }
    },
    hint: {},
    visible: true
  },
  tooltip: {
    visible: true
  },
  legend: {
    visible: false
  }
});
var stock_chart_default = StockChart;

// node_modules/@progress/kendo-charts/dist/es/gauges/constants.js
var ANGULAR_SPEED = 150;
var LINEAR_SPEED = 250;
var ARROW = "arrow";
var ARROW_POINTER = "arrowPointer";
var BAR_POINTER = "barPointer";
var DEFAULT_HEIGHT2 = 200;
var DEFAULT_LINE_WIDTH = 0.5;
var DEFAULT_WIDTH2 = 200;
var DEGREE = Math.PI / 180;
var INSIDE2 = "inside";
var LINEAR2 = "linear";
var OUTSIDE2 = "outside";
var RADIAL_POINTER = "radialPointer";
var RADIAL_RANGE_POINTER = "radialRangePointer";

// node_modules/@progress/kendo-charts/dist/es/gauges/utils/pad.js
function pad(bbox, value2) {
  const origin = bbox.getOrigin();
  const size = bbox.getSize();
  const spacing = getSpacing(value2);
  bbox.setOrigin([origin.x - spacing.left, origin.y - spacing.top]);
  bbox.setSize([size.width + (spacing.left + spacing.right), size.height + (spacing.top + spacing.bottom)]);
  return bbox;
}

// node_modules/@progress/kendo-charts/dist/es/gauges/utils/build-label-element.js
var { Group, Path, Text: Text2 } = drawing_exports;
function buildLabelElement(label, options) {
  const labelBox = label.box;
  const textBox = label.children[0].box;
  const border = options.border || {};
  const background = options.background || "";
  const wrapper = Path.fromRect(new geometry_exports.Rect([labelBox.x1, labelBox.y1], [labelBox.width(), labelBox.height()]), {
    stroke: {}
  });
  const text = new Text2(label.text, new geometry_exports.Point(textBox.x1, textBox.y1), {
    font: options.font,
    fill: { color: options.color }
  });
  const styleGeometry = pad(text.bbox().clone(), options.padding);
  const styleBox = Path.fromRect(styleGeometry, {
    stroke: {
      color: border.width ? border.color : "",
      width: border.width,
      opacity: border.opacity,
      dashType: border.dashType,
      lineJoin: "round",
      lineCap: "round"
    },
    fill: {
      color: background
    }
  });
  const elements = new Group();
  elements.append(wrapper);
  elements.append(styleBox);
  elements.append(text);
  return elements;
}

// node_modules/@progress/kendo-charts/dist/es/gauges/utils/get-range.js
function getRange(range, min4, max3) {
  const from = defined(range.from) ? range.from : MIN_VALUE;
  const to = defined(range.to) ? range.to : MAX_VALUE;
  range.from = Math.max(Math.min(to, from), min4);
  range.to = Math.min(Math.max(to, from), max3);
  return range;
}

// node_modules/@progress/kendo-charts/dist/es/gauges/utils/unpad.js
function unpad(bbox, value2) {
  const spacing = getSpacing(value2);
  spacing.left = -spacing.left;
  spacing.top = -spacing.top;
  spacing.right = -spacing.right;
  spacing.bottom = -spacing.bottom;
  return pad(bbox, spacing);
}

// node_modules/@progress/kendo-charts/dist/es/gauges/gauge.js
var DEFAULT_MARGIN = 5;
var { Path: Path2, Surface } = drawing_exports;
var Gauge = class {
  constructor(element, userOptions, theme, context = {}) {
    this.element = element;
    this.theme = theme;
    this.contextService = new chart_service_default(this, context);
    this._originalOptions = deepExtend({}, this.options, userOptions);
    this.options = deepExtend({}, this._originalOptions);
    this._initTheme(theme);
    this.redraw();
  }
  destroy() {
    if (this.surface) {
      this.surface.destroy();
      this.surface = null;
    }
    delete this.element;
    delete this.surfaceElement;
  }
  value(pointerValue) {
    const pointer = this.pointers[0];
    if (arguments.length === 0) {
      return pointer.value();
    }
    pointer.value(pointerValue);
    this._setValueOptions(pointerValue);
  }
  _draw() {
    const surface = this.surface;
    surface.clear();
    surface.draw(this._visuals);
  }
  exportVisual() {
    return this._visuals;
  }
  allValues(values) {
    const pointers = this.pointers;
    const allValues = [];
    if (arguments.length === 0) {
      for (let i37 = 0; i37 < pointers.length; i37++) {
        allValues.push(pointers[i37].value());
      }
      return allValues;
    }
    if (isArray(values)) {
      for (let i37 = 0; i37 < values.length; i37++) {
        if (isNumber(values[i37])) {
          pointers[i37].value(values[i37]);
        }
      }
    }
    this._setValueOptions(values);
  }
  _setValueOptions(values) {
    const pointers = [].concat(this.options.pointer);
    const arrayValues = [].concat(values);
    for (let i37 = 0; i37 < arrayValues.length; i37++) {
      pointers[i37].value = arrayValues[i37];
    }
  }
  resize() {
    this.noTransitionsRedraw();
  }
  noTransitionsRedraw() {
    const transitions = this.options.transitions;
    this._toggleTransitions(false);
    this.redraw();
    this._toggleTransitions(transitions);
  }
  redraw() {
    const size = this._surfaceSize();
    const wrapper = new geometry_exports.Rect([0, 0], [size.width, size.height]);
    this._initSurface();
    this.gaugeArea = this._createGaugeArea();
    this._createModel();
    const bbox = unpad(wrapper.bbox(), this._gaugeAreaMargin);
    this.reflow(bbox);
  }
  setOptions(options, theme) {
    this._originalOptions = deepExtend(this._originalOptions, options);
    this.options = deepExtend({}, this._originalOptions);
    this._initTheme(theme);
    this.redraw();
  }
  setDirection(rtl) {
    this.contextService.rtl = Boolean(rtl);
    if (this.surface && this.surface.type === "svg") {
      this.surface.destroy();
      this.surface = null;
    }
  }
  setIntlService(intl) {
    this.contextService.intl = intl;
  }
  _initTheme(theme) {
    let currentTheme = theme || this.theme || {};
    this.theme = currentTheme;
    this.options = deepExtend({}, currentTheme, this.options);
    const options = this.options;
    const pointer = options.pointer;
    if (isArray(pointer)) {
      const pointers = [];
      for (let i37 = 0; i37 < pointer.length; i37++) {
        pointers.push(deepExtend({}, currentTheme.pointer, pointer[i37]));
      }
      options.pointer = pointers;
    }
  }
  _createGaugeArea() {
    const options = this.options.gaugeArea;
    const size = this.surface.size();
    const border = options.border || {};
    let areaGeometry = new geometry_exports.Rect([0, 0], [size.width, size.height]);
    this._gaugeAreaMargin = options.margin || DEFAULT_MARGIN;
    if (border.width > 0) {
      areaGeometry = unpad(areaGeometry, border.width);
    }
    const gaugeArea = Path2.fromRect(areaGeometry, {
      stroke: {
        color: border.width ? border.color : "",
        width: border.width,
        opacity: border.opacity,
        dashType: border.dashType,
        lineJoin: "round",
        lineCap: "round"
      },
      fill: {
        color: options.background
      }
    });
    return gaugeArea;
  }
  _initSurface() {
    const { options, surface } = this;
    const element = this._surfaceElement();
    const size = this._surfaceSize();
    elementSize(element, size);
    if (!surface || surface.options.type !== options.renderAs) {
      if (surface) {
        surface.destroy();
      }
      this.surface = Surface.create(element, {
        type: options.renderAs
      });
    } else {
      this.surface.clear();
      this.surface.resize();
    }
  }
  _surfaceSize() {
    const options = this.options;
    const size = this._getSize();
    if (options.gaugeArea) {
      deepExtend(size, options.gaugeArea);
    }
    return size;
  }
  _surfaceElement() {
    if (!this.surfaceElement) {
      this.surfaceElement = document.createElement("div");
      this.element.appendChild(this.surfaceElement);
    }
    return this.surfaceElement;
  }
  getSize() {
    return this._getSize();
  }
  _getSize() {
    const element = this.element;
    const defaultSize = this._defaultSize();
    let width = element.offsetWidth;
    let height = element.offsetHeight;
    if (!width) {
      width = defaultSize.width;
    }
    if (!height) {
      height = defaultSize.height;
    }
    return { width, height };
  }
  _defaultSize() {
    return {
      width: DEFAULT_WIDTH2,
      height: DEFAULT_HEIGHT2
    };
  }
  _toggleTransitions(value2) {
    this.options.transitions = value2;
    for (let i37 = 0; i37 < this.pointers.length; i37++) {
      this.pointers[i37].options.animation.transitions = value2;
    }
  }
};
setDefaultOptions(Gauge, {
  plotArea: {},
  theme: "default",
  renderAs: "",
  pointer: {},
  scale: {},
  gaugeArea: {}
});
var gauge_default = Gauge;

// node_modules/@progress/kendo-charts/dist/es/gauges/linear/linear-scale.js
var { Path: Path3, Group: Group2 } = drawing_exports;
var Point2 = geometry_exports.Point;
function renderAxisTick(tickRenderOptions, tickOptions) {
  const { position, tickX, tickY } = tickRenderOptions;
  let start, end;
  if (tickRenderOptions.vertical) {
    start = new Point2(tickX, position);
    end = new Point2(tickX + tickOptions.size, position);
  } else {
    start = new Point2(position, tickY);
    end = new Point2(position, tickY + tickOptions.size);
  }
  const tickPath = new Path3({
    stroke: {
      color: tickOptions.color,
      width: tickOptions.width
    }
  }).moveTo(start).lineTo(end);
  return tickPath;
}
function renderTicks(tickGroup, tickPositions, tickRenderOptions, tickOptions) {
  const count = tickPositions.length;
  if (tickOptions.visible) {
    const { mirror, lineBox } = tickRenderOptions;
    for (let i37 = tickOptions.skip; i37 < count; i37 += tickOptions.step) {
      if (i37 % tickOptions.skipUnit === 0) {
        continue;
      }
      tickRenderOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;
      tickRenderOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;
      tickRenderOptions.position = tickPositions[i37];
      tickGroup.append(renderAxisTick(tickRenderOptions, tickOptions));
    }
  }
}
var LinearScale = class extends numeric_axis_default {
  constructor(options, service) {
    let scaleOptions = options || {};
    if (!defined(scaleOptions.reverse) && scaleOptions.vertical === false && (service || {}).rtl) {
      scaleOptions = Object.assign({}, scaleOptions, {
        reverse: true
      });
    }
    super(0, 1, scaleOptions, service);
    this.options.minorUnit = this.options.minorUnit || this.options.majorUnit / 10;
  }
  initUserOptions(options) {
    let scaleOptions = deepExtend({}, this.options, options);
    scaleOptions = deepExtend({}, scaleOptions, { labels: { mirror: scaleOptions.mirror } });
    scaleOptions.majorUnit = scaleOptions.majorUnit || autoMajorUnit(scaleOptions.min, scaleOptions.max);
    return scaleOptions;
  }
  initFields() {
  }
  render() {
    const elements = this.elements = new Group2();
    const labels = this.renderLabels();
    const scaleLine = this.renderLine();
    const scaleTicks = this.renderTicks();
    const ranges = this.renderRanges();
    elements.append(scaleLine, labels, scaleTicks, ranges);
    return elements;
  }
  renderRanges() {
    const options = this.options;
    const { min: min4, max: max3, vertical, labels: { mirror } } = options;
    const ranges = options.ranges || [];
    const elements = new Group2();
    const count = ranges.length;
    const rangeSize = options.rangeSize || options.minorTicks.size / 2;
    for (let i37 = 0; i37 < count; i37++) {
      const range = getRange(ranges[i37], min4, max3);
      const slot = this.getSlot(range.from, range.to);
      const slotX = vertical ? this.lineBox() : slot;
      const slotY = vertical ? slot : this.lineBox();
      if (vertical) {
        slotX.x1 -= rangeSize * (mirror ? -1 : 1);
      } else {
        slotY.y2 += rangeSize * (mirror ? -1 : 1);
      }
      elements.append(Path3.fromRect(new geometry_exports.Rect([slotX.x1, slotY.y1], [slotX.x2 - slotX.x1, slotY.y2 - slotY.y1]), {
        fill: { color: range.color, opacity: range.opacity },
        stroke: {}
      }));
    }
    return elements;
  }
  renderLabels() {
    const { labels, options } = this;
    const elements = new Group2();
    for (let i37 = 0; i37 < labels.length; i37++) {
      elements.append(buildLabelElement(labels[i37], options.labels));
    }
    return elements;
  }
  renderLine() {
    const line = this.options.line;
    const lineBox = this.lineBox();
    const elements = new Group2();
    if (line.width > 0 && line.visible) {
      const linePath = new Path3({
        stroke: {
          color: line.color,
          dashType: line.dashType,
          width: line.width
        }
      });
      linePath.moveTo(lineBox.x1, lineBox.y1).lineTo(lineBox.x2, lineBox.y2);
      elements.append(linePath);
    }
    return elements;
  }
  renderTicks() {
    const ticks = new Group2();
    const options = this.options;
    const majorUnit = options.majorTicks.visible ? options.majorUnit : 0;
    const tickRenderOptions = {
      vertical: options.vertical,
      mirror: options.labels.mirror,
      lineBox: this.lineBox()
    };
    renderTicks(ticks, this.getMajorTickPositions(), tickRenderOptions, options.majorTicks);
    renderTicks(ticks, this.getMinorTickPositions(), tickRenderOptions, deepExtend({}, {
      skipUnit: majorUnit / options.minorUnit
    }, options.minorTicks));
    return ticks;
  }
};
setDefaultOptions(LinearScale, {
  min: 0,
  max: 50,
  majorTicks: {
    size: 15,
    align: INSIDE2,
    color: BLACK,
    width: DEFAULT_LINE_WIDTH,
    visible: true
  },
  minorTicks: {
    size: 10,
    align: INSIDE2,
    color: BLACK,
    width: DEFAULT_LINE_WIDTH,
    visible: true
  },
  line: {
    width: DEFAULT_LINE_WIDTH
  },
  labels: {
    position: INSIDE2,
    padding: 2
  },
  mirror: false,
  _alignLines: false
});
var linear_scale_default = LinearScale;

// node_modules/@progress/kendo-charts/dist/es/gauges/pointer.js
var Pointer = class {
  constructor(scale, userOptions) {
    const { min: min4, max: max3 } = scale.options;
    const options = this.options = deepExtend({}, this.options, userOptions);
    options.fill = options.color;
    this.scale = scale;
    if (defined(options.value)) {
      options.value = limitValue(options.value, min4, max3);
    } else {
      options.value = min4;
    }
  }
  value(newValue) {
    const options = this.options;
    const value2 = options.value;
    if (arguments.length === 0) {
      return value2;
    }
    const { min: min4, max: max3 } = this.scale.options;
    options._oldValue = defined(options._oldValue) ? options.value : min4;
    options.value = limitValue(newValue, min4, max3);
    if (this.elements) {
      this.repaint();
    }
  }
};
setDefaultOptions(Pointer, {
  color: BLACK
});
var pointer_default = Pointer;

// node_modules/@progress/kendo-charts/dist/es/gauges/linear/linear-pointer.js
var LinearPointer = class extends pointer_default {
  constructor(scale, options) {
    super(scale, options);
    this.options = deepExtend({
      track: {
        visible: defined(options.track)
      }
    }, this.options);
  }
  reflow() {
    const { options, scale } = this;
    const { mirror, vertical } = scale.options;
    const scaleLine = scale.lineBox();
    const trackSize = options.track.size || options.size;
    const pointerHalfSize = options.size / 2;
    const margin = getSpacing(options.margin);
    let space = vertical ? margin[mirror ? "left" : "right"] : margin[mirror ? "bottom" : "top"];
    let pointerBox, pointerRangeBox, trackBox;
    space = mirror ? -space : space;
    if (vertical) {
      trackBox = new box_default(
        scaleLine.x1 + space,
        scaleLine.y1,
        scaleLine.x1 + space,
        scaleLine.y2
      );
      if (mirror) {
        trackBox.x1 -= trackSize;
      } else {
        trackBox.x2 += trackSize;
      }
      if (options.shape !== BAR_POINTER) {
        pointerRangeBox = new box_default(
          scaleLine.x2 + space,
          scaleLine.y1 - pointerHalfSize,
          scaleLine.x2 + space,
          scaleLine.y2 + pointerHalfSize
        );
        pointerBox = pointerRangeBox;
      }
    } else {
      trackBox = new box_default(
        scaleLine.x1,
        scaleLine.y1 - space,
        scaleLine.x2,
        scaleLine.y1 - space
      );
      if (mirror) {
        trackBox.y2 += trackSize;
      } else {
        trackBox.y1 -= trackSize;
      }
      if (options.shape !== BAR_POINTER) {
        pointerRangeBox = new box_default(
          scaleLine.x1 - pointerHalfSize,
          scaleLine.y1 - space,
          scaleLine.x2 + pointerHalfSize,
          scaleLine.y1 - space
        );
        pointerBox = pointerRangeBox;
      }
    }
    this.trackBox = trackBox;
    this.pointerRangeBox = pointerRangeBox;
    this.box = pointerBox || trackBox.clone().pad(options.border.width);
  }
  getElementOptions() {
    const options = this.options;
    return {
      fill: {
        color: options.color,
        opacity: options.opacity
      },
      stroke: defined(options.border) ? {
        color: options.border.width ? options.border.color || options.color : "",
        width: options.border.width,
        dashType: options.border.dashType,
        opacity: options.opacity
      } : null
    };
  }
  _margin() {
    const { scale, options } = this;
    const { mirror, vertical } = scale.options;
    const margin = getSpacing(options.margin);
    const space = vertical ? margin[mirror ? "left" : "right"] : margin[mirror ? "bottom" : "top"];
    return space;
  }
};
setDefaultOptions(LinearPointer, {
  shape: BAR_POINTER,
  track: {
    border: {
      width: 1
    }
  },
  color: BLACK,
  border: {
    width: 1
  },
  opacity: 1,
  margin: getSpacing(3),
  animation: {
    type: BAR_POINTER
  },
  visible: true
});
var linear_pointer_default = LinearPointer;

// node_modules/@progress/kendo-charts/dist/es/gauges/linear/arrow-linear-pointer-animation.js
var ArrowLinearPointerAnimation = class extends drawing_exports.Animation {
  setup() {
    const options = this.options;
    const { margin, from, to, vertical } = options;
    const axis = vertical ? "x1" : "y1";
    if (options.mirror === vertical) {
      from[axis] -= margin;
      to[axis] -= margin;
    } else {
      from[axis] += margin;
      to[axis] += margin;
    }
    const fromScale = this.fromScale = new geometry_exports.Point(from.x1, from.y1);
    const toScale = this.toScale = new geometry_exports.Point(to.x1, to.y1);
    if (options.duration !== 0) {
      options.duration = Math.max(fromScale.distanceTo(toScale) / options.duration * 1e3, 1);
    }
  }
  step(pos) {
    const translateX = interpolateValue(this.fromScale.x, this.toScale.x, pos);
    const translateY = interpolateValue(this.fromScale.y, this.toScale.y, pos);
    this.element.transform(geometry_exports.transform().translate(translateX, translateY));
  }
};
setDefaultOptions(ArrowLinearPointerAnimation, {
  easing: LINEAR2,
  duration: LINEAR_SPEED
});
drawing_exports.AnimationFactory.current.register(ARROW_POINTER, ArrowLinearPointerAnimation);
var arrow_linear_pointer_animation_default = ArrowLinearPointerAnimation;

// node_modules/@progress/kendo-charts/dist/es/gauges/linear/arrow-linear-pointer.js
var Point3 = geometry_exports.Point;
var Path4 = drawing_exports.Path;
var ArrowLinearPointer = class extends linear_pointer_default {
  constructor(scale, options) {
    super(scale, options);
    if (!defined(this.options.size)) {
      this.options.size = this.scale.options.majorTicks.size * 0.6;
    }
  }
  pointerShape() {
    const { scale, options: { size } } = this;
    const halfSize = size / 2;
    const sign = scale.options.mirror ? -1 : 1;
    let shape;
    if (scale.options.vertical) {
      shape = [
        new Point3(0, 0 - halfSize),
        new Point3(0 - sign * size, 0),
        new Point3(0, 0 + halfSize)
      ];
    } else {
      shape = [
        new Point3(0 - halfSize, 0),
        new Point3(0, 0 + sign * size),
        new Point3(0 + halfSize, 0)
      ];
    }
    return shape;
  }
  repaint() {
    const { scale, options } = this;
    const animation = new arrow_linear_pointer_animation_default(this.elements, deepExtend(options.animation, {
      vertical: scale.options.vertical,
      mirror: scale.options.mirror,
      margin: this._margin(options.margin),
      from: scale.getSlot(options._oldValue),
      to: scale.getSlot(options.value)
    }));
    if (options.animation.transitions === false) {
      animation.options.duration = 0;
    }
    animation.setup();
    animation.play();
  }
  render() {
    const { scale, options } = this;
    const elementOptions = this.getElementOptions();
    const shape = this.pointerShape(options.value);
    options.animation.type = ARROW_POINTER;
    const elements = new Path4({
      stroke: elementOptions.stroke,
      fill: elementOptions.fill
    }).moveTo(shape[0]).lineTo(shape[1]).lineTo(shape[2]).close();
    const slot = scale.getSlot(options.value);
    elements.transform(geometry_exports.transform().translate(slot.x1, slot.y1));
    this.elements = elements;
    return elements;
  }
};
var arrow_linear_pointer_default = ArrowLinearPointer;

// node_modules/@progress/kendo-charts/dist/es/gauges/linear/bar-linear-pointer-animation.js
var BarLinearPointerAnimation = class extends drawing_exports.Animation {
  setup() {
    const options = this.options;
    const axis = this.axis = options.vertical ? Y : X;
    const to = this.to = options.newPoints[0][axis];
    const from = this.from = options.oldPoints[0][axis];
    if (options.duration !== 0) {
      options.duration = Math.max(Math.abs(to - from) / options.speed * 1e3, 1);
    }
    this._set(from);
  }
  step(pos) {
    const value2 = interpolateValue(this.from, this.to, pos);
    this._set(value2);
  }
  _set(value2) {
    const setter = "set" + this.axis.toUpperCase();
    const points = this.options.newPoints;
    points[0][setter](value2);
    points[1][setter](value2);
  }
};
setDefaultOptions(BarLinearPointerAnimation, {
  easing: LINEAR2,
  speed: LINEAR_SPEED
});
drawing_exports.AnimationFactory.current.register(BAR_POINTER, BarLinearPointerAnimation);
var bar_linear_pointer_animation_default = BarLinearPointerAnimation;

// node_modules/@progress/kendo-charts/dist/es/gauges/linear/bar-linear-pointer.js
var { Group: Group3, Path: Path5 } = drawing_exports;
var BarLinearPointer = class extends linear_pointer_default {
  constructor(scale, options) {
    super(scale, options);
    if (!defined(this.options.size)) {
      this.options.size = this.scale.options.majorTicks.size * 0.3;
    }
  }
  pointerShape(value2) {
    const { scale, options } = this;
    const { mirror, vertical } = scale.options;
    const dir = mirror === vertical ? -1 : 1;
    const size = options.size * dir;
    const minSlot = scale.getSlot(scale.options.min);
    const slot = scale.getSlot(value2);
    const axis = vertical ? Y : X;
    const sizeAxis = vertical ? X : Y;
    const margin = this._margin() * dir;
    const p1 = new geometry_exports.Point();
    p1[axis] = minSlot[axis + "1"];
    p1[sizeAxis] = minSlot[sizeAxis + "1"];
    const p22 = new geometry_exports.Point();
    p22[axis] = slot[axis + "1"];
    p22[sizeAxis] = slot[sizeAxis + "1"];
    if (vertical) {
      p1.translate(margin, 0);
      p22.translate(margin, 0);
    } else {
      p1.translate(0, margin);
      p22.translate(0, margin);
    }
    const p32 = p22.clone();
    const p42 = p1.clone();
    if (vertical) {
      p32.translate(size, 0);
      p42.translate(size, 0);
    } else {
      p32.translate(0, size);
      p42.translate(0, size);
    }
    return [p1, p22, p32, p42];
  }
  repaint() {
    const { scale, options } = this;
    const shape = this.pointerShape(options.value);
    const pointerPath = this.pointerPath;
    const oldShape = this.pointerShape(options._oldValue);
    pointerPath.moveTo(shape[0]).lineTo(shape[1]).lineTo(shape[2]).lineTo(shape[3]).close();
    const animation = new bar_linear_pointer_animation_default(pointerPath, deepExtend(options.animation, {
      reverse: scale.options.reverse,
      vertical: scale.options.vertical,
      oldPoints: [oldShape[1], oldShape[2]],
      newPoints: [shape[1], shape[2]]
    }));
    if (options.animation.transitions === false) {
      animation.options.duration = 0;
    }
    animation.setup();
    animation.play();
  }
  render() {
    const group = new Group3();
    const elementOptions = this.getElementOptions();
    if (this.options.track.visible) {
      group.append(this.renderTrack());
    }
    const pointer = this.pointerPath = new Path5({
      stroke: elementOptions.stroke,
      fill: elementOptions.fill
    });
    group.append(pointer);
    this.elements = group;
    return group;
  }
  renderTrack() {
    const trackOptions = this.options.track;
    const border = trackOptions.border || {};
    const trackBox = this.trackBox.clone().pad(border.width || 0);
    return Path5.fromRect(trackBox.toRect(), {
      fill: {
        color: trackOptions.color,
        opacity: trackOptions.opacity
      },
      stroke: {
        color: border.width ? border.color || trackOptions.color : "",
        width: border.width,
        dashType: border.dashType
      }
    });
  }
};
var bar_linear_pointer_default = BarLinearPointer;

// node_modules/@progress/kendo-charts/dist/es/gauges/linear/linear-gauge.js
var DEFAULT_MIN_WIDTH = 60;
var DEFAULT_MIN_HEIGHT = 60;
var Group4 = drawing_exports.Group;
var LinearGauge = class extends gauge_default {
  reflow(bbox) {
    const pointers = this.pointers;
    const bboxX = bbox.origin.x;
    const bboxY = bbox.origin.y;
    const box = new box_default(bboxX, bboxY, bboxX + bbox.width(), bboxY + bbox.height());
    this.scale.reflow(box);
    this._shrinkScaleWidth(box);
    for (let i37 = 0; i37 < pointers.length; i37++) {
      pointers[i37].reflow();
    }
    this.bbox = this._getBox(box);
    this._alignElements();
    this._shrinkElements();
    this._buildVisual();
    this._draw();
  }
  _buildVisual() {
    const visuals = new Group4();
    const scaleElements = this.scale.render();
    const pointers = this.pointers;
    visuals.append(this.gaugeArea);
    visuals.append(scaleElements);
    for (let i37 = 0; i37 < pointers.length; i37++) {
      const current4 = pointers[i37];
      visuals.append(current4.render());
      current4.value(current4.options.value);
    }
    this._visuals = visuals;
  }
  _createModel() {
    const options = this.options;
    const scale = this.scale = new linear_scale_default(options.scale, this.contextService);
    this.pointers = [];
    let pointers = options.pointer;
    pointers = isArray(pointers) ? pointers : [pointers];
    for (let i37 = 0; i37 < pointers.length; i37++) {
      const currentOptions = deepExtend({}, pointers[i37], {
        animation: {
          transitions: options.transitions
        }
      });
      const pointerType = currentOptions.shape === ARROW ? arrow_linear_pointer_default : bar_linear_pointer_default;
      this.pointers.push(new pointerType(scale, currentOptions));
    }
  }
  _defaultSize() {
    const vertical = this.options.scale.vertical;
    return {
      width: vertical ? DEFAULT_MIN_WIDTH : DEFAULT_WIDTH2,
      height: vertical ? DEFAULT_HEIGHT2 : DEFAULT_MIN_HEIGHT
    };
  }
  _getBox(box) {
    const { scale, pointers } = this;
    const boxCenter = box.center();
    let plotAreaBox = pointers[0].box.clone().wrap(scale.box);
    for (let i37 = 0; i37 < pointers.length; i37++) {
      plotAreaBox.wrap(pointers[i37].box.clone());
    }
    let size;
    if (scale.options.vertical) {
      size = plotAreaBox.width() / 2;
      plotAreaBox = new box_default(
        boxCenter.x - size,
        box.y1,
        boxCenter.x + size,
        box.y2
      );
    } else {
      size = plotAreaBox.height() / 2;
      plotAreaBox = new box_default(
        box.x1,
        boxCenter.y - size,
        box.x2,
        boxCenter.y + size
      );
    }
    return plotAreaBox;
  }
  _alignElements() {
    const { scale, pointers } = this;
    const scaleBox = scale.box;
    const box = pointers[0].box.clone().wrap(scale.box);
    const plotAreaBox = this.bbox;
    for (let i37 = 0; i37 < pointers.length; i37++) {
      box.wrap(pointers[i37].box.clone());
    }
    let diff;
    if (scale.options.vertical) {
      diff = plotAreaBox.center().x - box.center().x;
      scale.reflow(new box_default(
        scaleBox.x1 + diff,
        plotAreaBox.y1,
        scaleBox.x2 + diff,
        plotAreaBox.y2
      ));
    } else {
      diff = plotAreaBox.center().y - box.center().y;
      scale.reflow(new box_default(
        scaleBox.x1,
        scaleBox.y1 + diff,
        scaleBox.x2,
        scaleBox.y2 + diff
      ));
    }
    for (let i37 = 0; i37 < pointers.length; i37++) {
      pointers[i37].reflow(this.bbox);
    }
  }
  _shrinkScaleWidth(bbox) {
    const { scale } = this;
    if (!scale.options.vertical) {
      const overflow = scale.contentBox().width() - bbox.width();
      if (overflow > 0) {
        scale.box.shrink(overflow, 0);
        scale.box.alignTo(bbox, "center");
        scale.reflow(scale.box);
      }
    }
  }
  _shrinkElements() {
    const { scale, pointers } = this;
    const scaleBox = scale.box.clone();
    const pos = scale.options.vertical ? "y" : "x";
    const pointerBox = pointers[0].box;
    for (let i37 = 0; i37 < pointers.length; i37++) {
      pointerBox.wrap(pointers[i37].box.clone());
    }
    scaleBox[pos + 1] += Math.max(scaleBox[pos + 1] - pointerBox[pos + 1], 0);
    scaleBox[pos + 2] -= Math.max(pointerBox[pos + 2] - scaleBox[pos + 2], 0);
    scale.reflow(scaleBox);
    for (let i37 = 0; i37 < pointers.length; i37++) {
      pointers[i37].reflow(this.bbox);
    }
  }
};
setDefaultOptions(LinearGauge, {
  transitions: true,
  gaugeArea: {
    background: ""
  },
  scale: {
    vertical: true
  }
});

// node_modules/@progress/kendo-charts/dist/es/gauges/radial/radial-scale.js
var GEO_ARC_ADJUST_ANGLE = 180;
var { Arc, Path: Path6, Group: Group5 } = drawing_exports;
function drawTicks(arc, tickAngles, unit, tickOptions) {
  const ticks = new Group5();
  const center = arc.center;
  const radius = arc.getRadiusX();
  if (tickOptions.visible) {
    for (let i37 = 0; i37 < tickAngles.length; i37++) {
      const tickStart = arc.pointAt(tickAngles[i37]);
      const tickEnd = new geometry_exports.Point(center.x + radius - tickOptions.size, center.y).rotate(tickAngles[i37], center);
      ticks.append(new Path6({
        stroke: {
          color: tickOptions.color,
          width: tickOptions.width
        }
      }).moveTo(tickStart).lineTo(tickEnd));
    }
  }
  return ticks;
}
function rangeSegment(from, to, color, opacity) {
  return { from, to, color, opacity };
}
var RadialScale = class extends numeric_axis_default {
  constructor(options, service) {
    super(0, 1, options, service);
  }
  initUserOptions(options) {
    const scaleOptions = deepExtend({}, this.options, options);
    scaleOptions.majorUnit = scaleOptions.majorUnit || autoMajorUnit(scaleOptions.min, scaleOptions.max);
    scaleOptions.minorUnit = scaleOptions.minorUnit || scaleOptions.majorUnit / 10;
    return scaleOptions;
  }
  initFields() {
  }
  render(center, radius) {
    const arc = this.renderArc(center, radius);
    this.bbox = arc.bbox();
    this.labelElements = this.renderLabels();
    this.ticks = this.renderTicks();
    this.ranges = this.renderRanges();
  }
  reflow(bbox) {
    const center = bbox.center();
    const radius = Math.min(bbox.height(), bbox.width()) / 2;
    if (defined(this.bbox)) {
      this.bbox = this.arc.bbox();
      this.radius(this.arc.getRadiusX());
      this.repositionRanges();
      this.renderLabels();
    } else {
      return this.render(center, radius);
    }
  }
  slotAngle(value2) {
    const { min: min4, max: max3, reverse, startAngle, endAngle } = this.options;
    const angle = endAngle - startAngle;
    let result;
    if (reverse) {
      result = endAngle - (value2 - min4) / (max3 - min4) * angle;
    } else {
      result = (value2 - min4) / (max3 - min4) * angle + startAngle;
    }
    return result + GEO_ARC_ADJUST_ANGLE;
  }
  hasRanges() {
    const ranges = this.options.ranges;
    return ranges && ranges.length;
  }
  ticksSize() {
    const { majorTicks, minorTicks } = this.options;
    let size = 0;
    if (majorTicks.visible) {
      size = majorTicks.size;
    }
    if (minorTicks.visible) {
      size = Math.max(minorTicks.size, size);
    }
    return size;
  }
  labelsCount() {
    let count = super.labelsCount();
    const options = this.options;
    const angle = options.endAngle - options.startAngle;
    if (angle >= 360 && options.max % options.majorUnit === 0) {
      count -= 1;
    }
    return count;
  }
  renderLabels() {
    const options = this.options;
    const arc = this.arc.clone();
    let radius = arc.getRadiusX();
    const tickAngles = this.tickAngles(arc, options.majorUnit);
    const rangeSize = options.rangeSize = options.rangeSize || radius * 0.1;
    const labelsGroup = new Group5();
    let rangeDistance = radius * 0.05;
    if (defined(options.rangeDistance)) {
      rangeDistance = options.rangeDistance;
    } else {
      options.rangeDistance = rangeDistance;
    }
    const labelsOptions = options.labels;
    const isInside = labelsOptions.position === INSIDE2;
    const hasLabelElements = defined(this.labelElements);
    if (isInside) {
      radius -= this.ticksSize();
      if (this.hasRanges() && !hasLabelElements) {
        radius -= rangeSize + rangeDistance;
      }
      arc.setRadiusX(radius).setRadiusY(radius);
    }
    const labels = this.labels;
    const count = labels.length;
    const padding = getSpacing(labelsOptions.padding);
    const paddingWidth = (padding.left + padding.right) / 2;
    const paddingHeight = (padding.top + padding.bottom) / 2;
    for (let i37 = 0; i37 < count; i37++) {
      const label = labels[i37];
      const halfWidth = label.box.width() / 2;
      const halfHeight = label.box.height() / 2;
      const angle = tickAngles[i37];
      const labelAngle = (angle - GEO_ARC_ADJUST_ANGLE) * DEGREE;
      const lp = arc.pointAt(angle);
      const cx = lp.x + Math.cos(labelAngle) * (halfWidth + paddingWidth) * (isInside ? 1 : -1);
      const cy = lp.y + Math.sin(labelAngle) * (halfHeight + paddingHeight) * (isInside ? 1 : -1);
      label.reflow(new box_default(cx - halfWidth, cy - halfHeight, cx + halfWidth, cy + halfHeight));
      const labelPos = new geometry_exports.Point(label.box.x1, label.box.y1);
      let labelElement;
      if (!hasLabelElements) {
        labelElement = buildLabelElement(label, options.labels);
        labelsGroup.append(labelElement);
      } else {
        labelElement = this.labelElements.children[i37];
        const prevLabelPos = labelElement.bbox().origin;
        const labelTransform = labelElement.transform() || geometry_exports.transform();
        labelTransform.translate(labelPos.x - prevLabelPos.x, labelPos.y - prevLabelPos.y);
        labelElement.transform(labelTransform);
      }
      this.bbox = geometry_exports.Rect.union(this.bbox, labelElement.bbox());
    }
    return labelsGroup;
  }
  repositionRanges() {
    const ranges = this.ranges.children;
    if (ranges.length > 0) {
      const { rangeDistance, rangeSize } = this.options;
      let rangeRadius = this.getRangeRadius();
      if (this.options.labels.position === INSIDE2) {
        rangeRadius += rangeSize + rangeDistance;
      }
      const newRadius = rangeRadius + rangeSize / 2;
      for (let i37 = 0; i37 < ranges.length; i37++) {
        ranges[i37]._geometry.setRadiusX(newRadius).setRadiusY(newRadius);
      }
      this.bbox = geometry_exports.Rect.union(this.bbox, this.ranges.bbox());
    }
  }
  renderRanges() {
    const segments = this.rangeSegments();
    const segmentsCount = segments.length;
    const result = new Group5();
    if (segmentsCount) {
      const { rangeSize, reverse, rangeDistance } = this.options;
      const rangeRadius = this.getRangeRadius();
      this.radius(this.radius() - rangeSize - rangeDistance);
      for (let i37 = 0; i37 < segmentsCount; i37++) {
        const segment = segments[i37];
        const from = this.slotAngle(segment[reverse ? "to" : "from"]);
        const to = this.slotAngle(segment[!reverse ? "to" : "from"]);
        if (to - from !== 0) {
          result.append(this.createRange(from, to, rangeRadius, segment));
        }
      }
    }
    return result;
  }
  createRange(startAngle, endAngle, rangeRadius, options) {
    const rangeSize = this.options.rangeSize;
    const rangeGeom = new geometry_exports.Arc(this.arc.center, {
      radiusX: rangeRadius + rangeSize / 2,
      radiusY: rangeRadius + rangeSize / 2,
      startAngle,
      endAngle
    });
    return new Arc(rangeGeom, {
      stroke: {
        width: rangeSize,
        color: options.color,
        opacity: options.opacity,
        lineCap: options.lineCap
      }
    });
  }
  rangeSegments() {
    const options = this.options;
    const ranges = options.ranges || [];
    const count = ranges.length;
    const segments = [];
    if (count) {
      const { min: min4, max: max3, rangePlaceholderColor: defaultColor } = options;
      segments.push(rangeSegment(min4, max3, defaultColor));
      for (let i37 = 0; i37 < count; i37++) {
        const range = getRange(ranges[i37], min4, max3);
        const segmentsCount = segments.length;
        for (let j = 0; j < segmentsCount; j++) {
          const segment = segments[j];
          if (segment.from <= range.from && range.from <= segment.to) {
            segments.push(rangeSegment(range.from, range.to, range.color, range.opacity));
            if (segment.from <= range.to && range.to <= segment.to) {
              segments.push(rangeSegment(range.to, segment.to, defaultColor, range.opacity));
            }
            segment.to = range.from;
            break;
          }
        }
      }
    }
    return segments;
  }
  getRangeRadius() {
    const { arc, options } = this;
    const { rangeSize, rangeDistance, majorTicks: { size: majorTickSize } } = options;
    let radius;
    if (options.labels.position === OUTSIDE2) {
      radius = arc.getRadiusX() - majorTickSize - rangeDistance - rangeSize;
    } else {
      radius = arc.getRadiusX() - rangeSize;
    }
    return radius;
  }
  renderArc(center, radius) {
    const options = this.options;
    const arc = this.arc = new geometry_exports.Arc(center, {
      radiusX: radius,
      radiusY: radius,
      startAngle: options.startAngle + GEO_ARC_ADJUST_ANGLE,
      endAngle: options.endAngle + GEO_ARC_ADJUST_ANGLE
    });
    return arc;
  }
  renderTicks() {
    const { arc, options } = this;
    const tickArc = arc.clone();
    this.majorTickAngles = this.tickAngles(arc, options.majorUnit);
    this.majorTicks = drawTicks(tickArc, this.majorTickAngles, options.majorUnit, options.majorTicks);
    const allTicks = new Group5();
    allTicks.append(this.majorTicks);
    const majorTickSize = options.majorTicks.size;
    const minorTickSize = options.minorTicks.size;
    this._tickDifference = majorTickSize - minorTickSize;
    if (options.labels.position === OUTSIDE2) {
      const radius = tickArc.getRadiusX();
      tickArc.setRadiusX(radius - majorTickSize + minorTickSize).setRadiusY(radius - majorTickSize + minorTickSize);
    }
    this.minorTickAngles = this.normalizeTickAngles(this.tickAngles(arc, options.minorUnit));
    this.minorTicks = drawTicks(tickArc, this.minorTickAngles, options.minorUnit, options.minorTicks);
    allTicks.append(this.minorTicks);
    return allTicks;
  }
  normalizeTickAngles(angles) {
    const options = this.options;
    const skip = options.majorUnit / options.minorUnit;
    for (let i37 = angles.length - 1; i37 >= 0; i37--) {
      if (i37 % skip === 0) {
        angles.splice(i37, 1);
      }
    }
    return angles;
  }
  tickAngles(ring, stepValue) {
    const options = this.options;
    const reverse = options.reverse;
    const range = options.max - options.min;
    const angle = ring.endAngle - ring.startAngle;
    let tickCount = range / stepValue;
    let pos = ring.startAngle;
    let step = angle / tickCount;
    if (reverse) {
      pos += angle;
      step = -step;
    }
    if (angle >= 360 && options.max % stepValue === 0) {
      tickCount -= 1;
    }
    const positions = [];
    for (let i37 = 0; i37 < tickCount; i37++) {
      positions.push(round(pos, COORD_PRECISION));
      pos += step;
    }
    if (round(pos) <= ring.endAngle) {
      positions.push(pos);
    }
    return positions;
  }
  radius(value2) {
    if (value2) {
      this.arc.setRadiusX(value2).setRadiusY(value2);
      this.repositionTicks(this.majorTicks.children, this.majorTickAngles);
      this.repositionTicks(this.minorTicks.children, this.minorTickAngles, true);
    } else {
      return this.arc.getRadiusX();
    }
  }
  repositionTicks(ticks, tickAngles, minor) {
    const diff = minor ? this._tickDifference || 0 : 0;
    let tickArc = this.arc;
    const radius = tickArc.getRadiusX();
    if (minor && this.options.labels.position === OUTSIDE2 && diff !== 0) {
      tickArc = this.arc.clone();
      tickArc.setRadiusX(radius - diff).setRadiusY(radius - diff);
    }
    for (let i37 = 0; i37 < ticks.length; i37++) {
      const newPoint = tickArc.pointAt(tickAngles[i37]);
      const segments = ticks[i37].segments;
      const xDiff = newPoint.x - segments[0].anchor().x;
      const yDiff = newPoint.y - segments[0].anchor().y;
      ticks[i37].transform(new geometry_exports.transform().translate(xDiff, yDiff));
    }
  }
};
setDefaultOptions(RadialScale, {
  min: 0,
  max: 100,
  majorTicks: {
    size: 15,
    align: INSIDE2,
    color: BLACK,
    width: DEFAULT_LINE_WIDTH,
    visible: true
  },
  minorTicks: {
    size: 10,
    align: INSIDE2,
    color: BLACK,
    width: DEFAULT_LINE_WIDTH,
    visible: true
  },
  startAngle: -30,
  endAngle: 210,
  labels: {
    position: INSIDE2,
    padding: 2
  }
});
var radial_scale_default = RadialScale;

// node_modules/@progress/kendo-charts/dist/es/gauges/radial/radial-pointer-animation.js
var RadialPointerAnimation = class extends drawing_exports.Animation {
  constructor(element, options) {
    super(element, options);
    const animationOptions = this.options;
    animationOptions.duration = Math.max(Math.abs(animationOptions.newAngle - animationOptions.oldAngle) / animationOptions.duration * 1e3, 1);
  }
  step(pos) {
    const options = this.options;
    const angle = interpolateValue(options.oldAngle, options.newAngle, pos);
    this.element.transform(geometry_exports.transform().rotate(angle, options.center));
  }
};
setDefaultOptions(RadialPointerAnimation, {
  easing: LINEAR2,
  duration: ANGULAR_SPEED
});
drawing_exports.AnimationFactory.current.register(RADIAL_POINTER, RadialPointerAnimation);
var radial_pointer_animation_default = RadialPointerAnimation;

// node_modules/@progress/kendo-charts/dist/es/gauges/radial/radial-pointer.js
var CAP_SIZE = 0.05;
var { Circle, Group: Group6, Path: Path7 } = drawing_exports;
var RadialPointer = class extends pointer_default {
  setAngle(angle) {
    this.elements.transform(geometry_exports.transform().rotate(angle, this.center));
  }
  repaint() {
    const { scale, options } = this;
    const oldAngle = scale.slotAngle(options._oldValue);
    const newAngle = scale.slotAngle(options.value);
    if (options.animation.transitions === false) {
      this.setAngle(newAngle);
    } else {
      new radial_pointer_animation_default(this.elements, deepExtend(options.animation, {
        oldAngle,
        newAngle
      })).play();
    }
  }
  render() {
    const { scale, options } = this;
    const elements = new Group6();
    if (options.animation !== false) {
      deepExtend(options.animation, {
        startAngle: 0,
        center: scale.arc.center,
        reverse: scale.options.reverse
      });
    }
    elements.append(this._renderNeedle(), this._renderCap());
    this.elements = elements;
    this.setAngle(DEGREE);
    return elements;
  }
  reflow(arc) {
    const center = this.center = arc.center;
    const length = limitValue(this.options.length || 1, 0.1, 1.5);
    const radius = this.radius = arc.getRadiusX() * length;
    const capSize = this.capSize = Math.round(radius * this.options.cap.size);
    this.bbox = geometry_exports.Rect.fromPoints(
      new geometry_exports.Point(center.x - capSize, center.y - capSize),
      new geometry_exports.Point(center.x + capSize, center.y + capSize)
    );
  }
  _renderNeedle() {
    const minorTickSize = this.scale.options.minorTicks.size;
    const center = this.center;
    const needleColor = this.options.color;
    const needlePath = new Path7({
      fill: { color: needleColor },
      stroke: { color: needleColor, width: DEFAULT_LINE_WIDTH }
    });
    needlePath.moveTo(center.x + this.radius - minorTickSize, center.y).lineTo(center.x, center.y - this.capSize / 2).lineTo(center.x, center.y + this.capSize / 2).close();
    return needlePath;
  }
  _renderCap() {
    const options = this.options;
    const capColor = options.cap.color || options.color;
    const circle = new geometry_exports.Circle(this.center, this.capSize);
    const cap = new Circle(circle, {
      fill: { color: capColor },
      stroke: { color: capColor }
    });
    return cap;
  }
};
setDefaultOptions(RadialPointer, {
  cap: {
    size: CAP_SIZE
  },
  arrow: {
    width: 16,
    height: 14
  },
  animation: {
    type: RADIAL_POINTER,
    duration: ANGULAR_SPEED
  }
});
var radial_pointer_default = RadialPointer;

// node_modules/@progress/kendo-charts/dist/es/gauges/radial/radial-gauge.js
var Group7 = drawing_exports.Group;
var RadialGauge = class extends gauge_default {
  reflow(bbox) {
    const pointers = this.pointers;
    this.scale.reflow(bbox);
    this._initialPlotArea = this.scale.bbox;
    for (let i37 = 0; i37 < pointers.length; i37++) {
      pointers[i37].reflow(this.scale.arc);
      this._initialPlotArea = geometry_exports.Rect.union(this._initialPlotArea, pointers[i37].bbox);
    }
    this.fitScale(bbox);
    this.alignScale(bbox);
    this._buildVisual(this.gaugeArea, pointers, this.scale);
    this._draw();
  }
  _buildVisual(gaugeArea, pointers, scale) {
    const visuals = this._visuals = new Group7();
    visuals.append(gaugeArea);
    visuals.append(scale.ticks);
    visuals.append(scale.ranges);
    this._buildPointers(pointers);
    visuals.append(scale.labelElements);
  }
  _buildPointers(pointers) {
    for (let i37 = 0; i37 < pointers.length; i37++) {
      const current4 = pointers[i37];
      current4.render();
      this._visuals.append(current4.elements);
      current4.value(current4.options.value);
    }
  }
  fitScale(bbox) {
    const arc = this.scale.arc;
    const plotAreaBox = this._initialPlotArea;
    const step = Math.abs(this.getDiff(plotAreaBox, bbox));
    let min4 = round(step, COORD_PRECISION);
    let max3 = round(-step, COORD_PRECISION);
    let minDiff, midDiff, maxDiff, mid, oldDiff;
    let staleFlag = 0;
    let i37 = 0;
    while (i37++ < 100) {
      staleFlag = oldDiff === maxDiff ? staleFlag + 1 : 0;
      if (staleFlag > 5) {
        break;
      }
      if (min4 !== mid) {
        minDiff = this.getPlotBox(min4, bbox, arc);
        if (0 <= minDiff && minDiff <= 2) {
          break;
        }
      }
      if (max3 !== mid) {
        maxDiff = this.getPlotBox(max3, bbox, arc);
        if (0 <= maxDiff && maxDiff <= 2) {
          break;
        }
      }
      if (minDiff > 0 && maxDiff > 0) {
        mid = min4 * 2;
      } else if (minDiff < 0 && maxDiff < 0) {
        mid = max3 * 2;
      } else {
        mid = round((min4 + max3) / 2 || 1, COORD_PRECISION);
      }
      midDiff = this.getPlotBox(mid, bbox, arc);
      if (0 <= midDiff && midDiff <= 2) {
        break;
      }
      oldDiff = maxDiff;
      if (midDiff > 0) {
        max3 = mid;
        maxDiff = midDiff;
      } else {
        min4 = mid;
        minDiff = midDiff;
      }
    }
  }
  getPlotBox(step, bbox, arc) {
    const scale = this.scale;
    const pointers = this.pointers;
    const radius = arc.getRadiusX();
    const scaleArc = arc.clone();
    scaleArc.setRadiusX(radius + step).setRadiusY(radius + step);
    scale.arc = scaleArc;
    scale.reflow(bbox);
    this.plotBbox = scale.bbox;
    for (let i37 = 0; i37 < pointers.length; i37++) {
      pointers[i37].reflow(scaleArc);
      this.plotBbox = geometry_exports.Rect.union(this.plotBbox, pointers[i37].bbox);
    }
    return this.getDiff(this.plotBbox, bbox);
  }
  getDiff(plotBox, box) {
    return Math.min(box.width() - plotBox.width(), box.height() - plotBox.height());
  }
  alignScale(bbox) {
    const plotBoxCenter = this.plotBbox.center();
    const boxCenter = bbox.center();
    const paddingX = plotBoxCenter.x - boxCenter.x;
    const paddingY = plotBoxCenter.y - boxCenter.y;
    const { scale, pointers } = this;
    scale.arc.center.x -= paddingX;
    scale.arc.center.y -= paddingY;
    scale.reflow(bbox);
    for (let i37 = 0; i37 < pointers.length; i37++) {
      pointers[i37].reflow(scale.arc);
      this.plotBbox = geometry_exports.Rect.union(scale.bbox, pointers[i37].bbox);
    }
  }
  _createModel() {
    const options = this.options;
    const pointers = options.pointer;
    const scale = this.scale = new radial_scale_default(options.scale, this.contextService);
    this.pointers = [];
    const pointersArr = isArray(pointers) ? pointers : [pointers];
    for (let i37 = 0; i37 < pointersArr.length; i37++) {
      const current4 = new radial_pointer_default(scale, deepExtend({}, pointersArr[i37], {
        animation: {
          transitions: options.transitions
        }
      }));
      this.pointers.push(current4);
    }
  }
};
setDefaultOptions(RadialGauge, {
  transitions: true,
  gaugeArea: {
    background: ""
  }
});

// node_modules/@progress/kendo-charts/dist/es/gauges/arc/arc-scale.js
var ArcScale = class extends radial_scale_default {
  rangeSegments() {
    const { min: min4, max: max3, rangePlaceholderColor, rangeLineCap } = this.options;
    return [{ from: min4, to: max3, color: rangePlaceholderColor, lineCap: rangeLineCap }];
  }
  hasRanges() {
    return true;
  }
  placeholderRangeAngle(angle) {
    const geometry = this.ranges.children[0].geometry();
    if (this.options.reverse) {
      geometry.setEndAngle(angle);
    } else {
      geometry.setStartAngle(angle);
    }
  }
  addRange(from, to, options) {
    const reverse = this.options.reverse;
    const startAngle = this.slotAngle(reverse ? to : from);
    const endAngle = this.slotAngle(reverse ? from : to);
    const range = this.createRange(startAngle, endAngle, this.getRangeRadius(), options);
    this.ranges.append(range);
    return range;
  }
};
setDefaultOptions(ArcScale, {
  min: 0,
  max: 100,
  majorTicks: {
    visible: false
  },
  minorTicks: {
    visible: false
  },
  labels: {
    visible: false
  },
  startAngle: 0,
  endAngle: 180,
  rangeLineCap: "round"
});

// node_modules/@progress/kendo-charts/dist/es/gauges/arc/range-pointer-animation.js
var MAX_DURATION = 800;
var RangePointerAnimation = class extends drawing_exports.Animation {
  constructor(element, options) {
    super(element, options);
    const animationOptions = this.options;
    const duration2 = Math.abs(animationOptions.newAngle - animationOptions.oldAngle) / animationOptions.duration * 1e3;
    animationOptions.duration = limitValue(duration2, ANGULAR_SPEED, MAX_DURATION);
    const startColor = element.elements.options.get("stroke.color");
    const color = element.currentColor();
    if (startColor !== color) {
      this.startColor = new color_default(startColor);
      this.color = new color_default(color);
    }
  }
  step(pos) {
    const { options, startColor, color } = this;
    const angle = interpolateValue(options.oldAngle, options.newAngle, pos);
    this.element.angle(angle);
    if (color) {
      const r28 = round(interpolateValue(startColor.r, color.r, pos));
      const g2 = round(interpolateValue(startColor.g, color.g, pos));
      const b2 = round(interpolateValue(startColor.b, color.b, pos));
      this.element.stroke(new color_default(r28, g2, b2).toHex());
    }
  }
};
setDefaultOptions(RangePointerAnimation, {
  easing: LINEAR2,
  duration: ANGULAR_SPEED
});
drawing_exports.AnimationFactory.current.register(RADIAL_RANGE_POINTER, RangePointerAnimation);
var range_pointer_animation_default = RangePointerAnimation;

// node_modules/@progress/kendo-charts/dist/es/gauges/arc/range-pointer.js
var RangePointer = class extends pointer_default {
  repaint() {
    const { scale, options } = this;
    const oldAngle = scale.slotAngle(options._oldValue);
    const newAngle = scale.slotAngle(options.value);
    if (this.animation) {
      this.animation.abort();
    }
    if (options.animation.transitions === false) {
      this.angle(newAngle);
      this.stroke(this.currentColor());
    } else {
      this.animation = new range_pointer_animation_default(this, deepExtend(options.animation, {
        oldAngle,
        newAngle
      }));
      this.animation.play();
    }
  }
  angle(value2) {
    const geometry = this.elements.geometry();
    if (this.scale.options.reverse) {
      geometry.setStartAngle(value2);
    } else {
      geometry.setEndAngle(value2);
    }
    this.scale.placeholderRangeAngle(value2);
  }
  stroke(value2) {
    this.elements.stroke(value2);
  }
  render() {
    if (this.elements) {
      return;
    }
    const { scale, options } = this;
    if (options.animation !== false) {
      deepExtend(options.animation, {
        startAngle: 0,
        center: scale.arc.center,
        reverse: scale.options.reverse
      });
    }
    this.elements = scale.addRange(scale.options.min, this.options.value, {
      color: this.currentColor(),
      opacity: options.opacity,
      lineCap: scale.options.rangeLineCap
    });
  }
  currentColor() {
    const { min: min4, max: max3 } = this.scale.options;
    const { colors, color, value: value2 } = this.options;
    const currentValue = isNumber(value2) ? value2 : min4;
    if (colors) {
      for (let idx = 0; idx < colors.length; idx++) {
        const { color: rangeColor, from = min4, to = max3 } = colors[idx];
        if (from <= currentValue && currentValue <= to) {
          return rangeColor;
        }
      }
    }
    return color;
  }
  reflow() {
    this.render();
    this.bbox = this.elements.bbox();
  }
};
setDefaultOptions(RangePointer, {
  animation: {
    type: RADIAL_RANGE_POINTER,
    duration: ANGULAR_SPEED
  }
});

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/encoding.js
var DEFAULT_QUIET_ZONE_LENGTH = 10;
var Encoding = class {
  constructor(options) {
    this.setOptions(options);
    this.initProperties();
  }
  initProperties() {
  }
  setOptions(options) {
    this.options = Object.assign({}, this.options, options);
    this.quietZoneLength = this.options.addQuietZone ? 2 * this.options.quietZoneLength : 0;
  }
  encode(value2, width, height) {
    const convertedValue = defined(value2) ? String(value2) : value2;
    this.initValue(convertedValue, width, height);
    if (this.options.addQuietZone) {
      this.addQuietZone();
    }
    this.addData();
    if (this.options.addQuietZone) {
      this.addQuietZone();
    }
    return {
      baseUnit: this.baseUnit,
      pattern: this.pattern
    };
  }
  initValue() {
  }
  addQuietZone() {
    this.pattern.push(this.options.quietZoneLength || DEFAULT_QUIET_ZONE_LENGTH);
  }
  addData() {
  }
  invalidCharacterError(character) {
    throw new Error(`Character "${character}" is not valid for symbology ${this.name}.`);
  }
};
setDefaultOptions(Encoding, {
  quietZoneLength: DEFAULT_QUIET_ZONE_LENGTH,
  addQuietZone: true,
  addCheckSum: true
});

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/code11.js
var extend2 = Object.assign;
var Code11 = class extends Encoding {
  initProperties() {
    super.initProperties();
    extend2(this, {
      name: "Code 11",
      characterMap: ["111121", "211121", "121121", "221111", "112121", "212111", "122111", "111221", "211211", "211111", "112111"],
      cCheckSumTotal: 10,
      kCheckSumTotal: 9,
      kCheckSumMinLength: 10,
      checkSumMod: 11,
      DASH_VALUE: 10,
      DASH: "-",
      START: "112211",
      STOP: "11221"
    });
  }
  initValue(value2, width) {
    this.pattern = [];
    this.value = value2;
    this.width = width;
    this.totalUnits = 0;
  }
  addData() {
    const value2 = this.value;
    this.addPattern(this.START);
    for (let i37 = 0; i37 < value2.length; i37++) {
      this.addCharacter(value2.charAt(i37));
    }
    if (this.options.addCheckSum) {
      this.addCheckSum();
    }
    this.addPattern(this.STOP);
    this.setBaseUnit();
  }
  setBaseUnit() {
    this.baseUnit = this.width / (this.totalUnits + this.quietZoneLength);
  }
  addCheckSum() {
    const value2 = this.value;
    let length = value2.length;
    const cValue = this.getWeightedSum(value2, length, this.cCheckSumTotal) % this.checkSumMod;
    this.checksum = String(cValue);
    this.addPattern(this.characterMap[cValue]);
    length++;
    if (length >= this.kCheckSumMinLength) {
      let kValue = (cValue + this.getWeightedSum(value2, length, this.kCheckSumTotal)) % this.checkSumMod;
      this.checksum += kValue;
      this.addPattern(this.characterMap[kValue]);
    }
  }
  getWeightedSum(value2, length, total) {
    let weightedSum = 0;
    for (let i37 = 0; i37 < value2.length; i37++) {
      weightedSum += this.weightedValue(this.getValue(value2.charAt(i37)), length, i37, total);
    }
    return weightedSum;
  }
  weightedValue(value2, length, index, total) {
    const weight = (length - index) % total || total;
    return weight * value2;
  }
  getValue(character) {
    if (!isNaN(character)) {
      return parseInt(character, 10);
    } else if (character !== this.DASH) {
      this.invalidCharacterError(character);
    }
    return this.DASH_VALUE;
  }
  addCharacter(character) {
    const value2 = this.getValue(character);
    const pattern = this.characterMap[value2];
    this.addPattern(pattern);
  }
  addPattern(pattern) {
    let value2;
    for (let i37 = 0; i37 < pattern.length; i37++) {
      value2 = parseInt(pattern.charAt(i37), 10);
      this.pattern.push(value2);
      this.totalUnits += value2;
    }
  }
};
setDefaultOptions(Code11, {
  addCheckSum: true
});

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/code39.js
var extend3 = Object.assign;
var Code39Base = class extends Encoding {
  initProperties() {
    super.initProperties();
    extend3(this, {
      minBaseUnitLength: 0.7
    });
  }
  addData() {
    const value2 = this.value;
    this.addStart();
    for (let idx = 0; idx < value2.length; idx++) {
      this.addCharacter(value2.charAt(idx));
    }
    if (this.options.addCheckSum) {
      this.pushCheckSum();
    }
    this.addStop();
    this.prepareValues();
  }
  addCharacter(character) {
    const characterData = this.characterMap[character];
    if (!characterData) {
      this.invalidCharacterError(character);
    }
    this.addBase(characterData);
  }
  addBase() {
  }
};
var Code39 = class extends Code39Base {
  initProperties() {
    super.initProperties();
    extend3(this, {
      name: "Code 39",
      checkSumMod: 43,
      minRatio: 2.5,
      maxRatio: 3,
      gapWidth: 1,
      splitCharacter: "|",
      patternMappings: {
        "b": "1|",
        "w": "1|",
        "B": "ratio|",
        "W": "ratio|"
      },
      characterMap: {
        "0": { "pattern": "bwbWBwBwb", "value": 0 },
        "1": { "pattern": "BwbWbwbwB", "value": 1 },
        "2": { "pattern": "bwBWbwbwB", "value": 2 },
        "3": { "pattern": "BwBWbwbwb", "value": 3 },
        "4": { "pattern": "bwbWBwbwB", "value": 4 },
        "5": { "pattern": "BwbWBwbwb", "value": 5 },
        "6": { "pattern": "bwBWBwbwb", "value": 6 },
        "7": { "pattern": "bwbWbwBwB", "value": 7 },
        "8": { "pattern": "BwbWbwBwb", "value": 8 },
        "9": { "pattern": "bwBWbwBwb", "value": 9 },
        "A": { "pattern": "BwbwbWbwB", "value": 10 },
        "B": { "pattern": "bwBwbWbwB", "value": 11 },
        "C": { "pattern": "BwBwbWbwb", "value": 12 },
        "D": { "pattern": "bwbwBWbwB", "value": 13 },
        "E": { "pattern": "BwbwBWbwb", "value": 14 },
        "F": { "pattern": "bwBwBWbwb", "value": 15 },
        "G": { "pattern": "bwbwbWBwB", "value": 16 },
        "H": { "pattern": "BwbwbWBwb", "value": 17 },
        "I": { "pattern": "bwBwbWBwb", "value": 18 },
        "J": { "pattern": "bwbwBWBwb", "value": 19 },
        "K": { "pattern": "BwbwbwbWB", "value": 20 },
        "L": { "pattern": "bwBwbwbWB", "value": 21 },
        "M": { "pattern": "BwBwbwbWb", "value": 22 },
        "N": { "pattern": "bwbwBwbWB", "value": 23 },
        "O": { "pattern": "BwbwBwbWb", "value": 24 },
        "P": { "pattern": "bwBwBwbWb", "value": 25 },
        "Q": { "pattern": "bwbwbwBWB", "value": 26 },
        "R": { "pattern": "BwbwbwBWb", "value": 27 },
        "S": { "pattern": "bwBwbwBWb", "value": 28 },
        "T": { "pattern": "bwbwBwBWb", "value": 29 },
        "U": { "pattern": "BWbwbwbwB", "value": 30 },
        "V": { "pattern": "bWBwbwbwB", "value": 31 },
        "W": { "pattern": "BWBwbwbwb", "value": 32 },
        "X": { "pattern": "bWbwBwbwB", "value": 33 },
        "Y": { "pattern": "BWbwBwbwb", "value": 34 },
        "Z": { "pattern": "bWBwBwbwb", "value": 35 },
        "-": { "pattern": "bWbwbwBwB", "value": 36 },
        ".": { "pattern": "BWbwbwBwb", "value": 37 },
        " ": { "pattern": "bWBwbwBwb", "value": 38 },
        "$": { "pattern": "bWbWbWbwb", "value": 39 },
        "/": { "pattern": "bWbWbwbWb", "value": 40 },
        "+": { "pattern": "bWbwbWbWb", "value": 41 },
        "%": { "pattern": "bwbWbWbWb", "value": 42 },
        START: { pattern: "bWbwBwBwb" }
      }
    });
  }
  initValue(value2, width, height) {
    this.width = width;
    this.height = height;
    this.value = value2;
    this.dataLength = value2.length;
    this.pattern = [];
    this.patternString = "";
  }
  prepareValues() {
    const minBaseUnit = this.minBaseUnitLength;
    const minRatio = this.minRatio;
    const minHeight = Math.ceil(Math.max(0.15 * this.width, 24));
    let baseUnit;
    let ratio = this.maxRatio;
    if (this.height < minHeight) {
      throw new Error(`Insufficient height for Code39 encoding: the current height is ${this.height}px and the minimum height is ${minHeight}px.`);
    }
    baseUnit = this.getBaseUnit(ratio);
    while (baseUnit < minBaseUnit && ratio > minRatio) {
      ratio = parseFloat((ratio - 0.1).toFixed(1));
      baseUnit = this.getBaseUnit(ratio);
    }
    if (baseUnit < minBaseUnit) {
      let minWidth = Math.ceil(this.getBaseWidth(minRatio) * minBaseUnit);
      throw new Error(`Insufficient width for Code39 encoding: the current width is ${this.width}px and the minimum width for value "${this.value}" is ${minWidth}px.`);
    }
    this.ratio = ratio;
    this.baseUnit = baseUnit;
    this.patternString = this.patternString.substring(0, this.patternString.length - 1);
    this.pattern = this.pattern.concat(this.patternString.replace(/ratio/g, ratio).split(this.splitCharacter));
  }
  getBaseUnit(ratio) {
    return this.width / this.getBaseWidth(ratio);
  }
  getBaseWidth(ratio) {
    const characterLength = 3 * (ratio + 2);
    return this.quietZoneLength + characterLength * (this.dataLength + 2) + this.gapWidth * (this.dataLength + 1);
  }
  addStart() {
    this.addPattern(this.characterMap.START.pattern);
    this.addCharacterGap();
  }
  addBase(character) {
    this.addPattern(character.pattern);
    this.addCharacterGap();
  }
  addStop() {
    this.addPattern(this.characterMap.START.pattern);
  }
  addPattern(pattern) {
    for (let i37 = 0; i37 < pattern.length; i37++) {
      this.patternString += this.patternMappings[pattern.charAt(i37)];
    }
  }
  addCharacterGap() {
    this.patternString += this.gapWidth + this.splitCharacter;
  }
};
setDefaultOptions(Code39, {
  addCheckSum: false
});

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/code39-extended.js
var Code39ExtendedBase = {
  addCharacter(character) {
    if (this.characterMap[character]) {
      this.addBase(this.characterMap[character]);
    } else if (character.charCodeAt(0) > 127) {
      this.invalidCharacterError(character);
    } else {
      this.addExtended(character.charCodeAt(0));
    }
  },
  addExtended(code) {
    let patterns;
    for (let i37 = 0; i37 < this.extendedMappings.length; i37++) {
      patterns = this.extendedMappings[i37].call(this, code);
      if (patterns) {
        for (let patternIndex = 0; patternIndex < patterns.length; patternIndex++) {
          const pattern = patterns[patternIndex];
          this.addBase(pattern);
        }
        this.dataLength += patterns.length - 1;
        return;
      }
    }
  },
  extendedMappings: [
    function(code) {
      if (97 <= code && code <= 122) {
        return [this.characterMap[this.shiftCharacters[0]], this.characterMap[String.fromCharCode(code - 32)]];
      }
    },
    function(code) {
      if (33 <= code && code <= 58) {
        return [this.characterMap[this.shiftCharacters[1]], this.characterMap[String.fromCharCode(code + 32)]];
      }
    },
    function(code) {
      if (1 <= code && code <= 26) {
        return [this.characterMap[this.shiftCharacters[2]], this.characterMap[String.fromCharCode(code + 64)]];
      }
    },
    function(code) {
      let result;
      let dataCharacter;
      if (!this.specialAsciiCodes[code]) {
        dataCharacter = Math.floor(code / 32) * 6 + (code - 27) % 32 + 64;
        result = [this.characterMap[this.shiftCharacters[3]], this.characterMap[String.fromCharCode(dataCharacter)]];
      } else {
        result = [];
        for (let i37 = 0; i37 < this.specialAsciiCodes[code].length; i37++) {
          result.push(this.characterMap[this.shiftCharacters[3]]);
          result.push(this.characterMap[this.specialAsciiCodes[code][i37]]);
        }
      }
      return result;
    }
  ],
  specialAsciiCodes: {
    "0": ["U"],
    "64": ["V"],
    "96": ["W"],
    "127": ["T", "X", "Y", "Z"]
  },
  shiftValuesAsciiCodes: {
    "39": 36,
    "40": 47,
    "41": 43,
    "42": 37
  },
  characterMap: {
    "+": false,
    "/": false,
    "$": false,
    "%": false
  },
  shiftCharacters: ["SHIFT0", "SHIFT1", "SHIFT2", "SHIFT3"]
};
var Code39Extended = class extends Code39 {
  initProperties() {
    super.initProperties();
    deepExtend(this, Code39ExtendedBase, {
      name: "Code 39 extended",
      characterMap: {
        SHIFT0: { "pattern": "bWbwbWbWb", "value": 41 },
        SHIFT1: { "pattern": "bWbWbwbWb", "value": 40 },
        SHIFT2: { "pattern": "bWbWbWbwb", "value": 39 },
        SHIFT3: { "pattern": "bwbWbWbWb", "value": 42 }
      }
    });
  }
};

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/code93.js
var extend4 = Object.assign;
var Code93 = class extends Code39Base {
  initProperties() {
    super.initProperties();
    extend4(this, {
      name: "Code 93",
      cCheckSumTotal: 20,
      kCheckSumTotal: 15,
      checkSumMod: 47,
      characterMap: {
        "0": { "pattern": "131112", "value": 0 },
        "1": { "pattern": "111213", "value": 1 },
        "2": { "pattern": "111312", "value": 2 },
        "3": { "pattern": "111411", "value": 3 },
        "4": { "pattern": "121113", "value": 4 },
        "5": { "pattern": "121212", "value": 5 },
        "6": { "pattern": "121311", "value": 6 },
        "7": { "pattern": "111114", "value": 7 },
        "8": { "pattern": "131211", "value": 8 },
        "9": { "pattern": "141111", "value": 9 },
        "A": { "pattern": "211113", "value": 10 },
        "B": { "pattern": "211212", "value": 11 },
        "C": { "pattern": "211311", "value": 12 },
        "D": { "pattern": "221112", "value": 13 },
        "E": { "pattern": "221211", "value": 14 },
        "F": { "pattern": "231111", "value": 15 },
        "G": { "pattern": "112113", "value": 16 },
        "H": { "pattern": "112212", "value": 17 },
        "I": { "pattern": "112311", "value": 18 },
        "J": { "pattern": "122112", "value": 19 },
        "K": { "pattern": "132111", "value": 20 },
        "L": { "pattern": "111123", "value": 21 },
        "M": { "pattern": "111222", "value": 22 },
        "N": { "pattern": "111321", "value": 23 },
        "O": { "pattern": "121122", "value": 24 },
        "P": { "pattern": "131121", "value": 25 },
        "Q": { "pattern": "212112", "value": 26 },
        "R": { "pattern": "212211", "value": 27 },
        "S": { "pattern": "211122", "value": 28 },
        "T": { "pattern": "211221", "value": 29 },
        "U": { "pattern": "221121", "value": 30 },
        "V": { "pattern": "222111", "value": 31 },
        "W": { "pattern": "112122", "value": 32 },
        "X": { "pattern": "112221", "value": 33 },
        "Y": { "pattern": "122121", "value": 34 },
        "Z": { "pattern": "123111", "value": 35 },
        "-": { "pattern": "121131", "value": 36 },
        ".": { "pattern": "311112", "value": 37 },
        " ": { "pattern": "311211", "value": 38 },
        "$": { "pattern": "321111", "value": 39 },
        "/": { "pattern": "112131", "value": 40 },
        "+": { "pattern": "113121", "value": 41 },
        "%": { "pattern": "211131", "value": 42 },
        SHIFT0: { "pattern": "122211", "value": 46 },
        SHIFT1: { "pattern": "311121", "value": 45 },
        SHIFT2: { "pattern": "121221", "value": 43 },
        SHIFT3: { "pattern": "312111", "value": 44 },
        START: { "pattern": "111141" },
        TERMINATION_BAR: "1"
      }
    });
  }
  initValue(value2, width, height) {
    this.value = value2;
    this.width = width;
    this.height = height;
    this.pattern = [];
    this.values = [];
    this.dataLength = value2.length;
  }
  prepareValues() {
    let minHeight = Math.ceil(Math.max(0.15 * this.width, 24));
    if (this.height < minHeight) {
      throw new Error(`Insufficient height for Code93 encoding: the current height is ${this.height}px, the minimum required height is ${minHeight}px.`);
    }
    this.setBaseUnit();
    if (this.baseUnit < this.minBaseUnitLength) {
      const minWidth = Math.ceil(this.minBaseUnitLength * (this.width / this.baseUnit));
      throw new Error(`Insufficient width for Code93 encoding: the current width is ${this.width}px and the minimum required width for value "${this.value}" is ${minWidth}px.`);
    }
  }
  setBaseUnit() {
    const checkSumLength = 2;
    this.baseUnit = this.width / (9 * (this.dataLength + 2 + checkSumLength) + this.quietZoneLength + 1);
  }
  addStart() {
    let pattern = this.characterMap.START.pattern;
    this.addPattern(pattern);
  }
  addStop() {
    this.addStart();
    this.pattern.push(this.characterMap.TERMINATION_BAR);
  }
  addBase(charData) {
    this.addPattern(charData.pattern);
    this.values.push(charData.value);
  }
  pushCheckSum() {
    const checkValues = this._getCheckValues();
    let charData;
    this.checksum = checkValues.join("");
    for (let i37 = 0; i37 < checkValues.length; i37++) {
      charData = this.characterMap[this._findCharacterByValue(checkValues[i37])];
      this.addPattern(charData.pattern);
    }
  }
  _getCheckValues() {
    const values = this.values;
    const length = values.length;
    let wightedSum = 0;
    let cValue;
    let kValue;
    let idx;
    for (idx = length - 1; idx >= 0; idx--) {
      wightedSum += this.weightedValue(values[idx], length - idx, this.cCheckSumTotal);
    }
    cValue = wightedSum % this.checkSumMod;
    wightedSum = this.weightedValue(cValue, 1, this.kCheckSumTotal);
    for (idx = length - 1; idx >= 0; idx--) {
      wightedSum += this.weightedValue(values[idx], length - idx + 1, this.kCheckSumTotal);
    }
    kValue = wightedSum % this.checkSumMod;
    return [cValue, kValue];
  }
  _findCharacterByValue(value2) {
    for (let character in this.characterMap) {
      if (this.characterMap[character].value === value2) {
        return character;
      }
    }
  }
  weightedValue(value2, index, total) {
    return (index % total || total) * value2;
  }
  addPattern(pattern) {
    let value2;
    for (let i37 = 0; i37 < pattern.length; i37++) {
      value2 = parseInt(pattern.charAt(i37), 10);
      this.pattern.push(value2);
    }
  }
};

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/code93-extended.js
var Code93Extended = class extends Code93 {
  initProperties() {
    super.initProperties();
    deepExtend(this, Code39ExtendedBase, {
      name: "Code 93 extended",
      pushCheckSum: function() {
        const checkValues = this._getCheckValues();
        let value2;
        this.checksum = checkValues.join("");
        for (let i37 = 0; i37 < checkValues.length; i37++) {
          value2 = checkValues[i37];
          if (this.shiftValuesAsciiCodes[value2]) {
            this.addExtended(this.shiftValuesAsciiCodes[value2]);
          } else {
            const characterByValue = this._findCharacterByValue(value2);
            this.addPattern(this.characterMap[characterByValue].pattern);
          }
        }
      }
    });
  }
};

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/postnet.js
var numberRegex = /^\d+$/;
var extend5 = Object.assign;
var Postnet = class extends Encoding {
  initProperties() {
    super.initProperties();
    extend5(this, {
      name: "Postnet",
      START: "2",
      VALID_CODE_LENGTHS: [5, 9, 11],
      DIGIT_SEPARATOR: "-",
      characterMap: ["22111", "11122", "11212", "11221", "12112", "12121", "12211", "21112", "21121", "21211"]
    });
  }
  initValue(value2, width, height) {
    this.height = height;
    this.width = width;
    this.baseHeight = height / 2;
    this.value = value2.replace(new RegExp(this.DIGIT_SEPARATOR, "g"), "");
    this.pattern = [];
    this.validate(this.value);
    this.checkSum = 0;
    this.setBaseUnit();
  }
  addData() {
    const value2 = this.value;
    this.addPattern(this.START);
    for (let i37 = 0; i37 < value2.length; i37++) {
      this.addCharacter(value2.charAt(i37));
    }
    if (this.options.addCheckSum) {
      this.addCheckSum();
    }
    this.addPattern(this.START);
    this.pattern.pop();
  }
  addCharacter(character) {
    const pattern = this.characterMap[character];
    this.checkSum += parseInt(character, 10);
    this.addPattern(pattern);
  }
  addCheckSum() {
    this.checksum = (10 - this.checkSum % 10) % 10;
    this.addCharacter(this.checksum);
  }
  setBaseUnit() {
    const startStopLength = 3;
    this.baseUnit = this.width / ((this.value.length + 1) * 10 + startStopLength + this.quietZoneLength);
  }
  validate(value2) {
    if (!numberRegex.test(value2)) {
      this.invalidCharacterError(value2.match(/[^0-9]/)[0]);
    }
    if (!inArray(value2.length, this.VALID_CODE_LENGTHS)) {
      throw new Error("Invalid value length. Valid lengths for the Postnet symbology are " + this.VALID_CODE_LENGTHS.join(",") + ".");
    }
  }
  addPattern(pattern) {
    let y1;
    for (let i37 = 0; i37 < pattern.length; i37++) {
      y1 = this.height - this.baseHeight * pattern.charAt(i37);
      this.pattern.push({ width: 1, y1, y2: this.height });
      this.pattern.push(1);
    }
  }
};

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/code128.js
var numberRegex2 = /^\d+$/;
var alphanumericRegex = /^[a-z0-9]+$/i;
var extend6 = Object.assign;
var State128 = class {
  constructor(encoding) {
    this.encoding = encoding;
    this.initProperties();
  }
  initProperties() {
  }
  addStart() {
  }
  is() {
  }
  isCode() {
    return false;
  }
  move() {
  }
  pushState() {
  }
};
var State128AB = class extends State128 {
  constructor(encoding, states) {
    super(encoding);
    this.states = states;
    this._initMoves(states);
  }
  initProperties() {
    super.initProperties();
    deepExtend(this, {
      FNC4: "FNC4",
      SHIFT: 98
    });
  }
  addStart() {
    this.encoding.addPattern(this.START);
  }
  is(value2, index) {
    let code = value2.charCodeAt(index);
    return this.isCode(code);
  }
  move(encodingState) {
    let idx = 0;
    while (!this._moves[idx].call(this, encodingState) && idx < this._moves.length) {
      idx++;
    }
  }
  pushState(encodingState) {
    let states = this.states, value2 = encodingState.value, maxLength = value2.length, code;
    if (inArray("C", states)) {
      let numberMatch = value2.substr(encodingState.index).match(/\d{4,}/g);
      if (numberMatch) {
        maxLength = value2.indexOf(numberMatch[0], encodingState.index);
      }
    }
    while ((code = encodingState.value.charCodeAt(encodingState.index)) >= 0 && this.isCode(code) && encodingState.index < maxLength) {
      this.encoding.addPattern(this.getValue(code));
      encodingState.index++;
    }
  }
  _initMoves(states) {
    this._moves = [];
    if (inArray(this.FNC4, states)) {
      this._moves.push(this._moveFNC);
    }
    if (inArray(this.shiftKey, states)) {
      this._moves.push(this._shiftState);
    }
    this._moves.push(this._moveState);
  }
  _moveFNC(encodingState) {
    if (encodingState.fnc) {
      encodingState.fnc = false;
      return encodingState.previousState === this.key;
    }
  }
  _shiftState(encodingState) {
    if (encodingState.previousState === this.shiftKey && (encodingState.index + 1 >= encodingState.value.length || this.encoding[this.shiftKey].is(encodingState.value, encodingState.index + 1))) {
      this.encoding.addPattern(this.SHIFT);
      encodingState.shifted = true;
      return true;
    }
  }
  _moveState() {
    this.encoding.addPattern(this.MOVE);
    return true;
  }
};
var states128 = {};
states128.A = class State128A extends State128AB {
  initProperties() {
    super.initProperties();
    extend6(this, {
      key: "A",
      shiftKey: "B",
      MOVE: 101,
      START: 103
    });
  }
  isCode(code) {
    return 0 <= code && code < 96;
  }
  getValue(code) {
    if (code < 32) {
      return code + 64;
    }
    return code - 32;
  }
};
states128.B = class State128B extends State128AB {
  initProperties() {
    super.initProperties();
    extend6(this, {
      key: "B",
      shiftKey: "A",
      MOVE: 100,
      START: 104
    });
  }
  isCode(code) {
    return 32 <= code && code < 128;
  }
  getValue(code) {
    return code - 32;
  }
};
states128.C = class State128C extends State128 {
  initProperties() {
    super.initProperties();
    extend6(this, {
      key: "C",
      MOVE: 99,
      START: 105
    });
  }
  addStart() {
    this.encoding.addPattern(this.START);
  }
  is(value2, index) {
    let next4 = getSubstring(value2, index, 4);
    return (index + 4 <= value2.length || value2.length === 2) && numberRegex2.test(next4);
  }
  move() {
    this.encoding.addPattern(this.MOVE);
  }
  pushState(encodingState) {
    let code;
    while ((code = getSubstring(encodingState.value, encodingState.index, 2)) && numberRegex2.test(code) && code.length === 2) {
      this.encoding.addPattern(parseInt(code, 10));
      encodingState.index += 2;
    }
  }
  getValue(code) {
    return code;
  }
};
states128.FNC4 = class State128FNC4 extends State128 {
  constructor(encoding, states) {
    super(encoding);
    this._initSubStates(states);
  }
  initProperties() {
    super.initProperties();
    extend6(this, {
      key: "FNC4",
      dependentStates: ["A", "B"]
    });
  }
  addStart(encodingState) {
    let code = encodingState.value.charCodeAt(0) - 128, subState = this._getSubState(code);
    this.encoding[subState].addStart();
  }
  is(value2, index) {
    let code = value2.charCodeAt(index);
    return this.isCode(code);
  }
  isCode(code) {
    return 128 <= code && code < 256;
  }
  pushState(encodingState) {
    let subState = this._initSubState(encodingState), encoding = this.encoding, length = subState.value.length;
    let code;
    encodingState.index += length;
    if (length < 3) {
      for (; subState.index < length; subState.index++) {
        code = subState.value.charCodeAt(subState.index);
        subState.state = this._getSubState(code);
        if (subState.previousState !== subState.state) {
          subState.previousState = subState.state;
          encoding[subState.state].move(subState);
        }
        encoding.addPattern(encoding[subState.state].MOVE);
        encoding.addPattern(encoding[subState.state].getValue(code));
      }
    } else {
      if (subState.state !== subState.previousState) {
        encoding[subState.state].move(subState);
      }
      this._pushStart(subState);
      encoding.pushData(subState, this.subStates);
      if (encodingState.index < encodingState.value.length) {
        this._pushStart(subState);
      }
    }
    encodingState.fnc = true;
    encodingState.state = subState.state;
  }
  _pushStart(subState) {
    this.encoding.addPattern(this.encoding[subState.state].MOVE);
    this.encoding.addPattern(this.encoding[subState.state].MOVE);
  }
  _initSubState(encodingState) {
    const subState = {
      value: this._getAll(encodingState.value, encodingState.index),
      index: 0
    };
    subState.state = this._getSubState(subState.value.charCodeAt(0));
    subState.previousState = encodingState.previousState === this.key ? subState.state : encodingState.previousState;
    return subState;
  }
  _initSubStates(states) {
    this.subStates = [];
    for (let i37 = 0; i37 < states.length; i37++) {
      if (inArray(states[i37], this.dependentStates)) {
        this.subStates.push(states[i37]);
      }
    }
  }
  _getSubState(code) {
    for (let i37 = 0; i37 < this.subStates.length; i37++) {
      if (this.encoding[this.subStates[i37]].isCode(code)) {
        return this.subStates[i37];
      }
    }
  }
  _getAll(value2, index) {
    let code;
    let result = "";
    let i37 = index;
    while ((code = value2.charCodeAt(i37++)) && this.isCode(code)) {
      result += String.fromCharCode(code - 128);
    }
    return result;
  }
};
states128.FNC1 = class States128FNC1 extends State128 {
  constructor(encoding, states) {
    super(encoding);
    this.states = states;
  }
  initProperties() {
    super.initProperties();
    extend6(this, {
      key: "FNC1",
      startState: "C",
      startAI: "(",
      endAI: ")",
      dependentStates: ["C", "B"],
      applicationIdentifiers: {
        "22": { max: 29, type: "alphanumeric" },
        "402": { length: 17 },
        "7004": { max: 4, type: "alphanumeric" },
        "242": { max: 6, type: "alphanumeric" },
        "8020": { max: 25, type: "alphanumeric" },
        "703": { min: 3, max: 30, type: "alphanumeric" },
        "8008": { min: 8, max: 12, type: "alphanumeric" },
        "253": { min: 13, max: 17, type: "alphanumeric" },
        "8003": { min: 14, max: 30, type: "alphanumeric" },
        multiKey: [{
          ids: ["15", "17", "8005", "8100"],
          ranges: [
            [11, 13],
            [310, 316],
            [320, 336],
            [340, 369]
          ],
          type: { length: 6 }
        }, {
          ids: ["240", "241", "250", "251", "400", "401", "403", "7002", "8004", "8007", "8110"],
          ranges: [[90 - 99]],
          type: { max: 30, type: "alphanumeric" }
        }, {
          ids: ["7001"],
          ranges: [[410, 414]],
          type: { length: 13 }
        }, {
          ids: ["10", "21", "254", "420", "8002"],
          type: { max: 20, type: "alphanumeric" }
        }, {
          ids: ["00", "8006", "8017", "8018"],
          type: { length: 18 }
        }, {
          ids: ["01", "02", "8001"],
          type: { length: 14 }
        }, {
          ids: ["422"],
          ranges: [
            [424, 426]
          ],
          type: { length: 3 }
        }, {
          ids: ["20", "8102"],
          type: { length: 2 }
        }, {
          ids: ["30", "37"],
          type: { max: 8, type: "alphanumeric" }
        }, {
          ids: ["390", "392"],
          type: { max: 15, type: "alphanumeric" }
        }, {
          ids: ["421", "423"],
          type: { min: 3, max: 15, type: "alphanumeric" }
        }, {
          ids: ["391", "393"],
          type: { min: 3, max: 18, type: "alphanumeric" }
        }, {
          ids: ["7003", "8101"],
          type: { length: 10 }
        }]
      },
      START: 102
    });
  }
  addStart() {
    this.encoding[this.startState].addStart();
  }
  is() {
    return inArray(this.key, this.states);
  }
  pushState(encodingState) {
    let encoding = this.encoding, value2 = encodingState.value.replace(/\s/g, ""), regexSeparators = new RegExp("[" + this.startAI + this.endAI + "]", "g"), index = encodingState.index, subState = {
      state: this.startState
    }, current4, nextStart, separatorLength;
    encoding.addPattern(this.START);
    const trueCondition = true;
    while (trueCondition) {
      subState.index = 0;
      separatorLength = value2.charAt(index) === this.startAI ? 2 : 0;
      current4 = separatorLength > 0 ? this.getBySeparator(value2, index) : this.getByLength(value2, index);
      if (current4.ai.length) {
        nextStart = index + separatorLength + current4.id.length + current4.ai.length;
      } else {
        nextStart = value2.indexOf(this.startAI, index + 1);
        if (nextStart < 0) {
          if (index + current4.ai.max + current4.id.length + separatorLength < value2.length) {
            throw new Error("Separators are required after variable length identifiers");
          }
          nextStart = value2.length;
        }
      }
      subState.value = value2.substring(index, nextStart).replace(regexSeparators, "");
      this.validate(current4, subState.value);
      encoding.pushData(subState, this.dependentStates);
      if (nextStart >= value2.length) {
        break;
      }
      index = nextStart;
      if (subState.state !== this.startState) {
        encoding[this.startState].move(subState);
        subState.state = this.startState;
      }
      if (!current4.ai.length) {
        encoding.addPattern(this.START);
      }
    }
    encodingState.index = encodingState.value.length;
  }
  validate(current4, value2) {
    let code = value2.substr(current4.id.length), ai = current4.ai;
    if (!ai.type && !numberRegex2.test(code)) {
      throw new Error("Application identifier " + current4.id + " is numeric only but contains non numeric character(s).");
    }
    if (ai.type === "alphanumeric" && !alphanumericRegex.test(code)) {
      throw new Error("Application identifier " + current4.id + " is alphanumeric only but contains non alphanumeric character(s).");
    }
    if (ai.length && ai.length !== code.length) {
      throw new Error("Application identifier " + current4.id + " must be " + ai.length + " characters long.");
    }
    if (ai.min && ai.min > code.length) {
      throw new Error("Application identifier " + current4.id + " must be at least " + ai.min + " characters long.");
    }
    if (ai.max && ai.max < code.length) {
      throw new Error("Application identifier " + current4.id + " must be at most " + ai.max + " characters long.");
    }
  }
  getByLength(value2, index) {
    let id;
    let applicationIdentifier;
    for (let i37 = 2; i37 <= 4; i37++) {
      id = getSubstring(value2, index, i37);
      applicationIdentifier = this.getApplicationIdentifier(id) || this.getApplicationIdentifier(id.substring(0, id.length - 1));
      if (applicationIdentifier) {
        return {
          id,
          ai: applicationIdentifier
        };
      }
    }
    this.unsupportedAIError(id);
  }
  unsupportedAIError(id) {
    throw new Error("'" + id + "' is not a supported Application Identifier");
  }
  getBySeparator(value2, index) {
    let start = value2.indexOf(this.startAI, index), end = value2.indexOf(this.endAI, start), id = value2.substring(start + 1, end), ai = this.getApplicationIdentifier(id) || this.getApplicationIdentifier(id.substr(id.length - 1));
    if (!ai) {
      this.unsupportedAIError(id);
    }
    return {
      ai,
      id
    };
  }
  getApplicationIdentifier(id) {
    let applicationIdentifier = this.applicationIdentifiers, multiKey = applicationIdentifier.multiKey;
    if (applicationIdentifier[id]) {
      return applicationIdentifier[id];
    }
    for (let i37 = 0; i37 < multiKey.length; i37++) {
      if (multiKey[i37].ids && inArray(id, multiKey[i37].ids)) {
        return multiKey[i37].type;
      } else if (multiKey[i37].ranges) {
        let ranges = multiKey[i37].ranges;
        for (let j = 0; j < ranges.length; j++) {
          if (ranges[j][0] <= id && id <= ranges[j][1]) {
            return multiKey[i37].type;
          }
        }
      }
    }
  }
};
var Code128Base = class extends Encoding {
  constructor(options) {
    super(options);
    this._initStates();
  }
  initProperties() {
    super.initProperties();
    extend6(this, {
      characterMap: [
        212222,
        222122,
        222221,
        121223,
        121322,
        131222,
        122213,
        122312,
        132212,
        221213,
        221312,
        231212,
        112232,
        122132,
        122231,
        113222,
        123122,
        123221,
        223211,
        221132,
        221231,
        213212,
        223112,
        312131,
        311222,
        321122,
        321221,
        312212,
        322112,
        322211,
        212123,
        212321,
        232121,
        111323,
        131123,
        131321,
        112313,
        132113,
        132311,
        211313,
        231113,
        231311,
        112133,
        112331,
        132131,
        113123,
        113321,
        133121,
        313121,
        211331,
        231131,
        213113,
        213311,
        213131,
        311123,
        311321,
        331121,
        312113,
        312311,
        332111,
        314111,
        221411,
        431111,
        111224,
        111422,
        121124,
        121421,
        141122,
        141221,
        112214,
        112412,
        122114,
        122411,
        142112,
        142211,
        241211,
        221114,
        413111,
        241112,
        134111,
        111242,
        121142,
        121241,
        114212,
        124112,
        124211,
        411212,
        421112,
        421211,
        212141,
        214121,
        412121,
        111143,
        111341,
        131141,
        114113,
        114311,
        411113,
        411311,
        113141,
        114131,
        311141,
        411131,
        211412,
        211214,
        211232,
        2331112
      ],
      STOP: 106
    });
  }
  _initStates() {
    for (let i37 = 0; i37 < this.states.length; i37++) {
      this[this.states[i37]] = new states128[this.states[i37]](this, this.states);
    }
  }
  initValue(value2, width, height) {
    this.pattern = [];
    this.value = value2;
    this.width = width;
    this.height = height;
    this.checkSum = 0;
    this.totalUnits = 0;
    this.index = 0;
    this.position = 1;
  }
  addData() {
    let encodingState = {
      value: this.value,
      index: 0,
      state: ""
    };
    if (this.value.length === 0) {
      return;
    }
    encodingState.state = encodingState.previousState = this.getNextState(encodingState, this.states);
    this.addStart(encodingState);
    this.pushData(encodingState, this.states);
    this.addCheckSum();
    this.addStop();
    this.setBaseUnit();
  }
  pushData(encodingState, states) {
    const trueCondition = true;
    while (trueCondition) {
      this[encodingState.state].pushState(encodingState);
      if (encodingState.index >= encodingState.value.length) {
        break;
      }
      if (!encodingState.shifted) {
        encodingState.previousState = encodingState.state;
        encodingState.state = this.getNextState(encodingState, states);
        this[encodingState.state].move(encodingState);
      } else {
        let temp = encodingState.state;
        encodingState.state = encodingState.previousState;
        encodingState.previousState = temp;
        encodingState.shifted = false;
      }
    }
  }
  addStart(encodingState) {
    this[encodingState.state].addStart(encodingState);
    this.position = 1;
  }
  addCheckSum() {
    this.checksum = this.checkSum % 103;
    this.addPattern(this.checksum);
  }
  addStop() {
    this.addPattern(this.STOP);
  }
  setBaseUnit() {
    this.baseUnit = this.width / (this.totalUnits + this.quietZoneLength);
  }
  addPattern(code) {
    const pattern = this.characterMap[code].toString();
    let value2;
    for (let i37 = 0; i37 < pattern.length; i37++) {
      value2 = parseInt(pattern.charAt(i37), 10);
      this.pattern.push(value2);
      this.totalUnits += value2;
    }
    this.checkSum += code * this.position++;
  }
  getNextState(encodingState, states) {
    for (let i37 = 0; i37 < states.length; i37++) {
      if (this[states[i37]].is(encodingState.value, encodingState.index)) {
        return states[i37];
      }
    }
    this.invalidCharacterError(encodingState.value.charAt(encodingState.index));
  }
};
var Code128a = class extends Code128Base {
  initProperties() {
    super.initProperties();
    extend6(this, {
      name: "Code 128 A",
      states: ["A"]
    });
  }
};
var Code128b = class extends Code128Base {
  initProperties() {
    super.initProperties();
    extend6(this, {
      name: "Code 128 B",
      states: ["B"]
    });
  }
};
var Code128c = class extends Code128Base {
  initProperties() {
    super.initProperties();
    extend6(this, {
      name: "Code 128 C",
      states: ["C"]
    });
  }
};
var Code128 = class extends Code128Base {
  initProperties() {
    super.initProperties();
    extend6(this, {
      name: "Code 128",
      states: ["C", "B", "A", "FNC4"]
    });
  }
};
var CodeGS1128 = class extends Code128Base {
  initProperties() {
    super.initProperties();
    extend6(this, {
      name: "Code GS1-128",
      states: ["FNC1", "C", "B"]
    });
  }
};
function getSubstring(value2, index, count) {
  return value2.substring(index, index + count);
}

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/msi.js
var extend7 = Object.assign;
var MsiBase = class extends Encoding {
  initProperties() {
    super.initProperties();
    extend7(this, {
      characterMap: [
        "12121212",
        "12121221",
        "12122112",
        "12122121",
        "12211212",
        "12211221",
        "12212112",
        "12212121",
        "21121212",
        "21121221"
      ],
      START: "21",
      STOP: "121",
      checkSumType: "",
      checkSums
    });
  }
  initValue(value2, width) {
    this.pattern = [];
    this.value = value2;
    this.checkSumLength = 0;
    this.width = width;
  }
  setBaseUnit() {
    const startStopLength = 7;
    this.baseUnit = this.width / (12 * (this.value.length + this.checkSumLength) + this.quietZoneLength + startStopLength);
  }
  addData() {
    const value2 = this.value;
    this.addPattern(this.START);
    for (let i37 = 0; i37 < value2.length; i37++) {
      this.addCharacter(value2.charAt(i37));
    }
    if (this.options.addCheckSum) {
      this.addCheckSum();
    }
    this.addPattern(this.STOP);
    this.setBaseUnit();
  }
  addCharacter(character) {
    const pattern = this.characterMap[character];
    if (!pattern) {
      this.invalidCharacterError(character);
    }
    this.addPattern(pattern);
  }
  addPattern(pattern) {
    for (let i37 = 0; i37 < pattern.length; i37++) {
      this.pattern.push(parseInt(pattern.charAt(i37), 10));
    }
  }
  addCheckSum() {
    const checkSumFunction = this.checkSums[this.checkSumType];
    const checkValues = checkSumFunction.call(this.checkSums, this.value);
    this.checksum = checkValues.join("");
    for (let i37 = 0; i37 < checkValues.length; i37++) {
      this.checkSumLength++;
      this.addPattern(this.characterMap[checkValues[i37]]);
    }
  }
};
var MsiMod10 = class extends MsiBase {
  initProperties() {
    super.initProperties();
    extend7(this, {
      name: "MSI Modulo10",
      checkSumType: "Modulo10"
    });
  }
};
var MsiMod11 = class extends MsiBase {
  initProperties() {
    super.initProperties();
    extend7(this, {
      name: "MSI Modulo11",
      checkSumType: "Modulo11"
    });
  }
};
var MsiMod1010 = class extends MsiBase {
  initProperties() {
    super.initProperties();
    extend7(this, {
      name: "MSI Modulo10 Modulo10",
      checkSumType: "Modulo10Modulo10"
    });
  }
};
var MsiMod1110 = class extends MsiBase {
  initProperties() {
    super.initProperties();
    extend7(this, {
      name: "MSI Modulo11 Modulo10",
      checkSumType: "Modulo11Modulo10"
    });
  }
};
var checkSums = {
  Modulo10(value2) {
    let checkValues = [0, ""], odd = value2.length % 2, idx, evenSum, oddSum;
    for (idx = 0; idx < value2.length; idx++) {
      checkValues[(idx + odd) % 2] += parseInt(value2.charAt(idx), 10);
    }
    oddSum = checkValues[0];
    evenSum = (checkValues[1] * 2).toString();
    for (idx = 0; idx < evenSum.length; idx++) {
      oddSum += parseInt(evenSum.charAt(idx), 10);
    }
    return [(10 - oddSum % 10) % 10];
  },
  Modulo11(value2) {
    let weightedSum = 0, mod = 11, length = value2.length, weight, checkValue;
    for (let i37 = 0; i37 < length; i37++) {
      weight = ((length - i37) % 6 || 6) + 1;
      weightedSum += weight * value2.charAt(i37);
    }
    checkValue = (mod - weightedSum % mod) % mod;
    if (checkValue !== 10) {
      return [checkValue];
    }
    return [1, 0];
  },
  Modulo11Modulo10(value2) {
    let checkValues = this.Modulo11(value2), mod11Value;
    mod11Value = value2 + checkValues[0];
    return checkValues.concat(this.Modulo10(mod11Value));
  },
  Modulo10Modulo10(value2) {
    let checkValues = this.Modulo10(value2), mod10Value;
    mod10Value = value2 + checkValues[0];
    return checkValues.concat(this.Modulo10(mod10Value));
  }
};

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/ean13.js
var extend8 = Object.assign;
var Ean13 = class extends Encoding {
  initProperties() {
    super.initProperties();
    extend8(this, {
      name: "EAN 13",
      keyTable: [
        "000000",
        "001011",
        "001101",
        "001110",
        "010011",
        "011001",
        "011100",
        "010101",
        "010110",
        "011010"
      ],
      characterMap: {
        digits: [
          [3, 2, 1, 1],
          [2, 2, 2, 1],
          [2, 1, 2, 2],
          [1, 4, 1, 1],
          [1, 1, 3, 2],
          [1, 2, 3, 1],
          [1, 1, 1, 4],
          [1, 3, 1, 2],
          [1, 2, 1, 3],
          [3, 1, 1, 2]
        ],
        start: [1, 1, 1],
        middle: [1, 1, 1, 1, 1]
      }
    });
  }
  initValue(value2, width, height) {
    const valueAsString = String(value2);
    if (valueAsString.length !== 12 || /\D/.test(valueAsString)) {
      throw new Error('The value of the "EAN13" encoding should be 12 symbols');
    }
    this.pattern = [];
    this.options.height = height;
    this.baseUnit = width / (95 + this.quietZoneLength);
    this.value = valueAsString;
    this.checksum = this.calculateChecksum();
    this.leftKey = valueAsString[0];
    this.leftPart = valueAsString.substr(1, 6);
    this.rightPart = valueAsString.substr(7) + this.checksum;
  }
  addData() {
    this.addPieces(this.characterMap.start);
    this.addSide(this.leftPart, this.leftKey);
    this.addPieces(this.characterMap.middle);
    this.addSide(this.rightPart);
    this.addPieces(this.characterMap.start);
  }
  addSide(leftPart, key) {
    for (let i37 = 0; i37 < leftPart.length; i37++) {
      if (key && parseInt(this.keyTable[key].charAt(i37), 10)) {
        this.addPieces(Array.prototype.slice.call(this.characterMap.digits[leftPart.charAt(i37)]).reverse(), true);
      } else {
        this.addPieces(this.characterMap.digits[leftPart.charAt(i37)], true);
      }
    }
  }
  addPieces(arrToAdd, limitedHeight) {
    for (let i37 = 0; i37 < arrToAdd.length; i37++) {
      if (limitedHeight) {
        this.pattern.push({
          y1: 0,
          y2: this.options.height * 0.95,
          width: arrToAdd[i37]
        });
      } else {
        this.pattern.push(arrToAdd[i37]);
      }
    }
  }
  calculateChecksum() {
    let odd = 0, even = 0, value2 = this.value.split("").reverse().join("");
    for (let i37 = 0; i37 < value2.length; i37++) {
      if (i37 % 2) {
        even += parseInt(value2.charAt(i37), 10);
      } else {
        odd += parseInt(value2.charAt(i37), 10);
      }
    }
    let checksum = (10 - (3 * odd + even) % 10) % 10;
    return checksum;
  }
};

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/ean8.js
var extend9 = Object.assign;
var Ean8 = class extends Ean13 {
  initProperties() {
    super.initProperties();
    extend9(this, {
      name: "EAN 8"
    });
  }
  initValue(value2, width, height) {
    if (value2.length !== 7 || /\D/.test(value2)) {
      throw new Error("Invalid value provided");
    }
    this.value = value2;
    this.options.height = height;
    this.checksum = this.calculateChecksum(this.value);
    this.leftPart = this.value.substr(0, 4);
    this.rightPart = this.value.substr(4) + this.checksum;
    this.pattern = [];
    this.baseUnit = width / (67 + this.quietZoneLength);
  }
};

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/main.js
var Encodings = {
  code11: Code11,
  code39: Code39,
  code39extended: Code39Extended,
  code93: Code93,
  code93extended: Code93Extended,
  code128: Code128,
  code128a: Code128a,
  code128b: Code128b,
  code128c: Code128c,
  ["gs1-128"]: CodeGS1128,
  msimod10: MsiMod10,
  msimod11: MsiMod11,
  msimod1010: MsiMod1010,
  msimod1110: MsiMod1110,
  postnet: Postnet,
  ean8: Ean8,
  ean13: Ean13
};

// node_modules/@progress/kendo-charts/dist/es/barcode/surface-size.js
function surfaceSize(element, surfaceType) {
  const display = element.style.display;
  if (surfaceType === "canvas") {
    element.style.display = "block";
  }
  const size = {
    width: element.clientWidth,
    height: element.clientHeight
  };
  element.style.display = display;
  return size;
}

// node_modules/@progress/kendo-charts/dist/es/barcode/barcode.js
var DEFAULT_BARCODE_WIDTH = 300;
var DEFAULT_BARCODE_HEIGHT = 100;
var Barcode = class {
  constructor(element, options, errorHandler = defaultErrorHandler) {
    this.options = deepExtend({}, this.options, options);
    this.element = element;
    this.onError = errorHandler;
    this._initElement();
    this._initSurface();
    this._setOptions(options);
    if (options && defined(options.value)) {
      this.redraw();
    }
  }
  destroy() {
    this._destroySurface();
  }
  _initElement() {
    addClass(this.element, "k-barcode");
  }
  _initSurface() {
    const { options, surface } = this;
    if (!surface || surface.options.type !== options.renderAs) {
      this._destroySurface();
      this._initSurfaceElement();
      this.surface = this._createSurface();
    }
  }
  _createSurface() {
    return drawing_exports.Surface.create(this.surfaceElement, {
      type: this.options.renderAs
    });
  }
  _destroySurface() {
    if (this.surface) {
      this.surface.destroy();
      this.surface = null;
      this._destroySurfaceElement();
    }
  }
  _initSurfaceElement() {
    if (!this.surfaceElement) {
      this.surfaceElement = document.createElement("div");
      this.surfaceElement.style.position = "relative";
      this.element.appendChild(this.surfaceElement);
    }
  }
  _destroySurfaceElement() {
    if (this.surfaceElement && this.surfaceElement.parentNode) {
      this.surfaceElement.parentNode.removeChild(this.surfaceElement);
      this.surfaceElement = null;
    }
  }
  setOptions(options) {
    this._setOptions(options);
    this._initSurface();
    this.redraw();
  }
  redraw() {
    let size = this._getSize();
    this.surface.clear();
    this.surface.setSize({
      width: size.width,
      height: size.height
    });
    this.createVisual();
    this.surface.draw(this.visual);
  }
  getSize() {
    return {
      width: this.element.offsetWidth,
      height: this.element.offsetHeight
    };
  }
  _resize() {
    this.redraw();
  }
  createVisual() {
    this.visual = this._render();
  }
  _render() {
    const options = this.options;
    const value2 = options.value;
    const textOptions = options.text;
    const textMargin = getSpacing(textOptions.margin);
    const size = this._getSize();
    const border = options.border || {};
    const encoding = this.encoding;
    const contentBox = new box_default(0, 0, size.width, size.height).unpad(border.width).unpad(options.padding);
    let barHeight = contentBox.height();
    let encodedValue;
    let textToDisplay;
    let textHeight;
    const visual = new drawing_exports.Group();
    this.contentBox = contentBox;
    visual.append(this._getBackground(size));
    if (textOptions.visible) {
      textHeight = drawing_exports.util.measureText(value2, { font: textOptions.font }).height;
      barHeight -= textHeight + textMargin.top + textMargin.bottom;
    }
    try {
      encodedValue = encoding.encode(value2, contentBox.width(), barHeight);
    } catch (error) {
      this.onError(error);
      return visual;
    }
    if (textOptions.visible) {
      textToDisplay = value2;
      if (options.checksum && defined(encoding.checksum)) {
        textToDisplay += " " + encoding.checksum;
      }
      visual.append(this._getText(textToDisplay));
    }
    this.barHeight = barHeight;
    this._bandsGroup = this._getBands(encodedValue.pattern, encodedValue.baseUnit);
    visual.append(this._bandsGroup);
    return visual;
  }
  exportVisual() {
    return this._render();
  }
  _getSize() {
    const element = this.element;
    const elementSize2 = surfaceSize(element, this.options.renderAs);
    const size = new geometry_exports.Size(DEFAULT_BARCODE_WIDTH, DEFAULT_BARCODE_HEIGHT);
    if (elementSize2.width > 0) {
      size.width = elementSize2.width;
    }
    if (elementSize2.height > 0) {
      size.height = elementSize2.height;
    }
    if (this.options.width) {
      size.width = this.options.width;
    }
    if (this.options.height) {
      size.height = this.options.height;
    }
    return size;
  }
  value(value2) {
    if (!defined(value2)) {
      return this.options.value;
    }
    this.options.value = String(value2);
    this.redraw();
  }
  _getBands(pattern, baseUnit) {
    const contentBox = this.contentBox;
    let offsetX = contentBox.x1;
    let stepX;
    let patternItem;
    const group = new drawing_exports.Group();
    for (let i37 = 0; i37 < pattern.length; i37++) {
      patternItem = isObject(pattern[i37]) ? pattern[i37] : {
        width: pattern[i37],
        y1: 0,
        y2: this.barHeight
      };
      stepX = patternItem.width * baseUnit;
      if (i37 % 2) {
        const rect = geometry_exports.Rect.fromPoints(
          new geometry_exports.Point(offsetX, patternItem.y1 + contentBox.y1),
          new geometry_exports.Point(offsetX + stepX, patternItem.y2 + contentBox.y1)
        );
        const path = drawing_exports.Path.fromRect(rect, {
          fill: {
            color: this.options.color
          },
          stroke: null
        });
        group.append(path);
      }
      offsetX += stepX;
    }
    return group;
  }
  _getBackground(size) {
    const options = this.options;
    const border = options.border || {};
    const box = new box_default(0, 0, size.width, size.height).unpad(border.width / 2);
    const path = drawing_exports.Path.fromRect(box.toRect(), {
      fill: {
        color: options.background
      },
      stroke: {
        color: border.width ? border.color : "",
        width: border.width,
        dashType: border.dashType
      }
    });
    return path;
  }
  _getText(value2) {
    const textOptions = this.options.text;
    const text = this._textbox = new text_box_default(value2, {
      font: textOptions.font,
      color: textOptions.color,
      align: "center",
      vAlign: "bottom",
      margin: textOptions.margin
    });
    text.reflow(this.contentBox);
    text.renderVisual();
    return text.visual;
  }
  _setOptions(options) {
    this.type = (options.type || this.options.type).toLowerCase();
    if (this.type === "upca") {
      this.type = "ean13";
      options.value = "0" + options.value;
    }
    if (this.type === "upce") {
      this.type = "ean8";
      options.value = "0" + options.value;
    }
    if (!Encodings[this.type]) {
      throw new Error(`Encoding '${this.type}' is not supported.`);
    }
    this.encoding = new Encodings[this.type]();
    this.options = deepExtend({}, this.options, options);
  }
};
setDefaultOptions(Barcode, {
  name: "Barcode",
  renderAs: "svg",
  value: "",
  type: "code39",
  checksum: false,
  width: 0,
  height: 0,
  color: "black",
  background: "white",
  text: {
    visible: true,
    font: "16px Consolas, Monaco, Sans Mono, monospace, sans-serif",
    color: "black",
    margin: {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0
    }
  },
  border: {
    width: 0,
    dashType: "solid",
    color: "black"
  },
  padding: {
    top: 0,
    bottom: 0,
    left: 0,
    right: 0
  }
});

// node_modules/@progress/kendo-charts/dist/es/qrcode/utils.js
var extend10 = Object.assign;
function splitInto(str, chunkLength) {
  let result = [];
  let idx = 0;
  while (idx < str.length) {
    result.push(str.substring(idx, idx + chunkLength));
    idx += chunkLength;
  }
  return result;
}
function toBitsString(value2, length) {
  let bitString = Number(value2).toString(2);
  if (bitString.length < length) {
    bitString = new Array(length - bitString.length + 1).join(0) + bitString;
  }
  return bitString;
}
function toDecimal(value2) {
  return parseInt(value2, 2);
}

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/free-cell-visitor.js
var FreeCellVisitor = class {
  constructor(matrix) {
    this.matrix = matrix;
    this.row = matrix.length - 1;
    this.column = matrix.length - 1;
    this.startColumn = this.column;
    this.dir = -1;
    this.c = 0;
  }
  move() {
    this.row += this.dir * this.c;
    this.c ^= 1;
    this.column = this.startColumn - this.c;
  }
  getNextCell() {
    while (this.matrix[this.row][this.column] !== void 0) {
      this.move();
      if (this.row < 0 || this.row >= this.matrix.length) {
        this.dir = -this.dir;
        this.startColumn -= this.startColumn !== 8 ? 2 : 3;
        this.column = this.startColumn;
        this.row = this.dir < 0 ? this.matrix.length - 1 : 0;
      }
    }
    return {
      row: this.row,
      column: this.column
    };
  }
  getNextRemainderCell() {
    this.move();
    if (this.matrix[this.row][this.column] === void 0) {
      return {
        row: this.row,
        column: this.column
      };
    }
  }
};

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/encoding-result.js
var EncodingResult = class {
  constructor(dataString, version) {
    this.dataString = dataString;
    this.version = version;
  }
};

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/utils/choose-mode.js
var NUMERIC = "numeric";
var ALPHA_NUMERIC = "alphanumeric";
var BYTE = "byte";
var numberRegex3 = /^\d+/;
var alphaPattern = "A-Z0-9 $%*+./:-";
var alphaExclusiveSet = "A-Z $%*+./:-";
var alphaRegex = new RegExp("^[" + alphaExclusiveSet + "]+");
var alphaNumericRegex = new RegExp("^[" + alphaPattern + "]+");
var byteRegex = new RegExp("^[^" + alphaPattern + "]+");
function chooseMode(str, minNumericBeforeAlpha2, minNumericBeforeByte2, minAlphaBeforeByte2, previousMode) {
  let numeric = numberRegex3.exec(str), numericMatch = numeric ? numeric[0] : "", alpha = alphaRegex.exec(str), alphaMatch = alpha ? alpha[0] : "", alphaNumeric = alphaNumericRegex.exec(str), alphaNumericMatch = alphaNumeric ? alphaNumeric[0] : "", mode, modeString;
  if (numericMatch && (numericMatch.length >= minNumericBeforeAlpha2 || str.length === numericMatch.length || numericMatch.length >= minNumericBeforeByte2 && !alphaNumericRegex.test(str.charAt(numericMatch.length)))) {
    mode = NUMERIC;
    modeString = numericMatch;
  } else if (alphaNumericMatch && (str.length === alphaNumericMatch.length || alphaNumericMatch.length >= minAlphaBeforeByte2 || previousMode === ALPHA_NUMERIC)) {
    mode = ALPHA_NUMERIC;
    modeString = numericMatch || alphaMatch;
  } else {
    mode = BYTE;
    if (alphaNumericMatch) {
      modeString = alphaNumericMatch + byteRegex.exec(str.substring(alphaNumericMatch.length))[0];
    } else {
      modeString = byteRegex.exec(str)[0];
    }
  }
  return {
    mode,
    modeString
  };
}

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/data-modes/qr-data-mode.js
var QRDataMode = class {
  constructor() {
    this.initProperties();
  }
  initProperties() {
    extend10(this, {
      modeIndicator: "",
      bitsInCharacterCount: []
    });
  }
  getVersionIndex(version) {
    if (version < 10) {
      return 0;
    } else if (version > 26) {
      return 2;
    }
    return 1;
  }
  getBitsCharacterCount(version) {
    return this.bitsInCharacterCount[this.getVersionIndex(version || 40)];
  }
  getModeCountString(length, version) {
    return this.modeIndicator + toBitsString(length, this.getBitsCharacterCount(version));
  }
  encode() {
  }
  getStringBitsLength() {
  }
  getValue() {
  }
};

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/data-modes/numeric-data-mode.js
var NumericQRDataMode = class extends QRDataMode {
  initProperties() {
    super.initProperties();
    extend10(this, {
      bitsInCharacterCount: [10, 12, 14],
      modeIndicator: "0001"
    });
  }
  getValue(character) {
    return parseInt(character, 10);
  }
  encode(str, version) {
    let mode = this, parts = splitInto(str, 3), result = mode.getModeCountString(str.length, version);
    let i37;
    for (i37 = 0; i37 < parts.length - 1; i37++) {
      result += toBitsString(parts[i37], 10);
    }
    return result + toBitsString(parts[i37], 1 + 3 * parts[i37].length);
  }
  getStringBitsLength(inputLength, version) {
    let mod3 = inputLength % 3;
    return 4 + this.getBitsCharacterCount(version) + 10 * Math.floor(inputLength / 3) + 3 * mod3 + (mod3 === 0 ? 0 : 1);
  }
};

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/data-modes/alpha-numeric-data-mode.js
var AlphaNumericQRDataMode = class extends QRDataMode {
  initProperties() {
    super.initProperties();
    extend10(this, {
      characters: {
        "0": 0,
        "1": 1,
        "2": 2,
        "3": 3,
        "4": 4,
        "5": 5,
        "6": 6,
        "7": 7,
        "8": 8,
        "9": 9,
        "A": 10,
        "B": 11,
        "C": 12,
        "D": 13,
        "E": 14,
        "F": 15,
        "G": 16,
        "H": 17,
        "I": 18,
        "J": 19,
        "K": 20,
        "L": 21,
        "M": 22,
        "N": 23,
        "O": 24,
        "P": 25,
        "Q": 26,
        "R": 27,
        "S": 28,
        "T": 29,
        "U": 30,
        "V": 31,
        "W": 32,
        "X": 33,
        "Y": 34,
        "Z": 35,
        " ": 36,
        "$": 37,
        "%": 38,
        "*": 39,
        "+": 40,
        "-": 41,
        ".": 42,
        "/": 43,
        ":": 44
      },
      bitsInCharacterCount: [9, 11, 13],
      modeIndicator: "0010"
    });
  }
  getValue(character) {
    return this.characters[character];
  }
  encode(str, version) {
    let parts = splitInto(str, 2), result = this.getModeCountString(str.length, version), value2;
    let i37;
    for (i37 = 0; i37 < parts.length - 1; i37++) {
      value2 = 45 * this.getValue(parts[i37].charAt(0)) + this.getValue(parts[i37].charAt(1));
      result += toBitsString(value2, 11);
    }
    value2 = parts[i37].length === 2 ? 45 * this.getValue(parts[i37].charAt(0)) + this.getValue(parts[i37].charAt(1)) : this.getValue(parts[i37].charAt(0));
    return result + toBitsString(value2, 1 + 5 * parts[i37].length);
  }
  getStringBitsLength(inputLength, version) {
    return 4 + this.getBitsCharacterCount(version) + 11 * Math.floor(inputLength / 2) + 6 * (inputLength % 2);
  }
};

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/data-modes/byte-data-mode.js
var ByteQRDataMode = class extends QRDataMode {
  initProperties() {
    super.initProperties();
    extend10(this, {
      bitsInCharacterCount: [8, 16, 16],
      modeIndicator: "0100"
    });
  }
  getValue(character) {
    let code = character.charCodeAt(0);
    if (code <= 127 || 160 <= code && code <= 255) {
      return code;
    }
    throw new Error(`Unsupported character in QR Code: "${character}".`);
  }
  encode(str, version) {
    let mode = this, result = mode.getModeCountString(str.length, version);
    for (let i37 = 0; i37 < str.length; i37++) {
      result += toBitsString(mode.getValue(str.charAt(i37)), 8);
    }
    return result;
  }
  getStringBitsLength(inputLength, version) {
    return 4 + this.getBitsCharacterCount(version) + 8 * inputLength;
  }
};

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/data-modes/data-mode-instances.js
var NUMERIC2 = "numeric";
var ALPHA_NUMERIC2 = "alphanumeric";
var BYTE2 = "byte";
var DataModeInstances = {
  [NUMERIC2]: new NumericQRDataMode(),
  [ALPHA_NUMERIC2]: new AlphaNumericQRDataMode(),
  [BYTE2]: new ByteQRDataMode()
};

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/utils/get-data-codewords-count.js
function getDataCodewordsCount(modes) {
  let length = 0, mode;
  for (let i37 = 0; i37 < modes.length; i37++) {
    mode = DataModeInstances[modes[i37].mode];
    length += mode.getStringBitsLength(modes[i37].modeString.length);
  }
  return Math.ceil(length / 8);
}

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/utils/get-data-string.js
function getDataString(modes, version) {
  let dataString = "", mode;
  for (let i37 = 0; i37 < modes.length; i37++) {
    mode = DataModeInstances[modes[i37].mode];
    dataString += mode.encode(modes[i37].modeString, version);
  }
  return dataString;
}

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/utils/get-modes.js
var initMinNumericBeforeAlpha = 8;
var initMinNumericBeforeByte = 5;
var initMinAlphaBeforeByte = 8;
var minNumericBeforeAlpha = 17;
var minNumericBeforeByte = 9;
var minAlphaBeforeByte = 16;
function getModes(inputString) {
  let modes = [], previousMode, idx = 0;
  let str = inputString;
  modes.push(chooseMode(str, initMinNumericBeforeAlpha, initMinNumericBeforeByte, initMinAlphaBeforeByte, previousMode));
  previousMode = modes[0].mode;
  str = str.substr(modes[0].modeString.length);
  while (str.length > 0) {
    let nextMode = chooseMode(str, minNumericBeforeAlpha, minNumericBeforeByte, minAlphaBeforeByte, previousMode);
    if (nextMode.mode !== previousMode) {
      previousMode = nextMode.mode;
      modes.push(nextMode);
      idx++;
    } else {
      modes[idx].modeString += nextMode.modeString;
    }
    str = str.substr(nextMode.modeString.length);
  }
  return modes;
}

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/version-codewords.js
var VersionsCodewordsInformation = [{
  L: {
    groups: [
      [1, 19]
    ],
    totalDataCodewords: 19,
    errorCodewordsPerBlock: 7
  },
  M: {
    groups: [
      [1, 16]
    ],
    totalDataCodewords: 16,
    errorCodewordsPerBlock: 10
  },
  Q: {
    groups: [
      [1, 13]
    ],
    totalDataCodewords: 13,
    errorCodewordsPerBlock: 13
  },
  H: {
    groups: [
      [1, 9]
    ],
    totalDataCodewords: 9,
    errorCodewordsPerBlock: 17
  }
}, {
  L: {
    groups: [
      [1, 34]
    ],
    totalDataCodewords: 34,
    errorCodewordsPerBlock: 10
  },
  M: {
    groups: [
      [1, 28]
    ],
    totalDataCodewords: 28,
    errorCodewordsPerBlock: 16
  },
  Q: {
    groups: [
      [1, 22]
    ],
    totalDataCodewords: 22,
    errorCodewordsPerBlock: 22
  },
  H: {
    groups: [
      [1, 16]
    ],
    totalDataCodewords: 16,
    errorCodewordsPerBlock: 28
  }
}, {
  L: {
    groups: [
      [1, 55]
    ],
    totalDataCodewords: 55,
    errorCodewordsPerBlock: 15
  },
  M: {
    groups: [
      [1, 44]
    ],
    totalDataCodewords: 44,
    errorCodewordsPerBlock: 26
  },
  Q: {
    groups: [
      [2, 17]
    ],
    totalDataCodewords: 34,
    errorCodewordsPerBlock: 18
  },
  H: {
    groups: [
      [2, 13]
    ],
    totalDataCodewords: 26,
    errorCodewordsPerBlock: 22
  }
}, {
  L: {
    groups: [
      [1, 80]
    ],
    totalDataCodewords: 80,
    errorCodewordsPerBlock: 20
  },
  M: {
    groups: [
      [2, 32]
    ],
    totalDataCodewords: 64,
    errorCodewordsPerBlock: 18
  },
  Q: {
    groups: [
      [2, 24]
    ],
    totalDataCodewords: 48,
    errorCodewordsPerBlock: 26
  },
  H: {
    groups: [
      [4, 9]
    ],
    totalDataCodewords: 36,
    errorCodewordsPerBlock: 16
  }
}, {
  L: {
    groups: [
      [1, 108]
    ],
    totalDataCodewords: 108,
    errorCodewordsPerBlock: 26
  },
  M: {
    groups: [
      [2, 43]
    ],
    totalDataCodewords: 86,
    errorCodewordsPerBlock: 24
  },
  Q: {
    groups: [
      [2, 15],
      [2, 16]
    ],
    totalDataCodewords: 62,
    errorCodewordsPerBlock: 18
  },
  H: {
    groups: [
      [2, 11],
      [2, 12]
    ],
    totalDataCodewords: 46,
    errorCodewordsPerBlock: 22
  }
}, {
  L: {
    groups: [
      [2, 68]
    ],
    totalDataCodewords: 136,
    errorCodewordsPerBlock: 18
  },
  M: {
    groups: [
      [4, 27]
    ],
    totalDataCodewords: 108,
    errorCodewordsPerBlock: 16
  },
  Q: {
    groups: [
      [4, 19]
    ],
    totalDataCodewords: 76,
    errorCodewordsPerBlock: 24
  },
  H: {
    groups: [
      [4, 15]
    ],
    totalDataCodewords: 60,
    errorCodewordsPerBlock: 28
  }
}, {
  L: {
    groups: [
      [2, 78]
    ],
    totalDataCodewords: 156,
    errorCodewordsPerBlock: 20
  },
  M: {
    groups: [
      [4, 31]
    ],
    totalDataCodewords: 124,
    errorCodewordsPerBlock: 18
  },
  Q: {
    groups: [
      [2, 14],
      [4, 15]
    ],
    totalDataCodewords: 88,
    errorCodewordsPerBlock: 18
  },
  H: {
    groups: [
      [4, 13],
      [1, 14]
    ],
    totalDataCodewords: 66,
    errorCodewordsPerBlock: 26
  }
}, {
  L: {
    groups: [
      [2, 97]
    ],
    totalDataCodewords: 194,
    errorCodewordsPerBlock: 24
  },
  M: {
    groups: [
      [2, 38],
      [2, 39]
    ],
    totalDataCodewords: 154,
    errorCodewordsPerBlock: 22
  },
  Q: {
    groups: [
      [4, 18],
      [2, 19]
    ],
    totalDataCodewords: 110,
    errorCodewordsPerBlock: 22
  },
  H: {
    groups: [
      [4, 14],
      [2, 15]
    ],
    totalDataCodewords: 86,
    errorCodewordsPerBlock: 26
  }
}, {
  L: {
    groups: [
      [2, 116]
    ],
    totalDataCodewords: 232,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [3, 36],
      [2, 37]
    ],
    totalDataCodewords: 182,
    errorCodewordsPerBlock: 22
  },
  Q: {
    groups: [
      [4, 16],
      [4, 17]
    ],
    totalDataCodewords: 132,
    errorCodewordsPerBlock: 20
  },
  H: {
    groups: [
      [4, 12],
      [4, 13]
    ],
    totalDataCodewords: 100,
    errorCodewordsPerBlock: 24
  }
}, {
  L: {
    groups: [
      [2, 68],
      [2, 69]
    ],
    totalDataCodewords: 274,
    errorCodewordsPerBlock: 18
  },
  M: {
    groups: [
      [4, 43],
      [1, 44]
    ],
    totalDataCodewords: 216,
    errorCodewordsPerBlock: 26
  },
  Q: {
    groups: [
      [6, 19],
      [2, 20]
    ],
    totalDataCodewords: 154,
    errorCodewordsPerBlock: 24
  },
  H: {
    groups: [
      [6, 15],
      [2, 16]
    ],
    totalDataCodewords: 122,
    errorCodewordsPerBlock: 28
  }
}, {
  L: {
    groups: [
      [4, 81]
    ],
    totalDataCodewords: 324,
    errorCodewordsPerBlock: 20
  },
  M: {
    groups: [
      [1, 50],
      [4, 51]
    ],
    totalDataCodewords: 254,
    errorCodewordsPerBlock: 30
  },
  Q: {
    groups: [
      [4, 22],
      [4, 23]
    ],
    totalDataCodewords: 180,
    errorCodewordsPerBlock: 28
  },
  H: {
    groups: [
      [3, 12],
      [8, 13]
    ],
    totalDataCodewords: 140,
    errorCodewordsPerBlock: 24
  }
}, {
  L: {
    groups: [
      [2, 92],
      [2, 93]
    ],
    totalDataCodewords: 370,
    errorCodewordsPerBlock: 24
  },
  M: {
    groups: [
      [6, 36],
      [2, 37]
    ],
    totalDataCodewords: 290,
    errorCodewordsPerBlock: 22
  },
  Q: {
    groups: [
      [4, 20],
      [6, 21]
    ],
    totalDataCodewords: 206,
    errorCodewordsPerBlock: 26
  },
  H: {
    groups: [
      [7, 14],
      [4, 15]
    ],
    totalDataCodewords: 158,
    errorCodewordsPerBlock: 28
  }
}, {
  L: {
    groups: [
      [4, 107]
    ],
    totalDataCodewords: 428,
    errorCodewordsPerBlock: 26
  },
  M: {
    groups: [
      [8, 37],
      [1, 38]
    ],
    totalDataCodewords: 334,
    errorCodewordsPerBlock: 22
  },
  Q: {
    groups: [
      [8, 20],
      [4, 21]
    ],
    totalDataCodewords: 244,
    errorCodewordsPerBlock: 24
  },
  H: {
    groups: [
      [12, 11],
      [4, 12]
    ],
    totalDataCodewords: 180,
    errorCodewordsPerBlock: 22
  }
}, {
  L: {
    groups: [
      [3, 115],
      [1, 116]
    ],
    totalDataCodewords: 461,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [4, 40],
      [5, 41]
    ],
    totalDataCodewords: 365,
    errorCodewordsPerBlock: 24
  },
  Q: {
    groups: [
      [11, 16],
      [5, 17]
    ],
    totalDataCodewords: 261,
    errorCodewordsPerBlock: 20
  },
  H: {
    groups: [
      [11, 12],
      [5, 13]
    ],
    totalDataCodewords: 197,
    errorCodewordsPerBlock: 24
  }
}, {
  L: {
    groups: [
      [5, 87],
      [1, 88]
    ],
    totalDataCodewords: 523,
    errorCodewordsPerBlock: 22
  },
  M: {
    groups: [
      [5, 41],
      [5, 42]
    ],
    totalDataCodewords: 415,
    errorCodewordsPerBlock: 24
  },
  Q: {
    groups: [
      [5, 24],
      [7, 25]
    ],
    totalDataCodewords: 295,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [11, 12],
      [7, 13]
    ],
    totalDataCodewords: 223,
    errorCodewordsPerBlock: 24
  }
}, {
  L: {
    groups: [
      [5, 98],
      [1, 99]
    ],
    totalDataCodewords: 589,
    errorCodewordsPerBlock: 24
  },
  M: {
    groups: [
      [7, 45],
      [3, 46]
    ],
    totalDataCodewords: 453,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [15, 19],
      [2, 20]
    ],
    totalDataCodewords: 325,
    errorCodewordsPerBlock: 24
  },
  H: {
    groups: [
      [3, 15],
      [13, 16]
    ],
    totalDataCodewords: 253,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [1, 107],
      [5, 108]
    ],
    totalDataCodewords: 647,
    errorCodewordsPerBlock: 28
  },
  M: {
    groups: [
      [10, 46],
      [1, 47]
    ],
    totalDataCodewords: 507,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [1, 22],
      [15, 23]
    ],
    totalDataCodewords: 367,
    errorCodewordsPerBlock: 28
  },
  H: {
    groups: [
      [2, 14],
      [17, 15]
    ],
    totalDataCodewords: 283,
    errorCodewordsPerBlock: 28
  }
}, {
  L: {
    groups: [
      [5, 120],
      [1, 121]
    ],
    totalDataCodewords: 721,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [9, 43],
      [4, 44]
    ],
    totalDataCodewords: 563,
    errorCodewordsPerBlock: 26
  },
  Q: {
    groups: [
      [17, 22],
      [1, 23]
    ],
    totalDataCodewords: 397,
    errorCodewordsPerBlock: 28
  },
  H: {
    groups: [
      [2, 14],
      [19, 15]
    ],
    totalDataCodewords: 313,
    errorCodewordsPerBlock: 28
  }
}, {
  L: {
    groups: [
      [3, 113],
      [4, 114]
    ],
    totalDataCodewords: 795,
    errorCodewordsPerBlock: 28
  },
  M: {
    groups: [
      [3, 44],
      [11, 45]
    ],
    totalDataCodewords: 627,
    errorCodewordsPerBlock: 26
  },
  Q: {
    groups: [
      [17, 21],
      [4, 22]
    ],
    totalDataCodewords: 445,
    errorCodewordsPerBlock: 26
  },
  H: {
    groups: [
      [9, 13],
      [16, 14]
    ],
    totalDataCodewords: 341,
    errorCodewordsPerBlock: 26
  }
}, {
  L: {
    groups: [
      [3, 107],
      [5, 108]
    ],
    totalDataCodewords: 861,
    errorCodewordsPerBlock: 28
  },
  M: {
    groups: [
      [3, 41],
      [13, 42]
    ],
    totalDataCodewords: 669,
    errorCodewordsPerBlock: 26
  },
  Q: {
    groups: [
      [15, 24],
      [5, 25]
    ],
    totalDataCodewords: 485,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [15, 15],
      [10, 16]
    ],
    totalDataCodewords: 385,
    errorCodewordsPerBlock: 28
  }
}, {
  L: {
    groups: [
      [4, 116],
      [4, 117]
    ],
    totalDataCodewords: 932,
    errorCodewordsPerBlock: 28
  },
  M: {
    groups: [
      [17, 42]
    ],
    totalDataCodewords: 714,
    errorCodewordsPerBlock: 26
  },
  Q: {
    groups: [
      [17, 22],
      [6, 23]
    ],
    totalDataCodewords: 512,
    errorCodewordsPerBlock: 28
  },
  H: {
    groups: [
      [19, 16],
      [6, 17]
    ],
    totalDataCodewords: 406,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [2, 111],
      [7, 112]
    ],
    totalDataCodewords: 1006,
    errorCodewordsPerBlock: 28
  },
  M: {
    groups: [
      [17, 46]
    ],
    totalDataCodewords: 782,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [7, 24],
      [16, 25]
    ],
    totalDataCodewords: 568,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [34, 13]
    ],
    totalDataCodewords: 442,
    errorCodewordsPerBlock: 24
  }
}, {
  L: {
    groups: [
      [4, 121],
      [5, 122]
    ],
    totalDataCodewords: 1094,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [4, 47],
      [14, 48]
    ],
    totalDataCodewords: 860,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [11, 24],
      [14, 25]
    ],
    totalDataCodewords: 614,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [16, 15],
      [14, 16]
    ],
    totalDataCodewords: 464,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [6, 117],
      [4, 118]
    ],
    totalDataCodewords: 1174,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [6, 45],
      [14, 46]
    ],
    totalDataCodewords: 914,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [11, 24],
      [16, 25]
    ],
    totalDataCodewords: 664,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [30, 16],
      [2, 17]
    ],
    totalDataCodewords: 514,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [8, 106],
      [4, 107]
    ],
    totalDataCodewords: 1276,
    errorCodewordsPerBlock: 26
  },
  M: {
    groups: [
      [8, 47],
      [13, 48]
    ],
    totalDataCodewords: 1e3,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [7, 24],
      [22, 25]
    ],
    totalDataCodewords: 718,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [22, 15],
      [13, 16]
    ],
    totalDataCodewords: 538,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [10, 114],
      [2, 115]
    ],
    totalDataCodewords: 1370,
    errorCodewordsPerBlock: 28
  },
  M: {
    groups: [
      [19, 46],
      [4, 47]
    ],
    totalDataCodewords: 1062,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [28, 22],
      [6, 23]
    ],
    totalDataCodewords: 754,
    errorCodewordsPerBlock: 28
  },
  H: {
    groups: [
      [33, 16],
      [4, 17]
    ],
    totalDataCodewords: 596,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [8, 122],
      [4, 123]
    ],
    totalDataCodewords: 1468,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [22, 45],
      [3, 46]
    ],
    totalDataCodewords: 1128,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [8, 23],
      [26, 24]
    ],
    totalDataCodewords: 808,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [12, 15],
      [28, 16]
    ],
    totalDataCodewords: 628,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [3, 117],
      [10, 118]
    ],
    totalDataCodewords: 1531,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [3, 45],
      [23, 46]
    ],
    totalDataCodewords: 1193,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [4, 24],
      [31, 25]
    ],
    totalDataCodewords: 871,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [11, 15],
      [31, 16]
    ],
    totalDataCodewords: 661,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [7, 116],
      [7, 117]
    ],
    totalDataCodewords: 1631,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [21, 45],
      [7, 46]
    ],
    totalDataCodewords: 1267,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [1, 23],
      [37, 24]
    ],
    totalDataCodewords: 911,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [19, 15],
      [26, 16]
    ],
    totalDataCodewords: 701,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [5, 115],
      [10, 116]
    ],
    totalDataCodewords: 1735,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [19, 47],
      [10, 48]
    ],
    totalDataCodewords: 1373,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [15, 24],
      [25, 25]
    ],
    totalDataCodewords: 985,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [23, 15],
      [25, 16]
    ],
    totalDataCodewords: 745,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [13, 115],
      [3, 116]
    ],
    totalDataCodewords: 1843,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [2, 46],
      [29, 47]
    ],
    totalDataCodewords: 1455,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [42, 24],
      [1, 25]
    ],
    totalDataCodewords: 1033,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [23, 15],
      [28, 16]
    ],
    totalDataCodewords: 793,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [17, 115]
    ],
    totalDataCodewords: 1955,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [10, 46],
      [23, 47]
    ],
    totalDataCodewords: 1541,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [10, 24],
      [35, 25]
    ],
    totalDataCodewords: 1115,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [19, 15],
      [35, 16]
    ],
    totalDataCodewords: 845,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [17, 115],
      [1, 116]
    ],
    totalDataCodewords: 2071,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [14, 46],
      [21, 47]
    ],
    totalDataCodewords: 1631,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [29, 24],
      [19, 25]
    ],
    totalDataCodewords: 1171,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [11, 15],
      [46, 16]
    ],
    totalDataCodewords: 901,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [13, 115],
      [6, 116]
    ],
    totalDataCodewords: 2191,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [14, 46],
      [23, 47]
    ],
    totalDataCodewords: 1725,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [44, 24],
      [7, 25]
    ],
    totalDataCodewords: 1231,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [59, 16],
      [1, 17]
    ],
    totalDataCodewords: 961,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [12, 121],
      [7, 122]
    ],
    totalDataCodewords: 2306,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [12, 47],
      [26, 48]
    ],
    totalDataCodewords: 1812,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [39, 24],
      [14, 25]
    ],
    totalDataCodewords: 1286,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [22, 15],
      [41, 16]
    ],
    totalDataCodewords: 986,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [6, 121],
      [14, 122]
    ],
    totalDataCodewords: 2434,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [6, 47],
      [34, 48]
    ],
    totalDataCodewords: 1914,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [46, 24],
      [10, 25]
    ],
    totalDataCodewords: 1354,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [2, 15],
      [64, 16]
    ],
    totalDataCodewords: 1054,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [17, 122],
      [4, 123]
    ],
    totalDataCodewords: 2566,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [29, 46],
      [14, 47]
    ],
    totalDataCodewords: 1992,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [49, 24],
      [10, 25]
    ],
    totalDataCodewords: 1426,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [24, 15],
      [46, 16]
    ],
    totalDataCodewords: 1096,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [4, 122],
      [18, 123]
    ],
    totalDataCodewords: 2702,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [13, 46],
      [32, 47]
    ],
    totalDataCodewords: 2102,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [48, 24],
      [14, 25]
    ],
    totalDataCodewords: 1502,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [42, 15],
      [32, 16]
    ],
    totalDataCodewords: 1142,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [20, 117],
      [4, 118]
    ],
    totalDataCodewords: 2812,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [40, 47],
      [7, 48]
    ],
    totalDataCodewords: 2216,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [43, 24],
      [22, 25]
    ],
    totalDataCodewords: 1582,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [10, 15],
      [67, 16]
    ],
    totalDataCodewords: 1222,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [19, 118],
      [6, 119]
    ],
    totalDataCodewords: 2956,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [18, 47],
      [31, 48]
    ],
    totalDataCodewords: 2334,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [34, 24],
      [34, 25]
    ],
    totalDataCodewords: 1666,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [20, 15],
      [61, 16]
    ],
    totalDataCodewords: 1276,
    errorCodewordsPerBlock: 30
  }
}];

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/utils/get-version.js
function getVersion(dataCodewordsCount, errorCorrectionLevel) {
  let x7 = 0, y2 = VersionsCodewordsInformation.length - 1, version = Math.floor(VersionsCodewordsInformation.length / 2);
  do {
    if (dataCodewordsCount < VersionsCodewordsInformation[version][errorCorrectionLevel].totalDataCodewords) {
      y2 = version;
    } else {
      x7 = version;
    }
    version = x7 + Math.floor((y2 - x7) / 2);
  } while (y2 - x7 > 1);
  if (dataCodewordsCount <= VersionsCodewordsInformation[x7][errorCorrectionLevel].totalDataCodewords) {
    return version + 1;
  }
  return y2 + 1;
}

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/encoders/iso-encoder.js
var IsoEncoder = class {
  getEncodingResult(inputString, errorCorrectionLevel) {
    let modes = getModes(inputString), dataCodewordsCount = getDataCodewordsCount(modes), version = getVersion(dataCodewordsCount, errorCorrectionLevel), dataString = getDataString(modes, version);
    return new EncodingResult(dataString, version);
  }
};

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/encoders/utf8-encoder.js
var BYTE3 = "byte";
var Utf8Encoder = class {
  constructor() {
    this.initProperties();
    this.mode = DataModeInstances[this.encodingMode];
  }
  initProperties() {
    extend10(this, {
      encodingMode: BYTE3,
      utfBOM: "111011111011101110111111",
      initialModeCountStringLength: 20,
      ranges: [128, 2048, 65536, 2097152, 67108864]
    });
  }
  getEncodingResult(inputString, errorCorrectionLevel) {
    let data = this.encode(inputString), dataCodewordsCount = this.getDataCodewordsCount(data), version = getVersion(dataCodewordsCount, errorCorrectionLevel), dataString = this.mode.getModeCountString(data.length / 8, version) + data;
    return new EncodingResult(dataString, version);
  }
  getDataCodewordsCount(data) {
    let dataLength = data.length, dataCodewordsCount = Math.ceil((this.initialModeCountStringLength + dataLength) / 8);
    return dataCodewordsCount;
  }
  encode(str) {
    let result = this.utfBOM;
    for (let i37 = 0; i37 < str.length; i37++) {
      result += this.encodeCharacter(str.charCodeAt(i37));
    }
    return result;
  }
  encodeCharacter(code) {
    let bytesCount = this.getBytesCount(code), bc = bytesCount - 1, result = "";
    if (bytesCount === 1) {
      result = toBitsString(code, 8);
    } else {
      let significantOnes = 8 - bytesCount;
      for (let i37 = 0; i37 < bc; i37++) {
        result = toBitsString(code >> i37 * 6 & 63 | 128, 8) + result;
      }
      result = (code >> bc * 6 | 255 >> significantOnes << significantOnes).toString(2) + result;
    }
    return result;
  }
  getBytesCount(code) {
    let ranges = this.ranges;
    for (let i37 = 0; i37 < ranges.length; i37++) {
      if (code < ranges[i37]) {
        return i37 + 1;
      }
    }
  }
};

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/encoding.js
var terminator = "0000";
var powersOfTwo = { "1": 0 };
var powersOfTwoResult = { "0": 1 };
var irregularAlignmentPatternsStartDistance = {
  15: 20,
  16: 20,
  18: 24,
  19: 24,
  22: 20,
  24: 22,
  26: 24,
  28: 20,
  30: 20,
  31: 24,
  32: 28,
  33: 24,
  36: 18,
  37: 22,
  39: 20,
  40: 24
};
var finderPattern = [1, 0, 1, 1, 1];
var alignmentPattern = [1, 0, 1];
var errorCorrectionPatterns = { L: "01", M: "00", Q: "11", H: "10" };
var formatMaskPattern = "101010000010010";
var formatGeneratorPolynomial = "10100110111";
var versionGeneratorPolynomial = "1111100100101";
var paddingCodewords = ["11101100", "00010001"];
var finderPatternValue = 93;
var maskPatternConditions = [
  (row, column) => {
    return (row + column) % 2 === 0;
  },
  (row, column) => {
    return row % 2 === 0;
  },
  (row, column) => {
    return column % 3 === 0;
  },
  (row, column) => {
    return (row + column) % 3 === 0;
  },
  (row, column) => {
    return (Math.floor(row / 2) + Math.floor(column / 3)) % 2 === 0;
  },
  (row, column) => {
    return row * column % 2 + row * column % 3 === 0;
  },
  (row, column) => {
    return (row * column % 2 + row * column % 3) % 2 === 0;
  },
  (row, column) => {
    return ((row + column) % 2 + row * column % 3) % 2 === 0;
  }
];
var generatorPolynomials = [[1, 0], [1, 25, 0]];
function fillFunctionCell(matrices, bit, x7, y2) {
  for (let i37 = 0; i37 < matrices.length; i37++) {
    matrices[i37][x7][y2] = bit;
  }
}
function fillDataCell(matrices, bit, x7, y2) {
  for (let i37 = 0; i37 < maskPatternConditions.length; i37++) {
    matrices[i37][x7][y2] = maskPatternConditions[i37](x7, y2) ? bit ^ 1 : parseInt(bit, 10);
  }
}
function fillData(matrices, blocks) {
  let cellVisitor = new FreeCellVisitor(matrices[0]), block, codewordIdx, cell;
  for (let blockIdx = 0; blockIdx < blocks.length; blockIdx++) {
    block = blocks[blockIdx];
    codewordIdx = 0;
    while (block.length > 0) {
      for (let i37 = 0; i37 < block.length; i37++) {
        for (let j = 0; j < 8; j++) {
          cell = cellVisitor.getNextCell();
          fillDataCell(matrices, block[i37][codewordIdx].charAt(j), cell.row, cell.column);
        }
      }
      codewordIdx++;
      while (block[0] && codewordIdx === block[0].length) {
        block.splice(0, 1);
      }
    }
  }
  while (cell = cellVisitor.getNextRemainderCell()) {
    fillDataCell(matrices, 0, cell.row, cell.column);
  }
}
function padDataString(initialDataString, totalDataCodewords) {
  let dataBitsCount = totalDataCodewords * 8, terminatorIndex = 0, paddingCodewordIndex = 0;
  let dataString = initialDataString;
  while (dataString.length < dataBitsCount && terminatorIndex < terminator.length) {
    dataString += terminator.charAt(terminatorIndex++);
  }
  if (dataString.length % 8 !== 0) {
    dataString += new Array(9 - dataString.length % 8).join("0");
  }
  while (dataString.length < dataBitsCount) {
    dataString += paddingCodewords[paddingCodewordIndex];
    paddingCodewordIndex ^= 1;
  }
  return dataString;
}
function generatePowersOfTwo() {
  let result;
  let power;
  for (power = 1; power < 255; power++) {
    result = powersOfTwoResult[power - 1] * 2;
    if (result > 255) {
      result = result ^ 285;
    }
    powersOfTwoResult[power] = result;
    powersOfTwo[result] = power;
  }
  result = powersOfTwoResult[power - 1] * 2 ^ 285;
  powersOfTwoResult[power] = result;
  powersOfTwoResult[-1] = 0;
}
function xorPolynomials(x7, y2) {
  let result = [], idx = x7.length - 2;
  for (let i37 = idx; i37 >= 0; i37--) {
    result[i37] = x7[i37] ^ y2[i37];
  }
  return result;
}
function multiplyPolynomials(x7, y2) {
  let result = [];
  for (let i37 = 0; i37 < x7.length; i37++) {
    for (let j = 0; j < y2.length; j++) {
      if (result[i37 + j] === void 0) {
        result[i37 + j] = (x7[i37] + (y2[j] >= 0 ? y2[j] : 0)) % 255;
      } else {
        result[i37 + j] = powersOfTwo[powersOfTwoResult[result[i37 + j]] ^ powersOfTwoResult[(x7[i37] + y2[j]) % 255]];
      }
    }
  }
  return result;
}
function generateGeneratorPolynomials() {
  let maxErrorCorrectionCodeWordsCount = 68;
  for (let idx = 2; idx <= maxErrorCorrectionCodeWordsCount; idx++) {
    let firstPolynomial = generatorPolynomials[idx - 1], secondPolynomial = [idx, 0];
    generatorPolynomials[idx] = multiplyPolynomials(firstPolynomial, secondPolynomial);
  }
}
generatePowersOfTwo();
generateGeneratorPolynomials();
function multiplyByConstant(polynomial, power) {
  let result = [], idx = polynomial.length - 1;
  do {
    result[idx] = powersOfTwoResult[(polynomial[idx] + power) % 255];
    idx--;
  } while (polynomial[idx] !== void 0);
  return result;
}
function generateErrorCodewords(data, errorCodewordsCount) {
  let generator = generatorPolynomials[errorCodewordsCount - 1], result = new Array(errorCodewordsCount).concat(data), generatorPolynomial = new Array(result.length - generator.length).concat(generator), steps = data.length, errorCodewords = [], divisor, idx;
  for (idx = 0; idx < steps; idx++) {
    divisor = multiplyByConstant(generatorPolynomial, powersOfTwo[result[result.length - 1]]);
    generatorPolynomial.splice(0, 1);
    result = xorPolynomials(divisor, result);
  }
  for (idx = result.length - 1; idx >= 0; idx--) {
    errorCodewords[errorCodewordsCount - 1 - idx] = toBitsString(result[idx], 8);
  }
  return errorCodewords;
}
function getBlocks(dataStream, versionCodewordsInformation) {
  let codewordStart = 0, dataBlocks = [], errorBlocks = [], dataBlock, versionGroups = versionCodewordsInformation.groups, blockCodewordsCount, groupBlocksCount, messagePolynomial, codeword;
  for (let groupIdx = 0; groupIdx < versionGroups.length; groupIdx++) {
    groupBlocksCount = versionGroups[groupIdx][0];
    for (let blockIdx = 0; blockIdx < groupBlocksCount; blockIdx++) {
      blockCodewordsCount = versionGroups[groupIdx][1];
      dataBlock = [];
      messagePolynomial = [];
      for (let codewordIdx = 1; codewordIdx <= blockCodewordsCount; codewordIdx++) {
        codeword = dataStream.substring(codewordStart, codewordStart + 8);
        dataBlock.push(codeword);
        messagePolynomial[blockCodewordsCount - codewordIdx] = toDecimal(codeword);
        codewordStart += 8;
      }
      dataBlocks.push(dataBlock);
      errorBlocks.push(generateErrorCodewords(
        messagePolynomial,
        versionCodewordsInformation.errorCodewordsPerBlock
      ));
    }
  }
  return [dataBlocks, errorBlocks];
}
function encodeFormatInformation(format) {
  let formatNumber = toDecimal(format), encodedString, result = "";
  if (formatNumber === 0) {
    return "101010000010010";
  }
  encodedString = encodeBCH(toDecimal(format), formatGeneratorPolynomial, 15);
  for (let i37 = 0; i37 < encodedString.length; i37++) {
    result += encodedString.charAt(i37) ^ formatMaskPattern.charAt(i37);
  }
  return result;
}
function encodeBCH(value2, generatorPolynomial, codeLength) {
  let generatorNumber = toDecimal(generatorPolynomial), polynomialLength = generatorPolynomial.length - 1, valueNumber = value2 << polynomialLength, length = codeLength - polynomialLength, valueString = toBitsString(value2, length), result = dividePolynomials(valueNumber, generatorNumber);
  result = valueString + toBitsString(result, polynomialLength);
  return result;
}
function dividePolynomials(numberX, numberY) {
  let yLength = numberY.toString(2).length, xLength = numberX.toString(2).length;
  let x7 = numberX;
  do {
    x7 ^= numberY << xLength - yLength;
    xLength = x7.toString(2).length;
  } while (xLength >= yLength);
  return x7;
}
function getNumberAt(str, idx) {
  return parseInt(str.charAt(idx), 10);
}
function initMatrices(version) {
  let matrices = [], modules = 17 + 4 * version;
  for (let i37 = 0; i37 < maskPatternConditions.length; i37++) {
    matrices[i37] = new Array(modules);
    for (let j = 0; j < modules; j++) {
      matrices[i37][j] = new Array(modules);
    }
  }
  return matrices;
}
function addFormatInformation(matrices, formatString) {
  let matrix = matrices[0], x7, y2, idx = 0, length = formatString.length;
  for (x7 = 0, y2 = 8; x7 <= 8; x7++) {
    if (x7 !== 6) {
      fillFunctionCell(matrices, getNumberAt(formatString, length - 1 - idx++), x7, y2);
    }
  }
  for (x7 = 8, y2 = 7; y2 >= 0; y2--) {
    if (y2 !== 6) {
      fillFunctionCell(matrices, getNumberAt(formatString, length - 1 - idx++), x7, y2);
    }
  }
  idx = 0;
  for (y2 = matrix.length - 1, x7 = 8; y2 >= matrix.length - 8; y2--) {
    fillFunctionCell(matrices, getNumberAt(formatString, length - 1 - idx++), x7, y2);
  }
  fillFunctionCell(matrices, 1, matrix.length - 8, 8);
  for (x7 = matrix.length - 7, y2 = 8; x7 < matrix.length; x7++) {
    fillFunctionCell(matrices, getNumberAt(formatString, length - 1 - idx++), x7, y2);
  }
}
function encodeVersionInformation(version) {
  return encodeBCH(version, versionGeneratorPolynomial, 18);
}
function addVersionInformation(matrices, dataString) {
  let matrix = matrices[0], modules = matrix.length, x1 = 0, y1 = modules - 11, x22 = modules - 11, y2 = 0, quotient, mod, value2;
  for (let idx = 0; idx < dataString.length; idx++) {
    quotient = Math.floor(idx / 3);
    mod = idx % 3;
    value2 = getNumberAt(dataString, dataString.length - idx - 1);
    fillFunctionCell(matrices, value2, x1 + quotient, y1 + mod);
    fillFunctionCell(matrices, value2, x22 + mod, y2 + quotient);
  }
}
function addCentricPattern(matrices, pattern, x7, y2) {
  let size = pattern.length + 2, length = pattern.length + 1, value2;
  for (let i37 = 0; i37 < pattern.length; i37++) {
    for (let j = i37; j < size - i37; j++) {
      value2 = pattern[i37];
      fillFunctionCell(matrices, value2, x7 + j, y2 + i37);
      fillFunctionCell(matrices, value2, x7 + i37, y2 + j);
      fillFunctionCell(matrices, value2, x7 + length - j, y2 + length - i37);
      fillFunctionCell(matrices, value2, x7 + length - i37, y2 + length - j);
    }
  }
}
function addFinderSeparator(matrices, direction, x7, y2) {
  let nextX = x7, nextY = y2, matrix = matrices[0];
  do {
    fillFunctionCell(matrices, 0, nextX, y2);
    fillFunctionCell(matrices, 0, x7, nextY);
    nextX += direction[0];
    nextY += direction[1];
  } while (nextX >= 0 && nextX < matrix.length);
}
function addFinderPatterns(matrices) {
  let modules = matrices[0].length;
  addCentricPattern(matrices, finderPattern, 0, 0);
  addFinderSeparator(matrices, [-1, -1], 7, 7);
  addCentricPattern(matrices, finderPattern, modules - 7, 0);
  addFinderSeparator(matrices, [1, -1], modules - 8, 7);
  addCentricPattern(matrices, finderPattern, 0, modules - 7);
  addFinderSeparator(matrices, [-1, 1], 7, modules - 8);
}
function addAlignmentPatterns(matrices, version) {
  if (version < 2) {
    return;
  }
  let matrix = matrices[0], modules = matrix.length, pointsCount = Math.floor(version / 7), points = [6], startDistance, distance, idx = 0;
  if (startDistance = irregularAlignmentPatternsStartDistance[version]) {
    distance = (modules - 13 - startDistance) / pointsCount;
  } else {
    startDistance = distance = (modules - 13) / (pointsCount + 1);
  }
  points.push(points[idx++] + startDistance);
  while (points[idx] + distance < modules) {
    points.push(points[idx++] + distance);
  }
  for (let i37 = 0; i37 < points.length; i37++) {
    for (let j = 0; j < points.length; j++) {
      if (matrix[points[i37]][points[j]] === void 0) {
        addCentricPattern(matrices, alignmentPattern, points[i37] - 2, points[j] - 2);
      }
    }
  }
}
function addTimingFunctions(matrices) {
  let row = 6, column = 6, value2 = 1, modules = matrices[0].length;
  for (let i37 = 8; i37 < modules - 8; i37++) {
    fillFunctionCell(matrices, value2, row, i37);
    fillFunctionCell(matrices, value2, i37, column);
    value2 ^= 1;
  }
}
function scoreMaskMatrixes(matrices) {
  let scores = [], previousBits = [], darkModules = [], patterns = [], adjacentSameBits = [], matrix, i37, row = 0, column = 1, modulesLength = matrices[0].length;
  for (i37 = 0; i37 < matrices.length; i37++) {
    scores[i37] = 0;
    darkModules[i37] = 0;
    adjacentSameBits[i37] = [0, 0];
    patterns[i37] = [0, 0];
    previousBits[i37] = [];
  }
  for (let rowIndex = 0; rowIndex < modulesLength; rowIndex++) {
    for (let columnIndex = 0; columnIndex < modulesLength; columnIndex++) {
      for (let matrixIndex = 0; matrixIndex < matrices.length; matrixIndex++) {
        matrix = matrices[matrixIndex];
        darkModules[matrixIndex] += parseInt(matrix[rowIndex][columnIndex], 10);
        if (previousBits[matrixIndex][row] === matrix[rowIndex][columnIndex] && rowIndex + 1 < modulesLength && columnIndex - 1 >= 0 && matrix[rowIndex + 1][columnIndex] === previousBits[matrixIndex][row] && matrix[rowIndex + 1][columnIndex - 1] === previousBits[matrixIndex][row]) {
          scores[matrixIndex] += 3;
        }
        scoreFinderPatternOccurance(matrixIndex, patterns, scores, row, matrix[rowIndex][columnIndex]);
        scoreFinderPatternOccurance(matrixIndex, patterns, scores, column, matrix[columnIndex][rowIndex]);
        scoreAdjacentSameBits(matrixIndex, scores, previousBits, matrix[rowIndex][columnIndex], adjacentSameBits, row);
        scoreAdjacentSameBits(matrixIndex, scores, previousBits, matrix[columnIndex][rowIndex], adjacentSameBits, column);
      }
    }
  }
  let total = modulesLength * modulesLength, minIdx, min4 = Number.MAX_VALUE;
  for (i37 = 0; i37 < scores.length; i37++) {
    scores[i37] += calculateDarkModulesRatioScore(darkModules[i37], total);
    if (scores[i37] < min4) {
      min4 = scores[i37];
      minIdx = i37;
    }
  }
  return minIdx;
}
function scoreFinderPatternOccurance(idx, patterns, scores, rowColumn, bit) {
  patterns[idx][rowColumn] = (patterns[idx][rowColumn] << 1 ^ bit) % 128;
  if (patterns[idx][rowColumn] === finderPatternValue) {
    scores[idx] += 40;
  }
}
function scoreAdjacentSameBits(idx, scores, previousBits, bit, adjacentBits, rowColumn) {
  if (previousBits[idx][rowColumn] === bit) {
    adjacentBits[idx][rowColumn]++;
  } else {
    previousBits[idx][rowColumn] = bit;
    if (adjacentBits[idx][rowColumn] >= 5) {
      scores[idx] += 3 + adjacentBits[idx][rowColumn] - 5;
    }
    adjacentBits[idx][rowColumn] = 1;
  }
}
function calculateDarkModulesRatioScore(darkModules, total) {
  let percent = Math.floor(darkModules / total * 100), mod5 = percent % 5, previous = Math.abs(percent - mod5 - 50), next = Math.abs(percent + 5 - mod5 - 50), score = 10 * Math.min(previous / 5, next / 5);
  return score;
}
function createQRCodeDataEncoder(encoding) {
  if (encoding && encoding.toLowerCase().indexOf("utf_8") >= 0) {
    return new Utf8Encoder();
  }
  return new IsoEncoder();
}
function encodeData(inputString, errorCorrectionLevel, encoding) {
  let encoder = createQRCodeDataEncoder(encoding), encodingResult = encoder.getEncodingResult(inputString, errorCorrectionLevel), version = encodingResult.version, versionInformation = VersionsCodewordsInformation[version - 1][errorCorrectionLevel], dataString = padDataString(encodingResult.dataString, versionInformation.totalDataCodewords), blocks = getBlocks(dataString, versionInformation), matrices = initMatrices(version);
  addFinderPatterns(matrices);
  addAlignmentPatterns(matrices, version);
  addTimingFunctions(matrices);
  if (version >= 7) {
    addVersionInformation(matrices, toBitsString(0, 18));
  }
  addFormatInformation(matrices, toBitsString(0, 15));
  fillData(matrices, blocks);
  let minIdx = scoreMaskMatrixes(matrices), optimalMatrix = matrices[minIdx];
  if (version >= 7) {
    addVersionInformation([optimalMatrix], encodeVersionInformation(version));
  }
  let formatString = errorCorrectionPatterns[errorCorrectionLevel] + toBitsString(minIdx, 3);
  addFormatInformation([optimalMatrix], encodeFormatInformation(formatString));
  return optimalMatrix;
}

// node_modules/@progress/kendo-charts/dist/es/qrcode/qrcode.js
var round2 = Math.round;
var crossPattern = [[0, 1], [1, 1], [1, 2], [2, 2], [2, 1], [3, 1], [3, 0], [2, 0], [2, -1], [1, -1], [1, 0]];
var squarePattern = [[0, 1], [1, 1], [1, 0]];
var QRCodeDefaults = {
  DEFAULT_SIZE: 200,
  QUIET_ZONE_LENGTH: 4,
  DEFAULT_ERROR_CORRECTION_LEVEL: "L",
  DEFAULT_BACKGROUND: "#fff",
  DEFAULT_DARK_MODULE_COLOR: "#000",
  MIN_BASE_UNIT_SIZE: 1,
  DEFAULT_LOGO_SIZE: 7
};
var QRCode = class {
  constructor(element, options, errorHandler = defaultErrorHandler) {
    this.options = deepExtend({}, this.options, options);
    this.element = element;
    this.wrapper = this.element;
    this.onError = errorHandler;
    this._initElement();
    this._initSurface();
    this.setOptions(options);
  }
  destroy() {
    this._destroySurface();
  }
  _initElement() {
    addClass(this.element, "k-qrcode");
  }
  _initSurface() {
    const { options, surface } = this;
    if (!surface || surface.options.type !== options.renderAs) {
      this._destroySurface();
      this._initSurfaceElement();
      this.surface = this._createSurface();
    }
  }
  _createSurface() {
    return drawing_exports.Surface.create(this.surfaceElement, {
      type: this.options.renderAs
    });
  }
  _destroySurface() {
    if (this.surface) {
      this.surface.destroy();
      this.surface = null;
      this._destroySurfaceElement();
    }
  }
  _initSurfaceElement() {
    if (!this.surfaceElement) {
      this.surfaceElement = document.createElement("div");
      this.surfaceElement.style.position = "relative";
      this.element.appendChild(this.surfaceElement);
    }
  }
  _destroySurfaceElement() {
    if (this.surfaceElement && this.surfaceElement.parentNode) {
      this.surfaceElement.parentNode.removeChild(this.surfaceElement);
      this.surfaceElement = null;
    }
  }
  redraw() {
    let size = this._getSize();
    this.surface.clear();
    this.surface.setSize({
      width: size,
      height: size
    });
    this.createVisual();
    this.surface.draw(this.visual);
  }
  getSize() {
    const element = this.element;
    const elementWidth = element.clientWidth;
    const elementHeight = element.clientHeight;
    const size = { width: 0, height: 0 };
    if (elementWidth > 0) {
      size.width = elementWidth;
    }
    if (elementHeight) {
      size.height = elementHeight;
    }
    return size;
  }
  _resize() {
    this.redraw();
  }
  createVisual() {
    this.visual = this._render();
  }
  exportVisual() {
    return this._render();
  }
  _render() {
    let value2 = this._value, baseUnit, border = this.options.border || {}, padding = this.options.padding || 0, borderWidth = border.width || 0, quietZoneSize, matrix, size, dataSize, contentSize;
    border.width = borderWidth;
    let visual = new drawing_exports.Group();
    try {
      if (value2) {
        matrix = encodeData(value2, this.options.errorCorrection, this.options.encoding);
        size = this._getSize();
        contentSize = size - 2 * (borderWidth + padding);
        baseUnit = this._calculateBaseUnit(contentSize, matrix.length);
        dataSize = matrix.length * baseUnit;
        quietZoneSize = borderWidth + padding + (contentSize - dataSize) / 2;
        visual.append(this._renderBackground(size, border));
        visual.append(this._renderMatrix(matrix, baseUnit, quietZoneSize));
        if (this._hasCustomLogo()) {
          visual.append(this._renderLogo(size, baseUnit));
        } else if (this._isSwiss()) {
          visual.append(this._renderSwissCode(size, baseUnit));
        }
      }
    } catch (error) {
      this.onError(error);
    }
    return visual;
  }
  _renderLogo(qrSize, baseUnit) {
    let image;
    let imageRect;
    let center = round2(qrSize / 2);
    let logoSize = this._getLogoSize(baseUnit * QRCodeDefaults.DEFAULT_LOGO_SIZE);
    let logoUrl = this.options.overlay.imageUrl;
    let position = {
      x: center - logoSize.width / 2,
      y: center - logoSize.height / 2
    };
    imageRect = new geometry_exports.Rect(
      new geometry_exports.Point(position.x, position.y),
      new geometry_exports.Size(logoSize.width, logoSize.height)
    );
    image = new drawing_exports.Image(logoUrl, imageRect);
    return image;
  }
  _renderSwissCode(qrSize, baseUnit) {
    let logoSize = this._getLogoSize(baseUnit * QRCodeDefaults.DEFAULT_LOGO_SIZE);
    logoSize = Math.max(logoSize.width, logoSize.height);
    let crossSize = logoSize / 4;
    let crossOffset = crossSize / 2;
    let center = qrSize / 2;
    let start = {};
    let visual = new drawing_exports.Group();
    start.x = start.y = Math.ceil(center - baseUnit - logoSize / 2);
    visual.append(this._renderShape(start, Math.ceil(logoSize + baseUnit * 2), squarePattern, "#fff"));
    start.x = start.y = center - logoSize / 2;
    visual.append(this._renderShape(start, logoSize, squarePattern, this.options.color));
    start.x = center + crossOffset - logoSize / 2;
    start.y = center + crossOffset + crossSize - logoSize / 2;
    visual.append(this._renderShape(start, crossSize, crossPattern, "#fff"));
    return visual;
  }
  _renderShape(start, step, pattern, color) {
    let path = new drawing_exports.MultiPath({
      fill: {
        color
      },
      stroke: null
    });
    path.moveTo(start.x, start.y);
    for (let i37 = 0; i37 < pattern.length; i37++) {
      path.lineTo(start.x + step * pattern[i37][0], start.y + step * pattern[i37][1]);
    }
    path.close();
    return path;
  }
  _getSize() {
    let size;
    if (this.options.size) {
      size = parseInt(this.options.size, 10);
    } else {
      const element = this.element;
      const elementSize2 = surfaceSize(element, this.options.renderAs);
      const min4 = Math.min(elementSize2.width, elementSize2.height);
      if (min4 > 0) {
        size = min4;
      } else {
        size = QRCodeDefaults.DEFAULT_SIZE;
      }
    }
    return size;
  }
  _calculateBaseUnit(size, matrixSize) {
    let baseUnit = Math.floor(size / matrixSize);
    if (baseUnit < QRCodeDefaults.MIN_BASE_UNIT_SIZE) {
      const minSize = Math.ceil(matrixSize * QRCodeDefaults.MIN_BASE_UNIT_SIZE);
      this.onError(new Error(
        `Insufficient size for QR Code: the current size is ${size}px and the minimum size is ${minSize}px.`
      ));
    } else if (baseUnit * matrixSize >= size && baseUnit - 1 >= QRCodeDefaults.MIN_BASE_UNIT_SIZE) {
      baseUnit--;
    }
    return baseUnit;
  }
  _renderMatrix(matrix, baseUnit, quietZoneSize) {
    let path = new drawing_exports.MultiPath({
      fill: {
        color: this.options.color
      },
      stroke: null
    });
    for (let row = 0; row < matrix.length; row++) {
      let y2 = quietZoneSize + row * baseUnit;
      let column = 0;
      while (column < matrix.length) {
        while (matrix[row][column] === 0 && column < matrix.length) {
          column++;
        }
        if (column < matrix.length) {
          let x7 = column;
          while (matrix[row][column] === 1) {
            column++;
          }
          let x1 = round2(quietZoneSize + x7 * baseUnit);
          let y1 = round2(y2);
          let x22 = round2(quietZoneSize + column * baseUnit);
          let y22 = round2(y2 + baseUnit);
          path.moveTo(x1, y1).lineTo(x1, y22).lineTo(x22, y22).lineTo(x22, y1).close();
        }
      }
    }
    return path;
  }
  _renderBackground(size, border) {
    const box = new box_default(0, 0, size, size).unpad(border.width / 2);
    const background = drawing_exports.Path.fromRect(box.toRect(), {
      fill: {
        color: this.options.background
      },
      stroke: {
        color: border.color,
        width: border.width
      }
    });
    return background;
  }
  setOptions(options) {
    let newOptions = options || {};
    this.options = extend10(this.options, newOptions);
    if (options.value !== void 0) {
      this._value = String(this.options.value);
    }
    this._initSurface();
    this.redraw();
  }
  value(value2) {
    if (value2 === void 0) {
      return this._value;
    }
    this._value = String(value2);
    this.redraw();
  }
  _hasCustomLogo() {
    return Boolean(this.options.overlay.imageUrl);
  }
  _isSwiss() {
    return this.options.overlay.type === "swiss";
  }
  _getLogoSize(defautLogoSize) {
    let width = this.options.overlay.width;
    let height = this.options.overlay.height;
    if (!width && !height) {
      width = height = defautLogoSize;
    } else if (width && !height) {
      height = width;
    } else if (!width && height) {
      width = height;
    }
    return {
      width,
      height
    };
  }
};
setDefaultOptions(QRCode, {
  name: "QRCode",
  renderAs: "svg",
  encoding: "ISO_8859_1",
  value: "",
  errorCorrection: QRCodeDefaults.DEFAULT_ERROR_CORRECTION_LEVEL,
  background: QRCodeDefaults.DEFAULT_BACKGROUND,
  color: QRCodeDefaults.DEFAULT_DARK_MODULE_COLOR,
  size: "",
  padding: 0,
  border: {
    color: "",
    width: 0
  },
  overlay: {
    type: "image",
    imageUrl: "",
    width: 0,
    height: 0
  }
});

// node_modules/@progress/kendo-charts/dist/es/map/datums.js
var WGS84 = {
  a: 6378137,
  // Semi-major radius
  b: 6356752314245179e-9,
  // Semi-minor radius
  f: 0.0033528106647474805,
  // Flattening
  e: 0.08181919084262149
  // Eccentricity
};
var datums = {
  WGS84
};

// node_modules/@progress/kendo-charts/dist/es/map/location.js
function toSquare(value2) {
  return value2 * value2;
}
var math = Math;
var abs = math.abs;
var atan = math.atan;
var atan2 = math.atan2;
var cos = math.cos;
var sin = math.sin;
var tan = math.tan;
var Location = class _Location {
  constructor(lat, lng) {
    this.initProperties();
    if (arguments.length === 1) {
      this.lat = lat[0];
      this.lng = lat[1];
    } else {
      this.lat = lat;
      this.lng = lng;
    }
  }
  initProperties() {
    deepExtend(this, {
      DISTANCE_ITERATIONS: 100,
      DISTANCE_CONVERGENCE: 1e-12,
      DISTANCE_PRECISION: 2,
      FORMAT: "{0:N6}{1:N6}"
    });
  }
  toArray() {
    return [
      this.lat,
      this.lng
    ];
  }
  equals(loc) {
    return loc && loc.lat === this.lat && loc.lng === this.lng;
  }
  clone() {
    return new _Location(this.lat, this.lng);
  }
  round(precision) {
    this.lng = round(this.lng, precision);
    this.lat = round(this.lat, precision);
    return this;
  }
  wrap() {
    this.lng = this.lng % 180;
    this.lat = this.lat % 90;
    return this;
  }
  distanceTo(dest, datum) {
    return this.greatCircleTo(dest, datum).distance;
  }
  destination(distance, initialBearing, initialDatum) {
    let bearing = rad(initialBearing);
    let datum = initialDatum || datums.WGS84;
    let fromLat = rad(this.lat);
    let fromLng = rad(this.lng);
    let dToR = distance / datum.a;
    let lat = math.asin(sin(fromLat) * cos(dToR) + cos(fromLat) * sin(dToR) * cos(bearing));
    let lng = fromLng + atan2(sin(bearing) * sin(dToR) * cos(fromLat), cos(dToR) - sin(fromLat) * sin(lat));
    return new _Location(deg(lat), deg(lng));
  }
  greatCircleTo(initialDest, initialDatum) {
    let dest = _Location.create(dest);
    let datum = initialDatum || datums.WGS84;
    if (!dest || this.clone().round(8).equals(dest.clone().round(8))) {
      return {
        distance: 0,
        azimuthFrom: 0,
        azimuthTo: 0
      };
    }
    let a50 = datum.a;
    let b2 = datum.b;
    let f5 = datum.f;
    let L2 = rad(dest.lng - this.lng);
    let U1 = atan((1 - f5) * tan(rad(this.lat)));
    let sinU1 = sin(U1);
    let cosU1 = cos(U1);
    let U2 = atan((1 - f5) * tan(rad(dest.lat)));
    let sinU2 = sin(U2);
    let cosU2 = cos(U2);
    let lambda = L2;
    let prevLambda;
    let i37 = this.DISTANCE_ITERATIONS;
    let converged = false;
    let sinLambda;
    let cosLambda;
    let sino;
    let cosA2;
    let coso;
    let cos2om;
    let sigma;
    while (!converged && i37-- > 0) {
      sinLambda = sin(lambda);
      cosLambda = cos(lambda);
      sino = math.sqrt(toSquare(cosU2 * sinLambda) + toSquare(cosU1 * sinU2 - sinU1 * cosU2 * cosLambda));
      coso = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda;
      sigma = atan2(sino, coso);
      let sinA = cosU1 * cosU2 * sinLambda / sino;
      cosA2 = 1 - toSquare(sinA);
      cos2om = 0;
      if (cosA2 !== 0) {
        cos2om = coso - 2 * sinU1 * sinU2 / cosA2;
      }
      prevLambda = lambda;
      let C2 = f5 / 16 * cosA2 * (4 + f5 * (4 - 3 * cosA2));
      lambda = L2 + (1 - C2) * f5 * sinA * (sigma + C2 * sino * (cos2om + C2 * coso * (-1 + 2 * toSquare(cos2om))));
      converged = abs(lambda - prevLambda) <= this.DISTANCE_CONVERGENCE;
    }
    let u22 = cosA2 * (toSquare(a50) - toSquare(b2)) / toSquare(b2);
    let A2 = 1 + u22 / 16384 * (4096 + u22 * (-768 + u22 * (320 - 175 * u22)));
    let B = u22 / 1024 * (256 + u22 * (-128 + u22 * (74 - 47 * u22)));
    let deltao = B * sino * (cos2om + B / 4 * (coso * (-1 + 2 * toSquare(cos2om)) - B / 6 * cos2om * (-3 + 4 * toSquare(sino)) * (-3 + 4 * toSquare(cos2om))));
    let azimuthFrom = atan2(cosU2 * sinLambda, cosU1 * sinU2 - sinU1 * cosU2 * cosLambda);
    let azimuthTo = atan2(cosU1 * sinLambda, -sinU1 * cosU2 + cosU1 * sinU2 * cosLambda);
    return {
      distance: round(b2 * A2 * (sigma - deltao), this.DISTANCE_PRECISION),
      azimuthFrom: deg(azimuthFrom),
      azimuthTo: deg(azimuthTo)
    };
  }
  // IE < 9 doesn't allow to override toString on definition
  toString() {
    return String(this.lat) + "," + String(this.lng);
  }
  static fromLngLat(lngAndLat) {
    return new _Location(lngAndLat[1], lngAndLat[0]);
  }
  static fromLatLng(lngAndLat) {
    return new _Location(lngAndLat[0], lngAndLat[1]);
  }
  static create(a50, b2) {
    if (defined(a50)) {
      if (a50 instanceof _Location) {
        return a50.clone();
      } else if (arguments.length === 1 && a50.length === 2) {
        return _Location.fromLatLng(a50);
      }
      return new _Location(a50, b2);
    }
  }
};

// node_modules/@progress/kendo-charts/dist/es/map/crs.js
var math2 = Math;
var atan3 = math2.atan;
var exp = math2.exp;
var pow = math2.pow;
var sin2 = math2.sin;
var log2 = math2.log;
var tan2 = math2.tan;
var Point4 = geometry_exports.Point;
var PI = math2.PI;
var PI_DIV_2 = PI / 2;
var PI_DIV_4 = PI / 4;
var DEG_TO_RAD = PI / 180;
var WGS842 = datums.WGS84;
var Mercator = class {
  constructor(options) {
    this.initProperties();
    this._initOptions(options);
  }
  _initOptions(options) {
    this.options = deepExtend({}, this.options, options);
  }
  initProperties() {
    deepExtend(this, {
      MAX_LNG: 180,
      MAX_LAT: 85.0840590501,
      INVERSE_ITERATIONS: 15,
      INVERSE_CONVERGENCE: 1e-12
    });
  }
  forward(loc, clamp) {
    let proj = this, options = proj.options, datum = options.datum, r28 = datum.a, lng0 = options.centralMeridian, lat = limitValue(loc.lat, -proj.MAX_LAT, proj.MAX_LAT), lng = clamp ? limitValue(loc.lng, -proj.MAX_LNG, proj.MAX_LNG) : loc.lng, x7 = rad(lng - lng0) * r28, y2 = proj._projectLat(lat);
    return new Point4(x7, y2);
  }
  _projectLat(lat) {
    let datum = this.options.datum, ecc = datum.e, r28 = datum.a, y2 = rad(lat), ts = tan2(PI_DIV_4 + y2 / 2), con = ecc * sin2(y2), p9 = pow((1 - con) / (1 + con), ecc / 2);
    return r28 * log2(ts * p9);
  }
  inverse(point, clamp) {
    let proj = this, options = proj.options, datum = options.datum, r28 = datum.a, lng0 = options.centralMeridian, lng = point.x / (DEG_TO_RAD * r28) + lng0, lat = limitValue(proj._inverseY(point.y), -proj.MAX_LAT, proj.MAX_LAT);
    if (clamp) {
      lng = limitValue(lng, -proj.MAX_LNG, proj.MAX_LNG);
    }
    return new Location(lat, lng);
  }
  _inverseY(y2) {
    let proj = this, datum = proj.options.datum, r28 = datum.a, ecc = datum.e, ecch = ecc / 2, ts = exp(-y2 / r28), phi = PI_DIV_2 - 2 * atan3(ts), i37;
    for (i37 = 0; i37 <= proj.INVERSE_ITERATIONS; i37++) {
      let con = ecc * sin2(phi), p9 = pow((1 - con) / (1 + con), ecch), dphi = PI_DIV_2 - 2 * atan3(ts * p9) - phi;
      phi += dphi;
      if (math2.abs(dphi) <= proj.INVERSE_CONVERGENCE) {
        break;
      }
    }
    return deg(phi);
  }
};
setDefaultOptions(Mercator, {
  centralMeridian: 0,
  datum: WGS842
});
var SphericalMercator = class extends Mercator {
  initProperties() {
    super.initProperties();
    deepExtend(this, {
      MAX_LAT: 85.0511287798
    });
  }
  _projectLat(lat) {
    let r28 = this.options.datum.a, y2 = rad(lat), ts = tan2(PI_DIV_4 + y2 / 2);
    return r28 * log2(ts);
  }
  _inverseY(y2) {
    let r28 = this.options.datum.a, ts = exp(-y2 / r28);
    return deg(PI_DIV_2 - 2 * atan3(ts));
  }
};
var EPSG3857 = class {
  constructor() {
    let crs = this, proj = crs._proj = new SphericalMercator();
    let c9 = this.c = 2 * PI * proj.options.datum.a;
    this._tm = geometry_exports.transform().translate(0.5, 0.5).scale(1 / c9, -1 / c9);
    this._itm = geometry_exports.transform().scale(c9, -c9).translate(-0.5, -0.5);
  }
  // Location <-> Point (screen coordinates for a given scale)
  toPoint(loc, scale, clamp) {
    let point = this._proj.forward(loc, clamp);
    return point.transform(this._tm).scale(scale || 1);
  }
  toLocation(point, scale, clamp) {
    let newPoint = point.clone().scale(1 / (scale || 1)).transform(this._itm);
    return this._proj.inverse(newPoint, clamp);
  }
};

// node_modules/@progress/kendo-charts/dist/es/map/utils.js
var proxy = (method, context) => {
  return method.bind(context);
};
var convertToHtml = (html) => {
  const div = document.createElement("div");
  div.innerHTML = html;
  return div.firstChild;
};
var appendHtml = (html, element) => {
  const div = document.createElement("div");
  div.innerHTML = html;
  while (div.childNodes.length > 0) {
    element.appendChild(div.childNodes[0]);
  }
};
var removeChildren = (element) => {
  while (element.firstChild) {
    element.removeChild(element.firstChild);
  }
};
var prepend = (element, originElement) => {
  originElement.insertBefore(element, originElement.firstChild);
};
var wrapInner = (parent, wrapper) => {
  parent.appendChild(wrapper);
  while (parent.firstChild !== wrapper) {
    wrapper.appendChild(parent.firstChild);
  }
};
var toHyphens = (str) => {
  const result = str.replace(/([a-z][A-Z])/g, function(g2) {
    return g2.charAt(0) + "-" + g2.charAt(1).toLowerCase();
  });
  return result;
};
var toPixels = (value2) => {
  let result;
  if (value2 && String(value2).endsWith("px")) {
    result = value2;
  } else {
    result = String(value2) + "px";
  }
  return result;
};
var hasNativeScrolling = (userAgent) => {
  const { mobileOS } = getSupportedFeatures(userAgent);
  return mobileOS.ios || mobileOS.android;
};
var setDefaultEvents = (type, events) => {
  const proto = type.prototype;
  if (proto.events) {
    events.forEach((event) => {
      if (proto.events.indexOf(event) < 0) {
        proto.events.push(event);
      }
    });
  } else {
    proto.events = events;
  }
};
var wheelDeltaY = (e41) => {
  const deltaY = e41.wheelDeltaY;
  let delta;
  if (e41.wheelDelta) {
    if (deltaY === void 0 || deltaY) {
      delta = e41.wheelDelta;
    }
  } else if (e41.detail && e41.axis === e41.VERTICAL_AXIS) {
    delta = -e41.detail * 10;
  }
  return delta;
};
var renderPos = (pos) => {
  let result = [];
  if (pos) {
    let parts = toHyphens(pos).split("-");
    for (let i37 = 0; i37 < parts.length; i37++) {
      result.push("k-pos-" + parts[i37]);
    }
  }
  return result.join(" ");
};

// node_modules/@progress/kendo-charts/dist/es/map/attribution.js
var Attribution = class extends Observable {
  constructor(element, options) {
    super();
    this.element = element;
    this._initOptions(options);
    this.items = [];
    addClass(this.element, "k-widget k-attribution");
  }
  _initOptions(options) {
    this.options = deepExtend({}, this.options, options);
  }
  filter(extent, zoom) {
    this._extent = extent;
    this._zoom = zoom;
    this._render();
  }
  add(item) {
    let newItem = item;
    if (defined(item)) {
      if (typeof item === "string") {
        newItem = {
          text: item
        };
      }
      this.items.push(newItem);
      this._render();
    }
  }
  remove(text) {
    let result = [];
    for (let i37 = 0; i37 < this.items.length; i37++) {
      let item = this.items[i37];
      if (item.text !== text) {
        result.push(item);
      }
    }
    this.items = result;
    this._render();
  }
  clear() {
    this.items = [];
    removeChildren(this.element);
  }
  _render() {
    let result = [];
    for (let i37 = 0; i37 < this.items.length; i37++) {
      let item = this.items[i37];
      let text = this._itemText(item);
      if (text !== "") {
        result.push(text);
      }
    }
    if (result.length > 0) {
      removeChildren(this.element);
      const html = result.join(this.options.separator);
      appendHtml(html, this.element);
      this.showElement();
    } else {
      this.hideElement();
    }
  }
  hideElement() {
    this.element.style.display = "none";
  }
  showElement() {
    this.element.style.display = "";
  }
  _itemText(item) {
    let text = "";
    let inZoomLevel = this._inZoomLevel(item.minZoom, item.maxZoom);
    let inArea = this._inArea(item.extent);
    if (inZoomLevel && inArea) {
      text += item.text;
    }
    return text;
  }
  _inZoomLevel(min4, max3) {
    let result = true;
    let newMin = valueOrDefault(min4, -Number.MAX_VALUE);
    let newMax = valueOrDefault(max3, Number.MAX_VALUE);
    result = this._zoom > newMin && this._zoom < newMax;
    return result;
  }
  _inArea(area) {
    let result = true;
    if (area) {
      result = area.contains(this._extent);
    }
    return result;
  }
};
setDefaultOptions(Attribution, {
  name: "Attribution",
  separator: "&nbsp;|&nbsp;"
});

// node_modules/@progress/kendo-charts/dist/es/map/navigator.js
var PAN = "pan";
var directionsMap = {
  up: {
    className: "k-navigator-n",
    iconClass: "k-i-caret-alt-up"
  },
  down: {
    className: "k-navigator-s",
    iconClass: "k-i-caret-alt-down"
  },
  right: {
    className: "k-navigator-e",
    iconClass: "k-i-caret-alt-right"
  },
  left: {
    className: "k-navigator-w",
    iconClass: "k-i-caret-alt-left"
  }
};
function createButton(direction, iconOptions) {
  const html = '<button type="button" class="k-button k-button-square k-rounded-full k-button-flat k-button-flat-base k-icon-button ' + directionsMap[direction].className + '" aria-label="move ' + direction + '">' + renderIcon({ icon: `caret-alt-${direction}`, iconClass: "k-button-icon", svgIcons: iconOptions.svgIcons, type: iconOptions.type }) + "</button>";
  return convertToHtml(html);
}
var Navigator2 = class extends Observable {
  constructor(element, options) {
    super();
    this.element = element;
    this._initOptions(options);
    const navigateUpButton = createButton("up", options.icons);
    const navigateRightlButton = createButton("right", options.icons);
    const navigateDownButton = createButton("down", options.icons);
    const navigateLeftButton = createButton("left", options.icons);
    this.element.appendChild(navigateUpButton);
    this.element.appendChild(navigateRightlButton);
    this.element.appendChild(navigateDownButton);
    this.element.appendChild(navigateLeftButton);
    addClass(this.element, "k-widget k-navigator");
    on(this.element, "click", ".k-button", proxy(this._click, this));
    let parentElement = this.element.parentNode.closest("[data-role]");
    this._keyroot = parentElement ? parentElement : this.element;
    this._tabindex(this._keyroot);
    this._keydownHandler = proxy(this._keydown, this);
    on(this._keyroot, "keydown", this._keydownHandler);
  }
  destroy() {
    this.dispose();
  }
  // originates from the kendo.jquery version
  dispose() {
    off(this._keyroot, "keydown", this._keydownHandler);
  }
  _tabindex(target) {
    const targetElement = target || this.wrapper || this.element;
    let element = this.element, TABINDEX = "tabindex", tabindex = targetElement.getAttribute(TABINDEX) || element.getAttribute(TABINDEX);
    element.removeAttribute(TABINDEX);
    targetElement.setAttribute(TABINDEX, !isNaN(tabindex) ? tabindex : 0);
  }
  _initOptions(options) {
    this.options = deepExtend({}, this.options, options);
  }
  _pan(x7, y2) {
    let panStep = this.options.panStep;
    this.trigger(PAN, {
      x: x7 * panStep,
      y: y2 * panStep
    });
  }
  _click(e41) {
    let x7 = 0;
    let y2 = 0;
    let button = e41.currentTarget;
    if (button.matches(".k-navigator-n")) {
      y2 = 1;
    } else if (button.matches(".k-navigator-s")) {
      y2 = -1;
    } else if (button.matches(".k-navigator-e")) {
      x7 = 1;
    } else if (button.matches(".k-navigator-w")) {
      x7 = -1;
    }
    this._pan(x7, y2);
    e41.preventDefault();
  }
  _keydown(e41) {
    switch (e41.which) {
      case keys_default.UP:
        this._pan(0, 1);
        e41.preventDefault();
        break;
      case keys_default.DOWN:
        this._pan(0, -1);
        e41.preventDefault();
        break;
      case keys_default.RIGHT:
        this._pan(1, 0);
        e41.preventDefault();
        break;
      case keys_default.LEFT:
        this._pan(-1, 0);
        e41.preventDefault();
        break;
      default:
        break;
    }
  }
};
setDefaultOptions(Navigator2, {
  name: "Navigator",
  panStep: 1
});
setDefaultEvents(Navigator2, [
  PAN
]);

// node_modules/@progress/kendo-charts/dist/es/map/zoom.js
function createButton2(direction, icon, iconOptions) {
  const html = '<button type="button" class="k-button k-button-md k-rounded-md k-button-solid k-button-solid-base k-icon-button k-zoom-' + direction + '" title="zoom-' + direction + '" aria-label="zoom-' + direction + '">' + renderIcon({ icon, iconClass: "k-button-icon", svgIcons: iconOptions.svgIcons, type: iconOptions.type }) + "</button>";
  return convertToHtml(html);
}
var PLUS = 187;
var MINUS = 189;
var FF_PLUS = 61;
var FF_MINUS = 173;
var CHANGE = "change";
var ZoomControl = class extends Observable {
  constructor(element, options, iconOptions) {
    super();
    this.element = element;
    this._initOptions(options);
    const zoomInButton = createButton2("in", "plus", iconOptions);
    const zoomOutButton = createButton2("out", "minus", iconOptions);
    this.element.appendChild(zoomInButton);
    this.element.appendChild(zoomOutButton);
    this.element.setAttribute("role", "group");
    addClass(this.element, "k-widget k-zoom-control k-button-group k-group-horizontal");
    this._clickHandler = this._click.bind(this);
    on(this.element, "click", ".k-button", this._clickHandler);
    let parentElement = this.element.parentNode.closest("[data-role]");
    this._keyroot = parentElement ? parentElement : this.element;
    this._tabindex(this._keyroot);
    this._keydownHandler = this._keydown.bind(this);
    on(this._keyroot, "keydown", this._keydownHandler);
  }
  destroy() {
    if (this.element) {
      off(this.element, "click", this._clickHandler);
    }
    if (this._keyroot) {
      off(this._keyroot, "keydown", this._keydownHandler);
    }
  }
  _tabindex(target) {
    const targetElement = target || this.wrapper || this.element;
    let element = this.element, TABINDEX = "tabindex", tabindex = targetElement.getAttribute(TABINDEX) || element.getAttribute(TABINDEX);
    element.removeAttribute(TABINDEX);
    targetElement.setAttribute(TABINDEX, !isNaN(tabindex) ? tabindex : 0);
  }
  _initOptions(options) {
    this.options = deepExtend({}, this.options, options);
  }
  _change(direction) {
    let zoomStep = this.options.zoomStep;
    this.trigger(CHANGE, { delta: direction * zoomStep });
  }
  _click(e41) {
    let button = e41.currentTarget;
    let direction = 1;
    if (hasClasses(button, "k-zoom-out")) {
      direction = -1;
    }
    this._change(direction);
    e41.preventDefault();
  }
  _keydown(e41) {
    switch (e41.which) {
      case keys_default.NUMPAD_PLUS:
      case PLUS:
      case FF_PLUS:
        this._change(1);
        break;
      case keys_default.NUMPAD_MINUS:
      case MINUS:
      case FF_MINUS:
        this._change(-1);
        break;
      default:
        break;
    }
  }
};
setDefaultOptions(ZoomControl, {
  name: "ZoomControl",
  zoomStep: 1
});
setDefaultEvents(ZoomControl, [
  CHANGE
]);

// node_modules/@progress/kendo-charts/dist/es/map/extent.js
var math3 = Math;
var max = math3.max;
var min = math3.min;
var Extent = class _Extent {
  constructor(initialNw, initialSe) {
    let nw = Location.create(initialNw);
    let se = Location.create(initialSe);
    if (nw.lng + 180 > se.lng + 180 && nw.lat + 90 < se.lat + 90) {
      this.se = nw;
      this.nw = se;
    } else {
      this.se = se;
      this.nw = nw;
    }
  }
  contains(loc) {
    let nw = this.nw, se = this.se, lng = valueOrDefault(loc.lng, loc[1]), lat = valueOrDefault(loc.lat, loc[0]);
    return loc && lng + 180 >= nw.lng + 180 && lng + 180 <= se.lng + 180 && lat + 90 >= se.lat + 90 && lat + 90 <= nw.lat + 90;
  }
  center() {
    let nw = this.nw;
    let se = this.se;
    let lng = nw.lng + (se.lng - nw.lng) / 2;
    let lat = nw.lat + (se.lat - nw.lat) / 2;
    return new Location(lat, lng);
  }
  containsAny(locs) {
    let result = false;
    for (let i37 = 0; i37 < locs.length; i37++) {
      result = result || this.contains(locs[i37]);
    }
    return result;
  }
  include(loc) {
    let nw = this.nw, se = this.se, lng = valueOrDefault(loc.lng, loc[1]), lat = valueOrDefault(loc.lat, loc[0]);
    nw.lng = min(nw.lng, lng);
    nw.lat = max(nw.lat, lat);
    se.lng = max(se.lng, lng);
    se.lat = min(se.lat, lat);
  }
  includeAll(locs) {
    for (let i37 = 0; i37 < locs.length; i37++) {
      this.include(locs[i37]);
    }
  }
  edges() {
    let nw = this.nw, se = this.se;
    return {
      nw: this.nw,
      ne: new Location(nw.lat, se.lng),
      se: this.se,
      sw: new Location(se.lat, nw.lng)
    };
  }
  toArray() {
    let nw = this.nw, se = this.se;
    return [
      nw,
      new Location(nw.lat, se.lng),
      se,
      new Location(se.lat, nw.lng)
    ];
  }
  overlaps(extent) {
    return this.containsAny(extent.toArray()) || extent.containsAny(this.toArray());
  }
  static create(a50, b2) {
    if (a50 instanceof _Extent) {
      return a50;
    } else if (a50 && b2) {
      return new _Extent(a50, b2);
    } else if (a50 && a50.length === 4 && !b2) {
      return new _Extent([
        a50[0],
        a50[1]
      ], [
        a50[2],
        a50[3]
      ]);
    }
  }
  static get World() {
    return new _Extent([90, -180], [-90, 180]);
  }
};

// node_modules/@progress/kendo-charts/dist/es/map/constants.js
var SHOW_TOOLTIP2 = "showTooltip";
var HIDE_TOOLTIP2 = "hideTooltip";
var CENTER_CHANGE = "centerChange";
var ZOOM_CHANGE = "zoomChange";
var INIT = "init";

// node_modules/@progress/kendo-charts/dist/es/map/tooltip/tooltip.js
var Tooltip2 = class {
  constructor(widgetService, options) {
    this.widgetService = widgetService;
    this.options = deepExtend({}, this.options, options);
    this.offset = { x: 0, y: 0 };
  }
  show(anchor, args) {
    if (this.location === args.location) {
      return;
    }
    this.anchor = anchor;
    this.location = args.location;
    this.widgetService.notify(
      SHOW_TOOLTIP2,
      Object.assign({ anchor: this.anchor }, args)
    );
    this.visible = true;
  }
  hide() {
    if (this.widgetService) {
      this.widgetService.notify(HIDE_TOOLTIP2);
    }
    this.visible = false;
    this.location = null;
  }
  get anchor() {
    return this._anchor;
  }
  set anchor(anchor) {
    const documentPoint = this.widgetService.widget._toDocumentCoordinates({
      x: anchor.left - this.offset.x,
      y: anchor.top - this.offset.y
    });
    this._anchor = {
      left: documentPoint.left,
      top: documentPoint.top
    };
  }
  destroy() {
    this.widgetService = null;
  }
};
setDefaultOptions(Tooltip2, {
  border: {
    width: 1
  },
  opacity: 1
});

// node_modules/@progress/kendo-charts/dist/es/map/layers/layer.js
var Layer = class {
  constructor(map2, options) {
    this.support = getSupportedFeatures();
    this._initOptions(options);
    this.map = map2;
    let element = document.createElement("div");
    addClass(element, "k-layer");
    element.style.zIndex = this.options.zIndex;
    element.style.opacity = this.options.opacity;
    this.element = element;
    map2.scrollElement.appendChild(this.element);
    this._beforeReset = this._beforeReset.bind(this);
    this._reset = this._reset.bind(this);
    this._resize = this._resize.bind(this);
    this._panEnd = this._panEnd.bind(this);
    this._activate();
    this._updateAttribution();
  }
  destroy() {
    this._deactivate();
  }
  _initOptions(options) {
    this.options = deepExtend({}, this.options, options);
  }
  show() {
    this.reset();
    this._activate();
    this._applyExtent(true);
  }
  hide() {
    this._deactivate();
    this._setVisibility(false);
  }
  reset() {
    this._beforeReset();
    this._reset();
  }
  _reset() {
    this._applyExtent();
  }
  _beforeReset() {
  }
  _resize() {
  }
  _panEnd() {
    this._applyExtent();
  }
  _applyExtent() {
    let options = this.options;
    let zoom = this.map.zoom();
    let matchMinZoom = !defined(options.minZoom) || zoom >= options.minZoom;
    let matchMaxZoom = !defined(options.maxZoom) || zoom <= options.maxZoom;
    let extent = Extent.create(options.extent);
    let inside = !extent || extent.overlaps(this.map.extent());
    this._setVisibility(matchMinZoom && matchMaxZoom && inside);
  }
  _setVisibility(visible) {
    this.element.style.display = visible ? "" : "none";
  }
  _activate() {
    let map2 = this.map;
    this._deactivate();
    map2.bind("beforeReset", this._beforeReset);
    map2.bind("reset", this._reset);
    map2.bind("resize", this._resize);
    map2.bind("panEnd", this._panEnd);
  }
  _deactivate() {
    let map2 = this.map;
    map2.unbind("beforeReset", this._beforeReset);
    map2.unbind("reset", this._reset);
    map2.unbind("resize", this._resize);
    map2.unbind("panEnd", this._panEnd);
  }
  _updateAttribution() {
    const attribution = this.map.attribution;
    if (attribution) {
      attribution.add(this.options.attribution);
    }
  }
  _readData() {
    const data = this.options.data || [];
    return data;
  }
  _hasData() {
    return this._data && this._data.length > 0;
  }
  _layerIndex() {
    const layers = this.map.layers || [];
    return layers.indexOf(this);
  }
};

// node_modules/@progress/kendo-charts/dist/es/map/layers/tile.js
var math4 = Math;
var Point5 = geometry_exports.Point;
function compileTemplate(template) {
  if (isFunction(template)) {
    return template;
  }
  return template_service_default.compile(template);
}
function roundPoint(point) {
  return new Point5(round(point.x), round(point.y));
}
function renderSize(size) {
  let newSize = size;
  if (typeof size !== "string") {
    newSize += "px";
  }
  return newSize;
}
var TileLayer = class extends Layer {
  constructor(map2, options) {
    super(map2, options);
    if (typeof this.options.subdomains === "string") {
      this.options.subdomains = this.options.subdomains.split("");
    }
    let viewType = this._viewType();
    this._view = new viewType(this.element, this.options);
  }
  destroy() {
    super.destroy();
    this._view.destroy();
    this._view = null;
  }
  _beforeReset() {
    let map2 = this.map;
    let origin = map2.locationToLayer(map2.extent().nw).round();
    this._view.viewOrigin(origin);
  }
  _reset() {
    super._reset();
    this._updateView();
    this._view.reset();
  }
  _viewType() {
    return TileView;
  }
  _activate() {
    super._activate();
    if (!this.support.mobileOS) {
      if (!this._pan) {
        this._pan = throttle(this._render.bind(this), 100);
      }
      this.map.bind("pan", this._pan);
    }
  }
  _deactivate() {
    super._deactivate();
    if (this._pan) {
      this.map.unbind("pan", this._pan);
    }
  }
  _updateView() {
    let view = this._view, map2 = this.map, extent = map2.extent(), extentToPoint = {
      nw: map2.locationToLayer(extent.nw).round(),
      se: map2.locationToLayer(extent.se).round()
    };
    view.center(map2.locationToLayer(map2.center()));
    view.extent(extentToPoint);
    view.zoom(map2.zoom());
  }
  _resize() {
    this._render();
  }
  _panEnd(e41) {
    super._panEnd(e41);
    this._render();
  }
  _render() {
    this._updateView();
    this._view.render();
  }
};
setDefaultOptions(TileLayer, {
  tileSize: 256,
  subdomains: ["a", "b", "c"],
  urlTemplate: "",
  zIndex: 1
});
var TileView = class {
  constructor(element, options) {
    this.element = element;
    this._initOptions(options);
    this.pool = new TilePool();
  }
  _initOptions(options) {
    this.options = deepExtend({}, this.options, options);
  }
  center(center) {
    this._center = center;
  }
  extent(extent) {
    this._extent = extent;
  }
  viewOrigin(origin) {
    this._viewOrigin = origin;
  }
  zoom(zoom) {
    this._zoom = zoom;
  }
  pointToTileIndex(point) {
    return new Point5(math4.floor(point.x / this.options.tileSize), math4.floor(point.y / this.options.tileSize));
  }
  tileCount() {
    let size = this.size(), firstTileIndex = this.pointToTileIndex(this._extent.nw), nw = this._extent.nw, point = this.indexToPoint(firstTileIndex).translate(-nw.x, -nw.y);
    return {
      x: math4.ceil((math4.abs(point.x) + size.width) / this.options.tileSize),
      y: math4.ceil((math4.abs(point.y) + size.height) / this.options.tileSize)
    };
  }
  size() {
    let nw = this._extent.nw, se = this._extent.se, diff = se.clone().translate(-nw.x, -nw.y);
    return {
      width: diff.x,
      height: diff.y
    };
  }
  indexToPoint(index) {
    let x7 = index.x, y2 = index.y;
    return new Point5(x7 * this.options.tileSize, y2 * this.options.tileSize);
  }
  subdomainText() {
    let subdomains = this.options.subdomains;
    return subdomains[this.subdomainIndex++ % subdomains.length];
  }
  destroy() {
    removeChildren(this.element);
    this.pool.empty();
  }
  reset() {
    this.pool.reset();
    this.subdomainIndex = 0;
    this.render();
  }
  render() {
    let size = this.tileCount(), firstTileIndex = this.pointToTileIndex(this._extent.nw), tile, x7, y2;
    for (x7 = 0; x7 < size.x; x7++) {
      for (y2 = 0; y2 < size.y; y2++) {
        tile = this.createTile({
          x: firstTileIndex.x + x7,
          y: firstTileIndex.y + y2
        });
        if (!tile.visible) {
          tile.show();
        }
      }
    }
  }
  createTile(currentIndex) {
    let options = this.tileOptions(currentIndex);
    let tile = this.pool.get(this._center, options);
    if (!tile.element.parentNode) {
      this.element.append(tile.element);
    }
    return tile;
  }
  tileOptions(currentIndex) {
    let index = this.wrapIndex(currentIndex), point = this.indexToPoint(currentIndex), origin = this._viewOrigin, offset = point.clone().translate(-origin.x, -origin.y);
    return {
      index,
      currentIndex,
      point,
      offset: roundPoint(offset),
      zoom: this._zoom,
      size: this.options.tileSize,
      subdomain: this.subdomainText(),
      urlTemplate: this.options.urlTemplate,
      errorUrlTemplate: this.options.errorUrlTemplate
    };
  }
  wrapIndex(index) {
    let boundary = math4.pow(2, this._zoom);
    return {
      x: this.wrapValue(index.x, boundary),
      y: limitValue(index.y, 0, boundary - 1)
    };
  }
  wrapValue(value2, boundary) {
    let remainder = math4.abs(value2) % boundary;
    let wrappedValue = value2;
    if (value2 >= 0) {
      wrappedValue = remainder;
    } else {
      wrappedValue = boundary - (remainder === 0 ? boundary : remainder);
    }
    return wrappedValue;
  }
};
var ImageTile = class {
  constructor(id, options) {
    this.id = id;
    this.visible = true;
    this._initOptions(options);
    this.createElement();
    this.show();
  }
  destroy() {
    const element = this.element;
    const parentNode = element ? element.parentNode : null;
    if (element) {
      if (parentNode) {
        parentNode.removeChild(element);
      }
      this.element = null;
    }
  }
  _initOptions(options) {
    this.options = deepExtend({}, this.options, options);
  }
  createElement() {
    let el = document.createElement("img");
    const size = this.options.size + "px";
    el.setAttribute("alt", "");
    el.style.position = "absolute";
    el.style.display = "block";
    el.style.width = el.style.maxWidth = size;
    el.style.height = el.style.maxHeight = size;
    this.element = el;
  }
  show() {
    let element = this.element;
    element.style.top = renderSize(this.options.offset.y);
    element.style.left = renderSize(this.options.offset.x);
    let url = this.url();
    if (url) {
      element.setAttribute("src", url);
    }
    element.style.visibility = "visible";
    this.visible = true;
  }
  hide() {
    this.element.style.visibility = "hidden";
    this.visible = false;
  }
  url() {
    let urlResult = compileTemplate(this.options.urlTemplate);
    return urlResult(this.urlOptions());
  }
  errorUrl() {
    let urlResult = compileTemplate(this.options.errorUrlTemplate);
    return urlResult(this.urlOptions());
  }
  urlOptions() {
    let options = this.options;
    return {
      zoom: options.zoom,
      subdomain: options.subdomain,
      z: options.zoom,
      x: options.index.x,
      y: options.index.y,
      s: options.subdomain,
      quadkey: options.quadkey,
      q: options.quadkey,
      culture: options.culture,
      c: options.culture
    };
  }
};
setDefaultOptions(ImageTile, {
  urlTemplate: "",
  errorUrlTemplate: ""
});
var TilePool = class {
  constructor() {
    this._items = [];
  }
  get(center, options) {
    if (this._items.length >= this.options.maxSize) {
      this._remove(center);
    }
    return this._create(options);
  }
  empty() {
    let items = this._items;
    for (let i37 = 0; i37 < items.length; i37++) {
      items[i37].destroy();
    }
    this._items = [];
  }
  reset() {
    let items = this._items;
    for (let i37 = 0; i37 < items.length; i37++) {
      items[i37].hide();
    }
  }
  _create(options) {
    let items = this._items;
    let tile;
    let id = hashKey(options.point.toString() + options.offset.toString() + options.zoom + options.urlTemplate);
    for (let i37 = 0; i37 < items.length; i37++) {
      if (items[i37].id === id) {
        tile = items[i37];
        break;
      }
    }
    if (tile) {
      tile.show();
    } else {
      tile = new ImageTile(id, options);
      this._items.push(tile);
    }
    return tile;
  }
  _remove(center) {
    let items = this._items;
    let maxDist = -1;
    let index = -1;
    for (let i37 = 0; i37 < items.length; i37++) {
      let dist = items[i37].options.point.distanceTo(center);
      if (dist > maxDist && !items[i37].visible) {
        index = i37;
        maxDist = dist;
      }
    }
    if (index !== -1) {
      items[index].destroy();
      items.splice(index, 1);
    }
  }
};
setDefaultOptions(TilePool, {
  maxSize: 100
});

// node_modules/@progress/kendo-charts/dist/es/map/scroller/draggable.js
var extend11 = Object.assign;
var CHANGE2 = "change";
var TapCapture = class extends Observable {
  constructor(element, options) {
    super();
    let that = this, domElement = element[0] || element;
    that.capture = false;
    if (domElement.addEventListener) {
      eventMap.down.split(" ").forEach(function(event) {
        domElement.addEventListener(event, proxy(that._press, that), true);
      });
      eventMap.up.split(" ").forEach(function(event) {
        domElement.addEventListener(event, proxy(that._release, that), true);
      });
    } else {
      eventMap.down.split(" ").forEach(function(event) {
        domElement.attachEvent(event, proxy(that._press, that));
      });
      eventMap.up.split(" ").forEach(function(event) {
        domElement.attachEvent(event, proxy(that._release, that));
      });
    }
    that.bind([
      "press",
      "release"
    ], options || {});
  }
  captureNext() {
    this.capture = true;
  }
  cancelCapture() {
    this.capture = false;
  }
  _press(e41) {
    let that = this;
    that.trigger("press");
    if (that.capture) {
      e41.preventDefault();
    }
  }
  _release(e41) {
    let that = this;
    that.trigger("release");
    if (that.capture) {
      e41.preventDefault();
      that.cancelCapture();
    }
  }
};
var PaneDimension = class extends Observable {
  constructor(options) {
    super();
    let that = this;
    that.forcedEnabled = false;
    extend11(that, options);
    that.scale = 1;
    if (that.horizontal) {
      that.measure = "offsetWidth";
      that.scrollSize = "scrollWidth";
      that.axis = "x";
    } else {
      that.measure = "offsetHeight";
      that.scrollSize = "scrollHeight";
      that.axis = "y";
    }
  }
  makeVirtual() {
    extend11(this, {
      virtual: true,
      forcedEnabled: true,
      _virtualMin: 0,
      _virtualMax: 0
    });
  }
  virtualSize(min4, max3) {
    if (this._virtualMin !== min4 || this._virtualMax !== max3) {
      this._virtualMin = min4;
      this._virtualMax = max3;
      this.update();
    }
  }
  outOfBounds(offset) {
    return offset > this.max || offset < this.min;
  }
  forceEnabled() {
    this.forcedEnabled = true;
  }
  getSize() {
    return this.container[this.measure];
  }
  getTotal() {
    return this.element[this.scrollSize];
  }
  rescale(scale) {
    this.scale = scale;
  }
  update(silent) {
    let that = this, total = that.virtual ? that._virtualMax : that.getTotal(), scaledTotal = total * that.scale, size = that.getSize();
    if (total === 0 && !that.forcedEnabled) {
      return;
    }
    that.max = that.virtual ? -that._virtualMin : 0;
    that.size = size;
    that.total = scaledTotal;
    that.min = Math.min(that.max, size - scaledTotal);
    that.minScale = size / total;
    that.centerOffset = (scaledTotal - size) / 2;
    that.enabled = that.forcedEnabled || scaledTotal > size;
    if (!silent) {
      that.trigger(CHANGE2, that);
    }
  }
};
var PaneDimensions = class extends Observable {
  constructor(options) {
    super();
    let that = this;
    that.x = new PaneDimension(extend11({
      horizontal: true
    }, options));
    that.y = new PaneDimension(extend11({
      horizontal: false
    }, options));
    that.container = options.container;
    that.forcedMinScale = options.minScale;
    that.maxScale = options.maxScale || 100;
    that.bind(CHANGE2, options);
  }
  rescale(newScale) {
    this.x.rescale(newScale);
    this.y.rescale(newScale);
    this.refresh();
  }
  centerCoordinates() {
    return {
      x: Math.min(0, -this.x.centerOffset),
      y: Math.min(0, -this.y.centerOffset)
    };
  }
  refresh() {
    let that = this;
    that.x.update();
    that.y.update();
    that.enabled = that.x.enabled || that.y.enabled;
    that.minScale = that.forcedMinScale || Math.min(that.x.minScale, that.y.minScale);
    that.fitScale = Math.max(that.x.minScale, that.y.minScale);
    that.trigger(CHANGE2);
  }
};
var PaneAxis = class extends Observable {
  constructor(options) {
    super();
    extend11(this, options);
  }
  outOfBounds() {
    return this.dimension.outOfBounds(this.movable[this.axis]);
  }
  dragMove(delta) {
    let that = this, dimension = that.dimension, axis = that.axis, movable = that.movable, position = movable[axis] + delta;
    if (!dimension.enabled) {
      return;
    }
    let dragDelta = delta;
    if (position < dimension.min && delta < 0 || position > dimension.max && delta > 0) {
      dragDelta *= that.resistance;
    }
    movable.translateAxis(axis, dragDelta);
    that.trigger(CHANGE2, that);
  }
};
var Pane2 = class {
  constructor(options) {
    let that = this, x7, y2, resistance, movable;
    extend11(that, {
      elastic: true
    }, options);
    resistance = that.elastic ? 0.5 : 0;
    movable = that.movable;
    that.x = x7 = new PaneAxis({
      axis: "x",
      dimension: that.dimensions.x,
      resistance,
      movable
    });
    that.y = y2 = new PaneAxis({
      axis: "y",
      dimension: that.dimensions.y,
      resistance,
      movable
    });
    that.userEvents.bind([
      "press",
      "move",
      "end",
      "gesturestart",
      "gesturechange"
    ], {
      gesturestart(e41) {
        that.gesture = e41;
        that.offset = elementOffset(that.dimensions.container);
      },
      press(e41) {
        const closestAnchor = e41.event.target.closest("a");
        if (closestAnchor && closestAnchor.matches("[data-navigate-on-press=true]")) {
          e41.sender.cancel();
        }
      },
      gesturechange(e41) {
        let previousGesture = that.gesture, previousCenter = previousGesture.center, center = e41.center, scaleDelta = e41.distance / previousGesture.distance, minScale = that.dimensions.minScale, maxScale = that.dimensions.maxScale, coordinates;
        if (movable.scale <= minScale && scaleDelta < 1) {
          scaleDelta += (1 - scaleDelta) * 0.8;
        }
        if (movable.scale * scaleDelta >= maxScale) {
          scaleDelta = maxScale / movable.scale;
        }
        let offsetX = movable.x + that.offset.left, offsetY = movable.y + that.offset.top;
        coordinates = {
          x: (offsetX - previousCenter.x) * scaleDelta + center.x - offsetX,
          y: (offsetY - previousCenter.y) * scaleDelta + center.y - offsetY
        };
        movable.scaleWith(scaleDelta);
        x7.dragMove(coordinates.x);
        y2.dragMove(coordinates.y);
        that.dimensions.rescale(movable.scale);
        that.gesture = e41;
        e41.preventDefault();
      },
      move(e41) {
        if (e41.event.target.tagName.match(/textarea|input/i)) {
          return;
        }
        if (x7.dimension.enabled || y2.dimension.enabled) {
          x7.dragMove(e41.x.delta);
          y2.dragMove(e41.y.delta);
          e41.preventDefault();
        } else {
          e41.touch.skip();
        }
      },
      end(e41) {
        e41.preventDefault();
      }
    });
  }
};
var translate = function(x7, y2, scale) {
  return "translate3d(" + x7 + "px," + y2 + "px,0) scale(" + scale + ")";
};
var Movable = class extends Observable {
  constructor(element) {
    super();
    let that = this;
    that.element = element;
    that.element.style.transformOrigin = "left top";
    that.x = 0;
    that.y = 0;
    that.scale = 1;
    const coordinates = translate(that.x, that.y, that.scale);
    that.element.style.transform = coordinates;
    that._saveCoordinates(coordinates);
  }
  translateAxis(axis, by) {
    this[axis] += by;
    this.refresh();
  }
  scaleTo(scale) {
    this.scale = scale;
    this.refresh();
  }
  scaleWith(scaleDelta) {
    this.scale *= scaleDelta;
    this.refresh();
  }
  translate(coordinates) {
    this.x += coordinates.x;
    this.y += coordinates.y;
    this.refresh();
  }
  moveAxis(axis, value2) {
    this[axis] = value2;
    this.refresh();
  }
  moveTo(coordinates) {
    extend11(this, coordinates);
    this.refresh();
  }
  refresh() {
    let that = this, x7 = that.x, y2 = that.y, newCoordinates;
    if (that.round) {
      x7 = Math.round(x7);
      y2 = Math.round(y2);
    }
    newCoordinates = translate(x7, y2, that.scale);
    if (newCoordinates !== that.coordinates) {
      that.element.style.transform = newCoordinates;
      that._saveCoordinates(newCoordinates);
      that.trigger(CHANGE2);
    }
  }
  _saveCoordinates(coordinates) {
    this.coordinates = coordinates;
  }
};

// node_modules/@progress/kendo-charts/dist/es/map/layers/shape.js
var Group8 = drawing_exports.Group;
var ShapeLayer = class extends Layer {
  constructor(map2, options) {
    super(map2, options);
    this._pan = proxy(this._pan, this);
    this.surface = drawing_exports.Surface.create(this.element, {
      width: map2.scrollElement.clientWidth,
      height: map2.scrollElement.clientHeight
    });
    this._initRoot();
    this.movable = new Movable(this.surface.element);
    this._markers = [];
    this._click = this._handler("shapeClick");
    this.surface.bind("click", this._click);
    this._mouseleave = this._handler("shapeMouseLeave");
    this.surface.bind("mouseleave", this._mouseleave);
    this.surface.bind("mouseenter", this._mouseenter.bind(this));
  }
  destroy() {
    super.destroy();
    this.surface.destroy();
  }
  _reset() {
    super._reset();
    this._translateSurface();
    this._data = this._readData();
    if (this._hasData()) {
      this._load(this._data);
    }
  }
  _initRoot() {
    this._root = new Group8();
    this.surface.draw(this._root);
  }
  _beforeReset() {
    this.surface.clear();
    this._initRoot();
  }
  _resize() {
    this.surface.size(this.map.size());
  }
  _readData() {
    const data = super._readData();
    if (data.type === "FeatureCollection") {
      return data.features;
    }
    if (data.type === "GeometryCollection") {
      return data.geometries;
    }
    return data;
  }
  _load(data) {
    this._data = data;
    this._clearMarkers();
    if (!this._loader) {
      this._loader = new GeoJsonLoader(this.map, this.options.style, this);
    }
    let container = new Group8();
    for (let i37 = 0; i37 < data.length; i37++) {
      let shape = this._loader.parse(data[i37]);
      if (shape) {
        container.append(shape);
      }
    }
    this._root.clear();
    this._root.append(container);
  }
  shapeCreated(shape) {
    let cancelled = false;
    if (shape instanceof drawing_exports.Circle && this.map.options.renderPointsAsMarkers) {
      cancelled = defined(this._createMarker(shape));
    }
    if (!cancelled) {
      let args = {
        layer: this,
        shape
      };
      cancelled = this.map.trigger("shapeCreated", args);
    }
    return cancelled;
  }
  featureCreated(e41) {
    e41.layer = this;
    this.map.trigger("shapeFeatureCreated", e41);
  }
  _createMarker(shape) {
    let marker = this.map.markers.bind({
      location: shape.location
    }, shape.dataItem);
    if (marker) {
      this._markers.push(marker);
    }
    return marker;
  }
  _clearMarkers() {
    for (let i37 = 0; i37 < this._markers.length; i37++) {
      this.map.markers.remove(this._markers[i37]);
    }
    this._markers = [];
  }
  _pan() {
    if (!this._panning) {
      this._panning = true;
      this.surface.suspendTracking();
    }
  }
  _panEnd(e41) {
    super._panEnd(e41);
    this._translateSurface();
    this.surface.resumeTracking();
    this._panning = false;
  }
  _translateSurface() {
    let map2 = this.map;
    let nw = map2.locationToView(map2.extent().nw);
    if (this.surface.translate) {
      this.surface.translate(nw);
      this.movable.moveTo({
        x: nw.x,
        y: nw.y
      });
    }
  }
  _eventArgs(e41) {
    return {
      layer: this,
      layerIndex: this._layerIndex(),
      shape: e41.element,
      shapeIndex: (this._data || []).indexOf(e41.element.dataItem),
      originalEvent: e41.originalEvent
    };
  }
  _handler(eventName) {
    return (e41) => {
      if (e41.element) {
        this.map.trigger(eventName, this._eventArgs(e41));
      }
    };
  }
  _mouseenter(e41) {
    if (!e41.element) {
      return;
    }
    this.map.trigger("shapeMouseEnter", this._eventArgs(e41));
    const shape = e41.element;
    const anchor = this._tooltipAnchor(e41);
    this.map._tooltip.show(anchor, this._tooltipContext(shape));
  }
  _tooltipContext(shape) {
    return {
      type: "shape",
      layerIndex: this._layerIndex(),
      className: "k-map-shape-tooltip",
      dataItem: shape.dataItem,
      location: shape.location
    };
  }
  _tooltipAnchor(e41) {
    const cursor = this.map.eventOffset(e41.originalEvent);
    return {
      top: cursor.y,
      left: cursor.x
    };
  }
  _activate() {
    super._activate();
    this._panHandler = proxy(this._pan, this);
    this.map.bind("pan", this.panHandler);
  }
  _deactivate() {
    super._deactivate();
    this.map.unbind("pan", this._panHandler);
  }
};
setDefaultOptions(ShapeLayer, {
  autoBind: true,
  zIndex: 100
});
var GeoJsonLoader = class {
  constructor(locator, defaultStyle, observer) {
    this.observer = observer;
    this.locator = locator;
    this.style = defaultStyle;
  }
  parse(item) {
    let root = new Group8();
    let unwrap = true;
    if (item.type === "Feature") {
      unwrap = false;
      this._loadGeometryTo(root, item.geometry, item);
      this._featureCreated(root, item);
    } else {
      this._loadGeometryTo(root, item, item);
    }
    if (unwrap && root.children.length < 2) {
      root = root.children[0];
    }
    return root;
  }
  _shapeCreated(shape) {
    let cancelled = false;
    if (this.observer && this.observer.shapeCreated) {
      cancelled = this.observer.shapeCreated(shape);
    }
    return cancelled;
  }
  _featureCreated(group, dataItem) {
    if (this.observer && this.observer.featureCreated) {
      this.observer.featureCreated({
        group,
        dataItem,
        properties: dataItem.properties
      });
    }
  }
  _loadGeometryTo(container, geometry, dataItem) {
    let coords = geometry.coordinates;
    let i37;
    let path;
    switch (geometry.type) {
      case "LineString":
        path = this._loadPolygon(container, [coords], dataItem);
        this._setLineFill(path);
        break;
      case "MultiLineString":
        for (i37 = 0; i37 < coords.length; i37++) {
          path = this._loadPolygon(container, [coords[i37]], dataItem);
          this._setLineFill(path);
        }
        break;
      case "Polygon":
        this._loadPolygon(container, coords, dataItem);
        break;
      case "MultiPolygon":
        for (i37 = 0; i37 < coords.length; i37++) {
          this._loadPolygon(container, coords[i37], dataItem);
        }
        break;
      case "Point":
        this._loadPoint(container, coords, dataItem);
        break;
      case "MultiPoint":
        for (i37 = 0; i37 < coords.length; i37++) {
          this._loadPoint(container, coords[i37], dataItem);
        }
        break;
      default:
        break;
    }
  }
  _setLineFill(path) {
    let segments = path.segments;
    if (segments.length < 4 || !segments[0].anchor().equals(last(segments).anchor())) {
      path.options.fill = null;
    }
  }
  _loadShape(container, shape) {
    if (!this._shapeCreated(shape)) {
      container.append(shape);
    }
    return shape;
  }
  _loadPolygon(container, rings, dataItem) {
    let shape = this._buildPolygon(rings);
    shape.dataItem = dataItem;
    shape.location = this.locator.viewToLocation(shape.bbox().center());
    return this._loadShape(container, shape);
  }
  _buildPolygon(rings) {
    let type = rings.length > 1 ? drawing_exports.MultiPath : drawing_exports.Path;
    let path = new type(this.style);
    for (let i37 = 0; i37 < rings.length; i37++) {
      for (let j = 0; j < rings[i37].length; j++) {
        let point = this.locator.locationToView(Location.fromLngLat(rings[i37][j]));
        if (j === 0) {
          path.moveTo(point.x, point.y);
        } else {
          path.lineTo(point.x, point.y);
        }
      }
    }
    return path;
  }
  _loadPoint(container, coords, dataItem) {
    let location = Location.fromLngLat(coords);
    let point = this.locator.locationToView(location);
    let circle = new geometry_exports.Circle(point, 10);
    let shape = new drawing_exports.Circle(circle, this.style);
    shape.dataItem = dataItem;
    shape.location = location;
    return this._loadShape(container, shape);
  }
};

// node_modules/@progress/kendo-charts/dist/es/map/layers/bubble.js
var BubbleLayer = class extends ShapeLayer {
  _readData() {
    const data = this.options.data || [];
    return data;
  }
  _load(data) {
    this._data = data;
    this.surface.clear();
    if (data.length === 0) {
      return;
    }
    let options = this.options;
    let getValue = getter(options.valueField);
    let newData = data.slice(0);
    newData.sort(function(a50, b2) {
      return getValue(b2) - getValue(a50);
    });
    let scaleType = this._scaleType();
    let scale;
    let getLocation = getter(this.options.locationField);
    for (let i37 = 0; i37 < newData.length; i37++) {
      let dataItem = newData[i37];
      let location = getLocation(dataItem);
      let value2 = getValue(dataItem);
      if (defined(location) && defined(value2)) {
        if (!scale) {
          scale = new scaleType([
            0,
            value2
          ], [
            options.minSize,
            options.maxSize
          ]);
        }
        location = Location.create(location);
        let center = this.map.locationToView(location);
        let size = scale.map(value2);
        let symbol = this._createSymbol({
          center,
          size,
          style: options.style,
          dataItem,
          location
        });
        symbol.dataItem = dataItem;
        symbol.location = location;
        symbol.value = value2;
        this._drawSymbol(symbol);
      }
    }
  }
  _scaleType() {
    let scale = this.options.scale;
    if (isFunction(scale)) {
      return scale;
    }
    return Scales[scale];
  }
  _createSymbol(args) {
    let symbol = this.options.symbol;
    if (!isFunction(symbol)) {
      symbol = Symbols[symbol];
    }
    return symbol(args);
  }
  _drawSymbol(shape) {
    let args = {
      layer: this,
      shape
    };
    let cancelled = this.map.trigger("shapeCreated", args);
    if (!cancelled) {
      this.surface.draw(shape);
    }
  }
  _tooltipContext(shape) {
    return {
      type: "bubble",
      layerIndex: this._layerIndex(),
      className: "k-map-bubble-tooltip",
      dataItem: shape.dataItem,
      location: shape.location,
      value: shape.value
    };
  }
  _tooltipAnchor(e41) {
    const shape = e41.element;
    const center = shape.bbox().center();
    return {
      top: center.y,
      left: center.x
    };
  }
};
setDefaultOptions(BubbleLayer, {
  // autoBind: true,
  locationField: "location",
  valueField: "value",
  minSize: 0,
  maxSize: 100,
  scale: "sqrt",
  symbol: "circle",
  // ensure bubble layers are displayed over tile and shape layers
  zIndex: 200
});
var SqrtScale = class {
  constructor(domain, range) {
    this._domain = domain;
    this._range = range;
    let domainRange = Math.sqrt(domain[1]) - Math.sqrt(domain[0]);
    let outputRange = range[1] - range[0];
    this._ratio = outputRange / domainRange;
  }
  map(value2) {
    let rel = (Math.sqrt(value2) - Math.sqrt(this._domain[0])) * this._ratio;
    return this._range[0] + rel;
  }
};
var Scales = {
  sqrt: SqrtScale
};
var Symbols = {
  circle: function(args) {
    let geo = new geometry_exports.Circle(args.center, args.size / 2);
    return new drawing_exports.Circle(geo, args.style);
  },
  square: function(args) {
    let path = new drawing_exports.Path(args.style);
    let halfSize = args.size / 2;
    let center = args.center;
    path.moveTo(center.x - halfSize, center.y - halfSize).lineTo(center.x + halfSize, center.y - halfSize).lineTo(center.x + halfSize, center.y + halfSize).lineTo(center.x - halfSize, center.y + halfSize).close();
    return path;
  }
};

// node_modules/@progress/kendo-charts/dist/es/map/layers/marker.js
var CLICK = "click";
var MOUSE_ENTER = "mouseenter";
var MOUSE_LEAVE = "mouseleave";
var extend12 = Object.assign;
var MARKER_CLASS_NAME = "k-marker";
var MARKER_CLASS = "." + MARKER_CLASS_NAME;
var MarkerLayer = class extends Layer {
  constructor(map2, options) {
    super(map2, options);
    this._markerClickHandler = proxy(this._markerClick, this);
    on(this.element, CLICK, MARKER_CLASS, this._markerClickHandler);
    this.items = [];
    this._load(this._readData());
  }
  destroy() {
    super.destroy();
    off(this.element, CLICK, this._markerClickHandler);
    this.clear();
  }
  add(args) {
    if (isArray(args)) {
      for (let i37 = 0; i37 < args.length; i37++) {
        this._addOne(args[i37]);
      }
    } else {
      return this._addOne(args);
    }
  }
  remove(marker) {
    marker.destroy();
    let index = (this.items || []).indexOf(marker);
    if (index > -1) {
      this.items.splice(index, 1);
    }
  }
  clear() {
    for (let i37 = 0; i37 < this.items.length; i37++) {
      this.items[i37].destroy();
    }
    this.items = [];
  }
  update(marker) {
    let location = marker.location();
    if (location) {
      marker.showAt(this.map.locationToView(location));
      let args = {
        marker,
        layer: this
      };
      this.map.trigger("markerActivate", args);
    }
  }
  _reset() {
    super._reset();
    let items = this.items;
    for (let i37 = 0; i37 < items.length; i37++) {
      this.update(items[i37]);
    }
  }
  bind(options, dataItem) {
    let marker = Marker.create(options, this.options);
    marker.dataItem = dataItem;
    let args = {
      marker,
      layer: this
    };
    let cancelled = this.map.trigger("markerCreated", args);
    if (!cancelled) {
      this.add(marker);
      return marker;
    }
  }
  _addOne(arg) {
    let marker = Marker.create(arg, this.options);
    marker.addTo(this);
    return marker;
  }
  _readData() {
    const data = this.options.data || [];
    return data;
  }
  _load(data) {
    this._data = data;
    this.clear();
    let getLocation = getter(this.options.locationField);
    let getTitle = getter(this.options.titleField);
    for (let i37 = 0; i37 < data.length; i37++) {
      let dataItem = data[i37];
      this.bind({
        location: getLocation(dataItem),
        title: getTitle(dataItem)
      }, dataItem);
    }
  }
  _markerClick(e41) {
    const marker = e41.currentTarget._kendoNode;
    let args = {
      layer: this,
      layerIndex: this._layerIndex(),
      marker,
      markerIndex: (this.items || []).indexOf(marker),
      originalEvent: e41
    };
    this.map.trigger("markerClick", args);
  }
  _markerMouseEnter(e41) {
    const args = this._createMarkerEventArgs(e41);
    this.map.trigger("markerMouseEnter", args);
  }
  _markerMouseLeave(e41) {
    const args = this._createMarkerEventArgs(e41);
    this.map.trigger("markerMouseLeave", args);
  }
  _createMarkerEventArgs(e41) {
    const marker = e41.marker;
    let args = extend12({}, {
      layer: this,
      layerIndex: this._layerIndex(),
      marker,
      markerIndex: (this.items || []).indexOf(marker)
    }, e41);
    return args;
  }
};
setDefaultOptions(MarkerLayer, {
  zIndex: 1e3,
  autoBind: true,
  locationField: "location",
  titleField: "title",
  template: ""
});
var Marker = class _Marker {
  constructor(options) {
    this.options = options || {};
  }
  destroy() {
    this.layer = null;
    this.unbindEvents();
    this.hide();
  }
  addTo(parent) {
    this.layer = parent.markers || parent;
    this.layer.items.push(this);
    this.layer.update(this);
  }
  location(value2) {
    if (value2) {
      this.options.location = Location.create(value2).toArray();
      if (this.layer) {
        this.layer.update(this);
      }
      return this;
    }
    return Location.create(this.options.location);
  }
  showAt(point) {
    this.render();
    this._anchor = { left: Math.round(point.x), top: Math.round(point.y) };
    this.element.style.left = toPixels(this._anchor.left);
    this.element.style.top = toPixels(this._anchor.top);
  }
  hide() {
    if (this.element) {
      this.element.remove();
      this.element = null;
    }
  }
  bindEvents() {
    if (!this.element) {
      return;
    }
    this._mouseEnterHandler = proxy(this._mouseEnter, this);
    on(this.element, MOUSE_ENTER, MARKER_CLASS, this._mouseEnterHandler);
    this._mouseLeaveHandler = proxy(this._mouseLeave, this);
    on(this.element, MOUSE_LEAVE, MARKER_CLASS, this._mouseLeaveHandler);
  }
  unbindEvents() {
    if (!this.element) {
      return;
    }
    off(this.element, MOUSE_ENTER, this._mouseEnterHandler);
    off(this.element, MOUSE_LEAVE, this._mouseLeaveHandler);
  }
  render() {
    if (!this.element) {
      let options = this.options;
      let layer = this.layer;
      let element = document.createElement("span");
      addClass(element, MARKER_CLASS_NAME);
      if (this.options.template) {
        const templateFn = this._compileTemplate(this.options.template);
        const templateHtml = templateFn(this.dataItem);
        const templateElement = convertToHtml(templateHtml);
        element.appendChild(templateElement);
      } else if (options.svgIcon) {
        renderIcon(element, { icon: options.svgIcon, iconClass: "k-icon-xxl", svgIcons: this.options.icons.svgIcons, type: "svg" });
      } else {
        let iconOptions = { icon: "map-marker", iconClass: "k-icon-xxl", svgIcons: this.options.icons.svgIcons, type: this.options.icons.type };
        if (options.shape) {
          if (options.shape === "pinTarget") {
            iconOptions.icon = "map-marker-target";
            renderIcon(element, iconOptions);
          } else if (options.shape === "pin") {
            renderIcon(element, iconOptions);
          } else {
            addClass(element, "k-icon k-icon-xxl k-i-marker-" + toHyphens(options.shape || "pin"));
          }
        } else {
          renderIcon(element, iconOptions);
        }
      }
      if (options.title) {
        element.setAttribute("title", options.title);
      }
      const attributes = options.attributes || {};
      Object.keys(attributes).forEach(function(key) {
        element.setAttribute(key, attributes[key]);
      });
      element._kendoNode = this;
      element.style.zIndex = options.zIndex;
      this.element = element;
      if (layer) {
        layer.element.appendChild(this.element);
      }
      this.bindEvents();
    }
  }
  _mouseEnter(e41) {
    const args = this._createEventArgs(e41);
    this.layer._markerMouseEnter(args);
    this.layer.map._tooltip.show({
      top: this._anchor.top - this.element.offsetHeight,
      left: this._anchor.left
    }, this._tooltipContext());
  }
  _tooltipContext() {
    return {
      type: "marker",
      layerIndex: this.layer._layerIndex(),
      className: "k-map-marker-tooltip",
      dataItem: this.dataItem,
      title: this.options.title,
      location: this.location()
    };
  }
  _mouseLeave(e41) {
    const args = this._createEventArgs(e41);
    this.layer._markerMouseLeave(args);
  }
  _createEventArgs(e41) {
    let args = {
      marker: this,
      originalEvent: e41
    };
    return args;
  }
  _compileTemplate(template) {
    return template_service_default.compile(template, {
      paramName: "dataItem",
      useWithBlock: false
    });
  }
  static create(arg, defaults) {
    if (arg instanceof _Marker) {
      return arg;
    }
    return new _Marker(deepExtend({}, defaults, arg));
  }
};

// node_modules/@progress/kendo-charts/dist/es/map/scroller/fx.js
var extend13 = Object.assign;
function animationFrame(callback) {
  window.requestAnimationFrame(callback);
}
var Animation = class {
  constructor() {
    let that = this;
    that._tickProxy = proxy(that._tick, that);
    that._started = false;
  }
  tick() {
  }
  done() {
  }
  onEnd() {
  }
  onCancel() {
  }
  start() {
    if (!this.enabled()) {
      return;
    }
    if (!this.done()) {
      this._started = true;
      animationFrame(this._tickProxy);
    } else {
      this.onEnd();
    }
  }
  enabled() {
    return true;
  }
  cancel() {
    this._started = false;
    this.onCancel();
  }
  _tick() {
    let that = this;
    if (!that._started) {
      return;
    }
    that.tick();
    if (!that.done()) {
      animationFrame(that._tickProxy);
    } else {
      that._started = false;
      that.onEnd();
    }
  }
};
var Transition = class extends Animation {
  constructor(options) {
    super();
    extend13(this, options);
  }
  done() {
    return this.timePassed() >= this.duration;
  }
  timePassed() {
    return Math.min(this.duration, now() - this.startDate);
  }
  moveTo(options) {
    let that = this, movable = that.movable;
    that.initial = movable[that.axis];
    that.delta = options.location - that.initial;
    that.duration = typeof options.duration === "number" ? options.duration : 300;
    that.tick = that._easeProxy(options.ease);
    that.startDate = now();
    that.start();
  }
  _easeProxy(ease) {
    let that = this;
    return function() {
      that.movable.moveAxis(that.axis, ease(that.timePassed(), that.initial, that.delta, that.duration));
    };
  }
  static easeOutExpo(t43, b2, c9, d5) {
    return t43 === d5 ? b2 + c9 : c9 * (-Math.pow(2, -10 * t43 / d5) + 1) + b2;
  }
  // static easeOutBack(t, b, c, d) {
  //     let s = 1.70158;
  //     return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
  // }
};

// node_modules/@progress/kendo-charts/dist/es/map/scroller/scroller.js
var extend14 = Object.assign;
var abs2 = Math.abs;
var SNAPBACK_DURATION = 500;
var SCROLLBAR_OPACITY = 0.7;
var FRICTION = 0.96;
var VELOCITY_MULTIPLIER = 10;
var MAX_VELOCITY = 55;
var OUT_OF_BOUNDS_FRICTION = 0.5;
var ANIMATED_SCROLLER_PRECISION = 5;
var PULL = "pull";
var CHANGE3 = "change";
var RESIZE = "resize";
var SCROLL = "scroll";
var MOUSE_WHEEL_ID = 2;
var ZoomSnapBack = class extends Animation {
  constructor(options) {
    super(options);
    let that = this;
    extend14(that, options);
    that.userEvents.bind("gestureend", that.start.bind(this));
    that.tapCapture.bind("press", that.cancel.bind(this));
  }
  enabled() {
    return this.movable.scale < this.dimensions.minScale;
  }
  done() {
    return this.dimensions.minScale - this.movable.scale < 0.01;
  }
  tick() {
    let movable = this.movable;
    movable.scaleWith(1.1);
    this.dimensions.rescale(movable.scale);
  }
  onEnd() {
    let movable = this.movable;
    movable.scaleTo(this.dimensions.minScale);
    this.dimensions.rescale(movable.scale);
  }
};
var DragInertia = class extends Animation {
  constructor(options) {
    super();
    let that = this;
    extend14(that, options, {
      transition: new Transition({
        axis: options.axis,
        movable: options.movable,
        onEnd() {
          that._end();
        }
      })
    });
    that.tapCapture.bind("press", function() {
      that.cancel();
    });
    that.userEvents.bind("end", proxy(that.start, that));
    that.userEvents.bind("gestureend", proxy(that.start, that));
    that.userEvents.bind("tap", proxy(that.onEnd, that));
  }
  onCancel() {
    this.transition.cancel();
  }
  freeze(location) {
    let that = this;
    that.cancel();
    that._moveTo(location);
  }
  onEnd() {
    let that = this;
    if (that.paneAxis.outOfBounds()) {
      that._snapBack();
    } else {
      that._end();
    }
  }
  done() {
    return abs2(this.velocity) < 1;
  }
  start(e41) {
    let that = this, velocity;
    if (!that.dimension.enabled) {
      return;
    }
    if (that.paneAxis.outOfBounds()) {
      if (that.transition._started) {
        that.transition.cancel();
        that.velocity = Math.min(e41.touch[that.axis].velocity * that.velocityMultiplier, MAX_VELOCITY);
        super.start();
      } else {
        that._snapBack();
      }
    } else {
      velocity = e41.touch.id === MOUSE_WHEEL_ID ? 0 : e41.touch[that.axis].velocity;
      that.velocity = Math.max(Math.min(velocity * that.velocityMultiplier, MAX_VELOCITY), -MAX_VELOCITY);
      that.tapCapture.captureNext();
      super.start();
    }
  }
  tick() {
    let that = this, dimension = that.dimension, friction = that.paneAxis.outOfBounds() ? OUT_OF_BOUNDS_FRICTION : that.friction, delta = that.velocity *= friction, location = that.movable[that.axis] + delta;
    if (!that.elastic && dimension.outOfBounds(location)) {
      location = Math.max(Math.min(location, dimension.max), dimension.min);
      that.velocity = 0;
    }
    that.movable.moveAxis(that.axis, location);
  }
  _end() {
    this.tapCapture.cancelCapture();
    this.end();
  }
  _snapBack() {
    let that = this, dimension = that.dimension, snapBack = that.movable[that.axis] > dimension.max ? dimension.max : dimension.min;
    that._moveTo(snapBack);
  }
  _moveTo(location) {
    this.transition.moveTo({
      location,
      duration: SNAPBACK_DURATION,
      ease: Transition.easeOutExpo
    });
  }
};
var AnimatedScroller = class extends Animation {
  constructor(options) {
    super(options);
    let that = this;
    extend14(that, options, {
      origin: {},
      destination: {},
      offset: {}
    });
  }
  tick() {
    this._updateCoordinates();
    this.moveTo(this.origin);
  }
  done() {
    return abs2(this.offset.y) < ANIMATED_SCROLLER_PRECISION && abs2(this.offset.x) < ANIMATED_SCROLLER_PRECISION;
  }
  onEnd() {
    this.moveTo(this.destination);
    if (this.callback) {
      this.callback.call();
    }
  }
  setCoordinates(from, to) {
    this.offset = {};
    this.origin = from;
    this.destination = to;
  }
  /* eslint-disable no-param-reassign */
  setCallback(callback) {
    if (callback && isFunction(callback)) {
      this.callback = callback;
    } else {
      callback = void 0;
    }
  }
  /* eslint-enable no-param-reassign */
  _updateCoordinates() {
    this.offset = {
      x: (this.destination.x - this.origin.x) / 4,
      y: (this.destination.y - this.origin.y) / 4
    };
    this.origin = {
      y: this.origin.y + this.offset.y,
      x: this.origin.x + this.offset.x
    };
  }
};
var ScrollBar = class {
  constructor(options) {
    let that = this, horizontal = options.axis === "x";
    const orientation = horizontal ? "horizontal" : "vertical";
    const element = convertToHtml('<div class="km-touch-scrollbar km-' + orientation + '-scrollbar" />');
    extend14(that, options, {
      element,
      elementSize: 0,
      movable: new Movable(element),
      scrollMovable: options.movable,
      alwaysVisible: options.alwaysVisible,
      size: horizontal ? "width" : "height"
    });
    that.scrollMovable.bind(CHANGE3, that.refresh.bind(that));
    that.container.appendChild(element);
    if (options.alwaysVisible) {
      that.show();
    }
  }
  refresh() {
    let that = this, axis = that.axis, dimension = that.dimension, paneSize = dimension.size, scrollMovable = that.scrollMovable, sizeRatio = paneSize / dimension.total, position = Math.round(-scrollMovable[axis] * sizeRatio), size = Math.round(paneSize * sizeRatio);
    if (sizeRatio >= 1) {
      this.element.style.display = "none";
    } else {
      this.element.style.display = "";
    }
    if (position + size > paneSize) {
      size = paneSize - position;
    } else if (position < 0) {
      size += position;
      position = 0;
    }
    if (that.elementSize !== size) {
      that.element.style[that.size] = size + "px";
      that.elementSize = size;
    }
    that.movable.moveAxis(axis, position);
  }
  show() {
    this.element.style.opacity = SCROLLBAR_OPACITY;
    this.element.style.visibility = "visible";
  }
  hide() {
    if (!this.alwaysVisible) {
      this.element.style.opacity = 0;
    }
  }
};
var Scroller = class extends Observable {
  constructor(element, options) {
    super();
    let that = this;
    this.element = element;
    this._initOptions(options);
    const hasScrolling = hasNativeScrolling(navigator.userAgent);
    that._native = that.options.useNative && hasScrolling;
    const scrollHeader = convertToHtml('<div class="km-scroll-header"/>');
    if (that._native) {
      addClass(element, "km-native-scroller");
      prepend(scrollHeader, element);
      extend14(that, {
        scrollElement: element,
        fixedContainer: element.children[0]
      });
      return;
    }
    element.style.overflow = "hidden";
    addClass(element, "km-scroll-wrapper");
    const scrollContainer = convertToHtml('<div class="km-scroll-container"/>');
    wrapInner(element, scrollContainer);
    prepend(scrollHeader, element);
    let inner = element.children[1], tapCapture = new TapCapture(element), movable = new Movable(inner), dimensions = new PaneDimensions({
      element: inner,
      container: element,
      forcedEnabled: that.options.zoom
    }), avoidScrolling = this.options.avoidScrolling, userEvents = new UserEvents(element, {
      touchAction: "none",
      allowSelection: true,
      preventDragEvent: true,
      captureUpIfMoved: true,
      multiTouch: that.options.zoom,
      supportDoubleTap: that.options.supportDoubleTap,
      start(e41) {
        dimensions.refresh();
        let velocityX = abs2(e41.x.velocity), velocityY = abs2(e41.y.velocity), horizontalSwipe = velocityX * 2 >= velocityY, originatedFromFixedContainer = that.fixedContainer.contains(e41.event.target), verticalSwipe = velocityY * 2 >= velocityX;
        if (!originatedFromFixedContainer && !avoidScrolling(e41) && that.enabled && (dimensions.x.enabled && horizontalSwipe || dimensions.y.enabled && verticalSwipe)) {
          userEvents.capture();
        } else {
          userEvents.cancel();
        }
      }
    }), pane = new Pane2({
      movable,
      dimensions,
      userEvents,
      elastic: that.options.elastic
    }), zoomSnapBack = new ZoomSnapBack({
      movable,
      dimensions,
      userEvents,
      tapCapture
    }), animatedScroller = new AnimatedScroller({
      moveTo(coordinates) {
        that.scrollTo(coordinates.x, coordinates.y);
      }
    });
    movable.bind(CHANGE3, function() {
      that.scrollTop = -movable.y;
      that.scrollLeft = -movable.x;
      that.trigger(SCROLL, {
        scrollTop: that.scrollTop,
        scrollLeft: that.scrollLeft
      });
    });
    if (that.options.mousewheelScrolling) {
      this._wheelScrollHandler = this._wheelScroll.bind(this);
      on(element, "wheel", this._wheelScrollHandler);
    }
    extend14(that, {
      movable,
      dimensions,
      zoomSnapBack,
      animatedScroller,
      userEvents,
      pane,
      tapCapture,
      pulled: false,
      enabled: true,
      scrollElement: inner,
      scrollTop: 0,
      scrollLeft: 0,
      fixedContainer: element.children[0]
    });
    that._initAxis("x");
    that._initAxis("y");
    that._wheelEnd = function() {
      that._wheel = false;
      that.userEvents.end(0, that._wheelY);
    };
    dimensions.refresh();
    if (that.options.pullToRefresh) {
      that._initPullToRefresh();
    }
  }
  _initOptions(options) {
    this.options = deepExtend({}, this.options, options);
  }
  _wheelScroll(e41) {
    if (e41.ctrlKey) {
      return;
    }
    if (!this._wheel) {
      this._wheel = true;
      this._wheelY = 0;
      this.userEvents.press(0, this._wheelY);
    }
    clearTimeout(this._wheelTimeout);
    this._wheelTimeout = setTimeout(this._wheelEnd, 50);
    let delta = wheelDeltaY(e41);
    if (delta) {
      this._wheelY += delta;
      this.userEvents.move(0, this._wheelY);
    }
    e41.preventDefault();
  }
  makeVirtual() {
    this.dimensions.y.makeVirtual();
  }
  virtualSize(min4, max3) {
    this.dimensions.y.virtualSize(min4, max3);
  }
  height() {
    return this.dimensions.y.size;
  }
  scrollHeight() {
    return this.scrollElement.scrollHeight;
  }
  scrollWidth() {
    return this.scrollElement.scrollWidth;
  }
  _resize() {
    if (!this._native) {
      this.contentResized();
    }
  }
  setOptions(options) {
    let that = this;
    this._initOptions(options);
    if (options.pullToRefresh) {
      that._initPullToRefresh();
    }
  }
  reset() {
    if (this._native) {
      this.scrollElement.scrollTop(0);
    } else {
      this.movable.moveTo({
        x: 0,
        y: 0
      });
      this._scale(1);
    }
  }
  contentResized() {
    this.dimensions.refresh();
    if (this.pane.x.outOfBounds()) {
      this.movable.moveAxis("x", this.dimensions.x.min);
    }
    if (this.pane.y.outOfBounds()) {
      this.movable.moveAxis("y", this.dimensions.y.min);
    }
  }
  zoomOut() {
    let dimensions = this.dimensions;
    dimensions.refresh();
    this._scale(dimensions.fitScale);
    this.movable.moveTo(dimensions.centerCoordinates());
  }
  enable() {
    this.enabled = true;
  }
  disable() {
    this.enabled = false;
  }
  scrollTo(x7, y2) {
    if (this._native) {
      this.scrollElement.scrollLeft(abs2(x7));
      this.scrollElement.scrollTop(abs2(y2));
    } else {
      this.dimensions.refresh();
      this.movable.moveTo({
        x: x7,
        y: y2
      });
    }
  }
  animatedScrollTo(x7, y2, callback) {
    let from, to;
    if (this._native) {
      this.scrollTo(x7, y2);
    } else {
      from = {
        x: this.movable.x,
        y: this.movable.y
      };
      to = {
        x: x7,
        y: y2
      };
      this.animatedScroller.setCoordinates(from, to);
      this.animatedScroller.setCallback(callback);
      this.animatedScroller.start();
    }
  }
  // kept for API compatibility, not used
  pullHandled() {
  }
  destroy() {
    const element = this.element;
    off(element, "wheel", this._wheelScrollHandler);
    if (this.userEvents) {
      this.userEvents.destroy();
    }
  }
  _scale(scale) {
    this.dimensions.rescale(scale);
    this.movable.scaleTo(scale);
  }
  _initPullToRefresh() {
  }
  // kept for API compatibility, not used
  _dragEnd() {
  }
  // kept for API compatibility, not used
  _paneChange() {
  }
  _initAxis(axis) {
    let that = this, movable = that.movable, dimension = that.dimensions[axis], tapCapture = that.tapCapture, paneAxis = that.pane[axis], scrollBar = new ScrollBar({
      axis,
      movable,
      dimension,
      container: that.element,
      alwaysVisible: that.options.visibleScrollHints
    });
    dimension.bind(CHANGE3, function() {
      scrollBar.refresh();
    });
    paneAxis.bind(CHANGE3, function() {
      scrollBar.show();
    });
    that[axis + "inertia"] = new DragInertia({
      axis,
      paneAxis,
      movable,
      tapCapture,
      userEvents: that.userEvents,
      dimension,
      elastic: that.options.elastic,
      friction: that.options.friction || FRICTION,
      velocityMultiplier: that.options.velocityMultiplier || VELOCITY_MULTIPLIER,
      end() {
        scrollBar.hide();
        that.trigger("scrollEnd", {
          axis,
          scrollTop: that.scrollTop,
          scrollLeft: that.scrollLeft
        });
      }
    });
  }
};
setDefaultOptions(Scroller, {
  name: "Scroller",
  zoom: false,
  pullOffset: 140,
  visibleScrollHints: false,
  elastic: true,
  useNative: false,
  mousewheelScrolling: true,
  avoidScrolling() {
    return false;
  },
  pullToRefresh: false,
  messages: {
    pullTemplate: "Pull to refresh",
    releaseTemplate: "Release to refresh",
    refreshTemplate: "Refreshing"
  }
});
setDefaultEvents(Scroller, [
  PULL,
  SCROLL,
  RESIZE
]);

// node_modules/@progress/kendo-charts/dist/es/services/map-service.js
var MapService = class {
  constructor(widget, context = {}) {
    this.sender = context.sender || widget;
    this.widget = widget;
    this.rtl = Boolean(context.rtl);
  }
  notify(name, args) {
    if (this.widget) {
      this.widget.trigger(name, args);
    }
  }
};
var map_service_default = MapService;

// node_modules/@progress/kendo-charts/dist/es/map/map.js
var math5 = Math;
var min2 = math5.min;
var pow2 = math5.pow;
var Point6 = geometry_exports.Point;
var MARKER = "marker";
var LOCATION = "location";
var FRICTION2 = 0.9;
var FRICTION_MOBILE = 0.93;
var MOUSEWHEEL2 = "wheel";
var MOUSEWHEEL_THROTTLE = 50;
var VELOCITY_MULTIPLIER2 = 5;
var DEFAULT_ZOOM_RATE = 1;
var layersMap = {
  bubble: BubbleLayer,
  shape: ShapeLayer,
  tile: TileLayer,
  [MARKER]: MarkerLayer
};
var Map2 = class extends Observable {
  constructor(element, options = {}, themeOptions = {}, context = {}) {
    super();
    this._init(element, options, themeOptions, context);
  }
  destroy() {
    this.scroller.destroy();
    if (this._tooltip) {
      this._tooltip.destroy();
    }
    if (this.navigator) {
      this.navigator.destroy();
    }
    if (this.attribution) {
      this.attribution.destroy();
    }
    if (this.zoomControl) {
      this.zoomControl.destroy();
    }
    if (isArray(this.markers)) {
      this.markers.forEach((markerLayer) => {
        markerLayer.destroy();
      });
    } else {
      this.markers.destroy();
    }
    for (let i37 = 0; i37 < this.layers.length; i37++) {
      this.layers[i37].destroy();
    }
    off(this.element, MOUSEWHEEL2, this._mousewheelHandler);
    super.destroy();
  }
  // eslint-disable-next-line no-unused-vars
  _init(element, options = {}, themeOptions = {}, context = {}) {
    this.support = getSupportedFeatures();
    this.context = context;
    this.initObserver(context);
    this.initServices(context);
    this._notifyObserver(INIT);
    this._initOptions(options);
    this._setEvents(options);
    this.crs = new EPSG3857();
    this._initElement(element);
    this._viewOrigin = this._getOrigin();
    this._tooltip = this._createTooltip();
    this._initScroller();
    this._initMarkers();
    this._initControls();
    this._initLayers();
    this._reset();
    const mousewheelThrottled = throttle(this._mousewheel.bind(this), MOUSEWHEEL_THROTTLE);
    this._mousewheelHandler = (e41) => {
      e41.preventDefault();
      mousewheelThrottled(e41);
    };
    on(this.element, MOUSEWHEEL2, this._mousewheelHandler);
  }
  _initOptions(options) {
    this.options = deepExtend({}, this.options, options);
  }
  _initElement(element) {
    this.element = element;
    addClass(element, "k-map");
    element.style.position = "relative";
    element.setAttribute("data-role", "map");
    removeChildren(element);
    const div = convertToHtml("<div />");
    this.element.appendChild(div);
  }
  initServices(context = {}) {
    this.widgetService = new map_service_default(this, context);
  }
  initObserver(context = {}) {
    this.observers = [];
    this.addObserver(context.observer);
  }
  addObserver(observer) {
    if (observer) {
      this.observers.push(observer);
    }
  }
  removeObserver(observer) {
    const index = this.observers.indexOf(observer);
    if (index >= 0) {
      this.observers.splice(index, 1);
    }
  }
  requiresHandlers(eventNames) {
    const observers = this.observers;
    for (let idx = 0; idx < observers.length; idx++) {
      if (observers[idx].requiresHandlers(eventNames)) {
        return true;
      }
    }
  }
  trigger(name, args = {}) {
    args.sender = this;
    const observers = this.observers;
    let isDefaultPrevented2 = false;
    for (let idx = 0; idx < observers.length; idx++) {
      if (observers[idx].trigger(name, args)) {
        isDefaultPrevented2 = true;
      }
    }
    if (!isDefaultPrevented2) {
      super.trigger(name, args);
    }
    return isDefaultPrevented2;
  }
  _notifyObserver(name, args = {}) {
    args.sender = this;
    const observers = this.observers;
    let isDefaultPrevented2 = false;
    for (let idx = 0; idx < observers.length; idx++) {
      if (observers[idx].trigger(name, args)) {
        isDefaultPrevented2 = true;
      }
    }
    return isDefaultPrevented2;
  }
  zoom(level) {
    let options = this.options;
    let result;
    if (defined(level)) {
      const zoomLevel = math5.round(limitValue(level, options.minZoom, options.maxZoom));
      if (options.zoom !== zoomLevel) {
        options.zoom = zoomLevel;
        this.widgetService.notify(ZOOM_CHANGE, { zoom: options.zoom });
        this._reset();
      }
      result = this;
    } else {
      result = options.zoom;
    }
    return result;
  }
  center(center) {
    let result;
    if (center) {
      const current4 = Location.create(center);
      const previous = Location.create(this.options.center);
      if (!current4.equals(previous)) {
        this.options.center = current4.toArray();
        this.widgetService.notify(CENTER_CHANGE, { center: this.options.center });
        this._reset();
      }
      result = this;
    } else {
      result = Location.create(this.options.center);
    }
    return result;
  }
  extent(extent) {
    let result;
    if (extent) {
      this._setExtent(extent);
      result = this;
    } else {
      result = this._getExtent();
    }
    return result;
  }
  setOptions(options = {}) {
    const element = this.element;
    this.destroy();
    removeChildren(element);
    this._init(element, options, {}, this.context);
    this._reset();
  }
  locationToLayer(location, zoom) {
    let clamp = !this.options.wraparound;
    const locationObject = Location.create(location);
    return this.crs.toPoint(locationObject, this._layerSize(zoom), clamp);
  }
  layerToLocation(point, zoom) {
    let clamp = !this.options.wraparound;
    const pointObject = Point6.create(point);
    return this.crs.toLocation(pointObject, this._layerSize(zoom), clamp);
  }
  locationToView(location) {
    const locationObject = Location.create(location);
    let origin = this.locationToLayer(this._viewOrigin);
    let point = this.locationToLayer(locationObject);
    return point.translateWith(origin.scale(-1));
  }
  viewToLocation(point, zoom) {
    const origin = this.locationToLayer(this._getOrigin(), zoom);
    const pointObject = Point6.create(point);
    const pointResult = pointObject.clone().translateWith(origin);
    return this.layerToLocation(pointResult, zoom);
  }
  eventOffset(e41) {
    let x7;
    let y2;
    let offset = elementOffset(this.element);
    if (e41.x && e41.x[LOCATION] || e41.y && e41.y[LOCATION]) {
      x7 = e41.x[LOCATION] - offset.left;
      y2 = e41.y[LOCATION] - offset.top;
    } else {
      let event = e41.originalEvent || e41;
      x7 = valueOrDefault(event.pageX, event.clientX) - offset.left;
      y2 = valueOrDefault(event.pageY, event.clientY) - offset.top;
    }
    const point = new geometry_exports.Point(x7, y2);
    return point;
  }
  eventToView(e41) {
    let cursor = this.eventOffset(e41);
    return this.locationToView(this.viewToLocation(cursor));
  }
  eventToLayer(e41) {
    return this.locationToLayer(this.eventToLocation(e41));
  }
  eventToLocation(e41) {
    let cursor = this.eventOffset(e41);
    return this.viewToLocation(cursor);
  }
  viewSize() {
    let element = this.element;
    let scale = this._layerSize();
    let width = element.clientWidth;
    if (!this.options.wraparound) {
      width = min2(scale, width);
    }
    return {
      width,
      height: min2(scale, element.clientHeight)
    };
  }
  exportVisual() {
    this._reset();
    return false;
  }
  hideTooltip() {
    if (this._tooltip) {
      this._tooltip.hide();
    }
  }
  _setOrigin(origin, zoom) {
    let size = this.viewSize(), topLeft;
    const originLocation = this._origin = Location.create(origin);
    topLeft = this.locationToLayer(originLocation, zoom);
    topLeft.x += size.width / 2;
    topLeft.y += size.height / 2;
    this.options.center = this.layerToLocation(topLeft, zoom).toArray();
    this.widgetService.notify(CENTER_CHANGE, { center: this.options.center });
    return this;
  }
  _getOrigin(invalidate) {
    let size = this.viewSize(), topLeft;
    if (invalidate || !this._origin) {
      topLeft = this.locationToLayer(this.center());
      topLeft.x -= size.width / 2;
      topLeft.y -= size.height / 2;
      this._origin = this.layerToLocation(topLeft);
    }
    return this._origin;
  }
  _setExtent(newExtent) {
    let raw = Extent.create(newExtent);
    let se = raw.se.clone();
    if (this.options.wraparound && se.lng < 0 && newExtent.nw.lng > 0) {
      se.lng = 180 + (180 + se.lng);
    }
    const extent = new Extent(raw.nw, se);
    this.center(extent.center());
    let width = this.element.clientWidth;
    let height = this.element.clientHeight;
    let zoom;
    for (zoom = this.options.maxZoom; zoom >= this.options.minZoom; zoom--) {
      let topLeft = this.locationToLayer(extent.nw, zoom);
      let bottomRight = this.locationToLayer(extent.se, zoom);
      let layerWidth = math5.abs(bottomRight.x - topLeft.x);
      let layerHeight = math5.abs(bottomRight.y - topLeft.y);
      if (layerWidth <= width && layerHeight <= height) {
        break;
      }
    }
    this.zoom(zoom);
  }
  _getExtent() {
    let nw = this._getOrigin();
    let bottomRight = this.locationToLayer(nw);
    let size = this.viewSize();
    bottomRight.x += size.width;
    bottomRight.y += size.height;
    let se = this.layerToLocation(bottomRight);
    return new Extent(nw, se);
  }
  _zoomAround(pivot, level) {
    this._setOrigin(this.layerToLocation(pivot, level), level);
    this.zoom(level);
  }
  _initControls() {
    let controls = this.options.controls;
    if (controls.attribution) {
      this._createAttribution(controls.attribution);
    }
    if (!this.support.mobileOS) {
      if (controls.navigator) {
        this._createNavigator(controls.navigator);
      }
      if (controls.zoom) {
        this._createZoomControl(controls.zoom);
      }
    }
  }
  _createControlElement(options, defaultPosition) {
    let pos = options.position || defaultPosition;
    let posSelector = "." + renderPos(pos).replace(" ", ".");
    let wrap = this.element.querySelector(".k-map-controls" + posSelector) || [];
    if (wrap.length === 0) {
      let div2 = document.createElement("div");
      addClass(div2, "k-map-controls " + renderPos(pos));
      wrap = div2;
      this.element.appendChild(wrap);
    }
    let div = document.createElement("div");
    wrap.appendChild(div);
    return div;
  }
  _createAttribution(options) {
    let element = this._createControlElement(options, "bottomRight");
    this.attribution = new Attribution(element, options);
  }
  _createNavigator(options) {
    let element = this._createControlElement(options, "topLeft");
    let navigator2 = this.navigator = new Navigator2(element, deepExtend({}, options, { icons: this.options.icons }));
    this._navigatorPan = this._navigatorPan.bind(this);
    navigator2.bind("pan", this._navigatorPan);
    this._navigatorCenter = this._navigatorCenter.bind(this);
    navigator2.bind("center", this._navigatorCenter);
  }
  _navigatorPan(e41) {
    let scroller = this.scroller;
    let x7 = scroller.scrollLeft + e41.x;
    let y2 = scroller.scrollTop - e41.y;
    let bounds = this._virtualSize;
    let width = this.element.clientWidth;
    let height = this.element.clientHeight;
    x7 = limitValue(x7, bounds.x.min, bounds.x.max - width);
    y2 = limitValue(y2, bounds.y.min, bounds.y.max - height);
    this.scroller.one("scroll", proxy(this._scrollEnd, this));
    this.scroller.scrollTo(-x7, -y2);
  }
  _navigatorCenter() {
    this.center(this.options.center);
  }
  _createZoomControl(options) {
    let element = this._createControlElement(options, "topLeft");
    let zoomControl = this.zoomControl = new ZoomControl(element, options, this.options.icons);
    this._zoomControlChange = this._zoomControlChange.bind(this);
    zoomControl.bind("change", this._zoomControlChange);
  }
  _zoomControlChange(e41) {
    if (!this.trigger("zoomStart", { originalEvent: e41 })) {
      this.zoom(this.zoom() + e41.delta);
      this.trigger("zoomEnd", {
        originalEvent: e41
      });
    }
  }
  _initScroller() {
    let friction = this.support.mobileOS ? FRICTION_MOBILE : FRICTION2;
    let zoomable = this.options.zoomable !== false;
    let scroller = this.scroller = new Scroller(this.element.children[0], {
      friction,
      velocityMultiplier: VELOCITY_MULTIPLIER2,
      zoom: zoomable,
      mousewheelScrolling: false,
      supportDoubleTap: true
    });
    scroller.bind("scroll", proxy(this._scroll, this));
    scroller.bind("scrollEnd", proxy(this._scrollEnd, this));
    scroller.userEvents.bind("gesturestart", proxy(this._scaleStart, this));
    scroller.userEvents.bind("gestureend", proxy(this._scale, this));
    scroller.userEvents.bind("doubleTap", proxy(this._doubleTap, this));
    scroller.userEvents.bind("tap", proxy(this._tap, this));
    this.scrollElement = scroller.scrollElement;
  }
  _initLayers() {
    let defs = this.options.layers, layers = this.layers = [];
    for (let i37 = 0; i37 < defs.length; i37++) {
      let options = defs[i37];
      const layer = this._createLayer(options);
      layers.push(layer);
    }
  }
  _createLayer(options) {
    let type = options.type || "shape";
    let layerDefaults = this.options.layerDefaults[type];
    let layerOptions = type === MARKER ? deepExtend({}, this.options.markerDefaults, options, { icons: this.options.icons }) : deepExtend({}, layerDefaults, options);
    let layerConstructor = layersMap[type];
    let layer = new layerConstructor(this, layerOptions);
    if (type === MARKER) {
      this.markers = layer;
    }
    return layer;
  }
  _createTooltip() {
    return new Tooltip2(this.widgetService, this.options.tooltip);
  }
  /* eslint-disable arrow-body-style */
  _initMarkers() {
    const markerLayers = (this.options.layers || []).filter((x7) => {
      return x7 && x7.type === MARKER;
    });
    if (markerLayers.length > 0) {
      return;
    }
    this.markers = new MarkerLayer(this, deepExtend({}, this.options.markerDefaults, { icons: this.options.icons }));
    this.markers.add(this.options.markers);
  }
  /* eslint-enable arrow-body-style */
  _scroll(e41) {
    let origin = this.locationToLayer(this._viewOrigin).round();
    let movable = e41.sender.movable;
    let offset = new geometry_exports.Point(movable.x, movable.y).scale(-1).scale(1 / movable.scale);
    origin.x += offset.x;
    origin.y += offset.y;
    this._scrollOffset = offset;
    this._tooltip.offset = offset;
    this.hideTooltip();
    this._setOrigin(this.layerToLocation(origin));
    this.trigger("pan", {
      originalEvent: e41,
      origin: this._getOrigin(),
      center: this.center()
    });
  }
  _scrollEnd(e41) {
    if (!this._scrollOffset || !this._panComplete()) {
      return;
    }
    this._scrollOffset = null;
    this._panEndTimestamp = now();
    this.trigger("panEnd", {
      originalEvent: e41,
      origin: this._getOrigin(),
      center: this.center()
    });
  }
  _panComplete() {
    return now() - (this._panEndTimestamp || 0) > 50;
  }
  _scaleStart(e41) {
    if (this.trigger("zoomStart", { originalEvent: e41 })) {
      let touch = e41.touches[1];
      if (touch) {
        touch.cancel();
      }
    }
  }
  _scale(e41) {
    let scale = this.scroller.movable.scale;
    let zoom = this._scaleToZoom(scale);
    let gestureCenter = new geometry_exports.Point(e41.center.x, e41.center.y);
    let centerLocation = this.viewToLocation(gestureCenter, zoom);
    let centerPoint = this.locationToLayer(centerLocation, zoom);
    let originPoint = centerPoint.translate(-gestureCenter.x, -gestureCenter.y);
    this._zoomAround(originPoint, zoom);
    this.trigger("zoomEnd", {
      originalEvent: e41
    });
  }
  _scaleToZoom(scaleDelta) {
    let scale = this._layerSize() * scaleDelta;
    let tiles = scale / this.options.minSize;
    let zoom = math5.log(tiles) / math5.log(2);
    return math5.round(zoom);
  }
  _reset() {
    if (this.attribution) {
      this.attribution.filter(this.center(), this.zoom());
    }
    this._viewOrigin = this._getOrigin(true);
    this._resetScroller();
    this.hideTooltip();
    this.trigger("beforeReset");
    this.trigger("reset");
  }
  _resetScroller() {
    let scroller = this.scroller;
    let x7 = scroller.dimensions.x;
    let y2 = scroller.dimensions.y;
    let scale = this._layerSize();
    let nw = this.extent().nw;
    let topLeft = this.locationToLayer(nw).round();
    scroller.movable.round = true;
    scroller.reset();
    scroller.userEvents.cancel();
    let zoom = this.zoom();
    scroller.dimensions.forcedMinScale = pow2(2, this.options.minZoom - zoom);
    scroller.dimensions.maxScale = pow2(2, this.options.maxZoom - zoom);
    let xBounds = {
      min: -topLeft.x,
      max: scale - topLeft.x
    };
    let yBounds = {
      min: -topLeft.y,
      max: scale - topLeft.y
    };
    if (this.options.wraparound) {
      xBounds.max = 20 * scale;
      xBounds.min = -xBounds.max;
    }
    if (this.options.pannable === false) {
      let viewSize = this.viewSize();
      xBounds.min = yBounds.min = 0;
      xBounds.max = viewSize.width;
      yBounds.max = viewSize.height;
    }
    x7.makeVirtual();
    y2.makeVirtual();
    x7.virtualSize(xBounds.min, xBounds.max);
    y2.virtualSize(yBounds.min, yBounds.max);
    this._virtualSize = {
      x: xBounds,
      y: yBounds
    };
  }
  // kept for API compatibility, not used
  _renderLayers() {
  }
  _layerSize(zoom) {
    const newZoom = valueOrDefault(zoom, this.options.zoom);
    return this.options.minSize * pow2(2, newZoom);
  }
  _tap(e41) {
    if (!this._panComplete()) {
      return;
    }
    let cursor = this.eventOffset(e41);
    this.hideTooltip();
    this.trigger("click", {
      originalEvent: e41,
      location: this.viewToLocation(cursor)
    });
  }
  _doubleTap(e41) {
    let options = this.options;
    if (options.zoomable !== false) {
      if (!this.trigger("zoomStart", { originalEvent: e41 })) {
        let toZoom = this.zoom() + DEFAULT_ZOOM_RATE;
        let cursor = this.eventOffset(e41);
        let location = this.viewToLocation(cursor);
        let postZoom = this.locationToLayer(location, toZoom);
        let origin = postZoom.translate(-cursor.x, -cursor.y);
        this._zoomAround(origin, toZoom);
        this.trigger("zoomEnd", {
          originalEvent: e41
        });
      }
    }
  }
  _mousewheel(e41) {
    let delta = mousewheelDelta(e41) > 0 ? -1 : 1;
    let options = this.options;
    let fromZoom = this.zoom();
    let toZoom = limitValue(fromZoom + delta, options.minZoom, options.maxZoom);
    if (options.zoomable !== false && toZoom !== fromZoom) {
      if (!this.trigger("zoomStart", { originalEvent: e41 })) {
        let cursor = this.eventOffset(e41);
        let location = this.viewToLocation(cursor);
        let postZoom = this.locationToLayer(location, toZoom);
        let origin = postZoom.translate(-cursor.x, -cursor.y);
        this._zoomAround(origin, toZoom);
        this.trigger("zoomEnd", {
          originalEvent: e41
        });
      }
    }
  }
  _toDocumentCoordinates(point) {
    const offset = elementOffset(this.element);
    return {
      left: round(point.x + offset.left),
      top: round(point.y + offset.top)
    };
  }
};
setDefaultOptions(Map2, {
  name: "Map",
  controls: {
    attribution: true,
    navigator: {
      panStep: 100
    },
    zoom: true
  },
  layers: [],
  layerDefaults: {
    shape: {
      style: {
        fill: {
          color: "#fff"
        },
        stroke: {
          color: "#aaa",
          width: 0.5
        }
      }
    },
    bubble: {
      style: {
        fill: {
          color: "#fff",
          opacity: 0.5
        },
        stroke: {
          color: "#aaa",
          width: 0.5
        }
      }
    },
    marker: {
      shape: "pinTarget",
      tooltip: {
        position: "top"
      }
    }
  },
  center: [
    0,
    0
  ],
  icons: {
    type: "font",
    svgIcons: {}
  },
  zoom: 3,
  minSize: 256,
  minZoom: 1,
  maxZoom: 19,
  markers: [],
  markerDefaults: {
    shape: "pinTarget",
    tooltip: {
      position: "top"
    }
  },
  wraparound: true,
  // If set to true, GeoJSON layer "Point" features will be rendered as markers.
  // Otherwise, the points will be rendered as circles.
  // Defaults to `true` for KUI/jQuery, `false` everywhere else.
  renderPointsAsMarkers: false
});
setDefaultEvents(Map2, [
  "beforeReset",
  "click",
  "markerActivate",
  "markerClick",
  "markerCreated",
  // Events for implementing custom tooltips.
  "markerMouseEnter",
  "markerMouseLeave",
  "pan",
  "panEnd",
  "reset",
  "shapeClick",
  "shapeCreated",
  "shapeFeatureCreated",
  "shapeMouseEnter",
  "shapeMouseLeave",
  "zoomEnd",
  "zoomStart"
]);

// node_modules/@progress/kendo-charts/dist/es/sankey/calculation.js
var max2 = (array, mapFn) => Math.max.apply(null, array.map(mapFn));
var min3 = (array, mapFn) => Math.min.apply(null, array.map(mapFn));
var sum = (array, mapFn) => array.map(mapFn).reduce((acc, curr) => acc + curr, 0);
var sortAsc = (a50, b2) => a50.y0 === b2.y0 ? a50.index - b2.index : a50.y0 + a50.y1 - b2.y0 - b2.y1;
var sortSource = (a50, b2) => sortAsc(a50.source, b2.source);
var sortTarget = (a50, b2) => sortAsc(a50.target, b2.target);
var value = (node) => node.value;
function sortLinks(nodes) {
  nodes.forEach((node) => {
    node.targetLinks.forEach((link) => {
      link.source.sourceLinks.sort(sortTarget);
    });
    node.sourceLinks.forEach((link) => {
      link.target.targetLinks.sort(sortSource);
    });
  });
}
var calcLayer = (node, maxDepth) => {
  if (node.align === "left") {
    return node.depth;
  }
  if (node.align === "right") {
    return maxDepth - node.height;
  }
  return node.sourceLinks.length ? node.depth : maxDepth;
};
var Sankey = class {
  constructor(options) {
    const { offset = {}, align } = options.nodesOptions;
    this.data = {
      nodes: options.nodes.map((node) => deepExtend({}, { offset, align }, node)),
      links: options.links.map((link) => deepExtend({}, link))
    };
    this.width = options.width;
    this.height = options.height;
    this.offsetX = options.offsetX || 0;
    this.offsetY = options.offsetY || 0;
    this.nodeWidth = options.nodesOptions.width;
    this.nodePadding = options.nodesOptions.padding;
    this.reverse = options.reverse;
    this.targetColumnIndex = options.targetColumnIndex;
    this.loops = options.loops;
    this.autoLayout = options.autoLayout;
  }
  calculate() {
    const { nodes, links } = this.data;
    this.connectLinksToNodes(nodes, links);
    this.calculateNodeValues(nodes);
    const circularLinks = this.calculateNodeHeights(nodes);
    if (circularLinks) {
      return { nodes: [], links: [], columns: [], circularLinks };
    }
    this.calculateNodeDepths(nodes);
    const columns = this.calculateNodeColumns(nodes);
    this.calculateNodeBreadths(columns);
    this.applyNodesOffset(nodes);
    this.calculateLinkBreadths(nodes);
    return Object.assign({}, this.data, { columns });
  }
  connectLinksToNodes(nodes, links) {
    const nodesMap = /* @__PURE__ */ new Map();
    nodes.forEach((node, i37) => {
      node.index = i37;
      node.sourceLinks = [];
      node.targetLinks = [];
      node.id = node.id !== void 0 ? node.id : node.label.text;
      nodesMap.set(node.id, node);
    });
    links.forEach((link) => {
      link.source = nodesMap.get(link.sourceId);
      link.target = nodesMap.get(link.targetId);
      link.source.sourceLinks.push(link);
      link.target.targetLinks.push(link);
    });
  }
  calculateNodeValues(nodes) {
    nodes.forEach((node) => {
      node.value = Math.max(
        sum(node.sourceLinks, value),
        sum(node.targetLinks, value)
      );
    });
  }
  calculateNodeDepths(nodes) {
    let current4 = new Set(nodes);
    let next = /* @__PURE__ */ new Set();
    let currDepth = 0;
    while (current4.size) {
      const currentNodes = Array.from(current4);
      for (let n21 = 0; n21 < currentNodes.length; n21++) {
        const node = currentNodes[n21];
        node.depth = currDepth;
        for (let l7 = 0; l7 < node.sourceLinks.length; l7++) {
          const link = node.sourceLinks[l7];
          next.add(link.target);
        }
      }
      currDepth++;
      current4 = next;
      next = /* @__PURE__ */ new Set();
    }
  }
  calculateNodeHeights(nodes) {
    const nodesLength = nodes.length;
    let current4 = new Set(nodes);
    let next = /* @__PURE__ */ new Set();
    let currentHeight = 0;
    const eachNode = (node) => {
      node.height = currentHeight;
      node.targetLinks.forEach((link) => {
        next.add(link.source);
      });
    };
    while (current4.size) {
      current4.forEach(eachNode);
      currentHeight++;
      if (currentHeight > nodesLength) {
        return true;
      }
      current4 = next;
      next = /* @__PURE__ */ new Set();
    }
    return false;
  }
  calculateNodeColumns(nodes) {
    const maxDepth = max2(nodes, (d5) => d5.depth);
    const columnWidth = (this.width - this.offsetX - this.nodeWidth) / maxDepth;
    const columns = new Array(maxDepth + 1);
    for (let i37 = 0; i37 < nodes.length; i37++) {
      const node = nodes[i37];
      const layer = Math.max(0, Math.min(maxDepth, calcLayer(node, maxDepth)));
      node.x0 = this.offsetX + layer * columnWidth;
      node.x1 = node.x0 + this.nodeWidth;
      node.layer = layer;
      columns[layer] = columns[layer] || [];
      columns[layer].push(node);
    }
    return columns;
  }
  calculateNodeBreadths(columns) {
    const kSize = min3(columns, (c9) => (this.height - this.offsetY - (c9.length - 1) * this.nodePadding) / sum(c9, value));
    columns.forEach((nodes) => {
      let y2 = this.offsetY;
      nodes.forEach((node) => {
        node.y0 = y2;
        node.y1 = y2 + node.value * kSize;
        y2 = node.y1 + this.nodePadding;
        node.sourceLinks.forEach((link) => {
          link.width = link.value * kSize;
        });
      });
      y2 = (this.height - y2 + this.nodePadding) / (nodes.length + 1);
      nodes.forEach((node, i37) => {
        node.y0 += y2 * (i37 + 1);
        node.y1 += y2 * (i37 + 1);
      });
    });
    if (this.autoLayout !== false) {
      const loops = this.loops !== void 0 ? this.loops : columns.length - 1;
      const targetColumnIndex = this.targetColumnIndex || 1;
      for (let i37 = 0; i37 < loops; i37++) {
        if (!this.reverse) {
          this.uncurlLinksToLeft(columns, targetColumnIndex);
          this.uncurlLinksToRight(columns, targetColumnIndex);
        } else {
          this.uncurlLinksToRight(columns, targetColumnIndex);
          this.uncurlLinksToLeft(columns, targetColumnIndex);
        }
      }
    }
    columns.forEach(sortLinks);
  }
  applyNodesOffset(nodes) {
    nodes.forEach((node) => {
      const offsetX = (node.offset ? node.offset.left : 0) || 0;
      const offsetY = (node.offset ? node.offset.top : 0) || 0;
      node.x0 += offsetX;
      node.x1 += offsetX;
      node.y0 += offsetY;
      node.y1 += offsetY;
    });
  }
  calculateLinkBreadths(nodes) {
    nodes.forEach((node) => {
      const { sourceLinks, targetLinks } = node;
      let y2 = node.y0;
      let y1 = y2;
      sourceLinks.forEach((link) => {
        link.x0 = link.source.x1;
        link.y0 = y2 + link.width / 2;
        y2 += link.width;
      });
      targetLinks.forEach((link) => {
        link.x1 = link.target.x0;
        link.y1 = y1 + link.width / 2;
        y1 += link.width;
      });
    });
  }
  uncurlLinksToRight(columns, targetColumnIndex) {
    const n21 = columns.length;
    for (let i37 = targetColumnIndex; i37 < n21; i37++) {
      const column = columns[i37];
      column.forEach((target) => {
        let y2 = 0;
        let sum2 = 0;
        target.targetLinks.forEach((link) => {
          let kValue = link.value * (target.layer - link.source.layer);
          y2 += this.targetTopPos(link.source, target) * kValue;
          sum2 += kValue;
        });
        let dy = y2 === 0 ? 0 : y2 / sum2 - target.y0;
        target.y0 += dy;
        target.y1 += dy;
        sortLinks([target]);
      });
      column.sort(sortAsc);
      this.arrangeNodesVertically(column);
    }
  }
  uncurlLinksToLeft(columns, targetColumnIndex) {
    const l7 = columns.length;
    const startIndex = l7 - 1 - targetColumnIndex;
    for (let i37 = startIndex; i37 >= 0; i37--) {
      const column = columns[i37];
      for (let j = 0; j < column.length; j++) {
        const source = column[j];
        let y2 = 0;
        let sum2 = 0;
        source.sourceLinks.forEach((link) => {
          let kValue = link.value * (link.target.layer - source.layer);
          y2 += this.sourceTopPos(source, link.target) * kValue;
          sum2 += kValue;
        });
        let dy = y2 === 0 ? 0 : y2 / sum2 - source.y0;
        source.y0 += dy;
        source.y1 += dy;
        sortLinks([source]);
      }
      column.sort(sortAsc);
      this.arrangeNodesVertically(column);
    }
  }
  arrangeNodesVertically(nodes) {
    const startIndex = 0;
    const endIndex = nodes.length - 1;
    this.arrangeUp(nodes, this.height, endIndex);
    this.arrangeDown(nodes, this.offsetY, startIndex);
  }
  arrangeDown(nodes, yPos, index) {
    let currentY = yPos;
    for (let i37 = index; i37 < nodes.length; i37++) {
      const node = nodes[i37];
      const dy = Math.max(0, currentY - node.y0);
      node.y0 += dy;
      node.y1 += dy;
      currentY = node.y1 + this.nodePadding;
    }
  }
  arrangeUp(nodes, yPos, index) {
    let currentY = yPos;
    for (let i37 = index; i37 >= 0; --i37) {
      const node = nodes[i37];
      const dy = Math.max(0, node.y1 - currentY);
      node.y0 -= dy;
      node.y1 -= dy;
      currentY = node.y0 - this.nodePadding;
    }
  }
  sourceTopPos(source, target) {
    let y2 = target.y0 - (target.targetLinks.length - 1) * this.nodePadding / 2;
    for (let i37 = 0; i37 < target.targetLinks.length; i37++) {
      const link = target.targetLinks[i37];
      if (link.source === source) {
        break;
      }
      y2 += link.width + this.nodePadding;
    }
    for (let i37 = 0; i37 < source.sourceLinks.length; i37++) {
      const link = source.sourceLinks[i37];
      if (link.target === target) {
        break;
      }
      y2 -= link.width;
    }
    return y2;
  }
  targetTopPos(source, target) {
    let y2 = source.y0 - (source.sourceLinks.length - 1) * this.nodePadding / 2;
    for (let i37 = 0; i37 < source.sourceLinks.length; i37++) {
      const link = source.sourceLinks[i37];
      if (link.target === target) {
        break;
      }
      y2 += link.width + this.nodePadding;
    }
    for (let i37 = 0; i37 < target.targetLinks.length; i37++) {
      const link = target.targetLinks[i37];
      if (link.source === source) {
        break;
      }
      y2 -= link.width;
    }
    return y2;
  }
};
var calculateSankey = (options) => new Sankey(options).calculate();
var crossesValue = (links) => {
  let value2 = 0;
  const linksLength = links.length;
  for (let i37 = 0; i37 < linksLength; i37++) {
    const link = links[i37];
    for (let lNext = i37 + 1; lNext < linksLength; lNext++) {
      const nextLink = links[lNext];
      if (intersect(link, nextLink)) {
        value2 += Math.min(link.value, nextLink.value);
      }
    }
  }
  return value2;
};
function rotationDirection(p1x, p1y, p2x, p2y, p3x, p3y) {
  const expression1 = (p3y - p1y) * (p2x - p1x);
  const expression2 = (p2y - p1y) * (p3x - p1x);
  if (expression1 > expression2) {
    return 1;
  } else if (expression1 === expression2) {
    return 0;
  }
  return -1;
}
function intersect(link1, link2) {
  const f1 = rotationDirection(link1.x0, link1.y0, link1.x1, link1.y1, link2.x1, link2.y1);
  const f22 = rotationDirection(link1.x0, link1.y0, link1.x1, link1.y1, link2.x0, link2.y0);
  const f32 = rotationDirection(link1.x0, link1.y0, link2.x0, link2.y0, link2.x1, link2.y1);
  const f42 = rotationDirection(link1.x1, link1.y1, link2.x0, link2.y0, link2.x1, link2.y1);
  return f1 !== f22 && f32 !== f42;
}

// node_modules/@progress/kendo-charts/dist/es/sankey/element.js
var SankeyElement = class {
  constructor(options) {
    this.options = deepExtend({}, this.options, options);
    this.createVisual();
  }
  createVisual() {
    this.visual = this.createElement();
  }
  exportVisual() {
    return this.visual;
  }
  createElement() {
    const customVisual = this.options.visual;
    let visual;
    if (customVisual) {
      visual = customVisual({
        sender: this.getSender(),
        options: this.visualOptions(),
        createVisual: () => this.getElement()
      });
    } else {
      visual = this.getElement();
    }
    return visual;
  }
  getSender() {
    return this;
  }
};

// node_modules/@progress/kendo-charts/dist/es/sankey/node.js
var Node = class extends SankeyElement {
  getElement() {
    return drawing_exports.Path.fromRect(this.getRect(), this.visualOptions());
  }
  getRect() {
    const node = this.options.node;
    return new geometry_exports.Rect([node.x0, node.y0], [node.x1 - node.x0, node.y1 - node.y0]);
  }
  getLabelText(options) {
    let labelTemplate = options.labels.ariaTemplate;
    if (labelTemplate) {
      return labelTemplate({ node: options.node });
    }
  }
  visualOptions() {
    const options = deepExtend({}, this.options, this.options.node);
    const ariaLabel = this.getLabelText(options);
    return {
      fill: {
        color: options.color,
        opacity: options.opacity
      },
      stroke: { width: 0 },
      className: "k-sankey-node",
      role: "graphics-symbol",
      ariaRoleDescription: "Node",
      ariaLabel
    };
  }
  createFocusHighlight() {
    if (!this.options.navigatable) {
      return;
    }
    this._highlight = drawing_exports.Path.fromRect(this.getRect(), {
      stroke: this.options.focusHighlight.border,
      visible: false
    });
    return this._highlight;
  }
  focus(options) {
    if (this._highlight) {
      const { highlight = true } = options || {};
      if (highlight) {
        this._highlight.options.set("visible", true);
      }
      const id = this.options.node.id;
      this.visual.options.set("id", id);
      if (this.options.root()) {
        this.options.root().setAttribute(ARIA_ACTIVE_DESCENDANT, id);
      }
    }
  }
  blur() {
    if (this._highlight) {
      this._highlight.options.set("visible", false);
      this.visual.options.set("id", "");
      if (this.options.root()) {
        this.options.root().removeAttribute(ARIA_ACTIVE_DESCENDANT);
      }
    }
  }
};
var nodeColor = (node, nodeColors, index) => node.color || nodeColors[index % nodeColors.length];
var resolveNodeOptions = (node, options, nodeColors, index) => {
  const nodeOptions = deepExtend({}, options, options.node);
  return deepExtend(
    {},
    { color: nodeColor(node, nodeColors, index) },
    nodeOptions,
    { node },
    {
      visual: node.visual,
      opacity: node.opacity,
      offset: node.offset,
      color: node.color
    }
  );
};

// node_modules/@progress/kendo-charts/dist/es/sankey/link.js
var bezierPoint = (p1, p22, p32, p42, t43) => {
  const t1 = 1 - t43;
  const t1t1 = t1 * t1;
  const tt = t43 * t43;
  return p1 * t1t1 * t1 + 3 * p22 * t43 * t1t1 + 3 * p32 * tt * t1 + p42 * tt * t43;
};
function calculatePerpendicularLine(x1, y1, x22, y2, L2) {
  let xM = (x1 + x22) / 2;
  let yM = (y1 + y2) / 2;
  let dx, dy;
  if (y1 === y2) {
    dx = 0;
    dy = L2 / 2;
  } else if (x1 === x22) {
    dx = L2 / 2;
    dy = 0;
  } else {
    let m10 = (y2 - y1) / (x22 - x1);
    let mPerp = -1 / m10;
    dx = L2 / 2 / Math.sqrt(1 + mPerp * mPerp);
    dy = mPerp * dx;
  }
  let P1 = { x: xM - dx, y: yM - dy };
  let P2 = { x: xM + dx, y: yM + dy };
  return { P1, P2 };
}
function findIntersection(a50, b2, L2, p9, q) {
  const midpoint = {
    x: (a50.x + b2.x) / 2,
    y: (a50.y + b2.y) / 2
  };
  const ab_dx = b2.x - a50.x;
  const ab_dy = b2.y - a50.y;
  let perp_dx = -ab_dy;
  let perp_dy = ab_dx;
  const magnitude = Math.sqrt(perp_dx * perp_dx + perp_dy * perp_dy);
  perp_dx = perp_dx / magnitude * L2;
  perp_dy = perp_dy / magnitude * L2;
  const c1 = {
    x: midpoint.x + perp_dx,
    y: midpoint.y + perp_dy
  };
  const c22 = {
    x: midpoint.x - perp_dx,
    y: midpoint.y - perp_dy
  };
  const pq_dx = q.x - p9.x;
  const pq_dy = q.y - p9.y;
  const denominator = pq_dy * (c1.x - c22.x) - pq_dx * (c1.y - c22.y);
  if (Math.abs(denominator) < 1e-10) {
    return null;
  }
  const ua = (pq_dx * (c22.y - p9.y) - pq_dy * (c22.x - p9.x)) / denominator;
  const ub = ((c1.x - c22.x) * (c22.y - p9.y) - (c1.y - c22.y) * (c22.x - p9.x)) / denominator;
  if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
    const intersection2 = {
      x: c22.x + ua * (c1.x - c22.x)
      // y: c2.y + ua * (c1.y - c2.y)
    };
    return intersection2;
  }
  return null;
}
var calculateControlPointsOffsetX = (link, rtl) => {
  const halfWidth = link.width / 2;
  const x0 = rtl ? link.x1 : link.x0;
  const x1 = rtl ? link.x0 : link.x1;
  const y0 = rtl ? link.y1 : link.y0;
  const y1 = rtl ? link.y0 : link.y1;
  const xC = (x0 + x1) / 2;
  const middlePoint = [xC, bezierPoint(y0, y0, y1, y1, 0.5)];
  const tH = 0.4999;
  const pointH = [
    bezierPoint(x0, xC, xC, x1, tH),
    bezierPoint(y0, y0, y1, y1, tH)
  ];
  const line = calculatePerpendicularLine(middlePoint[0], middlePoint[1], pointH[0], pointH[1], link.width);
  const middlePointDown = [xC, bezierPoint(y0 + halfWidth, y0 + halfWidth, y1 + halfWidth, y1 + halfWidth, 0.5)];
  const P2 = line.P1.y > line.P2.y ? line.P1 : line.P2;
  const L2 = halfWidth;
  const LDir = (y0 > y1 ? 1 : -1) * L2;
  const a50 = P2;
  const b2 = { x: middlePointDown[0], y: middlePointDown[1] };
  const p9 = { x: middlePointDown[0], y: middlePointDown[1] };
  const q = { x: Math.max(1, middlePointDown[0] + LDir), y: middlePointDown[1] };
  const Pmx = findIntersection(a50, b2, L2, p9, q) || { x: (middlePointDown[0] + P2.x) / 2 };
  const P1 = x0;
  const P4 = x1;
  const P22 = (Pmx.x - 0.125 * P1 - 0.125 * P4) / 0.75;
  return xC - P22;
};
var Link = class extends SankeyElement {
  getElement() {
    const link = this.options.link;
    const { x0, x1, y0, y1 } = link;
    const xC = (x0 + x1) / 2;
    return new drawing_exports.Path(this.visualOptions()).moveTo(x0, y0).curveTo([xC, y0], [xC, y1], [x1, y1]);
  }
  getLabelText(options) {
    let labelTemplate = options.labels.ariaTemplate;
    if (labelTemplate) {
      return labelTemplate({ link: options.link });
    }
  }
  visualOptions() {
    const options = this.options;
    const link = this.options.link;
    const ariaLabel = this.getLabelText(options);
    return {
      stroke: {
        width: options.link.width,
        color: link.color || options.color,
        opacity: defined(link.opacity) ? link.opacity : options.opacity
      },
      role: "graphics-symbol",
      ariaRoleDescription: "Link",
      ariaLabel
    };
  }
  createFocusHighlight() {
    if (!this.options.navigatable) {
      return;
    }
    const { link } = this.options;
    const { x0, x1, y0, y1 } = link;
    const xC = (x0 + x1) / 2;
    const halfWidth = link.width / 2;
    const offset = calculateControlPointsOffsetX(link, this.options.rtl);
    this._highlight = new drawing_exports.Path({ stroke: this.options.focusHighlight.border, visible: false }).moveTo(x0, y0 + halfWidth).lineTo(x0, y0 - halfWidth).curveTo([xC + offset, y0 - halfWidth], [xC + offset, y1 - halfWidth], [x1, y1 - halfWidth]).lineTo(x1, y1 + halfWidth).curveTo([xC - offset, y1 + halfWidth], [xC - offset, y0 + halfWidth], [x0, y0 + halfWidth]);
  }
  focus(options) {
    if (this._highlight) {
      const { highlight = true } = options || {};
      if (highlight) {
        this._highlight.options.set("visible", true);
      }
      const id = `${this.options.link.sourceId}->${this.options.link.targetId}`;
      this.visual.options.set("id", id);
      if (this.options.root()) {
        this.options.root().setAttribute(ARIA_ACTIVE_DESCENDANT, id);
      }
    }
  }
  blur() {
    if (this._highlight) {
      this._highlight.options.set("visible", false);
      this.visual.options.set("id", "");
      if (this.options.root()) {
        this.options.root().removeAttribute(ARIA_ACTIVE_DESCENDANT);
      }
    }
  }
};
var resolveLinkOptions = (link, options, sourceNode, targetNode) => {
  const linkOptions = deepExtend(
    {},
    options,
    {
      link,
      opacity: link.opacity,
      color: link.color,
      colorType: link.colorType,
      visual: link.visual,
      highlight: link.highlight
    }
  );
  if (linkOptions.colorType === "source") {
    linkOptions.color = sourceNode.options.fill.color;
  } else if (linkOptions.colorType === "target") {
    linkOptions.color = targetNode.options.fill.color;
  }
  return linkOptions;
};

// node_modules/@progress/kendo-charts/dist/es/sankey/label.js
var INSIDE3 = "inside";
var BEFORE = "before";
var AFTER = "after";
var Label = class extends SankeyElement {
  getElement() {
    const options = deepExtend({}, this.options, this.options.node.label);
    const { node, diagramMinX, diagramMaxX, text, offset, rtl } = options;
    let position = options.position;
    if (rtl && position !== INSIDE3) {
      position = position === BEFORE ? AFTER : BEFORE;
    }
    if (!options.visible || !text) {
      return null;
    }
    const nodeBox = new box_default(node.x0, node.y0, node.x1, node.y1);
    const visualOptions = this.visualOptions();
    if (rtl && !visualOptions.align) {
      visualOptions.align = "right";
    }
    const textbox = new text_box_default(text, visualOptions);
    textbox.reflow(new box_default());
    const textSizeBox = textbox.box;
    const textY = nodeBox.center().y - textSizeBox.height() / 2;
    const labelAfterLastNode = node.x1 + textSizeBox.width() > diagramMaxX;
    const labelBeforeFirstNode = node.x0 - textSizeBox.width() < diagramMinX;
    let side = position === BEFORE || position === INSIDE3 && labelAfterLastNode ? BEFORE : AFTER;
    if (rtl) {
      side = position === AFTER || position === INSIDE3 && labelBeforeFirstNode ? AFTER : BEFORE;
    }
    const textOrigin = [side === BEFORE ? node.x0 - textSizeBox.width() : node.x1, textY];
    const textRect = new box_default(textOrigin[0], textOrigin[1], textOrigin[0] + textSizeBox.width(), textOrigin[1] + textSizeBox.height());
    textRect.translate(offset.left || 0, offset.top || 0);
    textbox.reflow(textRect);
    textbox.renderVisual();
    return textbox.visual;
  }
  visualOptions() {
    const options = deepExtend({}, this.options, this.options.node.label);
    return {
      color: options.color,
      font: options.font,
      border: options.border,
      margin: options.margin,
      padding: options.padding,
      align: options.align,
      paintOrder: options.paintOrder,
      stroke: options.stroke
    };
  }
};
setDefaultOptions(Label, {
  position: INSIDE3
  // inside, before, after
});
var resolveLabelOptions = (node, options, rtl, diagramMinX, diagramMaxX) => deepExtend(
  {},
  options,
  {
    node,
    diagramMinX,
    diagramMaxX,
    rtl,
    visual: node.label.visual,
    visible: node.label.visible,
    margin: node.label.margin,
    padding: node.label.padding,
    border: node.label.border,
    align: node.label.align,
    offset: node.label.offset
  }
);

// node_modules/@progress/kendo-charts/dist/es/sankey/title.js
var Title2 = class extends SankeyElement {
  getElement() {
    const options = this.options;
    const { drawingRect, text } = options;
    if (options.visible === false || !text) {
      return null;
    }
    const title3 = title_default.buildTitle(text, options);
    title3.reflow(drawingRect);
    title3.renderVisual();
    return title3.visual;
  }
  createElement() {
    return this.getElement();
  }
};
setDefaultOptions(Title2, {
  align: CENTER,
  // 'left', 'right', 'center'
  border: {
    width: 0
  },
  margin: getSpacing(5),
  padding: getSpacing(5)
});

// node_modules/@progress/kendo-charts/dist/es/sankey/legend.js
var sortData = (a50, b2) => {
  if (a50.node.x0 - b2.node.x0 !== 0) {
    return a50.node.x0 - b2.node.x0;
  }
  return a50.node.y0 - b2.node.y0;
};
var sortDataRTL = (a50, b2) => {
  if (a50.node.x1 - b2.node.x1 !== 0) {
    return a50.node.x1 - b2.node.x1;
  }
  return b2.node.y0 - a50.node.y0;
};
var sort = (rtl) => rtl ? sortDataRTL : sortData;
var Legend2 = class extends SankeyElement {
  getElement() {
    const options = this.options;
    const { drawingRect, rtl, nodes = [], item, position } = options;
    if (options.visible === false || !nodes.length) {
      return null;
    }
    const labels = options.labels || {};
    let labelsTemplate;
    if (labels.content) {
      labelsTemplate = getTemplate(labels);
    }
    const data = nodes.map((node) => {
      const text = node.label && node.label.text || "";
      return {
        text: labelsTemplate ? labelsTemplate({ text, node }) : text,
        area: {
          background: item.areaBackground !== void 0 ? item.areaBackground : node.color,
          opacity: item.areaOpacity !== void 0 ? item.areaOpacity : node.opacity
        },
        node
      };
    });
    data.sort(sort(rtl));
    const reverse = rtl && position !== LEFT && position !== RIGHT;
    const legend2 = new legend_default(Object.assign({}, options, { data, reverse }), { rtl });
    legend2.reflow(drawingRect);
    legend2.renderVisual();
    return legend2.visual;
  }
  createElement() {
    return this.getElement();
  }
};
setDefaultOptions(Legend2, {
  markers: { visible: false },
  item: {
    type: AREA,
    cursor: POINTER,
    opacity: 1
  },
  position: BOTTOM,
  align: CENTER,
  accessibility: {
    role: "presentation",
    ariaLabel: null,
    ariaRoleDescription: null
  },
  border: {
    width: 0
  }
});

// node_modules/@progress/kendo-charts/dist/es/sankey/sankey.js
var LINK = "link";
var NODE = "node";
var toRtl = (sankey) => {
  const { nodes, links } = sankey;
  const startX = Math.min(...nodes.map((node) => node.x0));
  const endX = Math.max(...nodes.map((node) => node.x1));
  const width = endX - startX;
  nodes.forEach((node) => {
    const x0 = width - (node.x1 - 2 * startX);
    const x1 = width - (node.x0 - 2 * startX);
    node.x0 = x0;
    node.x1 = x1;
  });
  links.forEach((link) => {
    const x0 = width - (link.x1 - 2 * startX);
    const x1 = width - (link.x0 - 2 * startX);
    link.x1 = x0;
    link.x0 = x1;
  });
};
var Sankey2 = class extends Observable {
  constructor(element, options, theme) {
    super();
    this._initTheme(theme);
    this._setOptions(options);
    this._initElement(element);
    this._initSurface();
    if (options && options.data) {
      this._redraw();
      this._initResizeObserver();
      this._initNavigation(element);
    }
  }
  destroy() {
    this.unbind();
    this._destroySurface();
    this._destroyResizeObserver();
    if (this.element) {
      this.element.removeEventListener("keydown", this._keydownHandler);
      this.element.removeEventListener("focus", this._focusHandler);
      this.element.removeEventListener("mousedown", this._onDownHandler);
      this.element.removeEventListener("touchstart", this._onDownHandler);
      this.element.removeEventListener("pointerdown", this._onDownHandler);
    }
    this._focusState = null;
    this.element = null;
  }
  _initElement(element) {
    this.element = element;
    addClass(element, ["k-chart", "k-sankey"]);
    element.setAttribute("role", "graphics-document");
    const { title: title3 } = this.options;
    if (title3.text) {
      element.setAttribute("aria-label", title3.text);
    }
    if (title3.description) {
      element.setAttribute("aria-roledescription", title3.description);
    }
  }
  _initSurface() {
    if (!this.surface) {
      this._destroySurface();
      this._initSurfaceElement();
      this.surface = this._createSurface();
    }
  }
  _initNavigation(element) {
    element.tabIndex = element.getAttribute("tabindex") || 0;
    if (this.options.disableKeyboardNavigation) {
      return;
    }
    this._keydownHandler = this._keydown.bind(this);
    this._focusHandler = this._focus.bind(this);
    this._blurHandler = this._blur.bind(this);
    this._onDownHandler = this._onDown.bind(this);
    element.addEventListener("keydown", this._keydownHandler);
    element.addEventListener("focus", this._focusHandler);
    element.addEventListener("blur", this._blurHandler);
    element.addEventListener("mousedown", this._onDownHandler);
    element.addEventListener("touchstart", this._onDownHandler);
    element.addEventListener("pointerdown", this._onDownHandler);
    this._focusState = {
      node: this.firstFocusableNode(),
      link: null
    };
  }
  firstFocusableNode() {
    return this.columns[0][0];
  }
  _initResizeObserver() {
    const observer = new ResizeObserver((entries) => {
      entries.forEach((entry) => {
        const { width, height } = entry.contentRect;
        if (entry.target !== this.element || this.size && this.size.width === width && this.size.height === height) {
          return;
        }
        this.size = { width, height };
        this.surface.setSize(this.size);
        this.resize = true;
        this._redraw();
      });
    });
    this._resizeObserver = observer;
    observer.observe(this.element);
  }
  _createSurface() {
    return drawing_exports.Surface.create(this.surfaceElement, {
      mouseenter: this._mouseenter.bind(this),
      mouseleave: this._mouseleave.bind(this),
      mousemove: this._mousemove.bind(this),
      click: this._click.bind(this)
    });
  }
  _initTheme(theme) {
    let currentTheme = theme || this.theme || {};
    this.theme = currentTheme;
    this.options = deepExtend({}, currentTheme, this.options);
  }
  setLinksOpacity(opacity) {
    this.linksVisuals.forEach((link) => {
      this.setOpacity(link, opacity, link.linkOptions.opacity);
    });
  }
  setLinksInactivityOpacity(inactiveOpacity) {
    this.linksVisuals.forEach((link) => {
      this.setOpacity(link, inactiveOpacity, link.linkOptions.highlight.inactiveOpacity);
    });
  }
  setOpacity(link, opacity, linkValue) {
    link.options.set("stroke", Object.assign(
      {},
      link.options.stroke,
      { opacity: defined(linkValue) ? linkValue : opacity }
    ));
  }
  trigger(name, ev) {
    let dataItem = ev.element.dataItem;
    const targetType = ev.element.type;
    const event = Object.assign(
      {},
      ev,
      {
        type: name,
        targetType,
        dataItem
      }
    );
    return super.trigger(name, event);
  }
  _mouseenter(ev) {
    const element = ev.element;
    const isLink = element.type === LINK;
    const isNode = element.type === NODE;
    const isLegendItem = Boolean(element.chartElement && element.chartElement.options.node);
    if (isLink && this.trigger("linkEnter", ev) || isNode && this.trigger("nodeEnter", ev)) {
      return;
    }
    const { highlight } = this.options.links;
    if (isLink) {
      this.setLinksInactivityOpacity(highlight.inactiveOpacity);
      this.setOpacity(element, highlight.opacity, element.linkOptions.highlight.opacity);
    } else if (isNode) {
      this.highlightLinks(element, highlight);
    } else if (isLegendItem) {
      const nodeVisual = this.nodesVisuals.get(element.chartElement.options.node.id);
      this.highlightLinks(nodeVisual, highlight);
    }
  }
  _mouseleave(ev) {
    const element = ev.element;
    const isLink = element.type === LINK;
    const isNode = element.type === NODE;
    const isLegendItem = Boolean(element.chartElement && element.chartElement.options.node);
    const target = ev.originalEvent.relatedTarget;
    if (isLink && target && target.nodeName === "text") {
      return;
    }
    if (isLink || isNode) {
      if (this.tooltipTimeOut) {
        clearTimeout(this.tooltipTimeOut);
        this.tooltipTimeOut = null;
      }
      this.tooltipShown = false;
      this.trigger("tooltipHide", ev);
    }
    if (isLink && this.trigger("linkLeave", ev) || isNode && this.trigger("nodeLeave", ev)) {
      return;
    }
    if (isLink || isNode || isLegendItem) {
      this.linksVisuals.forEach((link) => {
        this.setOpacity(link, this.options.links.opacity, link.linkOptions.opacity);
      });
    }
  }
  _mousemove(ev) {
    const { followPointer, delay } = this.options.tooltip;
    const element = ev.element;
    const tooltipElType = element.type;
    if (tooltipElType !== LINK && tooltipElType !== NODE || this.tooltipShown && !followPointer) {
      return;
    }
    const mouseEvent = ev.originalEvent;
    const rect = this.element.getBoundingClientRect();
    const isLeft = mouseEvent.clientX - rect.left < rect.width / 2;
    const isTop = mouseEvent.clientY - rect.top < rect.height / 2;
    ev.tooltipData = {
      popupOffset: {
        left: mouseEvent.pageX,
        top: mouseEvent.pageY
      },
      popupAlign: {
        horizontal: isLeft ? "left" : "right",
        vertical: isTop ? "top" : "bottom"
      }
    };
    if (tooltipElType === NODE) {
      const { sourceLinks, targetLinks } = element.dataItem;
      const links = targetLinks.length ? targetLinks : sourceLinks;
      ev.nodeValue = links.reduce((acc, link) => acc + link.value, 0);
    }
    if (this.tooltipTimeOut) {
      clearTimeout(this.tooltipTimeOut);
      this.tooltipTimeOut = null;
    }
    const nextDelay = followPointer && this.tooltipShown ? 0 : delay;
    this.tooltipTimeOut = setTimeout(() => {
      this.trigger("tooltipShow", ev);
      this.tooltipShown = true;
      this.tooltipTimeOut = null;
    }, nextDelay);
  }
  _click(ev) {
    const element = ev.element;
    const dataItem = element.dataItem;
    const isLink = element.type === LINK;
    const isNode = element.type === NODE;
    const focusState = this._focusState || {};
    if (isNode) {
      const focusedNodeClicked = !focusState.link && this.sameNode(focusState.node, dataItem);
      if (!focusedNodeClicked) {
        this._focusState = { node: dataItem, link: null };
        this._focusNode({ highlight: false });
      }
      this.trigger("nodeClick", ev);
    } else if (isLink) {
      const link = {
        sourceId: dataItem.source.id,
        targetId: dataItem.target.id,
        value: dataItem.value
      };
      const focusedLinkClicked = this.sameLink(focusState.link, link);
      if (!focusedLinkClicked) {
        this._focusState = { node: dataItem.source, link };
        this._focusLink({ highlight: false });
      }
      this.trigger("linkClick", ev);
    }
  }
  sameNode(node1, node2) {
    return node1 && node2 && node1.id === node2.id;
  }
  sameLink(link1, link2) {
    return link1 && link2 && link1.sourceId === link2.sourceId && link1.targetId === link2.targetId;
  }
  _focusNode(options) {
    this._cleanFocusHighlight();
    const nodeData = this._focusState.node;
    const node = this.models.map.get(nodeData.id);
    node.focus(options);
  }
  _focusLink(options) {
    this._cleanFocusHighlight();
    const linkData = this._focusState.link;
    const link = this.models.map.get(`${linkData.sourceId}-${linkData.targetId}`);
    link.focus(options);
  }
  _focusNextNode(direction = 1) {
    const current4 = this._focusState.node;
    const columnIndex = this.columns.findIndex((column) => column.find((n21) => n21.id === current4.id));
    const columnNodes = this.columns[columnIndex];
    const nodeIndex = columnNodes.findIndex((n21) => n21.id === current4.id);
    const nextNode = columnNodes[nodeIndex + direction];
    if (nextNode) {
      this._focusState.node = nextNode;
      this._focusNode();
    }
  }
  _focusNextLink(direction = 1) {
    const node = this._focusState.node;
    const link = this._focusState.link;
    const sourceLinkIndex = node.sourceLinks.findIndex((l7) => l7.sourceId === link.sourceId && l7.targetId === link.targetId);
    const targetLinkIndex = node.targetLinks.findIndex((l7) => l7.sourceId === link.sourceId && l7.targetId === link.targetId);
    if (sourceLinkIndex !== -1) {
      const nextLink = node.sourceLinks[sourceLinkIndex + direction];
      if (nextLink) {
        this._focusState.link = nextLink;
        this._focusLink();
      }
    } else if (targetLinkIndex !== -1) {
      const nextLink = node.targetLinks[targetLinkIndex + direction];
      if (nextLink) {
        this._focusState.link = nextLink;
        this._focusLink();
      }
    }
  }
  _focusSourceNode() {
    const linkData = this._focusState.link;
    const sourceNode = this.models.map.get(linkData.sourceId);
    this._focusState = { node: sourceNode.options.node, link: null };
    this._focusNode();
  }
  _focusTargetNode() {
    const linkData = this._focusState.link;
    const targetNode = this.models.map.get(linkData.targetId);
    this._focusState = { node: targetNode.options.node, link: null };
    this._focusNode();
  }
  _focusSourceLink() {
    const nodeData = this._focusState.node;
    const sourceLinks = nodeData.sourceLinks;
    const linkData = sourceLinks[0];
    if (linkData) {
      this._focusState.link = linkData;
      this._focusLink();
    }
  }
  _focusTargetLink() {
    const nodeData = this._focusState.node;
    const targetLinks = nodeData.targetLinks;
    const linkData = targetLinks[0];
    if (linkData) {
      this._focusState.link = linkData;
      this._focusLink();
    }
  }
  _focus() {
    if (!this._skipFocusHighlight) {
      if (this._focusState.link) {
        this._focusLink();
      } else {
        this._focusNode();
      }
    }
    this._skipFocusHighlight = false;
  }
  _blur() {
    this._cleanFocusHighlight();
  }
  _onDown() {
    if (!this._hasFocus()) {
      this._skipFocusHighlight = true;
    }
  }
  _hasFocus() {
    return this.element.ownerDocument.activeElement === this.element;
  }
  _cleanFocusHighlight() {
    this.models.nodes.forEach((node) => node.blur());
    this.models.links.forEach((link) => link.blur());
  }
  _keydown(ev) {
    let handler = this["on" + ev.key];
    const rtl = this.options.rtl;
    if (rtl && ev.key === "ArrowLeft") {
      handler = this.onArrowRight;
    } else if (rtl && ev.key === "ArrowRight") {
      handler = this.onArrowLeft;
    }
    if (handler) {
      handler.call(this, ev);
    }
  }
  onEscape(ev) {
    ev.preventDefault();
    this._focusState = { node: this.firstFocusableNode(), link: null };
    this._focusNode();
  }
  onArrowDown(ev) {
    ev.preventDefault();
    if (this._focusState.link) {
      this._focusNextLink(1);
    } else {
      this._focusNextNode(1);
    }
  }
  onArrowUp(ev) {
    ev.preventDefault();
    if (this._focusState.link) {
      this._focusNextLink(-1);
    } else {
      this._focusNextNode(-1);
    }
  }
  onArrowLeft(ev) {
    ev.preventDefault();
    if (this._focusState.link) {
      this._focusSourceNode();
    } else {
      this._focusTargetLink();
    }
  }
  onArrowRight(ev) {
    ev.preventDefault();
    if (this._focusState.link) {
      this._focusTargetNode();
    } else {
      this._focusSourceLink();
    }
  }
  highlightLinks(node, highlight) {
    if (node) {
      this.setLinksInactivityOpacity(highlight.inactiveOpacity);
      node.links.forEach((link) => {
        this.setOpacity(link, highlight.opacity, link.linkOptions.highlight.opacity);
      });
    }
  }
  _destroySurface() {
    if (this.surface) {
      this.surface.destroy();
      this.surface = null;
      this._destroySurfaceElement();
    }
  }
  _destroyResizeObserver() {
    if (this._resizeObserver) {
      this._resizeObserver.disconnect();
      this._resizeObserver = null;
    }
  }
  _initSurfaceElement() {
    if (!this.surfaceElement) {
      this.surfaceElement = document.createElement("div");
      this.element.appendChild(this.surfaceElement);
    }
  }
  _destroySurfaceElement() {
    if (this.surfaceElement && this.surfaceElement.parentNode) {
      this.surfaceElement.parentNode.removeChild(this.surfaceElement);
      this.surfaceElement = null;
    }
  }
  setOptions(options, theme) {
    this._setOptions(options);
    this._initTheme(theme);
    this._initSurface();
    this._redraw();
  }
  _redraw() {
    this.surface.clear();
    const { width, height } = this._getSize();
    this.size = { width, height };
    this.surface.setSize(this.size);
    this.createVisual();
    this.surface.draw(this.visual);
  }
  _getSize() {
    return this.element.getBoundingClientRect();
  }
  createVisual() {
    this.visual = this._render();
  }
  titleBox(title3, drawingRect) {
    if (!title3 || title3.visible === false || !title3.text) {
      return null;
    }
    const titleElement = new Title2(Object.assign({}, { drawingRect }, title3));
    const titleVisual = titleElement.exportVisual();
    return titleVisual.chartElement.box;
  }
  legendBox(options, nodes, drawingRect) {
    if (!options || options.visible === false) {
      return null;
    }
    const legend2 = new Legend2(Object.assign({}, { nodes }, options, { drawingRect }));
    const legendVisual = legend2.exportVisual();
    return legendVisual.chartElement.box;
  }
  calculateSankey(calcOptions, sankeyOptions) {
    const { title: title3, legend: legend2, data, nodes, labels, nodeColors, disableAutoLayout, disableKeyboardNavigation, rtl } = sankeyOptions;
    const autoLayout = !disableAutoLayout;
    const focusHighlightWidth = ((nodes.focusHighlight || {}).border || {}).width || 0;
    const padding = disableKeyboardNavigation ? 0 : focusHighlightWidth / 2;
    const sankeyBox = new box_default(0, 0, calcOptions.width, calcOptions.height);
    sankeyBox.unpad(padding);
    const titleBox = this.titleBox(title3, sankeyBox);
    let legendArea = sankeyBox.clone();
    if (titleBox) {
      const titleHeight = titleBox.height();
      if (title3.position === TOP) {
        sankeyBox.unpad({ top: titleHeight });
        legendArea = new box_default(0, titleHeight, calcOptions.width, calcOptions.height);
      } else {
        sankeyBox.shrink(0, titleHeight);
        legendArea = new box_default(0, 0, calcOptions.width, calcOptions.height - titleHeight);
      }
    }
    const legendBox = this.legendBox(legend2, data.nodes, legendArea);
    const legendPosition = legend2 && legend2.position || Legend2.prototype.options.position;
    if (legendBox) {
      if (legendPosition === LEFT) {
        sankeyBox.unpad({ left: legendBox.width() });
      }
      if (legendPosition === RIGHT) {
        sankeyBox.shrink(legendBox.width(), 0);
      }
      if (legendPosition === TOP) {
        sankeyBox.unpad({ top: legendBox.height() });
      }
      if (legendPosition === BOTTOM) {
        sankeyBox.shrink(0, legendBox.height());
      }
    }
    const { nodes: calculatedNodes, circularLinks } = calculateSankey(Object.assign({}, calcOptions, { offsetX: 0, offsetY: 0, width: sankeyBox.width(), height: sankeyBox.height() }));
    if (circularLinks) {
      console.warn("Circular links detected. Kendo Sankey diagram does not support circular links.");
      return { sankey: { nodes: [], links: [], columns: [[]], circularLinks }, legendBox, titleBox };
    }
    const box = new box_default();
    const diagramMinX = calculatedNodes.reduce((acc, node) => Math.min(acc, node.x0), Infinity);
    const diagramMaxX = calculatedNodes.reduce((acc, node) => Math.max(acc, node.x1), 0);
    calculatedNodes.forEach((nodeEl, i37) => {
      if (rtl) {
        const { x0, x1 } = nodeEl;
        nodeEl.x0 = diagramMaxX - x1;
        nodeEl.x1 = diagramMaxX - x0;
      }
      const nodeOps = resolveNodeOptions(nodeEl, nodes, nodeColors, i37);
      const nodeInstance = new Node(nodeOps);
      box.wrap(rectToBox(nodeInstance.exportVisual().rawBBox()));
      const labelInstance = new Label(resolveLabelOptions(nodeEl, labels, rtl, diagramMinX, diagramMaxX));
      const labelVisual = labelInstance.exportVisual();
      if (labelVisual) {
        box.wrap(rectToBox(labelVisual.rawBBox()));
      }
    });
    let offsetX = sankeyBox.x1;
    let offsetY = sankeyBox.y1;
    let width = sankeyBox.width() + offsetX;
    let height = sankeyBox.height() + offsetY;
    width -= box.x2 > sankeyBox.width() ? box.x2 - sankeyBox.width() : 0;
    height -= box.y2 > sankeyBox.height() ? box.y2 - sankeyBox.height() : 0;
    offsetX += box.x1 < 0 ? -box.x1 : 0;
    offsetY += box.y1 < 0 ? -box.y1 : 0;
    if (autoLayout === false) {
      return {
        sankey: calculateSankey(Object.assign({}, calcOptions, { offsetX, offsetY, width, height, autoLayout: false })),
        legendBox,
        titleBox
      };
    }
    if (this.resize && autoLayout && this.permutation) {
      this.resize = false;
      return {
        sankey: calculateSankey(Object.assign({}, calcOptions, { offsetX, offsetY, width, height }, this.permutation)),
        legendBox,
        titleBox
      };
    }
    const startColumn = 1;
    const loops = 2;
    const columnsLength = calculateSankey(Object.assign({}, calcOptions, { offsetX, offsetY, width, height, autoLayout: false })).columns.length;
    const results = [];
    const permutation = (targetColumnIndex, reverse) => {
      let currPerm = calculateSankey(Object.assign({}, calcOptions, { offsetX, offsetY, width, height, loops, targetColumnIndex, reverse }));
      let crosses = crossesValue(currPerm.links);
      results.push({
        crosses,
        reverse,
        targetColumnIndex
      });
      return crosses === 0;
    };
    for (let index = startColumn; index <= columnsLength - 1; index++) {
      if (permutation(index, false) || permutation(index, true)) {
        break;
      }
    }
    const minCrosses = Math.min.apply(null, results.map((r28) => r28.crosses));
    const bestResult = results.find((r28) => r28.crosses === minCrosses);
    this.permutation = { targetColumnIndex: bestResult.targetColumnIndex, reverse: bestResult.reverse };
    const result = calculateSankey(Object.assign({}, calcOptions, { offsetX, offsetY, width, height }, this.permutation));
    return {
      sankey: result,
      legendBox,
      titleBox
    };
  }
  _render(options, context) {
    const sankeyOptions = options || this.options;
    const sankeyContext = context || this;
    const { labels: labelOptions, nodes: nodesOptions, links: linkOptions, nodeColors, title: title3, legend: legend2, rtl, disableKeyboardNavigation } = sankeyOptions;
    let data = sankeyOptions.data;
    const { width, height } = sankeyContext.size;
    const calcOptions = Object.assign({}, data, { width, height, nodesOptions, title: title3, legend: legend2 });
    const { sankey, titleBox, legendBox } = this.calculateSankey(calcOptions, sankeyOptions);
    if (rtl) {
      toRtl(sankey);
    }
    const { nodes, links, columns } = sankey;
    sankeyContext.columns = columns.map((column) => {
      const newColumn = column.slice();
      newColumn.sort((a50, b2) => a50.y0 - b2.y0);
      return newColumn;
    });
    const visual = new drawing_exports.Group({
      clip: drawing_exports.Path.fromRect(new geometry_exports.Rect([0, 0], [width, height]))
    });
    if (titleBox) {
      const titleElement = new Title2(Object.assign({}, title3, { drawingRect: titleBox }));
      const titleVisual = titleElement.exportVisual();
      visual.append(titleVisual);
    }
    if (sankey.circularLinks) {
      return visual;
    }
    const visualNodes = /* @__PURE__ */ new Map();
    sankeyContext.nodesVisuals = visualNodes;
    const models = {
      nodes: [],
      links: [],
      map: /* @__PURE__ */ new Map()
    };
    sankeyContext.models = models;
    const focusHighlights = [];
    nodes.forEach((node, i37) => {
      const nodeOps = resolveNodeOptions(node, nodesOptions, nodeColors, i37);
      nodeOps.root = () => sankeyContext.element;
      nodeOps.navigatable = disableKeyboardNavigation !== true;
      const nodeInstance = new Node(nodeOps);
      const nodeVisual = nodeInstance.exportVisual();
      nodeVisual.links = [];
      nodeVisual.type = NODE;
      node.color = nodeOps.color;
      node.opacity = nodeOps.opacity;
      nodeVisual.dataItem = Object.assign(
        {},
        data.nodes[i37],
        {
          color: nodeOps.color,
          opacity: nodeOps.opacity,
          sourceLinks: node.sourceLinks.map((link) => ({ sourceId: link.sourceId, targetId: link.targetId, value: link.value })),
          targetLinks: node.targetLinks.map((link) => ({ sourceId: link.sourceId, targetId: link.targetId, value: link.value }))
        }
      );
      visualNodes.set(node.id, nodeVisual);
      models.nodes.push(nodeInstance);
      models.map.set(node.id, nodeInstance);
      visual.append(nodeVisual);
      nodeInstance.createFocusHighlight();
      if (nodeInstance._highlight) {
        focusHighlights.push(nodeInstance._highlight);
      }
    });
    const sortedLinks = links.slice().sort((a50, b2) => b2.value - a50.value);
    const linksVisuals = [];
    sankeyContext.linksVisuals = linksVisuals;
    sortedLinks.forEach((link) => {
      const { source, target } = link;
      const sourceNode = visualNodes.get(source.id);
      const targetNode = visualNodes.get(target.id);
      const resolvedOptions = resolveLinkOptions(link, linkOptions, sourceNode, targetNode);
      resolvedOptions.root = () => sankeyContext.element;
      resolvedOptions.navigatable = disableKeyboardNavigation !== true;
      resolvedOptions.rtl = rtl;
      const linkInstance = new Link(resolvedOptions);
      const linkVisual = linkInstance.exportVisual();
      linkVisual.type = LINK;
      linkVisual.dataItem = {
        source: Object.assign({}, sourceNode.dataItem),
        target: Object.assign({}, targetNode.dataItem),
        value: link.value
      };
      linkVisual.linkOptions = resolvedOptions;
      linksVisuals.push(linkVisual);
      sourceNode.links.push(linkVisual);
      targetNode.links.push(linkVisual);
      models.links.push(linkInstance);
      models.map.set(`${source.id}-${target.id}`, linkInstance);
      linkInstance.createFocusHighlight();
      if (linkInstance._highlight) {
        focusHighlights.push(linkInstance._highlight);
      }
      visual.append(linkVisual);
    });
    const diagramMinX = nodes.reduce((acc, node) => Math.min(acc, node.x0), Infinity);
    const diagramMaxX = nodes.reduce((acc, node) => Math.max(acc, node.x1), 0);
    nodes.forEach((node) => {
      const textOps = resolveLabelOptions(node, labelOptions, rtl, diagramMinX, diagramMaxX);
      const labelInstance = new Label(textOps);
      const labelVisual = labelInstance.exportVisual();
      if (labelVisual) {
        visual.append(labelVisual);
      }
    });
    if (legendBox) {
      const legendElement = new Legend2(Object.assign({}, legend2, { rtl, drawingRect: legendBox, nodes }));
      const legendVisual = legendElement.exportVisual();
      visual.append(legendVisual);
    }
    if (focusHighlights.length !== 0) {
      const focusHighlight = new drawing_exports.Group();
      focusHighlight.append(...focusHighlights);
      visual.append(focusHighlight);
    }
    return visual;
  }
  exportVisual(exportOptions) {
    const options = exportOptions && exportOptions.options ? deepExtend({}, this.options, exportOptions.options) : this.options;
    const context = {
      size: {
        width: defined(exportOptions && exportOptions.width) ? exportOptions.width : this.size.width,
        height: defined(exportOptions && exportOptions.height) ? exportOptions.height : this.size.height
      }
    };
    return this._render(options, context);
  }
  _setOptions(options) {
    this.options = deepExtend({}, this.options, options);
  }
};
var highlightOptions = {
  opacity: 1,
  width: 2,
  color: BLACK
};
setDefaultOptions(Sankey2, {
  title: {
    position: TOP
    // 'top', 'bottom'
  },
  labels: {
    visible: true,
    margin: {
      left: 8,
      right: 8
    },
    padding: 0,
    border: {
      width: 0
    },
    paintOrder: "stroke",
    stroke: {
      lineJoin: "round",
      width: 1
    },
    offset: { left: 0, top: 0 }
  },
  nodes: {
    width: 24,
    padding: 16,
    opacity: 1,
    align: "stretch",
    // 'left', 'right', 'stretch'
    offset: { left: 0, top: 0 },
    focusHighlight: {
      border: Object.assign({}, highlightOptions)
    },
    labels: {
      ariaTemplate: ({ node }) => node.label.text
    }
  },
  links: {
    colorType: "static",
    // 'source', 'target', 'static'
    opacity: 0.4,
    highlight: {
      opacity: 0.8,
      inactiveOpacity: 0.2
    },
    focusHighlight: {
      border: Object.assign({}, highlightOptions)
    },
    labels: {
      ariaTemplate: ({ link }) => `${link.source.label.text} to ${link.target.label.text}`
    }
  },
  tooltip: {
    followPointer: false,
    delay: 200
  }
});

// node_modules/@progress/kendo-charts/dist/es/sankey/utils.js
var createSankeyData = (data, dimensions, measure) => {
  const nodes = /* @__PURE__ */ new Set();
  const links = /* @__PURE__ */ new Map();
  const linksMap = /* @__PURE__ */ new Map();
  data.forEach((row) => {
    dimensions.forEach((dimension) => {
      nodes.add(dimension.value(row));
    });
    for (let i37 = 0; i37 < dimensions.length - 1; i37++) {
      const source = dimensions[i37].value(row);
      const target = dimensions[i37 + 1].value(row);
      const key = `${source}_${target}`;
      const value2 = measure.value(row);
      const existingValue = links.get(key);
      if (existingValue !== void 0) {
        links.set(key, existingValue + value2);
      } else {
        links.set(key, value2);
        linksMap.set(key, { source, target });
      }
    }
  });
  const nodesId = /* @__PURE__ */ new Map();
  const nodesArray = Array.from(nodes).map((node, index) => {
    nodesId.set(node, index);
    return { id: index, label: { text: String(node) } };
  });
  const linksArray = Array.from(links).map(([key, value2]) => {
    const { source, target } = linksMap.get(key);
    return {
      sourceId: nodesId.get(source),
      targetId: nodesId.get(target),
      value: value2
    };
  });
  return { nodes: nodesArray, links: linksArray };
};

// node_modules/@progress/kendo-charts/dist/es/chart-wizard/get-wizard-data-from-data-rows.js
function getWizardDataFromDataRows(dataRows) {
  const result = [];
  dataRows.forEach((item) => {
    const { dataItem, dataColumns } = item;
    const row = [];
    dataColumns.forEach((column) => {
      row.push({
        field: column.title || column.field,
        value: getter(column.field)(dataItem)
      });
    });
    result.push(row);
  });
  return result;
}

// node_modules/@progress/kendo-charts/dist/es/chart-wizard/state.js
var ActionTypes = Object.freeze({
  seriesType: 0,
  stacked: 1,
  categoryAxisX: 2,
  valueAxisY: 3,
  seriesChange: 4,
  areaMarginLeft: 5,
  areaMarginRight: 6,
  areaMarginTop: 7,
  areaMarginBottom: 8,
  areaBackground: 9,
  titleText: 10,
  titleFontName: 11,
  titleFontSize: 12,
  titleColor: 13,
  subtitleText: 14,
  subtitleFontName: 15,
  subtitleFontSize: 16,
  subtitleColor: 17,
  seriesColor: 18,
  seriesLabel: 19,
  legendVisible: 20,
  legendFontName: 21,
  legendFontSize: 22,
  legendColor: 23,
  legendPosition: 24,
  categoryAxisTitleText: 25,
  categoryAxisTitleFontName: 26,
  categoryAxisTitleFontSize: 27,
  categoryAxisTitleColor: 28,
  categoryAxisLabelsFontName: 29,
  categoryAxisLabelsFontSize: 30,
  categoryAxisLabelsColor: 31,
  categoryAxisLabelsRotation: 32,
  categoryAxisReverseOrder: 33,
  valueAxisTitleText: 34,
  valueAxisTitleFontName: 35,
  valueAxisTitleFontSize: 36,
  valueAxisTitleColor: 37,
  valueAxisLabelsFormat: 38,
  valueAxisLabelsFontName: 39,
  valueAxisLabelsFontSize: 40,
  valueAxisLabelsColor: 41,
  valueAxisLabelsRotation: 42
});
var fontSizes = [
  { text: "10", value: "10px" },
  { text: "12", value: "12px" },
  { text: "14", value: "14px" },
  { text: "16", value: "16px" },
  { text: "20", value: "20px" },
  { text: "28", value: "28px" },
  { text: "42", value: "42px" },
  { text: "56", value: "56px" }
];
var titleSizeDefault = "20px";
var subtitleSizeDefault = "16px";
var labelSizeDefault = "12px";
var axisTitleSizeDefault = "16px";
var fontNames = [
  {
    text: "Arial",
    value: "Arial, Helvetica, sans-serif",
    style: { fontFamily: "Arial, Helvetica, sans-serif" }
  },
  {
    text: "Courier New",
    value: "'Courier New', Courier, monospace",
    style: { fontFamily: "'Courier New', Courier, monospace" }
  },
  {
    text: "Georgia",
    value: "Georgia, serif",
    style: { fontFamily: "Georgia, serif" }
  },
  {
    text: "Impact",
    value: "Impact, Charcoal, sans-serif",
    style: { fontFamily: "Impact, Charcoal, sans-serif" }
  },
  {
    text: "Lucida Console",
    value: "'Lucida Console', Monaco, monospace",
    style: { fontFamily: "'Lucida Console', Monaco, monospace" }
  },
  {
    text: "Tahoma",
    value: "Tahoma, Geneva, sans-serif",
    style: { fontFamily: "Tahoma, Geneva, sans-serif" }
  },
  {
    text: "Times New Roman",
    value: "'Times New Roman', Times,serif",
    style: { fontFamily: "'Times New Roman', Times,serif" }
  },
  {
    text: "Trebuchet MS",
    value: "'Trebuchet MS', Helvetica, sans-serif",
    style: { fontFamily: "'Trebuchet MS', Helvetica, sans-serif" }
  },
  {
    text: "Verdana",
    value: "Verdana, Geneva, sans-serif",
    style: { fontFamily: "Verdana, Geneva, sans-serif" }
  }
];
var fontNameDefault = fontNames[0].value;
var columnType = "column";
var barType = "bar";
var lineType = "line";
var pieType = "pie";
var scatterType = "scatter";
var categoricalTypes = [columnType, barType, lineType, scatterType];
var scatterSeries = {
  type: lineType,
  width: 0
};
function isCategorical(type) {
  return type && categoricalTypes.includes(type);
}
var categoryTypes = ["string", "date", "number"];
var valueTypes = ["number"];
var axesDefinitions = {
  bar: [
    { axisType: "category", types: categoryTypes },
    { axisType: "value", types: valueTypes }
  ],
  column: [
    { axisType: "category", types: categoryTypes },
    { axisType: "value", types: valueTypes }
  ],
  line: [
    { axisType: "category", types: categoryTypes },
    { axisType: "value", types: valueTypes }
  ],
  pie: [
    { axisType: "category", types: categoryTypes },
    { axisType: "value", types: valueTypes, count: 1 }
  ],
  scatter: [
    { axisType: "category", types: categoryTypes },
    { axisType: "value", types: valueTypes }
  ]
};
function getFont(font, size) {
  return `${size || ""} ${font || ""}`.trim();
}
function parseFont(font) {
  const spaceIndex = (font || "").indexOf(" ");
  const size = font && font.substring(0, spaceIndex);
  const name = font && font.substring(spaceIndex + 1);
  return { size, name };
}
var updateFontName = (fontName, defaultSize, currentFont) => {
  const { size } = parseFont(currentFont);
  return fontName ? getFont(fontName, size || defaultSize) : "";
};
var updateFontSize = (fontSize, defaultFontName, currentFont) => {
  const { name } = parseFont(currentFont);
  return fontSize ? getFont(name || defaultFontName, fontSize) : "";
};
var hasValue3 = (value2) => value2 !== void 0 && value2 !== null;
var recordWithValues = (data) => {
  const result = structuredClone(data[0]);
  result.forEach((item, i37) => {
    if (!hasValue3(item.value)) {
      for (let index = 0; index < data.length; index++) {
        const value2 = data[index][i37].value;
        if (hasValue3(value2)) {
          item.value = value2;
          break;
        }
      }
    }
  });
  return result;
};
var getCategoryColumnIndex = (data, categoryDef) => {
  const candidates = [];
  const sampleRecord = recordWithValues(data);
  categoryDef.types.forEach((type) => {
    sampleRecord.forEach((item, i37) => {
      if (typeof item.value === type) {
        candidates.push(i37);
      }
    });
  });
  const result = candidates.findIndex((index) => {
    const values = data.map((record) => record[index].value);
    return new Set(values).size === values.length;
  });
  return Math.max(result, 0);
};
var getValueColumnIndexes = (data, valuesDef) => {
  const candidates = [];
  const sampleRecord = recordWithValues(data);
  valuesDef.forEach((def) => {
    def.types.forEach((type) => {
      sampleRecord.forEach((item, i37) => {
        if (typeof item.value === type) {
          candidates.push(i37);
        }
      });
    });
  });
  return candidates;
};
var emptyState = () => structuredClone({
  columns: [],
  data: [],
  series: [],
  initialSeries: [],
  categoryAxis: [{ categories: [], labels: { visible: true, rotation: "auto" }, title: { text: "" } }],
  valueAxis: [{ labels: { visible: true, rotation: "auto" } }],
  area: {
    margin: {
      left: void 0,
      right: void 0,
      top: void 0,
      bottom: void 0
    }
  },
  title: { text: "" },
  subtitle: { text: "" },
  stack: false
});
var categoryValueChartState = (data, seriesType, options) => {
  const state = emptyState();
  state.seriesType = seriesType;
  state.data = data || [];
  state.legend = { visible: true, position: "bottom" };
  const chartDef = axesDefinitions[seriesType];
  if (!chartDef || !data.length) {
    return state;
  }
  const firstRecord = data[0].slice();
  state.columns = data[0].map((i37) => String(i37.field));
  const categoryDef = chartDef.find((def) => def.axisType === "category");
  let catIndex = -1;
  if (categoryDef) {
    catIndex = options && options.categoryAxis ? state.columns.indexOf(options.categoryAxis) : getCategoryColumnIndex(data, categoryDef);
  }
  const valuesDef = chartDef.filter((def) => def.axisType === "value");
  let valuesIndexes = getValueColumnIndexes(data, valuesDef);
  if (valuesIndexes.includes(catIndex)) {
    if (valuesIndexes.length > 1) {
      valuesIndexes = valuesIndexes.filter((index) => index !== catIndex);
    } else {
      catIndex = -1;
    }
  }
  const series = [];
  valuesIndexes.forEach((index) => {
    const valuesColumn = firstRecord[index];
    const valuesResult = [];
    data.forEach((record) => {
      valuesResult.push(record[index].value);
    });
    series.push(Object.assign(
      {},
      {
        name: valuesColumn.field,
        type: seriesType,
        data: valuesResult,
        stack: false,
        labels: { visible: false }
      },
      seriesType === scatterType ? scatterSeries : {}
    ));
  });
  const categories = catIndex > -1 ? data.map(
    (item) => String(
      hasValue3(item[catIndex].value) ? item[catIndex].value : " "
    )
  ) : [];
  if (series.length) {
    state.series = series.map((s10, i37) => Object.assign({}, s10, { id: i37 }));
    state.initialSeries = structuredClone(state.series);
  }
  state.categoryAxis = [
    { categories, labels: { visible: true, rotation: "auto" } }
  ];
  state.categoryField = state.columns[catIndex];
  return state;
};
var pieChartState = (data, seriesType, options) => {
  const state = emptyState();
  state.seriesType = seriesType;
  state.data = data || [];
  const chartDef = axesDefinitions[seriesType];
  if (!chartDef || !data.length) {
    return state;
  }
  const categoriesAxis = data[0].map((i37) => i37.field);
  const categoryDef = chartDef.find((def) => def.axisType === "category");
  let catIndex = -1;
  if (categoryDef) {
    catIndex = options && options.categoryAxis ? categoriesAxis.indexOf(options.categoryAxis) : getCategoryColumnIndex(data, categoryDef);
  }
  const valuesDef = chartDef.filter((def) => def.axisType === "value");
  let valuesIndexes = [];
  if (options && options.valueAxis) {
    valuesIndexes = [categoriesAxis.indexOf(options.valueAxis)];
  } else {
    valuesIndexes = getValueColumnIndexes(data, valuesDef);
  }
  if (valuesIndexes.includes(catIndex) && valuesIndexes.length > 1) {
    valuesIndexes = valuesIndexes.filter((index) => index !== catIndex);
  }
  if (typeof valuesDef[0].count === "number") {
    valuesIndexes = valuesIndexes.slice(0, valuesDef[0].count);
  }
  const categories = catIndex > -1 ? data.map((item) => String(item[catIndex].value)) : [];
  const flatData = [];
  data.forEach((item) => {
    const record = {};
    valuesIndexes.forEach((index) => {
      const col = item[index];
      record[col.field] = col.value || 0;
      record[item[catIndex].field] = item[catIndex].value || " ";
    });
    flatData.push(record);
  });
  state.columns = categoriesAxis;
  state.categoryAxis = [{ categories, title: { text: "" } }];
  state.series = [
    {
      id: 0,
      data: flatData,
      type: seriesType,
      name: categoriesAxis[catIndex],
      labels: { visible: true },
      categoryField: categoriesAxis[catIndex],
      field: categoriesAxis[valuesIndexes[0]]
    }
  ];
  state.categoryField = categoriesAxis[catIndex];
  state.valueField = categoriesAxis[valuesIndexes[0]];
  state.initialSeries = structuredClone(state.series);
  return state;
};
function createInitialState(data, seriesType, defaultState) {
  const state = createState(
    data,
    defaultState && defaultState.seriesType || seriesType
  );
  return typeof (defaultState && defaultState.stack) !== "undefined" ? updateState(state, ActionTypes.stacked, defaultState.stack) : state;
}
function createState(data, seriesType) {
  return (isCategorical(seriesType) ? categoryValueChartState : pieChartState)(
    data,
    seriesType
  );
}
function mergeStates(source, target) {
  const newState = structuredClone(target);
  newState.legend = source.legend;
  newState.area = source.area;
  newState.title = source.title;
  newState.subtitle = source.subtitle;
  if (newState.series.length === source.series.length) {
    for (let i37 = 0; i37 < newState.series.length; i37++) {
      newState.series[i37].color = source.series[i37].color;
      newState.series[i37].labels = source.series[i37].labels;
    }
  }
  if (source.series.every((s10) => s10.labels && s10.labels.visible) && isCategorical(newState.seriesType) && isCategorical(source.seriesType)) {
    newState.series.forEach((s10) => {
      s10.labels = s10.labels || {};
      s10.labels.visible = true;
    });
  }
  return newState;
}
function updateState(currentState, action, value2) {
  const state = Object.assign({}, currentState);
  switch (action) {
    case ActionTypes.seriesType:
      return createState(state.data, value2);
    case ActionTypes.stacked:
      state.series = state.series.map((s10) => Object.assign({}, s10, { stack: value2 }));
      state.stack = value2;
      return state;
    case ActionTypes.categoryAxisX: {
      if (state.seriesType && isCategorical(state.seriesType)) {
        const newState = categoryValueChartState(
          state.data,
          state.seriesType,
          { categoryAxis: value2 }
        );
        return mergeStates(state, newState);
      } else if (state.seriesType === pieType) {
        const newState = pieChartState(state.data, state.seriesType, {
          categoryAxis: value2
        });
        return mergeStates(state, newState);
      }
      return state;
    }
    case ActionTypes.valueAxisY: {
      if (state.seriesType === pieType) {
        const newState = pieChartState(state.data, state.seriesType, {
          categoryAxis: state.categoryField,
          valueAxis: value2
        });
        return mergeStates(state, newState);
      }
      return state;
    }
    case ActionTypes.seriesChange:
      state.series = value2;
      return state;
    case ActionTypes.areaMarginLeft:
      state.area = Object.assign(
        {},
        state.area,
        { margin: Object.assign(
          {},
          state.area && state.area.margin || {},
          { left: value2 }
        ) }
      );
      return state;
    case ActionTypes.areaMarginRight:
      state.area = Object.assign(
        {},
        state.area,
        { margin: Object.assign(
          {},
          state.area && state.area.margin || {},
          { right: value2 }
        ) }
      );
      return state;
    case ActionTypes.areaMarginTop:
      state.area = Object.assign(
        {},
        state.area,
        { margin: Object.assign(
          {},
          state.area && state.area.margin || {},
          { top: value2 }
        ) }
      );
      return state;
    case ActionTypes.areaMarginBottom:
      state.area = Object.assign(
        {},
        state.area,
        { margin: Object.assign(
          {},
          state.area && state.area.margin || {},
          { bottom: value2 }
        ) }
      );
      return state;
    case ActionTypes.areaBackground:
      state.area = Object.assign({}, state.area, { background: value2 });
      return state;
    case ActionTypes.titleText:
      state.title = Object.assign({}, state.title, { text: value2 });
      return state;
    case ActionTypes.titleFontName: {
      state.title = Object.assign(
        {},
        state.title,
        { font: updateFontName(
          value2,
          titleSizeDefault,
          state.title && state.title.font
        ) }
      );
      return state;
    }
    case ActionTypes.titleFontSize:
      state.title = Object.assign(
        {},
        state.title,
        { font: updateFontSize(
          value2,
          fontNameDefault,
          state.title && state.title.font
        ) }
      );
      return state;
    case ActionTypes.titleColor:
      state.title = Object.assign({}, state.title, { color: value2 });
      return state;
    case ActionTypes.subtitleText:
      state.subtitle = Object.assign({}, state.subtitle, { text: value2 });
      return state;
    case ActionTypes.subtitleFontName:
      state.subtitle = Object.assign(
        {},
        state.subtitle,
        { font: updateFontName(
          value2,
          subtitleSizeDefault,
          state.subtitle && state.subtitle.font
        ) }
      );
      return state;
    case ActionTypes.subtitleFontSize:
      state.subtitle = Object.assign(
        {},
        state.subtitle,
        { font: updateFontSize(
          value2,
          fontNameDefault,
          state.subtitle && state.subtitle.font
        ) }
      );
      return state;
    case ActionTypes.subtitleColor:
      state.subtitle = Object.assign({}, state.subtitle, { color: value2 });
      return state;
    case ActionTypes.seriesColor:
      state.series = state.series.map((s10) => Object.assign(
        {},
        s10,
        { color: value2.seriesName === s10.name ? value2.color : s10.color }
      ));
      return state;
    case ActionTypes.seriesLabel:
      state.series = state.series.map((s10) => {
        if (value2.all || value2.seriesName === s10.name) {
          return Object.assign({}, s10, { labels: { visible: value2.visible } });
        }
        return s10;
      });
      return state;
    case ActionTypes.legendVisible:
      state.legend = Object.assign({}, state.legend, { visible: value2 });
      return state;
    case ActionTypes.legendFontName: {
      const legend2 = state.legend || {};
      state.legend = Object.assign(
        {},
        legend2,
        { labels: Object.assign(
          {},
          legend2.labels,
          { font: updateFontName(
            value2,
            labelSizeDefault,
            legend2.labels && legend2.labels.font
          ) }
        ) }
      );
      return state;
    }
    case ActionTypes.legendFontSize: {
      const legend2 = state.legend || {};
      state.legend = Object.assign(
        {},
        legend2,
        { labels: Object.assign(
          {},
          legend2.labels,
          { font: updateFontSize(
            value2,
            fontNameDefault,
            legend2.labels && legend2.labels.font
          ) }
        ) }
      );
      return state;
    }
    case ActionTypes.legendColor: {
      const legend2 = state.legend || {};
      state.legend = Object.assign(
        {},
        legend2,
        { labels: Object.assign({}, legend2.labels, { color: value2 }) }
      );
      return state;
    }
    case ActionTypes.legendPosition:
      state.legend = Object.assign({}, state.legend, { position: value2 });
      return state;
    case ActionTypes.categoryAxisTitleText:
      state.categoryAxis = (state.categoryAxis || []).map((axis) => Object.assign({}, axis, { title: Object.assign({}, axis.title, { text: value2 }) }));
      return state;
    case ActionTypes.categoryAxisTitleFontName: {
      state.categoryAxis = (state.categoryAxis || []).map((axis) => Object.assign({}, axis, { title: Object.assign({}, axis.title, { font: updateFontName(value2, axisTitleSizeDefault, axis.title && axis.title.font) }) }));
      return state;
    }
    case ActionTypes.categoryAxisTitleFontSize:
      state.categoryAxis = (state.categoryAxis || []).map((axis) => Object.assign({}, axis, { title: Object.assign({}, axis.title, { font: updateFontSize(value2, fontNameDefault, axis.title && axis.title.font) }) }));
      return state;
    case ActionTypes.categoryAxisTitleColor:
      state.categoryAxis = (state.categoryAxis || []).map((axis) => Object.assign({}, axis, { title: Object.assign({}, axis.title, { color: value2 }) }));
      return state;
    case ActionTypes.categoryAxisLabelsFontName: {
      state.categoryAxis = (state.categoryAxis || []).map((axis) => Object.assign({}, axis, { labels: Object.assign({}, axis.labels, { font: updateFontName(value2, labelSizeDefault, axis.labels && axis.labels.font) }) }));
      return state;
    }
    case ActionTypes.categoryAxisLabelsFontSize:
      state.categoryAxis = (state.categoryAxis || []).map((axis) => Object.assign({}, axis, { labels: Object.assign({}, axis.labels, { font: updateFontSize(value2, fontNameDefault, axis.labels && axis.labels.font) }) }));
      return state;
    case ActionTypes.categoryAxisLabelsColor:
      state.categoryAxis = (state.categoryAxis || []).map((axis) => Object.assign({}, axis, { labels: Object.assign({}, axis.labels, { color: value2 }) }));
      return state;
    case ActionTypes.categoryAxisLabelsRotation: {
      const rotation = hasValue3(value2) ? value2 : "auto";
      state.categoryAxis = (state.categoryAxis || []).map((axis) => Object.assign({}, axis, { labels: Object.assign({}, axis.labels, { rotation }) }));
      return state;
    }
    case ActionTypes.categoryAxisReverseOrder:
      state.categoryAxis = (state.categoryAxis || []).map((axis) => Object.assign({}, axis, { reverse: value2 }));
      return state;
    case ActionTypes.valueAxisTitleText: {
      if (!state.valueAxis || state.valueAxis.length === 0) {
        state.valueAxis = [{ title: { text: value2 } }];
      } else {
        state.valueAxis = (state.valueAxis || []).map((axis) => Object.assign({}, axis, { title: Object.assign({}, axis.title, { text: value2 }) }));
      }
      return state;
    }
    case ActionTypes.valueAxisTitleFontName: {
      state.valueAxis = (state.valueAxis || []).map((axis) => Object.assign({}, axis, { title: Object.assign({}, axis.title, { font: updateFontName(value2, axisTitleSizeDefault, axis.title && axis.title.font) }) }));
      return state;
    }
    case ActionTypes.valueAxisTitleFontSize:
      state.valueAxis = (state.valueAxis || []).map((axis) => Object.assign({}, axis, { title: Object.assign({}, axis.title, { font: updateFontSize(value2, fontNameDefault, axis.title && axis.title.font) }) }));
      return state;
    case ActionTypes.valueAxisTitleColor:
      state.valueAxis = (state.valueAxis || []).map((axis) => Object.assign({}, axis, { title: Object.assign({}, axis.title, { color: value2 }) }));
      return state;
    case ActionTypes.valueAxisLabelsFormat:
      state.valueAxis = (state.valueAxis || []).map((axis) => Object.assign({}, axis, { labels: Object.assign({}, axis.labels, { format: value2 }) }));
      return state;
    case ActionTypes.valueAxisLabelsFontName: {
      state.valueAxis = (state.valueAxis || []).map((axis) => Object.assign({}, axis, { labels: Object.assign({}, axis.labels, { font: updateFontName(value2, labelSizeDefault, axis.labels && axis.labels.font) }) }));
      return state;
    }
    case ActionTypes.valueAxisLabelsFontSize:
      state.valueAxis = (state.valueAxis || []).map((axis) => Object.assign({}, axis, { labels: Object.assign({}, axis.labels, { font: updateFontSize(value2, fontNameDefault, axis.labels && axis.labels.font) }) }));
      return state;
    case ActionTypes.valueAxisLabelsColor:
      state.valueAxis = (state.valueAxis || []).map((axis) => Object.assign({}, axis, { labels: Object.assign({}, axis.labels, { color: value2 }) }));
      return state;
    case ActionTypes.valueAxisLabelsRotation: {
      const rotation = hasValue3(value2) ? value2 : "auto";
      state.valueAxis = (state.valueAxis || []).map((axis) => Object.assign({}, axis, { labels: Object.assign({}, axis.labels, { rotation }) }));
      return state;
    }
    default:
      return state;
  }
}

// node_modules/@progress/kendo-charts/dist/es/chart-wizard/messages.js
var messages = Object.freeze({
  windowTitle: "Chart Preview",
  exportButton: "Export",
  exportPDFButton: "PDF File",
  exportSVGButton: "SVG File",
  exportPNGButton: "PNG File",
  tabChart: "Chart",
  tabData: "Data",
  tabFormat: "Format",
  barChart: "Bar Chart",
  barChartBar: "Bar",
  barChartStackedBar: "Stacked Bar",
  barChart100StackedBar: "100% Stacked Bar",
  pieChart: "Pie Chart",
  pieChartPie: "Pie",
  columnChart: "Column Chart",
  columnChartColumn: "Column",
  columnChartStackedColumn: "Stacked Column",
  columnChart100StackedColumn: "100% Stacked Column",
  lineChart: "Line Chart",
  lineChartLine: "Line",
  lineChartStackedLine: "Stacked Line",
  lineChart100StackedLine: "100% Stacked Line",
  scatterChart: "Scatter Chart",
  scatterChartScatter: "Scatter",
  configuration: "Configuration",
  configurationCategoryAxis: "Category Axis",
  configurationXAxis: "X Axis",
  configurationValueAxis: "Value Axis",
  configurationSeries: "Series",
  configurationSeriesAdd: "Add",
  formatChartArea: "Chart Area",
  formatChartAreaMargins: "Margins",
  formatChartAreaMarginsAuto: "Auto",
  formatChartAreaMarginsLeft: "Left",
  formatChartAreaMarginsRight: "Right",
  formatChartAreaMarginsTop: "Top",
  formatChartAreaMarginsBottom: "Bottom",
  formatChartAreaBackground: "Background",
  formatChartAreaBackgroundColor: "Color",
  formatTitle: "Title",
  formatTitleApplyTo: "Apply to",
  formatTitleChartTitle: "Chart Title",
  formatTitleChartSubtitle: "Chart Subtitle",
  formatTitleLabel: "Title",
  formatTitleFont: "Font",
  formatTitleFontPlaceholder: "(inherited font)",
  formatTitleSize: "Size",
  formatTitleSizePlaceholder: "px",
  formatTitleColor: "Color",
  formatSeries: "Series",
  formatSeriesApplyTo: "Apply to",
  formatSeriesAllSeries: "All Series",
  formatSeriesColor: "Color",
  formatSeriesShowLabels: "Show Labels",
  formatLegend: "Legend",
  formatLegendShowLegend: "Show Legend",
  formatLegendFont: "Font",
  formatLegendFontPlaceholder: "(inherited font)",
  formatLegendSize: "Size",
  formatLegendSizePlaceholder: "px",
  formatLegendColor: "Color",
  formatLegendPosition: "Position",
  formatLegendPositionTop: "Top",
  formatLegendPositionBottom: "Bottom",
  formatLegendPositionLeft: "Left",
  formatLegendPositionRight: "Right",
  formatCategoryAxis: "Category Axis",
  formatXAxis: "X Axis",
  formatCategoryAxisTitle: "Title",
  formatCategoryAxisTitlePlaceholder: "Axis Title",
  formatCategoryAxisTitleFont: "Font",
  formatCategoryAxisTitleFontPlaceholder: "(inherited font)",
  formatCategoryAxisTitleSize: "Size",
  formatCategoryAxisTitleSizePlaceholder: "px",
  formatCategoryAxisTitleColor: "Color",
  formatCategoryAxisLabels: "Labels",
  formatCategoryAxisLabelsFont: "Font",
  formatCategoryAxisLabelsFontPlaceholder: "(inherited font)",
  formatCategoryAxisLabelsSize: "Size",
  formatCategoryAxisLabelsSizePlaceholder: "px",
  formatCategoryAxisLabelsColor: "Color",
  formatCategoryAxisLabelsRotation: "Rotation",
  formatCategoryAxisLabelsRotationAuto: "Auto",
  formatCategoryAxisLabelsReverseOrder: "Reverse Order",
  formatValueAxis: "Value Axis",
  formatYAxis: "Y Axis",
  formatValueAxisTitle: "Title",
  formatValueAxisTitlePlaceholder: "Axis Title",
  formatValueAxisTitleFont: "Font",
  formatValueAxisTitleFontPlaceholder: "(inherited font)",
  formatValueAxisTitleSize: "Size",
  formatValueAxisTitleSizePlaceholder: "px",
  formatValueAxisTitleColor: "Color",
  formatValueAxisLabels: "Labels",
  formatValueAxisLabelsFormat: "Label Format",
  formatValueAxisLabelsFormatText: "Text",
  formatValueAxisLabelsFormatNumber: "Number",
  formatValueAxisLabelsFormatCurrency: "Currency",
  formatValueAxisLabelsFormatPercent: "Percent",
  formatValueAxisLabelsFont: "Font",
  formatValueAxisLabelsFontPlaceholder: "(inherited font)",
  formatValueAxisLabelsSize: "Size",
  formatValueAxisLabelsSizePlaceholder: "px",
  formatValueAxisLabelsColor: "Color",
  formatValueAxisLabelsRotation: "Rotation",
  formatValueAxisLabelsRotationAuto: "Auto"
});

// node_modules/@progress/kendo-charts/dist/es/chart-wizard.js
var ChartWizardCommon = Object.freeze({
  getWizardDataFromDataRows,
  ActionTypes,
  createInitialState,
  createState,
  fontNames,
  fontSizes,
  isCategorical,
  mergeStates,
  parseFont,
  updateState,
  messages
});

// node_modules/@progress/kendo-charts/dist/es/chart/theme/base-theme.js
var BAR_GAP = 1.5;
var BAR_SPACING = 0.4;
var BLACK2 = "#000";
var SANS = "Arial, Helvetica, sans-serif";
var SANS11 = "11px " + SANS;
var SANS12 = "12px " + SANS;
var SANS16 = "16px " + SANS;
var TRANSPARENT = "transparent";
var WHITE2 = "#fff";
var lineSeriesLegendItem = {
  type: LINE
};
var areaSeriesLegendItem = {
  type: AREA
};
var areaNoMarkersSeriesLegendItem = Object.assign(
  {},
  areaSeriesLegendItem,
  {
    markers: {
      visible: false
    },
    highlight: {
      visible: false
    }
  }
);
var notes = () => ({
  icon: {
    border: {
      width: 1
    }
  },
  label: {
    font: SANS12,
    padding: 3
  },
  line: {
    length: 10,
    width: 2
  },
  legendItem: areaNoMarkersSeriesLegendItem,
  visible: true
});
var axisDefaults = () => ({
  labels: {
    font: SANS12
  },
  notes: notes(),
  title: {
    font: SANS16,
    margin: 5
  }
});
var areaSeries = () => ({
  highlight: {
    markers: {
      border: {}
    }
  },
  line: {
    opacity: 1,
    width: 0
  },
  markers: {
    size: 6,
    visible: false
  },
  legendItem: areaSeriesLegendItem,
  opacity: 0.4
});
var rangeAreaSeries = () => ({
  highlight: {
    markers: {
      border: {}
    }
  },
  line: {
    opacity: 1,
    width: 0
  },
  markers: {
    size: 6,
    visible: false
  },
  legendItem: areaSeriesLegendItem,
  opacity: 0.4
});
var barSeries = () => ({
  gap: BAR_GAP,
  spacing: BAR_SPACING,
  legendItem: areaNoMarkersSeriesLegendItem
});
var boxPlotSeries = () => ({
  outliersField: "",
  meanField: "",
  border: {
    _brightness: 0.8,
    width: 1
  },
  downColor: WHITE2,
  gap: 1,
  highlight: {
    border: {
      opacity: 1,
      width: 2
    },
    whiskers: {
      width: 3
    },
    mean: {
      width: 2
    },
    median: {
      width: 2
    }
  },
  mean: {
    width: 2
  },
  median: {
    width: 2
  },
  spacing: 0.3,
  whiskers: {
    width: 2
  },
  legendItem: areaNoMarkersSeriesLegendItem
});
var bubbleSeries = () => ({
  border: {
    width: 0
  },
  labels: {
    background: TRANSPARENT
  },
  legendItem: areaNoMarkersSeriesLegendItem,
  opacity: 0.6
});
var bulletSeries = () => ({
  gap: BAR_GAP,
  spacing: BAR_SPACING,
  target: {
    color: "#ff0000"
  },
  legendItem: areaNoMarkersSeriesLegendItem
});
var candlestickSeries = () => ({
  border: {
    _brightness: 0.8,
    width: 1
  },
  downColor: WHITE2,
  gap: 1,
  highlight: {
    border: {
      opacity: 1,
      width: 2
    },
    line: {
      width: 2
    }
  },
  line: {
    color: BLACK2,
    width: 1
  },
  legendItem: areaNoMarkersSeriesLegendItem,
  spacing: 0.3
});
var columnSeries = () => ({
  gap: BAR_GAP,
  spacing: BAR_SPACING,
  legendItem: areaNoMarkersSeriesLegendItem
});
var radarColumnSeries = () => ({
  legendItem: areaNoMarkersSeriesLegendItem
});
var polarScatterSeries = () => ({
  legendItem: lineSeriesLegendItem
});
var scatterSeries2 = () => ({
  legendItem: lineSeriesLegendItem
});
var donutSeries = () => ({
  margin: 1,
  legendItem: areaNoMarkersSeriesLegendItem
});
var lineSeries = () => ({
  width: 2,
  legendItem: lineSeriesLegendItem
});
var ohlcSeries = () => ({
  gap: 1,
  highlight: {
    line: {
      opacity: 1,
      width: 3
    }
  },
  line: {
    width: 1
  },
  legendItem: areaNoMarkersSeriesLegendItem,
  spacing: 0.3
});
var radarAreaSeries = () => ({
  line: {
    opacity: 1,
    width: 0
  },
  markers: {
    size: 6,
    visible: false
  },
  legendItem: areaSeriesLegendItem,
  opacity: 0.5
});
var radarLineSeries = () => ({
  markers: {
    visible: false
  },
  legendItem: lineSeriesLegendItem,
  width: 2
});
var rangeBarSeries = () => ({
  gap: BAR_GAP,
  spacing: BAR_SPACING,
  legendItem: areaNoMarkersSeriesLegendItem
});
var rangeColumnSeries = () => ({
  gap: BAR_GAP,
  spacing: BAR_SPACING,
  legendItem: areaNoMarkersSeriesLegendItem
});
var scatterLineSeries = () => ({
  width: 1,
  legendItem: lineSeriesLegendItem
});
var waterfallSeries = () => ({
  gap: 0.5,
  line: {
    color: BLACK2,
    width: 1
  },
  legendItem: areaNoMarkersSeriesLegendItem,
  spacing: BAR_SPACING
});
var pieSeries = () => ({
  labels: {
    background: "",
    color: "",
    padding: {
      top: 5,
      bottom: 5,
      left: 7,
      right: 7
    }
  },
  legendItem: areaNoMarkersSeriesLegendItem
});
var funnelSeries = () => ({
  labels: {
    background: "",
    color: "",
    padding: {
      top: 5,
      bottom: 5,
      left: 7,
      right: 7
    }
  },
  legendItem: areaNoMarkersSeriesLegendItem
});
var pyramidSeries = funnelSeries;
var heatmapSeries = () => ({
  labels: {
    color: "",
    background: TRANSPARENT,
    visible: true
  },
  highlight: {
    border: {
      width: 0
    }
  },
  legendItem: areaNoMarkersSeriesLegendItem
});
var trendlineSeriesDefaults = (options) => Object.assign({
  color: INHERIT,
  trendline: {},
  markers: {
    visible: false
  },
  width: 1,
  dashType: "longDash",
  legendItem: lineSeriesLegendItem
}, options);
var seriesDefaults = (options) => ({
  visible: true,
  labels: {
    font: SANS11
  },
  overlay: options.gradients ? {} : {
    gradient: "none"
  },
  area: areaSeries(),
  rangeArea: rangeAreaSeries(),
  verticalRangeArea: rangeAreaSeries(),
  bar: barSeries(),
  boxPlot: boxPlotSeries(),
  bubble: bubbleSeries(),
  bullet: bulletSeries(),
  candlestick: candlestickSeries(),
  column: columnSeries(),
  heatmap: heatmapSeries(),
  pie: pieSeries(),
  donut: donutSeries(),
  funnel: funnelSeries(),
  pyramid: pyramidSeries(),
  horizontalWaterfall: waterfallSeries(),
  line: lineSeries(),
  notes: notes(),
  ohlc: ohlcSeries(),
  radarArea: radarAreaSeries(),
  radarLine: radarLineSeries(),
  radarColumn: radarColumnSeries(),
  polarArea: radarAreaSeries(),
  polarLine: radarLineSeries(),
  polarScatter: polarScatterSeries(),
  rangeBar: rangeBarSeries(),
  rangeColumn: rangeColumnSeries(),
  scatter: scatterSeries2(),
  scatterLine: scatterLineSeries(),
  verticalArea: areaSeries(),
  verticalBoxPlot: boxPlotSeries(),
  verticalBullet: bulletSeries(),
  verticalLine: lineSeries(),
  waterfall: waterfallSeries(),
  linearTrendline: trendlineSeriesDefaults(),
  exponentialTrendline: trendlineSeriesDefaults({ style: "smooth" }),
  logarithmicTrendline: trendlineSeriesDefaults({ style: "smooth" }),
  polynomialTrendline: trendlineSeriesDefaults({ style: "smooth" }),
  powerTrendline: trendlineSeriesDefaults({ style: "smooth" }),
  movingAverageTrendline: trendlineSeriesDefaults()
});
var title = () => ({
  font: SANS16
});
var subtitle = () => ({
  font: SANS12
});
var legend = () => ({
  labels: {
    font: SANS12
  }
});
var baseTheme = (options = {}) => ({
  axisDefaults: axisDefaults(),
  categoryAxis: {
    majorGridLines: {
      visible: true
    }
  },
  navigator: {
    pane: {
      height: 90,
      margin: {
        top: 10
      }
    }
  },
  seriesDefaults: seriesDefaults(options),
  title: title(),
  subtitle: subtitle(),
  legend: legend()
});

// node_modules/@progress/kendo-charts/dist/es/chart/theme/load-theme.js
var SERIES_COLORS = 30;
var seriesVar = "--kendo-chart-series-";
var elementStyles2 = (element) => element.ownerDocument.defaultView.getComputedStyle(element);
var cache = {};
var toColor = (colorMix, element) => {
  if (cache[colorMix]) {
    return cache[colorMix];
  }
  const curColor = element.style.color;
  element.style.color = colorMix;
  const color = elementStyles2(element).color;
  element.style.color = curColor;
  cache[colorMix] = color;
  return color;
};
var getProp = (element, prop) => {
  let value2 = elementStyles2(element).getPropertyValue(prop);
  if (/^color-mix/i.test(value2)) {
    value2 = toColor(value2, element);
  }
  return value2;
};
var getNumberProp = (element, prop) => parseFloat(elementStyles2(element).getPropertyValue(prop));
var getFont2 = (element, weightProp, sizeProp, familyProp) => {
  const styles = elementStyles2(element);
  return [styles.getPropertyValue(weightProp), styles.getPropertyValue(sizeProp), styles.getPropertyValue(familyProp) || styles.fontFamily].join(" ");
};
var getSeriesColors = (element) => {
  const styles = elementStyles2(element);
  const result = [];
  let count = 1;
  let color = styles.getPropertyValue(`${seriesVar}${count}`);
  while (color || count <= SERIES_COLORS) {
    result.push(color);
    count++;
    color = styles.getPropertyValue(`${seriesVar}${count}`);
  }
  return result;
};
var defaultFont = (element) => getFont2(element, "--kendo-font-weight", "--kendo-chart-font-size", "--kendo-font-family");
var paneTitleFont = (element) => getFont2(element, "--kendo-chart-pane-title-font-weight", "--kendo-chart-pane-title-font-size", "--kendo-font-family");
var normalTextColor = (element) => getProp(element, "--kendo-chart-text");
var title2 = (element) => ({
  color: normalTextColor(element),
  font: getFont2(element, "--kendo-font-weight", "--kendo-chart-title-font-size", "--kendo-font-family")
});
var sankeyLegend = (element) => {
  const textColorNormal = normalTextColor(element);
  return {
    labels: {
      color: textColorNormal,
      font: defaultFont(element)
    },
    title: {
      color: textColorNormal
    }
  };
};
var chartLegend = (element) => {
  const inactiveColor = getProp(element, "--kendo-chart-inactive");
  return Object.assign(
    {},
    { inactiveItems: {
      labels: {
        color: inactiveColor
      },
      markers: {
        color: inactiveColor
      }
    } },
    sankeyLegend(element)
  );
};
var sankeyTheme = (element) => ({
  labels: {
    color: normalTextColor(element),
    font: defaultFont(element),
    stroke: {
      color: getProp(element, "--kendo-chart-bg")
    }
  },
  links: {
    color: getProp(element, "--kendo-color-subtle")
  },
  nodeColors: getSeriesColors(element),
  title: title2(element),
  legend: sankeyLegend(element)
});
var notes2 = (element) => ({
  icon: {
    background: getProp(element, "--kendo-chart-notes-bg"),
    border: {
      color: getProp(element, "--kendo-chart-notes-border")
    }
  },
  line: {
    color: getProp(element, "--kendo-chart-notes-lines")
  },
  label: {
    font: defaultFont(element)
  }
});
var chartTheme = (element) => {
  const majorLines = getProp(element, "--kendo-chart-major-lines");
  const normalTextColor2 = getProp(element, "--kendo-chart-text");
  const axisLabelFont = getFont2(element, "--kendo-font-weight", "--kendo-chart-label-font-size", "--kendo-font-family");
  const chartBg = getProp(element, "--kendo-chart-bg");
  const notesProps = notes2(element);
  const areaOpacity = getNumberProp(element, "--kendo-chart-area-opacity");
  const surfaceColor = getProp(element, "--kendo-color-surface");
  const primaryBg = getProp(element, "--kendo-chart-primary-bg");
  const boxPlot = () => ({
    downColor: majorLines,
    mean: {
      color: surfaceColor
    },
    median: {
      color: surfaceColor
    },
    whiskers: {
      color: primaryBg
    }
  });
  const waterfall = () => ({
    line: {
      color: majorLines
    }
  });
  const area = () => ({
    opacity: areaOpacity,
    highlight: {
      inactiveOpacity: getNumberProp(element, "--kendo-chart-area-inactive-opacity")
    }
  });
  const line = () => ({
    highlight: {
      inactiveOpacity: getNumberProp(element, "--kendo-chart-line-inactive-opacity")
    }
  });
  const bullet = () => ({
    target: {
      color: normalTextColor2
    }
  });
  return {
    axisDefaults: {
      crosshair: {
        color: getProp(element, "--kendo-chart-crosshair-bg")
      },
      labels: {
        color: normalTextColor2,
        font: axisLabelFont
      },
      line: {
        color: majorLines
      },
      majorGridLines: {
        color: majorLines
      },
      minorGridLines: {
        color: getProp(element, "--kendo-chart-minor-lines")
      },
      notes: structuredClone(notesProps),
      title: {
        color: normalTextColor2,
        font: defaultFont(element)
      }
    },
    chartArea: {
      background: chartBg
    },
    legend: chartLegend(element),
    seriesColors: getSeriesColors(element),
    seriesDefaults: {
      area: area(),
      verticalArea: area(),
      radarArea: area(),
      boxPlot: boxPlot(),
      verticalBoxPlot: boxPlot(),
      bullet: bullet(),
      verticalBullet: bullet(),
      horizontalWaterfall: waterfall(),
      waterfall: waterfall(),
      line: line(),
      verticalLine: line(),
      candlestick: {
        downColor: normalTextColor2,
        line: {
          color: normalTextColor2
        }
      },
      errorBars: {
        color: getProp(element, "--kendo-chart-error-bars-bg")
      },
      icon: {
        border: {
          color: majorLines
        }
      },
      labels: {
        background: chartBg,
        color: normalTextColor2,
        font: axisLabelFont,
        opacity: areaOpacity
      },
      notes: structuredClone(notesProps)
    },
    subtitle: {
      color: normalTextColor2,
      font: paneTitleFont(element)
    },
    title: title2(element),
    paneDefaults: {
      title: {
        font: paneTitleFont(element)
      }
    }
  };
};

// node_modules/@progress/kendo-react-charts/utils/index.mjs
function i3(e41, t43) {
  let r28 = e41;
  for (; r28 && r28 !== t43; )
    r28 = r28.parentNode;
  return !!r28;
}
function l2(e41, t43, r28, o39) {
  const n21 = e41[t43];
  if (n21 && Array.isArray(n21)) {
    for (const a50 of n21)
      if (!a50.type || a50.type !== o39)
        return new Error(`${r28} children should be Array of type ${o39.displayName}.`);
  }
  return null;
}
var u2 = (e41) => e41 === void 0 ? false : !e41;

// node_modules/@progress/kendo-react-charts/events/base-event.mjs
var e2 = class {
  /**
   * @hidden
   */
  constructor(t43) {
    this.target = t43;
  }
};

// node_modules/@progress/kendo-react-charts/events/axis-label-click-event.mjs
var x = class extends e2 {
  /**
   * @hidden
   */
  constructor(t43, s10) {
    super(s10), this.axis = t43.axis, this.dataItem = t43.dataItem, this.index = t43.index, this.text = t43.text, this.value = t43.value;
  }
};

// node_modules/@progress/kendo-react-charts/events/preventable-event.mjs
var n2 = class extends e2 {
  constructor() {
    super(...arguments), this.prevented = false;
  }
  /* eslint-disable max-len */
  /**
   * Prevents the default action for a specified event. In this way, the source component suppresses the built-in behavior that follows the event.
   */
  preventDefault() {
    this.prevented = true;
  }
  /**
   * Returns `true` if the event was prevented by any of its subscribers.
   *
   * @returns `true` if the default action was prevented.
   * Otherwise, returns `false`.
   */
  isDefaultPrevented() {
    return this.prevented;
  }
};

// node_modules/@progress/kendo-react-charts/events/drag-event.mjs
var r = class extends n2 {
  /**
   * @hidden
   */
  constructor(e41, t43) {
    super(t43), this.axisRanges = e41.axisRanges, this.nativeEvent = e41.originalEvent;
  }
};

// node_modules/@progress/kendo-react-charts/events/drag-end-event.mjs
var i4 = class extends e2 {
  /**
   * @hidden
   */
  constructor(s10, t43) {
    super(t43), this.axisRanges = s10.axisRanges, this.nativeEvent = s10.originalEvent;
  }
};

// node_modules/@progress/kendo-react-charts/events/drag-start-event.mjs
var r2 = class extends n2 {
  /**
   * @hidden
   */
  constructor(t43, e41) {
    super(e41), this.axisRanges = t43.axisRanges, this.nativeEvent = t43.originalEvent;
  }
};

// node_modules/@progress/kendo-react-charts/events/drilldown-event.mjs
var n3 = class extends e2 {
  /**
   * @hidden
   */
  constructor(t43, e41) {
    super(e41), this.value = t43.value, this.point = t43.point, this.series = t43.series, this.currentState = t43.currentState, this.nextState = t43.nextState;
  }
};

// node_modules/@progress/kendo-react-charts/events/legend-item-hover-event.mjs
var i5 = class extends n2 {
  /**
   * @hidden
   */
  constructor(e41, t43) {
    super(t43), this.series = e41.series, this.seriesIndex = e41.seriesIndex, this.pointIndex = e41.pointIndex, this.text = e41.text;
  }
  /**
   * If called, the series highlight is not shown as a result of hovering over the legend item.
   */
  preventDefault() {
    super.preventDefault();
  }
};

// node_modules/@progress/kendo-react-charts/events/legend-item-click-event.mjs
var i6 = class extends n2 {
  /**
   * @hidden
   */
  constructor(e41, t43) {
    super(t43), this.series = e41.series, this.seriesIndex = e41.seriesIndex, this.pointIndex = e41.pointIndex, this.text = e41.text;
  }
  /**
   * If called, the series visibility is not toggled as a result of clicking the legend item.
   */
  preventDefault() {
    super.preventDefault();
  }
};

// node_modules/@progress/kendo-react-charts/events/legend-item-leave-event.mjs
var i7 = class extends n2 {
  /**
   * @hidden
   */
  constructor(e41, t43) {
    super(t43), this.series = e41.series, this.seriesIndex = e41.seriesIndex, this.pointIndex = e41.pointIndex, this.text = e41.text;
  }
  /**
   * @hidden
   */
  preventDefault() {
    super.preventDefault();
  }
};

// node_modules/@progress/kendo-react-charts/events/navigator-filter-event.mjs
var i8 = class extends e2 {
  /**
   * Constructs the event arguments from a raw object.
   */
  constructor(t43, o39) {
    super(o39), this.from = t43.from, this.to = t43.to;
  }
};

// node_modules/@progress/kendo-react-charts/events/note-click-event.mjs
var r3 = class extends e2 {
  /**
   * @hidden
   */
  constructor(t43, s10) {
    super(s10), this.category = t43.category, this.dataItem = t43.dataItem, this.series = t43.series, this.value = t43.value, this.visual = t43.visual;
  }
};

// node_modules/@progress/kendo-react-charts/events/note-hover-event.mjs
var i9 = class extends e2 {
  /**
   * @hidden
   */
  constructor(t43, s10) {
    super(s10), this.category = t43.category, this.dataItem = t43.dataItem, this.series = t43.series, this.value = t43.value, this.visual = t43.visual;
  }
};

// node_modules/@progress/kendo-react-charts/events/plot-area-click-event.mjs
var a = class extends e2 {
  /**
   * @hidden
   */
  constructor(t43, e41) {
    super(e41), this.category = t43.category, this.nativeEvent = t43.originalEvent, this.value = t43.value, this.x = t43.x, this.y = t43.y;
  }
};

// node_modules/@progress/kendo-react-charts/events/plot-area-hover-event.mjs
var a2 = class extends e2 {
  /**
   * @hidden
   */
  constructor(t43, e41) {
    super(e41), this.category = t43.category, this.nativeEvent = t43.originalEvent, this.value = t43.value, this.x = t43.x, this.y = t43.y;
  }
};

// node_modules/@progress/kendo-react-charts/events/render-event.mjs
var o2 = class extends e2 {
  /**
   * @hidden
   */
  constructor(s10, e41) {
    super(e41);
  }
};

// node_modules/@progress/kendo-react-charts/events/select-event.mjs
var i10 = class extends n2 {
  /**
   * @hidden
   */
  constructor(t43, s10) {
    super(s10), this.axis = t43.axis, this.from = t43.from, this.to = t43.to;
  }
};

// node_modules/@progress/kendo-react-charts/events/select-end-event.mjs
var i11 = class extends e2 {
  /**
   * @hidden
   */
  constructor(t43, s10) {
    super(s10), this.axis = t43.axis, this.from = t43.from, this.to = t43.to;
  }
};

// node_modules/@progress/kendo-react-charts/events/select-start-event.mjs
var i12 = class extends n2 {
  /**
   * @hidden
   */
  constructor(t43, r28) {
    super(r28), this.axis = t43.axis, this.from = t43.from, this.to = t43.to;
  }
};

// node_modules/@progress/kendo-react-charts/events/series-click-event.mjs
var r4 = class extends e2 {
  // tslint:enable:max-line-length
  /**
   * @hidden
   */
  constructor(t43, e41) {
    super(e41), this.category = t43.category, this.dataItem = t43.dataItem, this.nativeEvent = t43.originalEvent, this.percentage = t43.percentage, this.point = t43.point, this.series = t43.series, this.stackValue = t43.stackValue, this.value = t43.value;
  }
};

// node_modules/@progress/kendo-react-charts/events/series-hover-event.mjs
var r5 = class extends n2 {
  /**
   * @hidden
   */
  constructor(t43, e41) {
    super(e41), this.category = t43.category, this.categoryPoints = t43.categoryPoints, this.dataItem = t43.dataItem, this.nativeEvent = t43.originalEvent, this.percentage = t43.percentage, this.point = t43.point, this.series = t43.series, this.stackValue = t43.stackValue, this.value = t43.value;
  }
};

// node_modules/@progress/kendo-react-charts/events/zoom-event.mjs
var i13 = class extends n2 {
  // tslint:enable:max-line-length
  /**
   * @hidden
   */
  constructor(t43, e41) {
    super(e41), this.axisRanges = t43.axisRanges, this.delta = t43.delta, this.nativeEvent = t43.originalEvent;
  }
};

// node_modules/@progress/kendo-react-charts/events/zoom-end-event.mjs
var i14 = class extends e2 {
  // tslint:enable:max-line-length
  /**
   * @hidden
   */
  constructor(s10, t43) {
    super(t43), this.axisRanges = s10.axisRanges, this.nativeEvent = s10.originalEvent;
  }
};

// node_modules/@progress/kendo-react-charts/events/zoom-start-event.mjs
var r6 = class extends n2 {
  // tslint:enable:max-line-length
  /**
   * @hidden
   */
  constructor(t43, e41) {
    super(e41), this.axisRanges = t43.axisRanges, this.nativeEvent = t43.originalEvent;
  }
};

// node_modules/@progress/kendo-react-charts/events/chart-event-builder.mjs
var t = {
  axisLabelClick: x,
  drag: r,
  dragEnd: i4,
  dragStart: r2,
  drilldownEvent: n3,
  legendItemHover: i5,
  legendItemClick: i6,
  legendItemLeave: i7,
  navigatorFilter: i8,
  noteClick: r3,
  noteHover: i9,
  plotAreaClick: a,
  plotAreaHover: a2,
  render: o2,
  select: i10,
  selectEnd: i11,
  selectStart: i12,
  seriesClick: r4,
  seriesHover: r5,
  zoom: i13,
  zoomEnd: i14,
  zoomStart: r6
};
function Q(e41, r28, o39) {
  if (t[e41])
    return new t[e41](r28, o39);
}

// node_modules/@progress/kendo-react-charts/events/dom-event.mjs
var o3 = class {
  /**
   * @hidden
   */
  constructor(t43, e41) {
    this.sender = t43, this.syntheticEvent = e41;
  }
};
function s(n21, t43) {
  return new o3(n21, t43);
}

// node_modules/@progress/kendo-react-charts/store/store.mjs
var l3 = 1e3 / 60;
var T = (i37) => {
  let o39, s10, t43 = [];
  const n21 = () => o39, c9 = (e41) => {
    o39 = i37(o39, e41), e && (window.clearTimeout(s10), s10 = window.setTimeout(() => t43.forEach((r28) => r28()), l3));
  }, a50 = (e41) => (t43.push(e41), () => t43 = t43.filter((r28) => r28 !== e41));
  return c9({}), { getState: n21, dispatch: c9, subscribe: a50 };
};

// node_modules/@progress/kendo-react-charts/store/reducer.mjs
var a3 = (t43, e41) => e41.chartCollectionIdxKey ? c.collectionConfigurationItem(t43, e41) : e41.chartKey ? c.configurationItem(t43, e41) : {};
var u3 = (t43, e41) => {
  if (e41.type)
    switch (e41.type) {
      case "set":
        return c.themeItem(t43, e41);
      case "push":
        return Object.assign(t43, e41.payload);
      default:
        return t43;
    }
  else
    return {};
};
var p2 = (t43, e41) => {
  if (e41.type)
    switch (e41.type) {
      case "add":
        return [...t43, e41.payload];
      case "remove":
        return t43.filter((r28) => r28 !== e41.payload);
      default:
        return t43;
    }
  else
    return [];
};
var c = {
  configurationItem(t43, e41) {
    return Object.assign(t43, {
      [e41.chartKey]: e41.payload
    });
  },
  collectionConfigurationItem(t43, e41) {
    let r28 = false;
    const [o39, n21] = e41.chartCollectionIdxKey.split("_"), i37 = t43[o39].map((l7, s10) => parseInt(n21, 10) === s10 ? (r28 = true, e41.payload) : l7);
    return r28 === false && i37.splice(parseInt(n21, 10), 0, e41.payload), Object.assign(t43, {
      [o39]: i37
    });
  },
  themeItem(t43, e41) {
    let r28 = {};
    const o39 = Object.assign(r28, t43), { field: n21, value: i37 } = e41.payload, l7 = n21.split(".");
    let s10 = l7.shift();
    for (; l7.length > 0; )
      r28 = r28[s10] = r28[s10] || {}, s10 = l7.shift();
    return r28[s10] = i37, o39;
  }
};

// node_modules/@progress/kendo-react-charts/tooltip/Series.mjs
var p3 = __toESM(require_react(), 1);

// node_modules/@progress/kendo-react-charts/tooltip/Point.mjs
var a4 = class {
  /**
   * @hidden
   */
  constructor(t43, h4) {
    this.value = t43.value, this.category = t43.category, this.categoryIndex = t43.categoryIx, this.series = t43.series, this.dataItem = t43.dataItem, this.percentage = t43.percentage, this.runningTotal = t43.runningTotal, this.total = t43.total, this.low = t43.low, this.high = t43.high, this.xLow = t43.xLow, this.xHigh = t43.xHigh, this.yLow = t43.yLow, this.yHigh = t43.yHigh, this.point = t43, this.format = ((t43.options || {}).tooltip || {}).format || h4;
  }
  get formattedValue() {
    return this.format ? this.point.formatValue(this.format) : String(this.value);
  }
};

// node_modules/@progress/kendo-react-charts/tooltip/SharedTooltipContent.mjs
var e3 = __toESM(require_react(), 1);
var u4 = "k-chart-shared-tooltip-marker";
var E = (l7) => {
  const { categoryText: r28, colorMarker: n21, colspan: a50, nameColumn: o39, points: c9 } = l7, m10 = (t43, s10) => e3.createElement("tr", { key: s10 }, n21 && e3.createElement("td", null, e3.createElement("span", { className: u4, style: { backgroundColor: t43.series.color } })), o39 && e3.createElement("td", null, t43.series.name), e3.createElement("td", { dangerouslySetInnerHTML: { __html: t43.formattedValue } }));
  return e3.createElement("table", null, e3.createElement("thead", null, e3.createElement("tr", null, e3.createElement("th", { colSpan: a50 }, r28))), e3.createElement("tbody", null, c9.map(m10)));
};

// node_modules/@progress/kendo-react-charts/tooltip/Popup.mjs
var s2 = __toESM(require_react(), 1);

// node_modules/@progress/kendo-react-charts/ChartContext.mjs
var t2 = __toESM(require_react(), 1);
var e4 = t2.createContext(null);
e4.displayName = "ChartContext";

// node_modules/@progress/kendo-react-charts/tooltip/Popup.mjs
var v3 = { horizontal: "fit", vertical: "fit" };
var d2 = "k-chart-tooltip";
var C = "k-chart-tooltip-wrapper";
var n4 = class n5 extends s2.Component {
  constructor(o39) {
    super(o39), this.context = null, this.element = null, this.onChartMouseLeave = (t43) => {
      const { syntheticEvent: e41 } = t43;
      return !!i3(e41.relatedTarget, this.element);
    }, this.onMouseLeave = (t43) => {
      const e41 = s(this, t43);
      this.context.childrenObserver.trigger("onMouseLeave", e41) && t43.preventDefault();
    }, this.popupRef = (t43) => {
      this.element = t43;
      const e41 = t43 && t43.closest(".k-animation-container");
      e41 && (e41.style.transition = "initial");
    }, this.chartObserver = new instance_observer_default(this, {
      onMouseLeave: "onChartMouseLeave"
    });
  }
  componentDidMount() {
    var o39;
    (o39 = this.context) == null || o39.observersStore.dispatch({
      type: "add",
      payload: this.chartObserver
    });
  }
  render() {
    const { popupShown: o39, popupAlign: t43, popupOffset: e41, popupStyles: r28, popupContent: i37, className: p9 } = this.props, c9 = [d2, p9].join(" ").trim();
    return s2.createElement(
      te,
      {
        animate: false,
        popupAlign: t43,
        offset: e41,
        show: o39,
        collision: v3,
        className: C
      },
      s2.createElement("div", { className: c9, style: r28, onMouseLeave: this.onMouseLeave, ref: this.popupRef }, i37())
    );
  }
  componentWillUnmount() {
    this.context.observersStore.dispatch({
      type: "remove",
      payload: this.chartObserver
    });
  }
};
n4.contextType = e4;
var a5 = n4;

// node_modules/@progress/kendo-react-charts/tooltip/Series.mjs
var T2 = "k-chart-shared-tooltip";
var x2 = "k-chart-tooltip-inverse";
var a6 = class a7 extends p3.Component {
  constructor() {
    super(...arguments), this.context = null, this.state = {
      popupShown: false
    }, this.chartObserver = null;
  }
  componentDidMount() {
    this.chartObserver = new instance_observer_default(this, {
      showTooltip: "onShowTooltip",
      hideTooltip: "onHideTooltip"
    }), this.context.observersStore.dispatch({
      type: "add",
      payload: this.chartObserver
    });
  }
  render() {
    const { popupContext: t43, shared: o39, className: n21, ...r28 } = this.state, i37 = this.state.popupShown ? () => {
      const e41 = this.findRenderFunction();
      if (o39)
        return e41 !== null ? e41(t43) : p3.createElement(E, { ...t43 });
      const u7 = t43.point, l7 = this.findRenderFunctionByIndex(u7.series.index);
      return l7 !== null ? l7(t43) : e41 !== null ? e41(t43) : p3.createElement(
        "span",
        {
          dangerouslySetInnerHTML: {
            __html: t43.point.formattedValue
          }
        }
      );
    } : Function.prototype, s10 = n({
      [T2]: o39,
      [x2]: !!n21
    });
    return p3.createElement(a5, { ...r28, popupContent: i37, className: s10 });
  }
  componentWillUnmount() {
    this.context.observersStore.dispatch({
      type: "remove",
      payload: this.chartObserver
    });
  }
  onShowTooltip(t43) {
    const { anchor: o39, style: n21, shared: r28, className: i37, crosshair: s10 } = t43;
    let e41;
    s10 || (r28 ? e41 = this.createSharedTooltipContext(t43) : e41 = this.createTooltipContext(t43), this.setState({
      popupShown: true,
      popupAlign: o39.align,
      popupOffset: o39.point,
      popupContext: e41,
      popupStyles: n21,
      className: i37,
      shared: r28
    }));
  }
  onHideTooltip() {
    this.setState({
      popupShown: false,
      popupStyles: {},
      className: void 0
    });
  }
  createSharedTooltipContext(t43) {
    const { points: o39, categoryText: n21 } = t43, r28 = o39.filter((e41) => typeof e41.series.name != "undefined").length > 0, i37 = t43.series.length > 1;
    let s10 = 1;
    return r28 && s10++, i37 && s10++, {
      categoryText: n21,
      colorMarker: i37,
      colspan: s10,
      nameColumn: r28,
      points: t43.points.map((e41) => new a4(e41, t43.format))
    };
  }
  createTooltipContext(t43) {
    const { point: o39, format: n21 } = t43;
    return { point: new a4(o39, n21) };
  }
  findRenderFunctionByIndex(t43) {
    const o39 = this.context.optionsStore.getState().series;
    return o39 !== void 0 && Array.isArray(o39) && o39[t43] !== void 0 && o39[t43].hasOwnProperty("tooltip") && o39[t43].tooltip.hasOwnProperty("render") ? o39[t43].tooltip.render : null;
  }
  findRenderFunction() {
    const t43 = this.context.optionsStore.getState().tooltip;
    return t43 !== void 0 && t43.hasOwnProperty("render") ? t43.render : null;
  }
};
a6.contextType = e4;
var h = a6;

// node_modules/@progress/kendo-react-charts/tooltip/CrosshairContainer.mjs
var r8 = __toESM(require_react(), 1);

// node_modules/@progress/kendo-react-charts/Container.mjs
var e5 = (n21) => n21.children;
e5.displayName = "Container";

// node_modules/@progress/kendo-react-charts/tooltip/Crosshair.mjs
var r7 = __toESM(require_react(), 1);
var x3 = "k-chart-crosshair-tooltip";
var v4 = "k-chart-tooltip-inverse";
var n6 = class n7 extends r7.Component {
  constructor(t43) {
    super(t43), this.context = null, this.state = {
      popupShown: false
    }, this.chartObserver = new instance_observer_default(this, {
      showTooltip: "onShowTooltip",
      hideTooltip: "onHideTooltip"
    });
  }
  componentDidMount() {
    var t43;
    (t43 = this.context) == null || t43.observersStore.dispatch({
      type: "add",
      payload: this.chartObserver
    });
  }
  render() {
    const { popupContend: t43, className: o39, ...e41 } = this.state, p9 = this.state.popupShown ? () => t43 : Function.prototype, s10 = n({
      [x3]: true,
      [v4]: !!o39
    });
    return r7.createElement(a5, { ...e41, popupContent: p9, className: s10 });
  }
  componentWillUnmount() {
    var t43;
    (t43 = this.context) == null || t43.observersStore.dispatch({
      type: "remove",
      payload: this.chartObserver
    });
  }
  onShowTooltip(t43) {
    const { anchor: o39, style: e41, className: p9, crosshair: s10, axisName: a50, axisIndex: c9, value: h4 } = t43, { name: l7, index: m10 } = this.props;
    s10 && a50 === l7 && c9 === m10 && this.setState({
      popupShown: true,
      popupAlign: o39.align,
      popupOffset: o39.point,
      popupContend: h4,
      popupStyles: e41,
      className: p9
    });
  }
  onHideTooltip() {
    this.setState({
      popupShown: false,
      popupStyles: {},
      className: void 0
    });
  }
};
n6.contextType = e4;
var i15 = n6;

// node_modules/@progress/kendo-react-charts/tooltip/CrosshairContainer.mjs
var l4 = ["categoryAxis", "valueAxis", "xAxis", "yAxis"];
function x4(n21) {
  const t43 = {};
  for (let o39 = 0; o39 < l4.length; o39++) {
    const s10 = m(n21, l4[o39]);
    for (let e41 = 0; e41 < s10.length; e41++) {
      const i37 = s10[e41];
      t43[i37.name + i37.index] = i37;
    }
  }
  return t43;
}
function m(n21, t43) {
  const o39 = [];
  if (n21[t43]) {
    const s10 = [].concat(n21[t43]);
    for (let e41 = 0; e41 < s10.length; e41++) {
      const i37 = (s10[e41].crosshair || {}).tooltip;
      i37 && i37.visible && o39.push({
        index: e41,
        name: t43
      });
    }
  }
  return o39;
}
var c2 = class c3 extends r8.Component {
  constructor() {
    super(...arguments), this.context = null, this.state = {
      tooltips: {}
    }, this.storeUnsubscriber = Function.prototype, this.subscriber = () => {
      var t43;
      this.setState({
        tooltips: x4((t43 = this.context) == null ? void 0 : t43.optionsStore.getState())
      });
    };
  }
  componentDidMount() {
    this.storeUnsubscriber = this.context.optionsStore.subscribe(this.subscriber);
  }
  render() {
    const { tooltips: t43 } = this.state, o39 = Object.keys(t43).map((s10) => r8.createElement(i15, { ...t43[s10], key: s10 }));
    return r8.createElement(e5, null, o39);
  }
  componentWillUnmount() {
    this.storeUnsubscriber();
  }
};
c2.contextType = e4;
var p4 = c2;

// node_modules/@progress/kendo-react-charts/package-metadata.mjs
var e6 = Object.freeze({
  name: "@progress/kendo-react-charts",
  productName: "KendoReact",
  productCode: "KENDOUIREACT",
  productCodes: ["KENDOUIREACT"],
  publishDate: 1755016201,
  version: "11.4.0",
  licensingDocsUrl: "https://www.telerik.com/kendo-react-ui/components/my-license/"
});

// node_modules/@progress/kendo-react-charts/BaseChart.mjs
var d3 = class d4 extends l5.Component {
  constructor(t43) {
    super(t43), this.chartInstance = null, this.surface = null, this._element = null, this.optionsStore = {}, this.optionsUnsubscriber = Function.prototype, this.themeStore = {}, this.themeUnsubscriber = Function.prototype, this.observersStore = {}, this.suppressTransitions = false, this.showLicenseWatermark = false, this.onRender = (e41) => {
      this.chartInstance !== null && (this.surface = e41.sender.surface, this.trigger("render", e41));
    }, this.onDrilldown = (e41) => {
      var i37;
      const { series: s10 } = this.optionsStore.getState(), r28 = s10.find((n21) => n21.name === e41.series.name);
      if (r28.drilldownSeriesFactory) {
        const n21 = "onDrilldown";
        if (this.props.hasOwnProperty(n21)) {
          const o39 = { seriesName: r28.name, drilldownValue: e41.value }, h4 = [...((i37 = this.props.drilldownState) == null ? void 0 : i37.steps) || [], o39], c9 = this.props.getTarget(), p9 = {
            ...e41,
            currentState: this.props.drilldownState,
            nextState: { steps: h4 }
          }, a50 = new n3(p9, c9);
          this.props[n21].call(void 0, a50);
        }
      }
      return true;
    }, this.onLegendItemClick = (e41) => {
      if (this.chartInstance !== null)
        if (this.props.onLegendItemClick)
          this.trigger("legendItemClick", e41);
        else {
          const { series: s10 } = this.optionsStore.getState();
          if (!s10)
            return;
          let r28 = {};
          const { seriesIndex: i37, pointIndex: n21 } = e41, o39 = s10[i37];
          if (n21 === void 0)
            r28 = Object.assign({}, o39, { visible: u2(o39.visible) });
          else {
            const h4 = o39.pointVisibility = o39.pointVisibility || [];
            h4[n21] = u2(h4[n21]), r28 = Object.assign({}, o39);
          }
          this.optionsStore.dispatch({
            chartCollectionIdxKey: `series_${i37}`,
            payload: r28
          }), this.suppressTransitions = true;
        }
    }, this.onWindowResize = () => {
      this.chartInstance !== null && this.chartInstance.resize();
    }, this.onChartMouseLeave = (e41) => {
      const s10 = s(this, e41);
      this.triggerDomEvent("onMouseLeave", s10) ? e41.preventDefault() : this.chartInstance !== null && this.chartInstance.hideElements();
    }, this.onChildMouseLeave = (e41) => {
      const { syntheticEvent: s10 } = e41;
      return this.chartInstance && !i3(s10.relatedTarget, this.element) && this.chartInstance.hideElements(), false;
    }, this.showLicenseWatermark = !d(e6, { component: "Chart" }), this.licenseMessage = w(e6), this.optionsStore = T(a3), this.observersStore = T(p2), this.childrenObserver = new instance_observer_default(this, { onMouseLeave: "onChildMouseLeave" }), this.state = {
      optionsStore: this.optionsStore,
      observersStore: this.observersStore,
      childrenObserver: this.childrenObserver,
      drilldownState: { steps: [] }
    }, this.themeStore = T(u3), this.chartObserver = new instance_observer_default(this, {
      render: "onRender",
      legendItemClick: "onLegendItemClick",
      drilldown: "onDrilldown"
    });
  }
  /**
   * @hidden
   */
  get element() {
    return this._element;
  }
  /**
   * @hidden
   */
  static getDerivedStateFromProps(t43, e41) {
    return {
      ...e41,
      drilldownState: t43.drilldownState || []
    };
  }
  /**
   * @hidden
   */
  componentDidMount() {
    if (this._element) {
      let t43 = {};
      try {
        t43 = chartTheme(this._element);
      } catch {
      }
      const e41 = deepExtend(baseTheme(), t43);
      this.themeStore.dispatch({ type: "push", payload: e41 }), this.instantiateCoreChart();
    }
    this.optionsUnsubscriber = this.optionsStore.subscribe(this.refresh.bind(this)), this.themeUnsubscriber = this.themeStore.subscribe(this.refresh.bind(this)), window.addEventListener("resize", this.onWindowResize);
  }
  /**
   * @hidden
   */
  componentWillUnmount() {
    this.optionsUnsubscriber(), this.themeUnsubscriber(), this.chartInstance !== null && (this.chartInstance.destroy(), this.chartInstance = null), window.removeEventListener("resize", this.onWindowResize);
  }
  /**
   * @hidden
   */
  componentDidUpdate(t43) {
    const { dir: e41, children: s10, ...r28 } = this.props;
    if (this.chartInstance !== null) {
      const i37 = l(this), n21 = this.chartInstance.chartService, o39 = i37.locale !== n21._intlService.locale, h4 = Object.entries(t43).filter((c9) => c9[0] !== "dir" && c9[0] !== "children").some((c9) => {
        const [p9, a50] = c9;
        return !(r28.hasOwnProperty(p9) && r28[p9] === a50);
      });
      o39 && (this.chartInstance.chartService._intlService = i37, this.chartInstance.chartService.format._intlService = i37, h4 || this.chartInstance.noTransitionsRedraw()), h4 && this.refresh(), t43.dir !== e41 && this.chartInstance.setDirection(this.getDirection(e41));
    }
  }
  /**
   * @hidden
   */
  render() {
    const { style: t43 = {}, className: e41, wrapper: s10, children: r28 } = this.props, i37 = Object.assign({}, t43, { position: "relative" }), n21 = l5.createElement(
      s10,
      {
        className: e41,
        style: i37,
        key: "chartElement"
      },
      l5.createElement(
        "div",
        {
          onMouseLeave: this.onChartMouseLeave,
          ref: (o39) => {
            this._element = o39;
          },
          className: "k-chart-surface"
        },
        r28
      ),
      l5.createElement(l5.Fragment, null, this.showLicenseWatermark && l5.createElement(P, { message: this.licenseMessage }))
    );
    return l5.createElement(e4.Provider, { value: this.state }, l5.createElement(h, { key: "seriesTooltip" }), l5.createElement(p4, { key: "crosshairTooltips" }), n21);
  }
  /**
   * @hidden
   */
  getDirection(t43) {
    return (t43 !== void 0 ? t43 : e && window.getComputedStyle(this.element).direction || "ltr") === "rtl";
  }
  /**
   * @hidden
   */
  getChartOptions() {
    const {
      renderAs: t43,
      pannable: e41,
      zoomable: s10,
      paneDefaults: r28,
      panes: i37,
      transitions: n21,
      seriesColors: o39,
      seriesDefaults: h4,
      axisDefaults: c9,
      deriveOptionsFromParent: p9
    } = this.props;
    let a50 = {};
    return t43 !== void 0 && (a50.renderAs = t43), e41 !== void 0 && (a50.pannable = e41), s10 !== void 0 && (a50.zoomable = s10), r28 !== void 0 && (a50.paneDefaults = r28), i37 !== void 0 && (a50.panes = i37), n21 !== void 0 && (a50.transitions = n21), o39 !== void 0 && (a50.seriesColors = o39), h4 !== void 0 && (a50.seriesDefaults = h4), c9 !== void 0 && (a50.axisDefaults = c9), a50 = Object.assign(a50, this.optionsStore.getState()), p9 && (a50 = p9(a50)), a50;
  }
  /**
   * @hidden
   */
  refresh() {
    if (this.chartInstance !== null) {
      const t43 = this.themeStore.getState(), e41 = this.getChartOptions(), s10 = e41.transitions;
      this.suppressTransitions && (e41.transitions = false), this.props.onRefresh ? this.props.onRefresh.call(void 0, e41, t43, this.chartInstance) : this.chartInstance.setOptions(e41, t43), this.suppressTransitions && (e41.transitions = s10, this.suppressTransitions = false);
    }
  }
  /**
   * @hidden
   */
  instantiateCoreChart() {
    const { dir: t43, chartConstructor: e41 } = this.props, s10 = this.getChartOptions();
    this.chartInstance = new e41(this.element, s10, this.themeStore.getState(), {
      rtl: this.getDirection(t43),
      intlService: l(this),
      observer: this.chartObserver,
      sender: this
    });
  }
  /* Triggers public dom event handlers */
  /**
   * @hidden
   */
  trigger(t43, e41) {
    const s10 = this.props.getTarget(), r28 = Q(t43, e41, s10), i37 = "on" + t43.charAt(0).toUpperCase() + t43.slice(1), n21 = this.observersStore.getState();
    let o39 = false;
    for (let h4 = 0; h4 < n21.length; h4++)
      n21[h4].trigger(t43, e41) && (o39 = true);
    return o39 === false && r28 && this.props.hasOwnProperty(i37) ? (this.props[i37].call(void 0, r28), r28.isDefaultPrevented && r28.isDefaultPrevented()) : o39;
  }
  /* Used by (event)InstanceObserver to check the wrapper for supported events */
  /**
   * @hidden
   */
  requiresHandlers(t43) {
    for (let e41 = 0; e41 < t43.length; e41++) {
      const s10 = t43[e41], r28 = "on" + s10.charAt(0).toUpperCase() + s10.slice(1);
      if (this.props.hasOwnProperty(r28))
        return true;
    }
    return false;
  }
  /* Triggers private dom event handlers */
  /**
   * @hidden
   */
  triggerDomEvent(t43, e41) {
    const s10 = this.observersStore.getState();
    let r28 = false;
    for (let i37 = 0; i37 < s10.length; i37++)
      s10[i37].trigger(t43, e41) && (r28 = true);
    return r28;
  }
};
d3.propTypes = {
  dir: import_prop_types.default.string,
  renderAs: import_prop_types.default.oneOf(["svg", "canvas"])
}, d3.defaultProps = {
  renderAs: "svg"
};
var f = d3;
p(f);

// node_modules/@progress/kendo-react-charts/DonutCenter.mjs
var o4 = __toESM(require_react(), 1);
var c4 = class c5 extends o4.Component {
  constructor(t43) {
    super(t43), this.state = {
      donutCenterStyles: null
    }, this.chartObserver = new instance_observer_default(this, {
      render: "onRender"
    });
  }
  componentDidMount() {
    var t43;
    (t43 = this.context) == null || t43.observersStore.dispatch({
      type: "add",
      payload: this.chartObserver
    });
  }
  render() {
    const { render: t43 } = this.props, { donutCenterStyles: e41 } = this.state;
    let r28 = null;
    return t43 && e41 && (r28 = o4.createElement("div", { className: "k-chart-donut-center", style: e41 }, o4.createElement(t43, null))), r28;
  }
  onRender(t43) {
    var d5;
    const e41 = (d5 = this.context) == null ? void 0 : d5.optionsStore.getState().series, r28 = Array.isArray(e41) ? e41[0] : null, i37 = t43.sender._plotArea.charts;
    if (!r28 || r28.type !== "donut" || i37[0].points.length === 0)
      return;
    const s10 = i37[0].points[0].sector, n21 = s10.innerRadius, l7 = s10.center.y - n21, p9 = s10.center.x - n21, a50 = n21 * 2;
    this.setState({
      donutCenterStyles: {
        height: a50,
        left: p9,
        top: l7,
        width: a50
      }
    });
  }
};
c4.contextType = e4;
var h2 = c4;

// node_modules/@progress/kendo-react-charts/Chart.mjs
var f2 = class extends t3.Component {
  constructor() {
    super(...arguments), this._baseChart = null, this.getTarget = () => this;
  }
  /**
   * @hidden
   */
  get chartInstance() {
    return this._baseChart !== null ? this._baseChart.chartInstance : null;
  }
  /**
   * The Drawing `Surface` of the Chart.
   */
  get surface() {
    return this._baseChart !== null ? this._baseChart.surface : null;
  }
  /**
   * The DOM element of the Chart.
   */
  get element() {
    return this._baseChart !== null ? this._baseChart.element : null;
  }
  /**
   * @hidden
   */
  render() {
    const { donutCenterRender: r28, children: e41, className: a50, ...s10 } = this.props;
    return t3.createElement(
      f,
      {
        ...s10,
        ref: (n21) => {
          this._baseChart = n21;
        },
        chartConstructor: chart_default,
        getTarget: this.getTarget,
        wrapper: "div",
        className: n("k-chart k-widget", a50)
      },
      e41,
      t3.createElement(h2, { render: r28 })
    );
  }
};

// node_modules/@progress/kendo-react-charts/Sparkline.mjs
var a8 = __toESM(require_react(), 1);
var m2 = class extends a8.Component {
  constructor() {
    super(...arguments), this._baseChart = null, this.deriveOptionsFromParent = (t43) => {
      const { type: s10, data: e41 } = this.props, r28 = Object.assign({}, t43, { type: s10, data: e41 });
      return sparkline_default.normalizeOptions(r28);
    }, this.getTarget = () => this;
  }
  /**
   * @hidden
   */
  get chartInstance() {
    return this._baseChart !== null ? this._baseChart.chartInstance : null;
  }
  /**
   * The Drawing `Surface` of the Sparkline.
   */
  get surface() {
    return this._baseChart !== null ? this._baseChart.surface : null;
  }
  /**
   * The DOM element of the Sparkline.
   */
  get element() {
    return this._baseChart !== null ? this._baseChart.element : null;
  }
  /**
   * @hidden
   */
  render() {
    const { children: t43, type: s10, className: e41, ...r28 } = this.props;
    return a8.createElement(
      f,
      {
        ...r28,
        ref: (i37) => {
          this._baseChart = i37;
        },
        chartConstructor: sparkline_default,
        getTarget: this.getTarget,
        wrapper: "span",
        deriveOptionsFromParent: this.deriveOptionsFromParent,
        className: n("k-sparkline k-widget", e41)
      },
      t43
    );
  }
};

// node_modules/@progress/kendo-react-charts/StockChart.mjs
var s3 = __toESM(require_react(), 1);
var h3 = {
  autoBindElements: true,
  liveDrag: false,
  partialRedraw: true
};
var m3 = class extends s3.Component {
  constructor() {
    super(...arguments), this._baseChart = null, this.deriveOptionsFromParent = (t43) => {
      const e41 = Object.assign({}, t43.navigator || {}, h3);
      return Object.assign({}, t43, { navigator: e41 });
    }, this.onRefresh = (t43, e41, r28) => {
      this.props.partialRedraw ? (r28.applyOptions(t43), r28.bindCategories(), r28.navigator.redrawSlaves()) : r28.setOptions(t43, e41);
    }, this.getTarget = () => this;
  }
  /**
   * @hidden
   */
  get chartInstance() {
    return this._baseChart !== null ? this._baseChart.chartInstance : null;
  }
  /**
   * The Drawing `Surface` of the StockChart.
   */
  get surface() {
    return this._baseChart !== null ? this._baseChart.surface : null;
  }
  /**
   * The DOM element of the StockChart.
   */
  get element() {
    return this._baseChart !== null ? this._baseChart.element : null;
  }
  /**
   * @hidden
   */
  render() {
    const { children: t43, className: e41, ...r28 } = this.props;
    return s3.createElement(
      f,
      {
        ...r28,
        ref: (a50) => {
          this._baseChart = a50;
        },
        chartConstructor: stock_chart_default,
        getTarget: this.getTarget,
        wrapper: "div",
        deriveOptionsFromParent: this.deriveOptionsFromParent,
        onRefresh: this.onRefresh,
        className: n("k-chart k-stockchart", e41)
      },
      t43
    );
  }
};

// node_modules/@progress/kendo-react-charts/components/base/CollectionConfigurationComponent.mjs
var r9 = __toESM(require_react(), 1);
var p5 = class p6 extends r9.Component {
  get optionsStore() {
    var t43;
    return (t43 = this.context) == null ? void 0 : t43.optionsStore;
  }
  renderChildren(t43, s10) {
    const { children: o39 } = t43.props, { _chartKey: c9, _parentStore: e41 } = this.props, n21 = {
      ...t43.props,
      _chartCollectionIdxKey: `${c9}_${s10}`,
      _parentStore: e41
    };
    return r9.cloneElement(t43, n21, o39);
  }
  render() {
    const { _chartKey: t43, _parentStore: s10, children: o39 } = this.props;
    return (s10 || this.optionsStore).dispatch({
      chartKey: t43,
      payload: []
    }), r9.Children.map(o39, (e41, n21) => r9.isValidElement(e41) ? this.renderChildren(e41, n21) : e41);
  }
};
p5.contextType = e4;
var a9 = p5;

// node_modules/@progress/kendo-react-charts/components/base/ConfigurationComponent.mjs
var r10 = __toESM(require_react(), 1);
var s4 = class s5 extends r10.Component {
  get optionsStore() {
    var t43;
    return (t43 = this.context) == null ? void 0 : t43.optionsStore;
  }
  constructor(t43) {
    super(t43), this.childStore = T(a3);
  }
  render() {
    const { children: t43 } = this.props;
    return t43 !== void 0 ? r10.Children.map(t43, (e41) => r10.isValidElement(e41) ? this.renderChildren(e41) : e41) : null;
  }
  componentDidMount() {
    this.dispatch();
  }
  componentDidUpdate() {
    this.dispatch();
  }
  dispatch() {
    const { _chartKey: t43, _chartCollectionIdxKey: e41, _parentStore: o39, children: a50, ...i37 } = this.props;
    (o39 || this.optionsStore).dispatch({
      chartKey: t43,
      chartCollectionIdxKey: e41,
      payload: Object.assign({}, i37, this.childStore.getState())
    });
  }
  renderChildren(t43) {
    const { children: e41 } = t43.props, o39 = {
      ...t43.props,
      _parentStore: this.childStore
    };
    return r10.cloneElement(t43, o39, e41);
  }
};
s4.contextType = e4;
var n8 = s4;

// node_modules/@progress/kendo-react-charts/ChartBreadcrumb.mjs
var n10 = __toESM(require_react(), 1);
var import_prop_types2 = __toESM(require_prop_types(), 1);

// node_modules/@progress/kendo-react-charts/events/drilldown-state-change-event.mjs
var n9 = class {
  /**
   * @hidden
   */
  constructor(t43) {
    this.currentState = t43.currentState, this.nextState = t43.nextState;
  }
};

// node_modules/@progress/kendo-react-charts/ChartBreadcrumb.mjs
var s6 = n10.forwardRef((t43, m10) => {
  const a50 = n10.useRef(null), u7 = n10.useRef(null), d5 = {
    valueField: i16.valueField,
    textField: i16.textField,
    iconField: i16.iconField,
    iconClassField: i16.iconClassField,
    ...t43
  };
  n10.useImperativeHandle(a50, () => ({
    element: u7.current,
    props: d5
  })), n10.useImperativeHandle(m10, () => a50.current);
  let l7 = [{
    id: "0",
    ...t43.rootItem || {
      text: "Home",
      icon: n10.createElement(
        M,
        {
          icon: homeIcon,
          style: { marginInlineEnd: "4px" }
        }
      )
    }
  }];
  t43.drilldownState && (l7 = [
    ...l7,
    ...t43.drilldownState.steps.map((o39, r28) => ({
      id: (r28 + 1).toString(),
      text: o39.drilldownValue
    }))
  ]);
  const b2 = { ...d5, data: l7 }, p9 = (o39) => {
    var c9;
    const r28 = "onDrilldownStateChange";
    if (t43.hasOwnProperty(r28)) {
      const f5 = l7.findIndex((g2) => g2.id === o39.id), F = { steps: (((c9 = t43.drilldownState) == null ? void 0 : c9.steps) || []).slice(0, f5) }, S = new n9({ currentState: t43.drilldownState, nextState: F });
      t43[r28].call(void 0, S);
    }
  };
  return n10.createElement("div", null, n10.createElement(v2, { ...b2, onItemSelect: p9 }));
});
var x5 = {
  id: import_prop_types2.default.string,
  style: import_prop_types2.default.object,
  className: import_prop_types2.default.string,
  breadcrumbOrderedList: import_prop_types2.default.elementType,
  breadcrumbListItem: import_prop_types2.default.elementType,
  breadcrumbDelimiter: import_prop_types2.default.elementType,
  breadcrumbLink: import_prop_types2.default.elementType,
  dir: import_prop_types2.default.oneOf(["ltr", "rtl"]),
  disabled: import_prop_types2.default.bool,
  valueField: import_prop_types2.default.string,
  textField: import_prop_types2.default.string,
  iconField: import_prop_types2.default.string,
  iconClassField: import_prop_types2.default.string,
  onItemSelect: import_prop_types2.default.func,
  ariaLabel: import_prop_types2.default.string,
  onDrilldownStateChange: import_prop_types2.default.func,
  drilldownState: import_prop_types2.default.shape({
    steps: import_prop_types2.default.array
  }),
  rootItem: import_prop_types2.default.object
};
var i16 = {
  valueField: "id",
  textField: "text",
  iconField: "icon",
  iconClassField: "iconClass",
  data: []
};
s6.displayName = "KendoReactChartBreadcrumb";
s6.propTypes = x5;

// node_modules/@progress/kendo-react-charts/ChartNoDataOverlay.mjs
var e8 = __toESM(require_react(), 1);

// node_modules/@progress/kendo-react-charts/messages.mjs
var a10 = "charts.nodata";
var t4 = {
  [a10]: "No data available."
};

// node_modules/@progress/kendo-react-charts/ChartNoDataOverlay.mjs
var i17 = (a50) => {
  const o39 = i2();
  return e8.createElement("div", { className: n("k-chart-overlay", a50.className), style: { display: "none", ...a50.style } }, e8.createElement("div", { className: "k-no-data" }, a50.children === void 0 ? o39.toLanguageString(a10, t4[a10]) : a50.children));
};
i17.displayName = "ChartNoDataOverlay";

// node_modules/@progress/kendo-react-charts/methods/index.mjs
var e9 = (n21, a50) => {
  if (n21 && n21.chartInstance !== null)
    return n21.chartInstance.findAxisByName(a50);
};
var s7 = (n21, a50) => {
  if (n21 && n21.chartInstance !== null)
    return n21.chartInstance.findPaneByIndex(a50);
};
var i18 = (n21, a50) => {
  if (n21 && n21.chartInstance !== null)
    return n21.chartInstance.findPaneByName(a50);
};
var c6 = (n21, a50 = {}) => {
  if (n21 && n21.chartInstance !== null)
    return n21.chartInstance.exportVisual(a50);
};

// node_modules/@progress/kendo-react-charts/components/axis-defaults/Title.mjs
var e10 = __toESM(require_react(), 1);
var i19 = (t43) => e10.createElement(n8, { ...t43, _chartKey: "title" });
i19.displayName = "ChartAxisDefaultsTitle";

// node_modules/@progress/kendo-react-charts/components/axis-defaults/Labels.mjs
var e11 = __toESM(require_react(), 1);
var o5 = (a50) => e11.createElement(n8, { ...a50, _chartKey: "labels" });
o5.displayName = "ChartAxisDefaultsLabels";

// node_modules/@progress/kendo-react-charts/components/axis-defaults/Crosshair.mjs
var t5 = __toESM(require_react(), 1);
var s8 = (r28) => t5.createElement(n8, { visible: true, ...r28, _chartKey: "crosshair" });
s8.displayName = "ChartAxisDefaultsCrosshair";

// node_modules/@progress/kendo-react-charts/components/axis-defaults/CrosshairTooltip.mjs
var o6 = __toESM(require_react(), 1);
var i20 = (t43) => o6.createElement(n8, { visible: true, ...t43, _chartKey: "tooltip" });
i20.displayName = "ChartAxisDefaultsCrosshairTooltip";

// node_modules/@progress/kendo-react-charts/components/category-axis-item/Crosshair.mjs
var o7 = __toESM(require_react(), 1);
var a11 = (r28) => o7.createElement(n8, { visible: true, ...r28, _chartKey: "crosshair" });

// node_modules/@progress/kendo-react-charts/components/category-axis-item/CrosshairTooltip.mjs
var t6 = __toESM(require_react(), 1);
var i21 = (o39) => t6.createElement(n8, { visible: true, ...o39, _chartKey: "tooltip" });

// node_modules/@progress/kendo-react-charts/components/category-axis-item/Title.mjs
var e12 = __toESM(require_react(), 1);
var r11 = (t43) => e12.createElement(n8, { ...t43, _chartKey: "title" });
r11.displayName = "ChartCategoryAxisTitle";

// node_modules/@progress/kendo-react-charts/components/category-axis-item/Labels.mjs
var t7 = __toESM(require_react(), 1);
var a12 = (e41) => t7.createElement(n8, { visible: true, ...e41, _chartKey: "labels" });

// node_modules/@progress/kendo-react-charts/components/category-axis-item/Notes.mjs
var o8 = __toESM(require_react(), 1);
var a13 = (t43) => o8.createElement(n8, { ...t43, _chartKey: "notes" });

// node_modules/@progress/kendo-react-charts/components/category-axis-item/NotesIcon.mjs
var t8 = __toESM(require_react(), 1);
var n11 = (o39) => t8.createElement(n8, { ...o39, _chartKey: "icon" });

// node_modules/@progress/kendo-react-charts/components/category-axis-item/NotesLabel.mjs
var e13 = __toESM(require_react(), 1);
var a14 = (t43) => e13.createElement(n8, { ...t43, _chartKey: "label" });

// node_modules/@progress/kendo-react-charts/components/category-axis-item/RangeLabels.mjs
var t9 = __toESM(require_react(), 1);
var o9 = (e41) => t9.createElement(n8, { visible: true, ...e41, _chartKey: "rangeLabels" });

// node_modules/@progress/kendo-react-charts/components/pane-defaults/Title.mjs
var e14 = __toESM(require_react(), 1);
var o10 = (t43) => e14.createElement(n8, { ...t43, _chartKey: "title" });
o10.displayName = "ChartPaneDefaultsTitle";

// node_modules/@progress/kendo-react-charts/components/legend/Item.mjs
var t10 = __toESM(require_react(), 1);
var o11 = (e41) => t10.createElement(n8, { ...e41, _chartKey: "item" });
o11.displayName = "ChartLegendItem";

// node_modules/@progress/kendo-react-charts/components/legend/Title.mjs
var t11 = __toESM(require_react(), 1);
var r12 = (e41) => t11.createElement(n8, { ...e41, _chartKey: "title" });
r12.displayName = "ChartLegendTitle";

// node_modules/@progress/kendo-react-charts/components/legend/InactiveItems.mjs
var t12 = __toESM(require_react(), 1);
var n12 = (e41) => t12.createElement(n8, { ...e41, _chartKey: "inactiveItems" });
n12.displayName = "ChartLegendInactiveItems";

// node_modules/@progress/kendo-react-charts/components/series-item/Tooltip.mjs
var o12 = __toESM(require_react(), 1);
var i22 = (t43) => o12.createElement(n8, { ...t43, _chartKey: "tooltip" });

// node_modules/@progress/kendo-react-charts/components/series-item/Outliers.mjs
var e15 = __toESM(require_react(), 1);
var i23 = (t43) => e15.createElement(n8, { ...t43, _chartKey: "outliers" });

// node_modules/@progress/kendo-react-charts/components/series-item/Notes.mjs
var e16 = __toESM(require_react(), 1);
var n13 = (t43) => e16.createElement(n8, { ...t43, _chartKey: "notes" });

// node_modules/@progress/kendo-react-charts/components/series-item/Markers.mjs
var e17 = __toESM(require_react(), 1);
var a15 = (r28) => e17.createElement(n8, { ...r28, _chartKey: "markers" });

// node_modules/@progress/kendo-react-charts/components/series-item/Labels.mjs
var t13 = __toESM(require_react(), 1);
var a16 = (e41) => t13.createElement(n8, { visible: true, ...e41, _chartKey: "labels" });

// node_modules/@progress/kendo-react-charts/components/series-item/Highlight.mjs
var e18 = __toESM(require_react(), 1);
var i24 = (t43) => e18.createElement(n8, { ...t43, _chartKey: "highlight" });

// node_modules/@progress/kendo-react-charts/components/series-item/Extremes.mjs
var t14 = __toESM(require_react(), 1);
var m4 = (e41) => t14.createElement(n8, { ...e41, _chartKey: "extremes" });

// node_modules/@progress/kendo-react-charts/components/series-item/ErrorBars.mjs
var o13 = __toESM(require_react(), 1);
var a17 = (r28) => o13.createElement(n8, { ...r28, _chartKey: "errorBars" });

// node_modules/@progress/kendo-react-charts/components/series-item/LabelsFrom.mjs
var r13 = __toESM(require_react(), 1);
var m5 = (o39) => r13.createElement(n8, { ...o39, _chartKey: "from" });

// node_modules/@progress/kendo-react-charts/components/series-item/LabelsTo.mjs
var t15 = __toESM(require_react(), 1);
var a18 = (o39) => t15.createElement(n8, { ...o39, _chartKey: "to" });

// node_modules/@progress/kendo-react-charts/components/series-item/NotesLabel.mjs
var t16 = __toESM(require_react(), 1);
var a19 = (e41) => t16.createElement(n8, { ...e41, _chartKey: "label" });

// node_modules/@progress/kendo-react-charts/components/series-item/NotesIcon.mjs
var t17 = __toESM(require_react(), 1);
var n14 = (o39) => t17.createElement(n8, { ...o39, _chartKey: "icon" });

// node_modules/@progress/kendo-react-charts/components/value-axis-item/Crosshair.mjs
var o14 = __toESM(require_react(), 1);
var a20 = (r28) => o14.createElement(n8, { visible: true, ...r28, _chartKey: "crosshair" });

// node_modules/@progress/kendo-react-charts/components/value-axis-item/CrosshairTooltip.mjs
var t18 = __toESM(require_react(), 1);
var i25 = (o39) => t18.createElement(n8, { visible: true, ...o39, _chartKey: "tooltip" });

// node_modules/@progress/kendo-react-charts/components/value-axis-item/Title.mjs
var e19 = __toESM(require_react(), 1);
var i26 = (t43) => e19.createElement(n8, { ...t43, _chartKey: "title" });
i26.displayName = "ChartValueAxisTitle";

// node_modules/@progress/kendo-react-charts/components/value-axis-item/Labels.mjs
var t19 = __toESM(require_react(), 1);
var a21 = (e41) => t19.createElement(n8, { visible: true, ...e41, _chartKey: "labels" });

// node_modules/@progress/kendo-react-charts/components/value-axis-item/Notes.mjs
var o15 = __toESM(require_react(), 1);
var a22 = (t43) => o15.createElement(n8, { ...t43, _chartKey: "notes" });

// node_modules/@progress/kendo-react-charts/components/value-axis-item/NotesIcon.mjs
var t20 = __toESM(require_react(), 1);
var n15 = (o39) => t20.createElement(n8, { ...o39, _chartKey: "icon" });

// node_modules/@progress/kendo-react-charts/components/value-axis-item/NotesLabel.mjs
var t21 = __toESM(require_react(), 1);
var r14 = (e41) => t21.createElement(n8, { ...e41, _chartKey: "label" });

// node_modules/@progress/kendo-react-charts/components/x-axis-item/Crosshair.mjs
var o16 = __toESM(require_react(), 1);
var i27 = (r28) => o16.createElement(n8, { visible: true, ...r28, _chartKey: "crosshair" });

// node_modules/@progress/kendo-react-charts/components/x-axis-item/CrosshairTooltip.mjs
var t22 = __toESM(require_react(), 1);
var i28 = (o39) => t22.createElement(n8, { visible: true, ...o39, _chartKey: "tooltip" });

// node_modules/@progress/kendo-react-charts/components/x-axis-item/Title.mjs
var e20 = __toESM(require_react(), 1);
var o17 = (t43) => e20.createElement(n8, { ...t43, _chartKey: "title" });
o17.displayName = "ChartXAxisTitle";

// node_modules/@progress/kendo-react-charts/components/x-axis-item/Labels.mjs
var t23 = __toESM(require_react(), 1);
var a23 = (e41) => t23.createElement(n8, { visible: true, ...e41, _chartKey: "labels" });

// node_modules/@progress/kendo-react-charts/components/x-axis-item/Notes.mjs
var o18 = __toESM(require_react(), 1);
var n16 = (t43) => o18.createElement(n8, { ...t43, _chartKey: "notes" });

// node_modules/@progress/kendo-react-charts/components/x-axis-item/NotesIcon.mjs
var t24 = __toESM(require_react(), 1);
var n17 = (o39) => t24.createElement(n8, { ...o39, _chartKey: "icon" });

// node_modules/@progress/kendo-react-charts/components/x-axis-item/NotesLabel.mjs
var e21 = __toESM(require_react(), 1);
var a24 = (t43) => e21.createElement(n8, { ...t43, _chartKey: "label" });

// node_modules/@progress/kendo-react-charts/components/y-axis-item/Crosshair.mjs
var o19 = __toESM(require_react(), 1);
var i29 = (r28) => o19.createElement(n8, { visible: true, ...r28, _chartKey: "crosshair" });

// node_modules/@progress/kendo-react-charts/components/y-axis-item/CrosshairTooltip.mjs
var t25 = __toESM(require_react(), 1);
var i30 = (o39) => t25.createElement(n8, { visible: true, ...o39, _chartKey: "tooltip" });

// node_modules/@progress/kendo-react-charts/components/y-axis-item/Title.mjs
var e22 = __toESM(require_react(), 1);
var o20 = (t43) => e22.createElement(n8, { ...t43, _chartKey: "title" });
o20.displayName = "ChartYAxisTitle";

// node_modules/@progress/kendo-react-charts/components/y-axis-item/Labels.mjs
var t26 = __toESM(require_react(), 1);
var a25 = (e41) => t26.createElement(n8, { visible: true, ...e41, _chartKey: "labels" });

// node_modules/@progress/kendo-react-charts/components/y-axis-item/Notes.mjs
var o21 = __toESM(require_react(), 1);
var n18 = (t43) => o21.createElement(n8, { ...t43, _chartKey: "notes" });

// node_modules/@progress/kendo-react-charts/components/y-axis-item/NotesIcon.mjs
var t27 = __toESM(require_react(), 1);
var n19 = (o39) => t27.createElement(n8, { ...o39, _chartKey: "icon" });

// node_modules/@progress/kendo-react-charts/components/y-axis-item/NotesLabel.mjs
var e23 = __toESM(require_react(), 1);
var a26 = (t43) => e23.createElement(n8, { ...t43, _chartKey: "label" });

// node_modules/@progress/kendo-react-charts/components/navigator/pane/Title.mjs
var a27 = __toESM(require_react(), 1);
var o22 = (t43) => a27.createElement(n8, { ...t43, _chartKey: "title" });
o22.displayName = "ChartNavigatorPaneTitle";

// node_modules/@progress/kendo-react-charts/components/navigator/series-item/Tooltip.mjs
var o23 = __toESM(require_react(), 1);
var a28 = (t43) => o23.createElement(n8, { ...t43, _chartKey: "tooltip" });

// node_modules/@progress/kendo-react-charts/components/navigator/series-item/Outliers.mjs
var e24 = __toESM(require_react(), 1);
var a29 = (t43) => e24.createElement(n8, { ...t43, _chartKey: "outliers" });

// node_modules/@progress/kendo-react-charts/components/navigator/series-item/Notes.mjs
var o24 = __toESM(require_react(), 1);
var a30 = (t43) => o24.createElement(n8, { ...t43, _chartKey: "notes" });

// node_modules/@progress/kendo-react-charts/components/navigator/series-item/Markers.mjs
var e25 = __toESM(require_react(), 1);
var a31 = (r28) => e25.createElement(n8, { ...r28, _chartKey: "markers" });

// node_modules/@progress/kendo-react-charts/components/navigator/series-item/Labels.mjs
var t28 = __toESM(require_react(), 1);
var a32 = (e41) => t28.createElement(n8, { visible: true, ...e41, _chartKey: "labels" });

// node_modules/@progress/kendo-react-charts/components/navigator/series-item/Highlight.mjs
var o25 = __toESM(require_react(), 1);
var i31 = (t43) => o25.createElement(n8, { ...t43, _chartKey: "highlight" });

// node_modules/@progress/kendo-react-charts/components/navigator/series-item/Extremes.mjs
var t29 = __toESM(require_react(), 1);
var a33 = (e41) => t29.createElement(n8, { ...e41, _chartKey: "extremes" });

// node_modules/@progress/kendo-react-charts/components/navigator/series-item/ErrorBars.mjs
var o26 = __toESM(require_react(), 1);
var a34 = (r28) => o26.createElement(n8, { ...r28, _chartKey: "errorBars" });

// node_modules/@progress/kendo-react-charts/components/navigator/series-item/LabelsFrom.mjs
var r15 = __toESM(require_react(), 1);
var a35 = (o39) => r15.createElement(n8, { ...o39, _chartKey: "from" });

// node_modules/@progress/kendo-react-charts/components/navigator/series-item/LabelsTo.mjs
var t30 = __toESM(require_react(), 1);
var a36 = (o39) => t30.createElement(n8, { ...o39, _chartKey: "to" });

// node_modules/@progress/kendo-react-charts/components/navigator/series-item/NotesLabel.mjs
var t31 = __toESM(require_react(), 1);
var a37 = (e41) => t31.createElement(n8, { ...e41, _chartKey: "label" });

// node_modules/@progress/kendo-react-charts/components/navigator/series-item/NotesIcon.mjs
var t32 = __toESM(require_react(), 1);
var a38 = (o39) => t32.createElement(n8, { ...o39, _chartKey: "icon" });

// node_modules/@progress/kendo-react-charts/components/navigator/CategoryAxis.mjs
var a39 = __toESM(require_react(), 1);
var r16 = (t43) => a39.createElement(n8, { ...t43, _chartKey: "categoryAxis" });
r16.displayName = "ChartNavigatorCategoryAxis";

// node_modules/@progress/kendo-react-charts/components/navigator/Hint.mjs
var o27 = __toESM(require_react(), 1);
var e26 = (t43) => o27.createElement(n8, { ...t43, _chartKey: "hint" });

// node_modules/@progress/kendo-react-charts/components/navigator/Pane.mjs
var t33 = __toESM(require_react(), 1);
var o28 = (a50) => t33.createElement(n8, { ...a50, _chartKey: "pane" });
o28.displayName = "ChartNavigatorPane";

// node_modules/@progress/kendo-react-charts/components/navigator/Select.mjs
var e27 = __toESM(require_react(), 1);
var a40 = (t43) => e27.createElement(n8, { ...t43, _chartKey: "select" });

// node_modules/@progress/kendo-react-charts/components/navigator/Series.mjs
var o29 = __toESM(require_react(), 1);

// node_modules/@progress/kendo-react-charts/components/navigator/SeriesItem.mjs
var e28 = __toESM(require_react(), 1);
var a41 = (t43) => e28.createElement(n8, { ...t43 });
a41.displayName = "ChartNavigatorSeriesItem";

// node_modules/@progress/kendo-react-charts/components/navigator/Series.mjs
var m6 = (r28) => o29.createElement(a9, { ...r28, _chartKey: "series" });
m6.propTypes = {
  children: function(r28, e41, t43) {
    return l2(r28, e41, t43, a41);
  }
};

// node_modules/@progress/kendo-react-charts/components/ChartArea.mjs
var a42 = __toESM(require_react(), 1);
var e29 = (r28) => a42.createElement(n8, { ...r28, _chartKey: "chartArea" });
e29.displayName = "ChartArea";

// node_modules/@progress/kendo-react-charts/components/AxisDefaults.mjs
var e30 = __toESM(require_react(), 1);
var r17 = (t43) => e30.createElement(n8, { ...t43, _chartKey: "axisDefaults" });

// node_modules/@progress/kendo-react-charts/components/CategoryAxis.mjs
var a43 = __toESM(require_react(), 1);

// node_modules/@progress/kendo-react-charts/components/CategoryAxisItem.mjs
var e31 = __toESM(require_react(), 1);
var r18 = (t43) => e31.createElement(n8, { ...t43 });
r18.displayName = "ChartCategoryAxisItem";

// node_modules/@progress/kendo-react-charts/components/CategoryAxis.mjs
var t34 = (r28) => a43.createElement(a9, { ...r28, _chartKey: "categoryAxis" });
t34.propTypes = {
  children: function(r28, o39, e41) {
    return l2(r28, o39, e41, r18);
  }
};
t34.displayName = "ChartCategoryAxis";

// node_modules/@progress/kendo-react-charts/components/Legend.mjs
var t35 = __toESM(require_react(), 1);
var o30 = (e41) => t35.createElement(n8, { visible: true, ...e41, _chartKey: "legend" });
o30.displayName = "ChartLegend";

// node_modules/@progress/kendo-react-charts/components/Navigator.mjs
var o31 = __toESM(require_react(), 1);
var r19 = (t43) => o31.createElement(n8, { visible: true, position: "bottom", ...t43, _chartKey: "navigator" });
r19.displayName = "ChartNavigator";

// node_modules/@progress/kendo-react-charts/components/Pane.mjs
var a44 = __toESM(require_react(), 1);
var o32 = (t43) => a44.createElement(n8, { ...t43 });
o32.displayName = "ChartPane";

// node_modules/@progress/kendo-react-charts/components/PaneDefaults.mjs
var e32 = __toESM(require_react(), 1);
var o33 = (a50) => e32.createElement(n8, { ...a50, _chartKey: "paneDefaults" });
o33.displayName = "ChartPaneDefaults";

// node_modules/@progress/kendo-react-charts/components/Panes.mjs
var e33 = __toESM(require_react(), 1);
var m7 = (r28) => e33.createElement(a9, { ...r28, _chartKey: "panes" });
m7.propTypes = {
  children: function(r28, o39, t43) {
    return l2(r28, o39, t43, o32);
  }
};

// node_modules/@progress/kendo-react-charts/components/PlotArea.mjs
var o34 = __toESM(require_react(), 1);
var a45 = (t43) => o34.createElement(n8, { ...t43, _chartKey: "plotArea" });

// node_modules/@progress/kendo-react-charts/components/Series.mjs
var i32 = __toESM(require_react(), 1);

// node_modules/@progress/kendo-react-charts/components/SeriesItem.mjs
var r20 = __toESM(require_react(), 1);
var c7 = (t43) => {
  let l7 = (e41) => r20.createElement(r20.Fragment, null);
  t43.drilldownSeriesFactory && (l7 = t43.drilldownSeriesFactory);
  const n21 = (e41) => {
    var a50, o39;
    return e41 && ((o39 = (a50 = e41.drilldownState) == null ? void 0 : a50.steps) == null ? void 0 : o39.find(({ seriesName: i37 }) => i37 === t43.name));
  };
  return r20.createElement(e4.Consumer, null, (e41) => n21(e41) ? r20.createElement(
    l7,
    {
      _chartCollectionIdxKey: t43._chartCollectionIdxKey,
      drilldownValue: n21(e41).drilldownValue
    }
  ) : r20.createElement(n8, { ...t43 }));
};
c7.displayName = "ChartSeriesItem";

// node_modules/@progress/kendo-react-charts/components/Series.mjs
var r21 = (e41) => i32.createElement(a9, { ...e41, _chartKey: "series" });
r21.propTypes = {
  children: function(e41, t43, o39) {
    return l2(e41, t43, o39, c7);
  }
};
r21.displayName = "ChartSeries";

// node_modules/@progress/kendo-react-charts/components/SeriesDefaults.mjs
var t36 = __toESM(require_react(), 1);
var a46 = (e41) => t36.createElement(n8, { ...e41, _chartKey: "seriesDefaults" });

// node_modules/@progress/kendo-react-charts/components/Subtitle.mjs
var e34 = __toESM(require_react(), 1);
var r22 = (t43) => e34.createElement(n8, { ...t43, _chartKey: "subtitle" });
r22.displayName = "ChartSubtitle";

// node_modules/@progress/kendo-react-charts/components/Title.mjs
var e35 = __toESM(require_react(), 1);
var r23 = (t43) => e35.createElement(n8, { ...t43, _chartKey: "title" });
r23.displayName = "ChartTitle";

// node_modules/@progress/kendo-react-charts/components/Tooltip.mjs
var o35 = __toESM(require_react(), 1);
var r24 = (t43) => o35.createElement(n8, { visible: true, ...t43, _chartKey: "tooltip" });
r24.displayName = "ChartTooltip";

// node_modules/@progress/kendo-react-charts/components/ValueAxis.mjs
var a47 = __toESM(require_react(), 1);

// node_modules/@progress/kendo-react-charts/components/ValueAxisItem.mjs
var e36 = __toESM(require_react(), 1);
var o36 = (t43) => e36.createElement(n8, { ...t43 });
o36.displayName = "ChartValueAxisItem";

// node_modules/@progress/kendo-react-charts/components/ValueAxis.mjs
var r25 = (e41) => a47.createElement(a9, { ...e41, _chartKey: "valueAxis" });
r25.propTypes = {
  children: function(e41, t43, o39) {
    return l2(e41, t43, o39, o36);
  }
};
r25.displayName = "ChartValueAxis";

// node_modules/@progress/kendo-react-charts/components/XAxis.mjs
var i33 = __toESM(require_react(), 1);

// node_modules/@progress/kendo-react-charts/components/XAxisItem.mjs
var e37 = __toESM(require_react(), 1);
var m8 = (t43) => e37.createElement(n8, { ...t43 });
m8.displayName = "ChartXAxisItem";

// node_modules/@progress/kendo-react-charts/components/XAxis.mjs
var r26 = (t43) => i33.createElement(a9, { ...t43, _chartKey: "xAxis" });
r26.prototype = {
  children: function(t43, o39, e41) {
    return l2(t43, o39, e41, m8);
  }
};
r26.displayName = "ChartXAxis";

// node_modules/@progress/kendo-react-charts/components/YAxis.mjs
var i34 = __toESM(require_react(), 1);

// node_modules/@progress/kendo-react-charts/components/YAxisItem.mjs
var e38 = __toESM(require_react(), 1);
var m9 = (t43) => e38.createElement(n8, { ...t43 });
m9.displayName = "ChartYAxisItem";

// node_modules/@progress/kendo-react-charts/components/YAxis.mjs
var t37 = (r28) => i34.createElement(a9, { ...r28, _chartKey: "yAxis" });
t37.propTypes = {
  children: function(r28, o39, e41) {
    return l2(r28, o39, e41, m9);
  }
};
t37.displayName = "ChartYAxis";

// node_modules/@progress/kendo-react-charts/components/Zoomable.mjs
var t38 = __toESM(require_react(), 1);
var a48 = (o39) => t38.createElement(n8, { ...o39, _chartKey: "zoomable" });

// node_modules/@progress/kendo-react-charts/sankey/Sankey.mjs
var e40 = __toESM(require_react(), 1);

// node_modules/@progress/kendo-react-charts/sankey/propTypes.mjs
var import_prop_types3 = __toESM(require_prop_types(), 1);
var r27 = import_prop_types3.default.exact({
  left: import_prop_types3.default.number,
  top: import_prop_types3.default.number
});
var i35 = {
  left: import_prop_types3.default.number,
  right: import_prop_types3.default.number
};
var l6 = {
  ...i35,
  top: import_prop_types3.default.number,
  bottom: import_prop_types3.default.number
};
var t39 = import_prop_types3.default.oneOfType([import_prop_types3.default.number, import_prop_types3.default.exact(l6)]);
var n20 = t39;
var o37 = import_prop_types3.default.exact({
  width: import_prop_types3.default.number,
  color: import_prop_types3.default.string,
  opacity: import_prop_types3.default.number,
  dashType: import_prop_types3.default.string
});
var a49 = {
  visible: import_prop_types3.default.bool,
  font: import_prop_types3.default.string,
  color: import_prop_types3.default.string,
  opacity: import_prop_types3.default.number,
  align: import_prop_types3.default.oneOf(["left", "right", "center"]),
  position: import_prop_types3.default.oneOf(["inside", "before", "after"]),
  padding: n20,
  margin: import_prop_types3.default.exact(i35),
  border: o37,
  offset: r27
};
var s9 = {
  color: import_prop_types3.default.string,
  opacity: import_prop_types3.default.number,
  offset: r27,
  padding: import_prop_types3.default.number,
  width: import_prop_types3.default.number,
  focusHighlight: import_prop_types3.default.exact({
    border: o37
  })
};
var c8 = {
  colorType: import_prop_types3.default.oneOf(["static", "source", "target"]),
  color: import_prop_types3.default.string,
  opacity: import_prop_types3.default.number,
  highlight: import_prop_types3.default.exact({
    opacity: import_prop_types3.default.number,
    inactiveOpacity: import_prop_types3.default.number
  }),
  focusHighlight: import_prop_types3.default.exact({
    border: o37
  })
};
var b = import_prop_types3.default.exact({
  text: import_prop_types3.default.string,
  ...a49
});
var p7 = import_prop_types3.default.exact({
  id: import_prop_types3.default.oneOfType([import_prop_types3.default.string, import_prop_types3.default.number]).isRequired,
  label: b.isRequired,
  ...s9
});
var u6 = import_prop_types3.default.exact({
  sourceId: import_prop_types3.default.oneOfType([import_prop_types3.default.string, import_prop_types3.default.number]).isRequired,
  targetId: import_prop_types3.default.oneOfType([import_prop_types3.default.string, import_prop_types3.default.number]).isRequired,
  value: import_prop_types3.default.number.isRequired,
  ...c8
});
var f3 = {
  data: import_prop_types3.default.exact({
    nodes: import_prop_types3.default.arrayOf(p7.isRequired).isRequired,
    links: import_prop_types3.default.arrayOf(u6.isRequired).isRequired
  }).isRequired,
  links: import_prop_types3.default.exact(c8),
  nodes: import_prop_types3.default.exact(s9),
  labels: import_prop_types3.default.exact(a49),
  legend: import_prop_types3.default.exact({
    align: import_prop_types3.default.oneOf(["start", "center", "end"]),
    background: import_prop_types3.default.string,
    border: o37,
    height: import_prop_types3.default.number,
    labels: import_prop_types3.default.object,
    margin: t39,
    offsetX: import_prop_types3.default.number,
    offsetY: import_prop_types3.default.number,
    orientation: import_prop_types3.default.oneOf(["vertical", "horizontal"]),
    padding: n20,
    position: import_prop_types3.default.oneOf(["top", "bottom", "left", "right", "custom"]),
    reverse: import_prop_types3.default.bool,
    visible: import_prop_types3.default.bool,
    width: import_prop_types3.default.number,
    item: import_prop_types3.default.object,
    title: import_prop_types3.default.object
  }),
  title: import_prop_types3.default.exact({
    align: import_prop_types3.default.oneOf(["center", "left", "right"]),
    background: import_prop_types3.default.string,
    border: o37,
    color: import_prop_types3.default.string,
    font: import_prop_types3.default.string,
    margin: t39,
    padding: n20,
    position: import_prop_types3.default.oneOf(["top", "bottom"]),
    text: import_prop_types3.default.string,
    visible: import_prop_types3.default.bool
  }),
  tooltip: import_prop_types3.default.exact({
    visible: import_prop_types3.default.bool,
    appendTo: import_prop_types3.default.any,
    offset: import_prop_types3.default.number,
    followPointer: import_prop_types3.default.bool,
    delay: import_prop_types3.default.number,
    linkComponent: import_prop_types3.default.any,
    nodeComponent: import_prop_types3.default.any
  }),
  className: import_prop_types3.default.string,
  style: import_prop_types3.default.object,
  dir: import_prop_types3.default.string,
  disableAutoLayout: import_prop_types3.default.bool,
  disableKeyboardNavigation: import_prop_types3.default.bool,
  onNodeEnter: import_prop_types3.default.func,
  onNodeLeave: import_prop_types3.default.func,
  onLinkEnter: import_prop_types3.default.func,
  onLinkLeave: import_prop_types3.default.func,
  onNodeClick: import_prop_types3.default.func,
  onLinkClick: import_prop_types3.default.func
};

// node_modules/@progress/kendo-react-charts/sankey/SankeyTooltip.mjs
var t41 = __toESM(require_react(), 1);
var k = __toESM(require_react_dom(), 1);

// node_modules/@progress/kendo-react-charts/sankey/messages.mjs
var t40 = "sankey.tooltipUnitFormat";
var o38 = {
  [t40]: "({0} units)"
};

// node_modules/@progress/kendo-react-charts/sankey/SankeyTooltip.mjs
var $ = (e41) => {
  const {
    appendTo: n21,
    Content: l7,
    dir: c9,
    offset: o39,
    event: { tooltipData: s10, dataItem: x7, nodeValue: v5 }
  } = e41, f5 = t41.useRef(null);
  t41.useEffect(() => {
    const r28 = f5.current;
    if (!s10 || !r28)
      return;
    const d5 = { width: r28.offsetWidth, height: r28.offsetHeight }, a50 = { ...s10.popupOffset }, m10 = s10.popupAlign;
    a50.left += m10.horizontal === "left" ? o39 : -1 * o39, m10.horizontal === "right" && (a50.left -= d5.width), m10.vertical === "bottom" ? a50.top -= d5.height + o39 : a50.top += o39, r28.style.left = `${a50.left}px`, r28.style.top = `${a50.top}px`, r28.style.visibility = "";
  }, [s10, o39]);
  const u7 = t41.createElement(
    "div",
    {
      ref: f5,
      style: { visibility: "hidden" },
      dir: c9,
      className: "k-tooltip k-sankey-tooltip k-chart-tooltip k-chart-shared-tooltip"
    },
    t41.createElement("div", { className: "k-tooltip-content" }, t41.createElement(l7, { dir: c9, dataItem: x7, nodeValue: v5 }))
  );
  return n21 ? k.createPortal(u7, n21) : u7;
};
var g = 3;
var L = `0 ${g}px`;
var E2 = { display: "flex", alignItems: "center" };
var p8 = (e41) => t41.createElement(
  "div",
  {
    style: {
      width: 15,
      height: 15,
      backgroundColor: e41.color,
      display: "inline-flex",
      marginLeft: g
    }
  }
);
var i36 = (e41) => t41.createElement("span", { style: { margin: L } }, e41.children);
var y = (e41) => i().format(
  i2().toLanguageString(t40, o38[t40]),
  [e41 || 0]
);
var A = (e41) => {
  const { color: n21, label: l7 } = e41.dataItem;
  return t41.createElement("div", { style: E2, className: "k-tooltip-content" }, t41.createElement(p8, { color: n21 }), t41.createElement(i36, null, l7.text), t41.createElement(i36, null, y(e41.nodeValue)));
};
var D = (e41) => {
  const { source: n21, target: l7, value: c9 } = e41.dataItem, o39 = e41.dir === "rtl" ? arrowLeftIcon : arrowRightIcon;
  return t41.createElement("div", { style: E2 }, t41.createElement(p8, { color: n21.color }), t41.createElement(i36, null, n21.label.text), t41.createElement(v, { icon: o39, name: o39.name }), t41.createElement(p8, { color: l7.color }), t41.createElement(i36, null, l7.label.text), t41.createElement(i36, null, y(c9)));
};

// node_modules/@progress/kendo-react-charts/sankey/Sankey.mjs
var w2 = 12;
var f4 = {
  offset: w2,
  visible: true
};
var J = ["nodeEnter", "nodeLeave", "linkEnter", "linkLeave", "nodeClick", "linkClick"];
var Q2 = (n21, u7) => {
  n21 && (n21.unbind(), J.forEach((s10) => {
    u7[s10] && n21.bind(s10, u7[s10]);
  }));
};
var x6 = e40.forwardRef((n21, u7) => {
  const s10 = !d(e6, { component: "Sankey" }), D2 = w(e6), l7 = e40.useRef(null), o39 = e40.useRef(null), c9 = u(l7, n21.dir, [n21.dir, l7.current]), k2 = e40.useRef(null), m10 = o(l7), {
    data: y2,
    links: v5,
    nodes: g2,
    labels: E3,
    title: b2,
    legend: C2,
    tooltip: d5 = f4,
    disableAutoLayout: L2,
    disableKeyboardNavigation: T3
  } = n21, R = e40.useRef(void 0);
  R.current = n21;
  const [h4, N] = e40.useState(null), S = e40.useCallback(
    (r28) => {
      const {
        visible: i37,
        appendTo: t43 = m10().body,
        offset: p9 = w2,
        nodeComponent: M2 = A,
        linkComponent: H = D
      } = { ...f4, ...d5 };
      if (i37) {
        const W = {
          appendTo: t43,
          event: r28,
          offset: p9,
          dir: c9,
          Content: r28.targetType === "node" ? M2 : H
        };
        N(W);
      }
    },
    [d5, c9, m10]
  ), O = e40.useCallback(() => {
    N(null);
  }, []), a50 = e40.useCallback((r28, i37) => {
    const t43 = R.current[r28];
    if (t43) {
      const p9 = {
        ...i37,
        nativeEvent: i37.originalEvent,
        target: k2.current
      };
      t43.call(void 0, p9);
    }
  }, []);
  return e40.useEffect(() => {
    const r28 = {
      data: y2,
      links: v5,
      nodes: g2,
      labels: E3,
      title: b2,
      legend: C2,
      disableAutoLayout: L2,
      disableKeyboardNavigation: T3,
      rtl: c9 === "rtl",
      tooltip: { ...f4, ...d5 }
    };
    if (o39.current)
      o39.current.setOptions(r28);
    else if (e && l7.current) {
      const i37 = sankeyTheme(l7.current);
      o39.current = new Sankey2(l7.current, r28, i37), Q2(o39.current, {
        nodeEnter: (t43) => {
          a50("onNodeEnter", t43);
        },
        nodeLeave: (t43) => {
          a50("onNodeLeave", t43);
        },
        linkEnter: (t43) => {
          a50("onLinkEnter", t43);
        },
        linkLeave: (t43) => {
          a50("onLinkLeave", t43);
        },
        nodeClick: (t43) => {
          a50("onNodeClick", t43);
        },
        linkClick: (t43) => {
          a50("onLinkClick", t43);
        }
      }), o39.current.bind("tooltipShow", S), o39.current.bind("tooltipHide", O);
    }
    return () => {
      o39.current && (o39.current.destroy(), o39.current = null);
    };
  }, [
    y2,
    v5,
    g2,
    E3,
    b2,
    C2,
    L2,
    T3,
    c9,
    d5,
    O,
    S,
    a50
  ]), e40.useImperativeHandle(
    k2,
    () => ({
      get element() {
        return l7.current;
      },
      exportVisual: (r28) => o39.current.exportVisual(r28),
      props: n21
    }),
    []
  ), e40.useImperativeHandle(u7, () => k2.current), e40.createElement(e40.Fragment, null, e40.createElement("div", { ref: l7, className: n21.className, style: n21.style, dir: c9 }), h4 && e40.createElement($, { ...h4 }), s10 && e40.createElement(P, { message: D2 }));
});
x6.propTypes = f3;
x6.displayName = "KendoReactSankey";

// node_modules/@progress/kendo-react-charts/sankey/utils.mjs
var t42 = createSankeyData;
export {
  x as AxisLabelClickEvent,
  f2 as Chart,
  e29 as ChartArea,
  r17 as ChartAxisDefaults,
  s8 as ChartAxisDefaultsCrosshair,
  i20 as ChartAxisDefaultsCrosshairTooltip,
  o5 as ChartAxisDefaultsLabels,
  i19 as ChartAxisDefaultsTitle,
  s6 as ChartBreadcrumb,
  t34 as ChartCategoryAxis,
  a11 as ChartCategoryAxisCrosshair,
  i21 as ChartCategoryAxisCrosshairTooltip,
  r18 as ChartCategoryAxisItem,
  a12 as ChartCategoryAxisLabels,
  a13 as ChartCategoryAxisNotes,
  n11 as ChartCategoryAxisNotesIcon,
  a14 as ChartCategoryAxisNotesLabel,
  o9 as ChartCategoryAxisRangeLabels,
  r11 as ChartCategoryAxisTitle,
  o30 as ChartLegend,
  n12 as ChartLegendInactiveItems,
  o11 as ChartLegendItem,
  r12 as ChartLegendTitle,
  r19 as ChartNavigator,
  r16 as ChartNavigatorCategoryAxis,
  e26 as ChartNavigatorHint,
  o28 as ChartNavigatorPane,
  o22 as ChartNavigatorPaneTitle,
  a40 as ChartNavigatorSelect,
  m6 as ChartNavigatorSeries,
  a34 as ChartNavigatorSeriesErrorBars,
  a33 as ChartNavigatorSeriesExtremes,
  i31 as ChartNavigatorSeriesHighlight,
  a41 as ChartNavigatorSeriesItem,
  a29 as ChartNavigatorSeriesItemOutliers,
  a28 as ChartNavigatorSeriesItemTooltip,
  a32 as ChartNavigatorSeriesLabels,
  a35 as ChartNavigatorSeriesLabelsFrom,
  a36 as ChartNavigatorSeriesLabelsTo,
  a31 as ChartNavigatorSeriesMarkers,
  a30 as ChartNavigatorSeriesNotes,
  a38 as ChartNavigatorSeriesNotesIcon,
  a37 as ChartNavigatorSeriesNotesLabel,
  i17 as ChartNoDataOverlay,
  o32 as ChartPane,
  o33 as ChartPaneDefaults,
  o10 as ChartPaneDefaultsTitle,
  m7 as ChartPanes,
  a45 as ChartPlotArea,
  r21 as ChartSeries,
  a46 as ChartSeriesDefaults,
  a17 as ChartSeriesErrorBars,
  m4 as ChartSeriesExtremes,
  i24 as ChartSeriesHighlight,
  c7 as ChartSeriesItem,
  i23 as ChartSeriesItemOutliers,
  i22 as ChartSeriesItemTooltip,
  a16 as ChartSeriesLabels,
  m5 as ChartSeriesLabelsFrom,
  a18 as ChartSeriesLabelsTo,
  a15 as ChartSeriesMarkers,
  n13 as ChartSeriesNotes,
  n14 as ChartSeriesNotesIcon,
  a19 as ChartSeriesNotesLabel,
  r22 as ChartSubtitle,
  r23 as ChartTitle,
  r24 as ChartTooltip,
  r25 as ChartValueAxis,
  a20 as ChartValueAxisCrosshair,
  i25 as ChartValueAxisCrosshairTooltip,
  o36 as ChartValueAxisItem,
  a21 as ChartValueAxisLabels,
  a22 as ChartValueAxisNotes,
  n15 as ChartValueAxisNotesIcon,
  r14 as ChartValueAxisNotesLabel,
  i26 as ChartValueAxisTitle,
  r26 as ChartXAxis,
  i27 as ChartXAxisCrosshair,
  i28 as ChartXAxisCrosshairTooltip,
  m8 as ChartXAxisItem,
  a23 as ChartXAxisLabels,
  n16 as ChartXAxisNotes,
  n17 as ChartXAxisNotesIcon,
  a24 as ChartXAxisNotesLabel,
  o17 as ChartXAxisTitle,
  t37 as ChartYAxis,
  i29 as ChartYAxisCrosshair,
  i30 as ChartYAxisCrosshairTooltip,
  m9 as ChartYAxisItem,
  a25 as ChartYAxisLabels,
  n18 as ChartYAxisNotes,
  n19 as ChartYAxisNotesIcon,
  a26 as ChartYAxisNotesLabel,
  o20 as ChartYAxisTitle,
  a48 as ChartZoomable,
  a9 as CollectionConfigurationComponent,
  n8 as ConfigurationComponent,
  i15 as CrosshairTooltip,
  p4 as CrosshairTooltipContainer,
  h2 as DonutCenter,
  i4 as DragEndEvent,
  r as DragEvent,
  r2 as DragStartEvent,
  n3 as DrilldownEvent,
  n9 as DrilldownStateChangeEvent,
  i6 as LegendItemClickEvent,
  i5 as LegendItemHoverEvent,
  i8 as NavigatorFilterEvent,
  r3 as NoteClickEvent,
  i9 as NoteHoverEvent,
  a as PlotAreaClickEvent,
  a2 as PlotAreaHoverEvent,
  o2 as RenderEvent,
  x6 as Sankey,
  i11 as SelectEndEvent,
  i10 as SelectEvent,
  i12 as SelectStartEvent,
  r4 as SeriesClickEvent,
  r5 as SeriesHoverEvent,
  h as SeriesTooltip,
  E as SharedTooltipContent,
  m2 as Sparkline,
  m3 as StockChart,
  a4 as TooltipPoint,
  a5 as TooltipPopup,
  i14 as ZoomEndEvent,
  i13 as ZoomEvent,
  r6 as ZoomStartEvent,
  t42 as createSankeyData,
  c6 as exportVisual,
  e9 as findAxisByName,
  s7 as findPaneByIndex,
  i18 as findPaneByName
};
/*! Bundled license information:

@progress/kendo-react-charts/utils/index.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/events/base-event.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/events/axis-label-click-event.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/events/preventable-event.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/events/drag-event.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/events/drag-end-event.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/events/drag-start-event.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/events/drilldown-event.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/events/legend-item-hover-event.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/events/legend-item-click-event.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/events/legend-item-leave-event.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/events/navigator-filter-event.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/events/note-click-event.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/events/note-hover-event.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/events/plot-area-click-event.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/events/plot-area-hover-event.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/events/render-event.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/events/select-event.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/events/select-end-event.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/events/select-start-event.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/events/series-click-event.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/events/series-hover-event.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/events/zoom-event.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/events/zoom-end-event.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/events/zoom-start-event.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/events/chart-event-builder.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/events/dom-event.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/store/store.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/store/reducer.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/tooltip/Point.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/tooltip/SharedTooltipContent.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/ChartContext.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/tooltip/Popup.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/tooltip/Series.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/Container.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/tooltip/Crosshair.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/tooltip/CrosshairContainer.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/package-metadata.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/BaseChart.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/DonutCenter.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/Chart.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/Sparkline.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/StockChart.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/base/CollectionConfigurationComponent.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/base/ConfigurationComponent.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/events/drilldown-state-change-event.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/ChartBreadcrumb.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/messages.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/ChartNoDataOverlay.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/methods/index.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/axis-defaults/Title.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/axis-defaults/Labels.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/axis-defaults/Crosshair.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/axis-defaults/CrosshairTooltip.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/category-axis-item/Crosshair.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/category-axis-item/CrosshairTooltip.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/category-axis-item/Title.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/category-axis-item/Labels.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/category-axis-item/Notes.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/category-axis-item/NotesIcon.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/category-axis-item/NotesLabel.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/category-axis-item/RangeLabels.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/pane-defaults/Title.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/legend/Item.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/legend/Title.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/legend/InactiveItems.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/series-item/Tooltip.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/series-item/Outliers.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/series-item/Notes.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/series-item/Markers.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/series-item/Labels.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/series-item/Highlight.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/series-item/Extremes.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/series-item/ErrorBars.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/series-item/LabelsFrom.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/series-item/LabelsTo.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/series-item/NotesLabel.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/series-item/NotesIcon.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/value-axis-item/Crosshair.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/value-axis-item/CrosshairTooltip.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/value-axis-item/Title.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/value-axis-item/Labels.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/value-axis-item/Notes.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/value-axis-item/NotesIcon.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/value-axis-item/NotesLabel.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/x-axis-item/Crosshair.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/x-axis-item/CrosshairTooltip.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/x-axis-item/Title.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/x-axis-item/Labels.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/x-axis-item/Notes.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/x-axis-item/NotesIcon.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/x-axis-item/NotesLabel.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/y-axis-item/Crosshair.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/y-axis-item/CrosshairTooltip.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/y-axis-item/Title.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/y-axis-item/Labels.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/y-axis-item/Notes.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/y-axis-item/NotesIcon.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/y-axis-item/NotesLabel.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/navigator/pane/Title.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/navigator/series-item/Tooltip.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/navigator/series-item/Outliers.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/navigator/series-item/Notes.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/navigator/series-item/Markers.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/navigator/series-item/Labels.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/navigator/series-item/Highlight.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/navigator/series-item/Extremes.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/navigator/series-item/ErrorBars.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/navigator/series-item/LabelsFrom.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/navigator/series-item/LabelsTo.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/navigator/series-item/NotesLabel.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/navigator/series-item/NotesIcon.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/navigator/CategoryAxis.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/navigator/Hint.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/navigator/Pane.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/navigator/Select.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/navigator/SeriesItem.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/navigator/Series.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/ChartArea.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/AxisDefaults.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/CategoryAxisItem.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/CategoryAxis.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/Legend.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/Navigator.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/Pane.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/PaneDefaults.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/Panes.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/PlotArea.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/SeriesItem.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/Series.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/SeriesDefaults.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/Subtitle.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/Title.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/Tooltip.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/ValueAxisItem.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/ValueAxis.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/XAxisItem.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/XAxis.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/YAxisItem.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/YAxis.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/components/Zoomable.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/sankey/propTypes.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/sankey/messages.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/sankey/SankeyTooltip.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/sankey/Sankey.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/sankey/utils.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-charts/index.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)
*/
//# sourceMappingURL=@progress_kendo-react-charts.js.map
