/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import * as r from "react";
import e from "prop-types";
import { getPageMargin as h } from "../getPageMargin.mjs";
import { savePDF as g } from "../savePDF.mjs";
import { provideSaveGridPDF as c } from "./provideSaveGridPDF.mjs";
import { createPortal as d } from "react-dom";
import { validatePackage as u, getLicenseMessage as f, WatermarkOverlay as y } from "@progress/kendo-react-common";
import { packageMetadata as n } from "../package-metadata.mjs";
const i = class i extends r.Component {
  constructor(t) {
    super(t), this.state = {
      show: !1
    }, this.showLicenseWatermark = !1, this.showLicenseWatermark = !u(n, { component: "GridPDFExport" }), this.licenseMessage = f(n), this.saveGridPDF = c(this.getSavePDF()), this.gridInnerWrapperRef = r.createRef();
  }
  /**
   * @hidden
   */
  componentDidUpdate(t, s) {
    this.state.show && this.state.show !== s.show && this.saveGridPDF(
      this.gridInnerWrapperRef.current,
      Object.assign({}, this.props, { margin: h(this.props) }),
      this.callback
    );
  }
  /**
   * @hidden
   */
  render() {
    return /* @__PURE__ */ r.createElement(r.Fragment, null, this.state.show && d(
      /* @__PURE__ */ r.createElement(
        "div",
        {
          style: {
            position: "absolute",
            left: "-5000px",
            top: "0px"
          }
        },
        /* @__PURE__ */ r.createElement("div", { ref: this.gridInnerWrapperRef }, this.prepareRawGridForExport(this.data))
      ),
      document.body
    ), this.showLicenseWatermark && /* @__PURE__ */ r.createElement(y, { message: this.licenseMessage }));
  }
  /* eslint-disable max-len */
  /**
   * Saves the content of the Grid as a PDF file.
   *
   * @param data - The data can be different from the currently displayed data in the Grid. Can be used to export all Grid pages.
   * @param callback - The callback that will be executed after the PDF is saved.
   */
  // tslint:enable:max-line-length
  save(t, s) {
    this.grid = this.getGrid(), this.columns = this.getCustomColumns(), this.data = t, this.callback = () => {
      this.setState({ show: !1 }), s && s();
    }, this.setState({ show: !0 });
  }
  getSavePDF() {
    return g;
  }
  getGrid() {
    return r.Children.toArray(this.props.children).find(
      (t) => t && t.type.displayName === "KendoReactGrid"
    );
  }
  getCustomColumns() {
    return r.Children.toArray(this.props.children).filter(
      (t) => t && t.type.displayName === "KendoReactGridColumn"
    );
  }
  prepareRawGridForExport(t) {
    const s = t && {
      data: t,
      total: t.length,
      pageSize: t.length,
      skip: 0
    }, p = { style: Object.assign({}, this.grid.props.style, { width: "1000px" }) }, l = { scrollable: this.grid.props === "none" ? "none" : "scrollable" }, o = Object.assign({}, s, p, l);
    if (this.columns && this.columns.length > 0) {
      const m = this.getGridNotColumnChildren(this.grid);
      return r.cloneElement(this.grid, o, this.columns.concat(m));
    }
    return r.cloneElement(this.grid, o);
  }
  getGridNotColumnChildren(t) {
    return r.Children.toArray(t.props.children).filter(
      (s) => s && s.type && s.type.displayName !== "KendoReactGridColumn"
    );
  }
};
i.propTypes = {
  author: e.string,
  avoidLinks: e.oneOfType([e.bool, e.string]),
  forcePageBreak: e.string,
  keepTogether: e.string,
  creator: e.string,
  date: e.instanceOf(Date),
  imageResolution: e.number,
  fileName: e.string,
  forceProxy: e.bool,
  keywords: e.string,
  landscape: e.bool,
  margin: e.oneOfType([
    e.string,
    e.number,
    e.shape({
      left: e.oneOfType([e.number, e.string]),
      top: e.oneOfType([e.number, e.string]),
      right: e.oneOfType([e.number, e.string]),
      bottom: e.oneOfType([e.number, e.string])
    })
  ]),
  pageTemplate: e.any,
  paperSize: e.any,
  repeatHeaders: e.bool,
  scale: e.number,
  proxyData: e.any,
  proxyURL: e.string,
  proxyTarget: e.string,
  producer: e.string,
  subject: e.string,
  title: e.string
};
let a = i;
export {
  a as GridPDFExport
};
