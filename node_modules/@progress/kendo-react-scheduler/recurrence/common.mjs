/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import { isPresent as s, isNullOrEmptyString as f } from "../utils/index.mjs";
import { parseRule as i } from "@progress/kendo-recurrence";
import { toLocalDate as u } from "@progress/kendo-date-math";
const r = (e) => e.charAt(0).toUpperCase() + e.slice(1), l = ["first", "second", "third", "fourth", "last"], k = ["never", "daily", "weekly", "monthly", "yearly"], m = [
  { day: 0, offset: 0 },
  { day: 1, offset: 0 },
  { day: 2, offset: 0 },
  { day: 3, offset: 0 },
  { day: 4, offset: 0 },
  { day: 5, offset: 0 },
  { day: 6, offset: 0 }
], D = [
  { day: 1, offset: 0 },
  { day: 2, offset: 0 },
  { day: 3, offset: 0 },
  { day: 4, offset: 0 },
  { day: 5, offset: 0 }
], b = [
  { day: 0, offset: 0 },
  { day: 6, offset: 0 }
], w = (e) => {
  switch (e) {
    case "day":
      return m;
    case "weekday":
      return D;
    case "weekend":
      return b;
  }
}, v = (e) => i({ recurrenceRule: e }) || {}, W = (e) => k.map((t) => ({
  value: t,
  text: e("Frequencies" + r(t))
})), R = (e) => s(e) && !f(e.freq) ? e.freq : "never", x = (e) => s(e.until) ? u(e.until) : null, F = (e) => e.dateFormatNames({
  type: "months",
  nameType: "wide",
  standAlone: !0
}).map(
  (t, a) => ({
    text: t,
    value: a + 1
  })
), N = (e) => {
  const t = e.firstDay(), a = e.dateFormatNames({
    type: "days",
    nameType: "abbreviated"
  }).map(
    (n, y) => ({
      text: n,
      value: y
    })
  );
  return a.slice(t).concat(a.slice(0, t));
}, O = (e, t, a) => {
  var y;
  let n;
  if (s(t.byWeekDay))
    switch (t.byWeekDay.length) {
      case 7:
        n = "day";
        break;
      case 5:
        n = "weekday";
        break;
      case 2:
        n = "weekend";
        break;
      case 1:
        n = t.byWeekDay[0].day;
        break;
      default:
        n = a.getDay();
        break;
    }
  else
    n = a.getDay();
  return (y = e.find((o) => n === o.value)) != null ? y : e[0];
}, S = (e, t) => {
  const a = e.firstDay(), n = e.dateFormatNames({
    type: "days",
    nameType: "wide"
  }).map(
    (c, d) => ({
      text: c,
      value: d
    })
  ), y = n.slice(a).concat(n.slice(0, a));
  return [
    { text: t("WeekdaysDay"), value: "day" },
    { text: t("WeekdaysWeekday"), value: "weekday" },
    { text: t("WeekdaysWeekendday"), value: "weekend" }
  ].concat(y);
}, E = (e, t) => e.find(
  (a) => a.value === (t.bySetPosition ? t.bySetPosition[0] : t.byWeekDay && t.byWeekDay[0] ? t.byWeekDay[0].offset : 1)
) || e[0], M = (e) => {
  const t = [1, 2, 3, 4, -1];
  return l.map(
    (a, n) => ({
      text: e("OffsetPositions" + r(a)),
      value: t[n]
    })
  );
}, P = (e) => s(e.count) ? "count" : s(e.until) ? "until" : "never", T = (e) => {
  if (s(e.byWeekDay))
    return "weekday";
  if (s(e.byMonthDay))
    return "monthday";
}, q = (e, t) => e.find((a) => (t.byMonth ? t.byMonth[0] : null) === a.value) || e[0], C = (e, t) => s(e.byMonthDay) && e.byMonthDay.length > 0 ? e.byMonthDay[0] : t.getDate();
export {
  k as FREQUENCIES,
  l as OFFSET_POSITIONS,
  r as capitalize,
  m as dayRule,
  P as getEndRule,
  S as getExtendedWeekDays,
  W as getFrequencies,
  R as getFrequency,
  q as getMonth,
  C as getMonthDay,
  F as getMonths,
  E as getOffset,
  M as getOffsets,
  T as getRepeatOnRule,
  v as getRule,
  x as getUntil,
  O as getWeekDay,
  N as getWeekDays,
  w as weekDayRuleFromString,
  D as weekdayRule,
  b as weekendRule
};
