/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
function g(n) {
  return n !== void 0 && (typeof n == "number" || /px$/i.test(String(n)));
}
function u(n, o, c) {
  const h = Array.from(n.tHead && n.tHead.rows || []), i = [o];
  let r;
  const l = c || ((t) => window.getComputedStyle(t).height || void 0);
  h.forEach((t) => {
    const e = l(t);
    i.push(g(e) ? parseFloat(String(e)) : t.offsetHeight);
  });
  for (let t = 0; t < h.length; t++)
    r = i.slice(0, t + 1).reduce((e, s) => e + s), Array.from(h[t].cells).forEach((e) => e.style.top = r + "px");
}
const a = 1e6;
function p(n) {
  const { rows: o, tableViewPortHeight: c, scrollTop: h } = n;
  if (o.length === 0)
    return [];
  const i = o[0].height, r = Math.min(Math.round(h / i), o.length), l = Math.round(c / i), t = Math.max(0, r - l), e = Math.min(o.length, r + 2 * l), s = o.slice(t, e), f = s[s.length - 1];
  return t > 0 && s.unshift({
    dataItem: {},
    level: [a],
    offsetTop: 0,
    height: s[0].offsetTop,
    levelCount: 0
  }), e < o.length - 1 && s.push({
    dataItem: {},
    level: [a, a],
    offsetTop: f.offsetTop + f.height,
    height: (o.length - e) * i,
    levelCount: 0
  }), s;
}
export {
  u as setHeaderRowsTop,
  p as tableRowsVirtualization
};
