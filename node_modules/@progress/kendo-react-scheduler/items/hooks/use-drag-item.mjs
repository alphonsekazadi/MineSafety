/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import { clone as c } from "@progress/kendo-react-common";
import * as R from "react";
import { useControlledState as C } from "../../hooks/useControlledState.mjs";
import { setField as u, getField as d, slotDive as _ } from "../../utils/index.mjs";
import { DATA_ACTION as M } from "../../constants/index.mjs";
import { useSchedulerViewSelectedItemsContext as x } from "../../context/SchedulerViewContext.mjs";
import { useSchedulerFieldsContext as k, useSchedulerGroupsContext as L } from "../../context/SchedulerContext.mjs";
var v = /* @__PURE__ */ ((t) => (t.set = "DRAG_ITEM_SET", t.start = "DRAG_ITEM_START", t.drag = "DRAG_ITEM_DRAG", t.complete = "DRAG_ITEM_COMPLETE", t.completeOccurrence = "DRAG_ITEM_COMPLETE_OCCURRENCE", t.completeSeries = "DRAG_ITEM_COMPLETE_SERIES", t.reset = "DRAG_ITEM_RESET", t.dragSelected = "DRAG_ITEM_DRAG_SELECTED", t))(v || {});
const B = (t, w) => {
  const f = R.useRef(0), S = R.useRef(0), b = R.useRef(0), y = R.useRef(null), [s, o] = C(...w), [h] = x(), r = k(), g = L();
  return [s, o, (n) => {
    switch (n.type) {
      case "DRAG_ITEM_SET": {
        o(n.payload);
        break;
      }
      case "DRAG_ITEM_RESET": {
        o(null);
        break;
      }
      case "DRAG_ITEM_DRAG_SELECTED": {
        if (Math.abs(S.current - n.payload.x) < 10 && Math.abs(b.current - n.payload.y) < 10)
          return;
        const e = _(n.payload.x, n.payload.y, 7);
        if (!e || e === y.current)
          return;
        const a = c(t.dataItem), l = e.getAttribute("data-slot-start"), E = e.getAttribute("data-slot-allday") === "true";
        if (!t.ignoreIsAllDay && E !== t.isAllDay)
          return;
        const i = new Date(d(a, r.start)), m = Number(l) - i.getTime(), G = h.map((p) => {
          if (!p.current)
            return null;
          const A = c(p.current.props.dataItem), T = new Date(p.current.props.start.getTime() + m), I = new Date(p.current.props.end.getTime() + m);
          return u(A, r.start, T), u(A, r.end, I), A;
        }).filter(Boolean);
        y.current = e, o([...G]);
        break;
      }
      case "DRAG_ITEM_START": {
        const e = n.payload.x, a = n.payload.y;
        S.current = e, b.current = a;
        const l = _(e, a, 7);
        if (!l)
          return;
        const E = c(t.dataItem), i = l.getAttribute("data-slot-start"), m = d(E, r.start);
        if (i === null)
          return;
        f.current = Number(i) - new Date(m).getTime();
        break;
      }
      case "DRAG_ITEM_DRAG": {
        if (Math.abs(S.current - n.payload.x) < 10 && Math.abs(b.current - n.payload.y) < 10)
          return;
        const e = _(n.payload.x, n.payload.y, 7);
        if (!e || e === y.current)
          return;
        const a = c(t.dataItem), l = e.getAttribute("data-slot-start"), E = e.getAttribute("data-slot-group"), i = e.getAttribute("data-slot-allday") === "true";
        if (!t.ignoreIsAllDay && i !== t.isAllDay)
          return;
        const m = new Date(d(a, r.start)), p = new Date(d(a, r.end)).getTime() - m.getTime(), A = new Date(Number(l) - Number(f.current)), T = new Date(Number(l) - Number(f.current) + p), I = g.find((D) => D.index === Number(E));
        u(a, r.start, A), u(a, r.end, T), I && g.length > 1 && I.resources.forEach((D) => {
          D.multiple || u(a, D.field, D[D.valueField]);
        }), y.current = e, a && o(a);
        break;
      }
      case "DRAG_ITEM_COMPLETE": {
        o(null), t.onDataAction && s && t.onDataAction.call(void 0, {
          type: M.update,
          series: !1,
          dataItem: s
        });
        break;
      }
      case "DRAG_ITEM_COMPLETE_OCCURRENCE": {
        const e = Array.isArray(s) ? s.slice() : c(s);
        o(null), t.onDataAction && s && t.onDataAction.call(void 0, {
          type: M.update,
          series: !1,
          dataItem: e
        });
        break;
      }
      case "DRAG_ITEM_COMPLETE_SERIES": {
        let e;
        if (Array.isArray(s))
          e = s.map((a) => {
            const l = c(a);
            return u(l, r.start, d(a, r.start)), u(l, r.end, d(a, r.end)), l;
          });
        else {
          const a = c(s);
          u(a, r.start, d(s, r.start)), u(a, r.end, d(s, r.end)), e = a;
        }
        o(null), t.onDataAction && e && t.onDataAction.call(void 0, {
          type: M.update,
          series: !0,
          dataItem: e
        });
        break;
      }
      default:
        o(s);
        break;
    }
  }];
};
export {
  v as DRAG_ITEM_ACTION,
  B as useDragItem
};
