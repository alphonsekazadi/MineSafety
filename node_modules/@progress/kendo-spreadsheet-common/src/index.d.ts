
/* eslint-disable max-len */

/**
 * Represents the default cell styles that will be applied to the sheet cells.
 */
export interface CellDefaultStyle {
    /**
     * The background [CSS color](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value) of the cell.
     */
    background?: string;

    /**
     * The text [CSS color](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value) of the cell.
     */
    color?: string;

    /**
     * The font family of the cell.
     */
    fontFamily?: string;

    /**
     * The font size of the cell in pixels.
     */
    fontSize?: number;

    /**
     * If set to `true`, sets the cell font to bold.
     */
    bold?: boolean;

    /**
     * If set to `true`, sets the cell font to italic.
     */
    italic?: boolean;

    /**
     * If set to `true`, sets the cell font to underline.
     */
    underline?: boolean;

    /**
     * If set to `true`, sets the cell wrap.
     */
    wrap?: boolean;
}

/**
 * Configures the Excel export settings of the Spreadsheet.
 */
export interface ExcelExportSettings {
    /**
     * Specifies the file name of the exported Excel file.
     *
     * @default 'Workbook.xslx'
     */
    fileName?: string;

    /**
     * If set to `true`, the content will be forwarded to proxyURL even if the browser supports the saving of files locally.
     *
     * @default false
     */
    forceProxy?: boolean;

    /**
     * The URL of the server side proxy which will stream the file to the end user. A proxy will be used when the browser is not capable of saving files locally. Such browsers are IE version 9 and lower and Safari. The developer is responsible for implementing the server-side proxy. The proxy will return the decoded file with the `Content-Disposition` header set to `attachment; filename="<fileName.xslx>"`.
     * The proxy will receive a POST request with the following parameters in the request body:
     * - contentType - The MIME type of the file.
     * - base64 - The base-64 encoded file content.
     * - fileName - The file name as requested by the caller.
     *
     * @default null
     */
    proxyURL?: string | null;
}

/**
 * The SheetColumn object.
 */
export interface SheetColumn {
    /**
     * The zero-based index of the column. Required to ensure correct positioning.
     */
    index?: number;

    /**
     * The width of the column in pixels. Defaults to columnWidth.
     */
    width?: number;
}

/**
 * The CellBorder object.
 */
export interface CellBorder {
    /**
     * The border color of the cell. Many standard CSS formats are supported. However, the canonical form is #ccff00.
     */
    color?: string;
    /**
     * The width of the border in pixels.
     */
    size?: number;
}

/**
 * Represents the interface of a Spreadsheet cell.
 */
export interface Cell extends CellDefaultStyle {
    /**
     * The style information for the bottom border of the cell.
     */
    borderBottom?: CellBorder;

    /**
     * The style information for the left border of the cell.
     */
    borderLeft?: CellBorder;

    /**
     * The style information for the right border of the cell.
     */
    borderRight?: CellBorder;

    /**
     * The style information for the top border of the cell.
     */
    borderTop?: CellBorder;

    /**
     * If set to `false`, disables the cell.
     */
    enable?: boolean;

    /**
     * The format of the cell text. For more information, refer to the article on
     * [creating or deleting a custom number format on MS Office](https://support.office.com/en-au/article/Create-or-delete-a-custom-number-format-78f2a361-936b-4c03-8772-09fab54be7f4).
     */
    format?: string;

    /**
     * The cell formula without the leading equals sign, for example, `A1 * 10`.
     */
    formula?: string;

    /**
     * If set to `true`, renders the cell value as HTML.
     * It is important to sanitize the value of the cell on the server for passing safe html because there is no client-side sanitizing.
     * When editing a cell the new value can be checked and prevented in the client `changing` event.
     */
    html?: boolean;

    /**
     * The zero-based index of the cell. Required to ensure correct positioning.
     */
    index?: number;

    /**
     * The hyperlink (URL) of the cell.
     */
    link?: string;

    /**
     * The text-align setting for the cell content.
     *
     * The available options are: `left`, `center`, `right` or `justify`.
     */
    textAlign?: string;

    /**
     * The cell value.
     */
    value?: number | string | boolean | Date;

    /**
     * The vertical align setting for the cell content.
     *
     * The available options are: `top`, `center` or `bottom`.
     */
    verticalAlign?: string;
}

/**
 * The SheetRow object.
 */
export interface SheetRow {
    /**
     * The cells in the row.
     */
    cells?: Cell[];

    /**
     * The row height in pixels. Defaults to rowHeight.
     */
    height?: number;

    /**
     * The absolute row index. Required to ensure correct positioning.
     */
    index?: number;

    /**
     * The table row element role in the context of the Grid table structure.
     */
    type?: string;
}

/**
 * Represents the interface of a Spreadsheet document sheet and its content.
 */
export interface SheetDescriptor {
    /**
     * The active cell in the sheet, for example, `A1`.
     */
    activeCell?: string;

    /**
     * The name of the sheet.
     */
    name?: string;

    /**
     * An array which defines the columns in this sheet and their content.
     */
    columns?: SheetColumn[];

    /**
     * The number of frozen columns in this sheet.
     */
    frozenColumns?: number;

    /**
     * The number of frozen rows in this sheet.
     */
    frozenRows?: number;

    /**
     * An array of merged cell ranges, for example, `B1:D2`.
     */
    mergedCells?: string[];

    /**
     * The row data for this sheet.
     */
    rows?: SheetRow[];

    /**
     * The selected range in the sheet, for example, `A1:B10`.
     */
    selection?: string;

    /**
     * A Boolean value which indicates if the grid lines of the sheet will be displayed.
     *
     * @default true
     */
    showGridLines?: boolean;

    /**
     * @hidden
     */
    gridLinesColor?: string | null;

    /**
     * An array which contains the hyperlinks of the cells.
     */
    hyperlinks?: { ref: string; target: string }[];

    /**
     * The default cell styles that will be applied to the sheet cells.
     */
    defaultCellStyle?: CellDefaultStyle;

    /**
     * An array which contains the drawings used in this sheet.
     */
    drawings?: { topLeftCell: any; offsetX: number; offsetY: number; width: number; height: number; image: string; opacity: any }[];

    /**
     * The state of the sheet.
     *
     * @default 'visible'
     */
    state?: 'visible' | 'hidden' | 'veryHidden';
}

/**
 * Represents the configuration of a Spreadsheet document.
 */
export interface DocumentDescriptor {
    /**
     * The name of the currently active sheet. Must exactly match one of the sheet names.
     */
    activeSheet?: string;

    /**
     * An array which defines the document sheets and their content.
     */
    sheets?: SheetDescriptor[];

    /**
     * An array which holds the names of the sheets.
     */
    names?: { value: string; name: string; sheet: string; localName: string }[];

    /**
     * An object containing any images used in the Spreadsheet. The keys should be image ID-s
     * (they are referenced by this ID in `sheets.drawings`) and the values should be image URLs.
     * The image URLs can be either [data URLs](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs), in which case the images are fully contained by the JSON,
     * or can be external URLs.
     * Note that when external URLs are used, they should reside on the same domain, or the server must
     * be configured with the proper [CORS headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS),
     * for the Spreadsheet to be able to fetch binary image data using a XMLHttpRequest. If it cannot fetch
     * the image, export to Excel or PDF might not work.
     */
    images?: { [name: string]: string };

    /**
     * The default column width in pixels.
     *
     * @default 64
     */
    columnWidth?: number;

    /**
     * The number of columns in the document.
     *
     * @default 50
     */
    columns?: number;

    /**
     * The default cell styles that will be applied to the sheet cells.
     */
    defaultCellStyle?: CellDefaultStyle;

    /**
     * The height of the header row in pixels.
     *
     * @default 20
     */
    headerHeight?: number;

    /**
     * The width of the header column in pixels.
     *
     * @default 32
     */
    headerWidth?: number;

    /**
     * The default row height in pixels.
     *
     * @default 20
     */
    rowHeight?: number;

    /**
     * The number of rows in the document.
     *
     * @default 200
     */
    rows?: number;
}

/**
 * The View object.
 */
export class View {
    constructor(element: HTMLElement, options: any);

    /**
     * A function which enables and disables the clipboard.
     */
    enableClipboard(enable: boolean): void;

    /**
     * Returns the workbook object of the View.
     */
    workbook(workbook?: Workbook): void | Workbook;
    /**
     * @hidden
     */
    sheet(sheet: Sheet): void;

    /**
     * Re-renders all data in the View.
     */
    refresh(reason: any): void;
    /**
     * @hidden
     */
    nameEditor: any;
    /**
     * @hidden
     */
    bind(eventName: string, handler: any, one?: boolean): void;
}

/**
 * The props of the Workbook component.
 */
export class Workbook {
    constructor(options: any, view: View);

    /**
     * Executes a command with the passed options.
     *
     * @param options The object from where data will be loaded. This has to be the deserialized object, not the JSON string.
     */
    execute(options: any): any;

    /**
     * Re-renders all data in the Workbook.
     */
    refresh(reason: any): void;

    /**
     * A collection holding the commands available for undo and redo.
     */
    undoRedoStack: any;
}

/**
 * Represents one or more rectangular regions of cells in a given Sheet.
 */
export class Range {
    /**
     * Gets or sets the background color of the cells in the range.
     *
     * @param value Any valid [CSS color](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value).
     * @returns the current background color of the top-left cell of the range.
     */
    background(value?: string): string;
    /**
     * Gets or sets the bold state of the cells in the range.
     *
     * @param value True to make the text bold; false otherwise.
     * @returns the current bold state of the top-left cell of the range.
     */
    bold(value?: boolean): boolean;
    /**
     * Gets or sets the state of the bottom border of the cells. If the range includes more than a single cell, the setting is applied to all cells.
     *
     * @param value The border configuration object. It may contain size and color keys.
     * @returns the current value of the top-left cell of the range.
     */
    borderBottom(value?: CellBorder): CellBorder;
    /**
     * Gets or sets the state of the left border of the cells. If the range includes more than a single cell, the setting is applied to all cells.
     *
     * @param value The border configuration object. It may contain size and color keys.
     * @returns the current value of the top-left cell of the range.
     */
    borderLeft(value?: CellBorder): CellBorder;
    /**
     * Gets or sets the state of the right border of the cells. If the range includes more than a single cell, the setting is applied to all cells.
     *
     * @param value The border configuration object. It may contain size and color keys.
     * @returns the current value of the top-left cell of the range.
     */
    borderRight(value?: CellBorder): CellBorder;
    /**
     * Gets or sets the state of the top border of the cells. If the range includes more than a single cell, the setting is applied to all cells.
     *
     * @param value The border configuration object. It may contain size and color keys.
     * @returns the current value of the top-left cell of the range.
     */
    borderTop(value?: CellBorder): CellBorder;
    /**
     * Gets or sets the text color of the cells in the range.
     *
     * @param value - Any valid [CSS color](https://developer.mozilla.org/en-US/docs/Web/CSS/color_value).
     * @returns the current text color of the top-left cell of the range.
     */
    color(value?: string): string;
    /**
     * Clears the contents of the range cells.
     *
     * @param value An object which may contain `contentsOnly: true` or `formatOnly: true` key values. Clearing the format will remove the cell formatting and visual styles.
     * If a parameter is not passed, the method will clear both the cells values and the formatting.
     */
    clear(value?: { contentsOnly?: boolean; formatOnly: boolean }): void;
    /**
     * Gets or sets the disabled state of the cells in the range.
     *
     * @param value True to make the cell enabled; false to disable it.
     * @returns the current disabled state of the top-left cell of the range.
     */
    enable(value?: boolean): boolean;
    /**
     * Gets or sets the font family of the cells in the range.
     *
     * @param value The font family that should be set.
     * @returns the font family of the top-left cell of the range.
     */
    fontFamily(value?: string): string;
    /**
     * Gets or sets the font size of the cells in the range.
     *
     * @param value The font size (in pixels) that should be set.
     * @returns the font size of the top-left cell of the range.
     */
    fontSize(value?: number): number;
    /**
     * Executes a function for each cell in the range.
     *
     * @param value The function that will be executed against every cell. The function receives the following parameters:
     * `rowIndex` - the row index of the cell,
     * `columnIndex` - the column index of the cell,
     * `cellProperties` - the cell properties
     */
    forEachCell(value: (rowIndex: number, columnIndex: number, cellProperties: Cell) => void): void;
    /**
     * Gets or sets the format of the cells.
     *
     * @param value The new format for the cells.
     * @returns the format of the top-left cell of the range. When used as a setter, format returns the Range object to allow chained calls.
     */
    format(value?: string): string;
    /**
     * Gets or sets the formula of the cells.
     *
     * @param value The new formula of the cell. The string may optionally start with `=`.
     * @returns the formula of the top-left cell of the range.
     */
    formula(value?: string): string;
    /**
     * Gets or sets the value of the cells. This is similar to `value`, but it parses the argument as if it was entered through the text box:
     * - if it starts with `=` (equal sign), a formula is set. This may throw an error if the formula is syntactically invalid. Example: `range("C1").input("=A1+B1")`.
     * - if it looks like a number, a numeric value (not string) is set.
     * - if it's `true` or `false` (case-insensitive) the respective boolean value is set.
     * - if it's a `Date` object, or a string that can be parsed as a date, it is converted to the numerical representation of the date.
     * - if it starts with `'` (single quote), a string containing the rest of the characters is set. Example: `range("A1").input("'TRUE")` — sets the text "TRUE", not the boolean.
     *
     * @param value The value to be set to the cells.
     * @returns the current value of the top-left cell of the range.
     */
    input(value?: string | number | Date): any;
    /**
     * Gets or sets the italic state of the cells in the range.
     *
     * @param value True will make the text of the cells italic; false otherwise.
     * @returns the current italic state of the top-left cell of the range.
     */
    italic(value?: boolean): boolean;
    /**
     * Gets or sets the hyperlink of the cells in the range.
     *
     * @param value Pass a string (the URL) to create a hyperlink. Pass `null` to remove the link. Omit argument to get the existing URL, if any.
     * @returns the current hyperlink attribute of the top-left cell of the range.
     */
    link(value?: string): any;
    /**
     * Sets the sheet selection to the range cells.
     */
    select(): void;
    /**
     * Gets or sets the text alignment of the cells in the range.
     *
     * @param value One of the following values: "left", "center", "right" and "justify".
     * @returns the current text alignment of the top-left cell of the range.
     */
    textAlign(value?: string): string;
    /**
     * Gets or sets the value of the cells. If the cell has formula set, the value setting will clear it.
     *
     * @param value The value to be set to the cells.
     * @returns the current value of the top-left cell of the range.
     */
    value(value?: string | number | Date): any;
    /**
     * Gets or sets the vertical alignment of the cells in the range.
     *
     * @param value One of the following values: "top", "center" and "bottom".
     * @returns the current text alignment of the top-left cell of the range.
     */
    verticalAlign(value?: string): string;
    /**
     * Gets or sets the wrap of the range cells.
     *
     * @param value `true` if to enable wrapping, `false` otherwise.
     * @returns the current wrap state of the top-left cell of the range.
     */
    wrap(value?: boolean): boolean;
}

/**
 * @hidden
 */
export interface SelectedHeaders {
    all: boolean;
    allCols: boolean;
    allRows: boolean;
    cols: {
        [key: number]: 'full' | 'partial';
    };
    rows: {
        [key: number]: 'full' | 'partial';
    };
}

/**
 * The Sheet object.
 */
export class Sheet {
    /**
     * Changes the size of the rows and columns of the current sheet.
     *
     * @param newRows The rows of the sheet after the resizing.
     *
     * @param newCols The columns of the sheet after the resizing.
     */
    resize(newRows: number, newCols: number): void;

    /**
     * Returns the name of the sheet.
     */
    name(): string;

    /**
     * Returns a Range object based on the passed cells.
     */
    range(cell: string): Range;

    /**
     * Returns the active cell in the sheet, for example, A1.
     */
    activeCell(): any;

    /**
     * A Boolean value which indicates if the grid lines of the sheet will be displayed.
     *
     * @default true
     */
    showGridLines(value?: any): any;

    /**
     * @hidden
     */
    selectedHeaders(): SelectedHeaders;
}

/**
 * @hidden
 */
export interface ExternalRef<T> {
    get current(): T | null;
}

/**
 * Represents the options that will be applied the Spreadsheet.
 */
export interface SpreadsheetOptions extends DocumentDescriptor {
    /**
     * The name of the sheet.
     */
    name?: string;

    /**
     * @hidden
     */
    sheetsbar?: boolean;

    /**
     * Configures the Excel export settings of the Spreadsheet.
     */
    excel?: ExcelExportSettings;

    /**
     * Sets the component messages.
     */
    messages?: any;

    /**
     * Sets the component locale.
     */
    locale?: string;

    /**
     * @hidden
     */
    formulaBarInputRef?: ExternalRef<any>;
    /**
     * @hidden
     */
    formulaCellInputRef?: ExternalRef<any>;
    /**
     * @hidden
     */
    nameBoxRef?: ExternalRef<any>;
}

/**
 * Represents the SpreadsheetWidget, holding the core functionality of the Spreadsheet.
 */
export class SpreadsheetWidget {
    constructor(element: HTMLElement, options: SpreadsheetOptions);

    /**
     * Returns the `View` object of the Spreadsheet.
     */
    get view(): View;

    /**
     * Returns the `Workbook` object of the Spreadsheet.
     */
    get workbook(): Workbook;

    /**
     * @hidden
     */
    get options(): SpreadsheetOptions;

    /**
     * Executes the passed command against the selected cell/range.
     *
     * @param options An object containing the command name and the required by it options.
     */
    executeCommand(options: any): void;

    /**
     * Loads the workbook data from an object with the format that is defined in the configuration.
     *
     * Note: All existing sheets and their data will be lost.
     *
     * @param json The object from where data will be loaded. This has to be the deserialized object, not the JSON string.
     */
    fromJSON(json: DocumentDescriptor): void;

    /**
     * Serializes the workbook.
     */
    toJSON(): DocumentDescriptor;

    /**
     * Serializes the workbook. This method does not return the JSON, but a Promise object which will yield the JSON data when it is available.
     * The method is functionally similar to `toJSON`, but it is also able to save the embedded images (this is the reason why it must be asynchronous).
     */
    saveJSON(): Promise<DocumentDescriptor>;

    /**
     * Clears the Spreadsheet and populates it with data from the specified Excel (.xlsx) file.
     *
     * @param blob The file or blob that is usually obtained through a file input.
     * 
     * @returns A promise that will be resolved when the file is loaded and the data is populated.
     */
    fromFile(file: File | Blob): Promise<void>;

    /**
     * Initiates the Excel export. Also fires the excelExport event.
     *
     * Note: Calling this method may trigger the built-in popup blocker of the browser.
     * To avoid that, always call it as a response to an end-user action, for example, a button click.
     */
    saveAsExcel(options: any): Promise<Blob | string>;

    /**
     * Gets or sets the active sheet.
     */
    activeSheet(sheet?: Sheet): Sheet | void;

    /**
     * Returns an array with the sheets in the workbook.
     */
    sheets(): Sheet[];

    /**
     * Re-renders all data in the Spreadsheet.
     */
    refresh(): void;

    /**
     * @hidden
     */
    bind(eventName: string, handler: any, one?: boolean): void;

    /**
     * @hidden
     */
    destroy(): void;
}

/**
 * The context object of the custom JavaScript functions (primitives) in formulas.
 */
export class Context {
    /**
     * Verifies that all references in the given array are resolved before invoking your callback—that is, executes any formula.
     * If this array turns out to include the cell where the current formula lives, it returns a `#CIRCULAR!` error. Elements that are not references are ignored.
     */
    resolveCells(array: Ref[] | Ref[][], callback: () => any): any;

    /**
     * Returns as a flat array the values in any reference that exist in the given array. Elements that are not references are copied over.
     */
    cellValues(array: (Ref | Matrix)[] | Ref | Matrix): any;

    /**
     * Converts the given argument to a matrix, if possible.
     * It accepts a `RangeRef` object or a plain JavaScript non-empty array.
     * Additionally, if a `Matrix` object is provided, it is returned as is.
     */
    asMatrix(arg: RangeRef | RangeRef[] | Matrix): Matrix;

    /**
     * Returns the `Workbook` object where the current formula is evaluated.
     */
    workbook(): Workbook;

    /**
     * Returns the data that is the value in the given reference.
     * If a `CellRef` is given, it returns a single value. For a `RangeRef` or `UnionRef`, it returns a flat array of values.
     */
    getRefData(ref: CellRef | RangeRef | UnionRef): any;
}

/**
 * The "matrix" type which can be used in the custom JavaScript functions (primitives) in formulas.
 */
export class Matrix {
    constructor(context: Context);
    /**
     * Indicate the width of the matrix.
     */
    width: number;

    /**
     * Indicate the height of the matrix.
     */
    height: number;

    /**
     * Returns a new matrix with the same data.
     */
    clone(): Matrix;

    /**
     * Returns the element at a given location.
     */
    get(row: number, col: number): any;

    /**
     * Sets the element at a given location.
     */
    set(row: number, col: number, value: any): void;

    /**
     * Iterates through elements of the matrix and calling the `func` for each element (first columns, then rows).
     *
     * @param func The function which will be called for each element.
     * @param includeEmpty If `true`, it will call the function for empty (`null`) elements as well. Otherwise, it only calls it where a value exists.
     */
    each(func: (value: any, row: number, column: number) => void, includeEmpty: boolean): void;

    /**
     * Similar to `each`, but produces a new matrix of the same shape as the original one with the values returned by the function.
     *
     * @param func The function which will be called for each element.
     * @param includeEmpty If `true`, it will call the function for empty (`null`) elements as well. Otherwise, it only calls it where a value exists.
     */
    map(func: (value: any, row: number, column: number) => void, includeEmpty: boolean): Matrix;

    /**
     * Returns the transposed matrix. The rows of the original matrix become columns of the transposed one.
     */
    transpose(): Matrix;

    /**
     * Returns the unit square matrix of size `n`.
     */
    unit(n: number): Matrix;

    /**
     * Multiplies the current matrix by the given matrix, and returns a new matrix as the result.
     */
    multiply(m: Matrix): Matrix;

    /**
     * Returns the determinant of this matrix. The matrix should contain only numbers and be square. Note that there are no checks for this.
     */
    determinant(): number;

    /**
     * Returns the inverse of this matrix. The matrix should contain only numbers and be square.
     * Note that there are no checks for this. If the inverse does not exist, the determinant is zero, then it returns `null`.
     */
    inverse(): Matrix | null;
}

/**
 * A class from which formula calculation errors will be instantiated.
 */
export class CalcError {
    /**
     * The error code.
     */
    code: string;
}

export const calc;
export const validation;

/**
 * A base class only. All references inherit from it, but no direct instance of this object should ever be created.
 * The class is exported just to make it easier to check whether something is a reference: `x instanceof Ref`.
 */
export class Ref {
    /**
     * The name of the sheet that this cell points to.
     */
    sheet: string;
}

/**
 * Represents a cell reference. Note that the references do not contain data.
 * Instead they just point to where the data is.
 */
export class CellRef extends Ref {
    /**
     * The row number, zero-based.
     */
    row: number;
    /**
     * The column number, zero-based.
     */
    col: number;
}

/**
 * Represents a name cell reference.
 */
export class NameRef extends Ref { }

/**
 * A range reference.
 */
export class RangeRef extends Ref {
    /**
     * The top-left CellRef of the range.
     */
    topLeft: CellRef;
    /**
     * The bottom-right CellRef of the range.
     */
    bottomRight: CellRef;
}

/**
 * A union. It contains a refs property, which is an array of references (it can be empty).
 * A UnionRef can be created by the union operator, which is the comma.
 */
export class UnionRef extends Ref {
    refs: (CellRef | RangeRef)[];
}
export class NULLREFClass {}

/**
 * An object (a singleton) and not a class.
 * It represents the NULL reference, and could occur, for example, when you intersect two disjoint ranges, or when a formula depends on a cell that has been deleted.
 * For example, when you put in some cell `=test(B5)` and then right-click on column `B` and delete it.
 * To test when something is the `NULL` reference, just do `x === NULLREF`.
 */
export const NULLREF: NULLREFClass;

/**
 * Converts date parameters to number.
 */
export function packDate(year: number, month: number, date: number): number;

/**
 * Converts number to date parameters.
 */
export function unpackDate(serial: number): {
    year: number;
    month: number;
    date: number;
    day: number;
    ord: number
};

/**
 * Converts time parameters to number.
 */
export function packTime(hh: number, mm: number, ss: number, ms: number): number;

/**
 * Converts number to time parameters.
 */
export function unpackTime(serial: number): {
    hours: number;
    minutes: number;
    seconds: number;
    milliseconds: number
};

/**
 * Converts number to date.
 */
export function serialToDate(serial: number): Date;

/**
 * Converts date to number.
 */
export function dateToSerial(date: Date): number;

/**
 * Defines custom formula.
 */
export function defineFunction(name: string, func: Function): {
    args(args: any, log: any): any;
    argsAsync(args: any, log: any): any;
};

/**
 * Registers custom editor.
 */
export function registerEditor(name, editor): void;

/**
 * Defines alias of a formula.
 */
export function defineAlias(alias: string, name: string): void;

/**
 * Deferred class similar to jQuery's Deferred.
 */
export class Deferred<T = any, N = any> {
    /**
     * Creates a new Deferred object.
     */
    constructor();

    /**
     * Resolves the Deferred object and calls any done callbacks with the given value.
     * @param value The value to resolve the promise with.
     * @returns The Deferred object.
     */
    resolve(value?: T): this;

    /**
     * Rejects the Deferred object and calls any fail callbacks with the given reason.
     * @param reason The reason for rejecting the promise.
     * @returns The Deferred object.
     */
    reject(reason?: any): this;

    /**
     * Notifies progress callbacks with the given value.
     * @param value The value to pass to the progress callbacks.
     */
    notify(value?: N): void;

    /**
     * Adds a handler to be called when the Deferred object is notified of progress.
     * @param callback A function to call when progress is notified.
     * @returns The Deferred object.
     */
    progress(callback: (value?: N) => void): this;

    /**
     * Attaches callbacks for the resolution, rejection, and progress of the Promise.
     * @param onFulfilled The callback to execute when the Promise is resolved.
     * @param onRejected The callback to execute when the Promise is rejected.
     * @param onProgress The callback to execute when the Promise reports progress.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
        onFulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | null,
        onRejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | null,
        onProgress?: (value?: N) => void
    ): Promise<TResult1 | TResult2>;

    /**
     * Returns the underlying Promise object.
     * @returns The Promise object.
     */
    promise(): Promise<T>;
}
