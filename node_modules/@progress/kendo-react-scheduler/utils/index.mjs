/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright © 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import "@progress/kendo-date-math";
import { toGroupResources as h, toFlatGroupResources as E } from "../views/common/utils.mjs";
import { getter as x, setter as M } from "@progress/kendo-react-common";
import { orderBy as T } from "@progress/kendo-data-query";
const v = (r) => r[0], _ = (r) => r[r.length - 1], z = (r) => {
  const e = /* @__PURE__ */ new Set();
  return r.forEach((o) => {
    e.add(o.field);
  }), e.size === r.length;
};
function N(r, e, o, n) {
  const t = { skeleton: "yMMMMEEEEdhm" }, s = { skeleton: "yMMMMEEEEd" };
  return n ? `${r.formatDate(e, s)}` : `${r.formatDate(e, t)}–${r.formatDate(o, "t")}`;
}
const y = (r, e, o, n = 0) => {
  if (n === o)
    return null;
  let t = null;
  const s = document.elementFromPoint(r, e);
  if (!s)
    return t;
  if (s.getAttribute("data-slot") === "true")
    return s;
  const d = s.style.pointerEvents;
  return s.style.pointerEvents = "none", t = y(r, e, o, n + 1), s.style.pointerEvents = d, t;
}, p = (r, e) => x(e)(r), G = (r, e, o) => {
  if (e)
    return M(e)(r, o);
}, P = (r) => r != null;
function b(r) {
  return new Date(
    Date.UTC(
      r.getFullYear(),
      r.getMonth(),
      r.getDate(),
      r.getHours(),
      r.getMinutes(),
      r.getSeconds(),
      r.getMilliseconds()
    )
  );
}
const k = (r, e, o) => {
  const n = F(r, e) ? p(r, e.id) : p(r, e.recurrenceId);
  return o.find((t) => p(t, e.id) === n);
}, F = (r, e) => {
  const o = p(r, e.id), n = p(r, e.recurrenceId), t = p(r, e.recurrenceRule);
  return !!(o && t && n == null);
}, f = (r, e) => Math.max(r.getTime(), e.getTime()), m = (r, e) => Math.min(r.getTime(), e.getTime()), a = (r, e, o, n, t = !1) => t ? f(e, n) - m(r, o) <= e.getTime() - r.getTime() + (n.getTime() - o.getTime()) : f(e, n) - m(r, o) < e.getTime() - r.getTime() + (n.getTime() - o.getTime()), I = {
  id: "id",
  start: "start",
  startTimezone: "startTimezone",
  originalStart: "originalStart",
  end: "end",
  endTimezone: "endTimezone",
  isAllDay: "isAllDay",
  title: "title",
  description: "description",
  recurrenceRule: "recurrenceRule",
  recurrenceId: "recurrenceId",
  recurrenceExceptions: "recurrenceExceptions"
}, w = (r) => ({ fields: { ...I, ...r } }), B = (r, e, o) => (e.getHours() < r.getHours() || e.getHours() === r.getHours() && e.getMinutes() <= r.getMinutes()) && (r.getHours() < o.getHours() || o.getHours() === r.getHours() && r.getMinutes() < o.getMinutes()), O = (r, e, o) => e < o ? e <= r && r <= o : r <= o || e <= r, $ = (r, e) => {
  const o = h(r, e), n = E(o);
  return n.length === 1 ? [
    {
      index: 0,
      // resources: []
      resources: (e || []).reduce(
        (t, s) => [
          ...t,
          ...s.data.map((u) => ({
            ...u,
            field: s.field,
            valueField: s.valueField,
            colorField: s.colorField,
            multiple: s.multiple
          }))
        ],
        []
      )
    }
  ] : n.map((t, s) => ({
    index: s,
    resources: t
  }));
}, D = (r) => r == null, C = (r) => D(r) || r.trim && r.trim().length === 0, g = (r) => {
  let e = 0;
  const o = r.slice();
  return o.sort((n, t) => n - t).forEach((n, t) => {
    o[t] === t && (e = t + 1);
  }), e;
}, U = (r, e, o, n = !1) => {
  let t;
  return o.forEach((s) => {
    const u = [];
    e.sort((i, c) => i.props.start.getTime() - c.props.start.getTime()).forEach((i) => {
      if ((n || i.props.isAllDay === s.current.props.isAllDay) && i.props.range.index === s.current.props.range.index && i.props.group.index === s.current.props.group.index && a(i.props.start, i.props.end, s.current.props.start, s.current.props.end)) {
        const l = g(u);
        i === r && t === void 0 && (t = l), u.splice(l, 0, l);
      }
    });
  }), t;
}, Y = (r, e) => {
  const o = /* @__PURE__ */ new Set();
  return e.forEach((t) => {
    t._order !== void 0 && t._order !== null && o.add(t._order);
  }), g(Array.from(o));
}, j = (r, e, o = !1) => {
  e.forEach((n) => n.items.splice(0, n.items.length)), e.forEach((n) => {
    const t = [];
    r.forEach((s) => {
      if ((o || s.isAllDay === n.isAllDay) && s.range.index === n.range.index && s.group.index === n.group.index && a(s.start, s.end, n.start, n.end)) {
        const d = g(t);
        (s.order === null || s.order === void 0 || s.order < d) && (s.order = d), t.splice(s.order, 0, s.order), n.items.push(s);
      }
    });
  });
}, q = (r, e, o = !1) => {
  r.forEach((n) => n.slots.splice(0, n.slots.length)), r.forEach((n) => {
    e.forEach((t) => {
      (o || n.isAllDay === t.isAllDay) && n.range.index === t.range.index && n.group.index === t.group.index && a(n.start, n.end, t.start, t.end) && n.slots.push(t);
    });
  });
}, J = (...r) => {
}, K = (r) => {
  const e = r.props.items.find((o) => o.order === 0) || r.props.items[0];
  return e && e._ref.current;
}, L = (r, e, o = !1, n = !1) => {
  const t = r.current;
  if (!t || !e)
    return null;
  const s = e.filter((c) => c.current !== null && c.current.element !== null), u = T(s, [
    { field: "current.props.group.index", dir: "asc" },
    { field: "current.props.range.index", dir: "asc" },
    o ? { field: "" } : { field: "current.props.isAllDay", dir: "desc" },
    { field: "current.props.start", dir: "asc" }
  ]), d = u.findIndex(
    (c) => c.current !== null && !!(c.current.props.uid === t.props.uid && (c.current.props.occurrenceId === void 0 || c.current.props.occurrenceId === t.props.occurrenceId) && c.current.props.group.index === t.props.group.index && c.current.props.range.index === t.props.range.index && (o || c.current.props.isAllDay === t.props.isAllDay))
  );
  return u[d + (n ? -1 : 1)];
}, Q = (r, e) => (r.order || 0) - (e.order || 0);
export {
  U as calculateOrder,
  Y as calculateProportionalOrder,
  I as defaultModelFields,
  K as findFirstItem,
  k as findMaster,
  g as findMissing,
  L as findNextItem,
  v as first,
  N as formatEventTime,
  p as getField,
  w as getModelFields,
  a as intersects,
  D as isBlank,
  z as isGroupped,
  O as isInDaysRange,
  B as isInTimeRange,
  F as isMaster,
  C as isNullOrEmptyString,
  P as isPresent,
  _ as last,
  q as mapItemsToSlots,
  j as mapSlotsToItems,
  J as noop,
  Q as orderSort,
  G as setField,
  y as slotDive,
  $ as toSchedulerGroups,
  b as toUTCDateTime
};
