/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import * as N from "react";
import { classNames as O, kendoThemeMaps as b } from "@progress/kendo-react-common";
import { ServerOrgChartNode as P } from "./ServerOrgChartNode.mjs";
import { VERTICAL_LINE as H, HORIZONTAL_GAP as x, NODE_WIDTH as V, NODE_HEIGHT as M } from "../utils/consts.mjs";
const R = ({
  dataByGroups: c,
  data: r = [],
  cardWidth: l,
  childrenField: n,
  idField: e,
  expandField: t,
  hasChildrenField: i,
  groupField: a,
  level: m = 1,
  parentId: h = 0
}) => {
  r.forEach((d) => {
    const f = d[n];
    if (d[t] && f && f.length) {
      const s = f.some(
        (g) => g[n] && g[n].length || i && g[i]
      ), L = s ? "horizontal" : "vertical", v = s ? null : l;
      c.push({
        ids: [d[e]],
        items: f,
        level: m,
        parentId: h,
        hasChildren: s,
        orientation: L,
        width: v
      }), R({
        dataByGroups: c,
        data: d[n],
        childrenField: n,
        cardWidth: l,
        idField: e,
        expandField: t,
        hasChildrenField: i,
        groupField: a,
        level: m + 1,
        parentId: d[e]
      });
    }
  });
}, j = (c, r) => {
  const l = r || V, n = c.sort((e, t) => t.level - e.level);
  n.forEach((e) => {
    if (!e.width) {
      const t = n.filter(
        (h) => e.ids.includes(h.parentId)
      ), i = t.length ? Math.max(...t.map((h) => h.width || 0)) : l, a = e.orientation === "horizontal" ? e.items.length : 1, m = i * a + x * (a - 1);
      e.width = m;
    }
  });
}, B = (c, r, l) => {
  const n = c.sort((e, t) => e.level - t.level);
  n.forEach((e) => {
    if (e.level === 0)
      return;
    const t = n.find(
      (s) => s.ids.includes(e.parentId)
    ), i = (t == null ? void 0 : t.items.findIndex((s) => e.ids.includes(s[l]))) || 0, a = (t == null ? void 0 : t.items) || [], m = t.width ? (t.width - (a.length - 1) * x) / a.length : 0;
    if (!e.left) {
      let s = (t == null ? void 0 : t.left) || 0;
      a.forEach((L, v) => {
        v < i && (s += m + x);
      }), e.left = s;
    }
    const h = (t == null ? void 0 : t.width) || 0, d = (t == null ? void 0 : t.items.length) || 1, f = (h - (d - 1) * x) / d;
    e.width = f;
    const k = t == null ? void 0 : t.items.map((s) => {
      const L = s[r] ? s[r].length : 0, v = n.find((y) => y.ids.includes(s[l])), g = (v == null ? void 0 : v.width) || 0;
      return (v == null ? void 0 : v.orientation) === "vertical" || L === 0 || !s.expanded ? 0 : g - (g - (L - 1) * x) / L;
    });
    t && (t.childLineWidths = k);
  });
}, G = (c, r, l) => {
  const n = r || M, e = l || H;
  c.forEach((t) => {
    const i = t.level, a = (n + e) * i + H * (i ? i - 1 : 0) - (e - H) * (i ? 1 : 0);
    t.top = a;
  });
}, K = (c, r, l) => {
  const n = r || M, e = l || H;
  return Math.max(
    ...c.map((i) => {
      const a = i.top || 0, m = i.items.length, h = i.orientation === "horizontal" ? n + e + e : m * (n + e);
      return a + h;
    })
  );
}, Z = (c) => {
  const r = {
    width: "100%",
    data: [],
    ariaLabel: "Org Chart",
    idField: "id",
    childrenField: "items",
    avatarField: "avatar",
    titleField: "title",
    subtitleField: "subtitle",
    expandField: "expanded",
    avatarType: "image",
    showAvatar: !0
  }, {
    id: l,
    width: n,
    data: e,
    groupField: t,
    cardWidth: i,
    cardHeight: a,
    verticalLine: m,
    idField: h,
    childrenField: d,
    hasChildrenField: f,
    expandField: k,
    avatarField: s,
    titleField: L,
    subtitleField: v,
    ariaLabel: g,
    itemRender: y,
    height: _,
    avatarType: z,
    showAvatar: A
  } = { ...r, ...c }, E = [
    {
      items: e,
      level: 0,
      hasChildren: !0,
      orientation: "horizontal",
      ids: [0],
      parentId: null,
      width: null
    }
  ];
  R({
    dataByGroups: E,
    data: e,
    cardWidth: i,
    expandField: k,
    hasChildrenField: f,
    childrenField: d,
    idField: h,
    groupField: t
  }), j(E, i), B(E, d, h), G(E, a, m);
  const D = K(E, a, m);
  return /* @__PURE__ */ N.createElement("div", { className: "k-orgchart-container", style: { width: n, height: _ || D } }, E.map((o) => {
    const W = o.level, T = o.items, p = o.orientation;
    return /* @__PURE__ */ N.createElement(
      "div",
      {
        role: W === 0 ? "tree" : "group",
        id: l + "-" + W + "-" + o.ids[0],
        "aria-label": W === 0 ? g : void 0,
        "aria-orientation": W === 0 ? p : void 0,
        key: o.ids[0] + "_" + W,
        className: O(
          "k-orgchart-group",
          // The following class is not part of the reference rendering. After a team discussion we decided to keep it as it will be useful for the end users.
          `k-orgchart-level-${W}`,
          "k-pos-absolute",
          {
            [`k-${b.orientationMap[p]}`]: p
          }
        ),
        style: {
          width: o.width || "100%",
          left: o.left,
          top: o.top
        }
      },
      T.length > 0 && /* @__PURE__ */ N.createElement(
        "div",
        {
          role: "group",
          style: { width: "100%" },
          className: O("k-orgchart-node-container", "k-justify-content-around", {
            [`k-${b.orientationMap[o.orientation]}`]: o.orientation
          })
        },
        T.map((w, I) => {
          const u = w[d] && w[d].length || f && w[f], F = u || o.orientation === "vertical" && I !== T.length - 1, S = o.orientation === "vertical" && I !== 0 ? 0 : m || H, $ = o.childLineWidths ? Math.max(...o.childLineWidths) : void 0, C = w[k];
          return /* @__PURE__ */ N.createElement(
            P,
            {
              id: l + "-" + (W + 1) + "-" + w[h],
              style: { width: $ },
              itemRender: y,
              cardHeight: a,
              cardWidth: i,
              verticalLine: S,
              key: I,
              level: W,
              avatar: w[s],
              avatarType: z,
              showAvatar: A,
              title: w[L],
              subtitle: w[v],
              line: F,
              expanded: C,
              node: w,
              childLineWidth: u && C && o.orientation === "horizontal" ? o.childLineWidths[I] : 0,
              plus: u
            },
            w.text
          );
        })
      )
    );
  }));
};
Z.displayName = "KendoServerOrgChart";
export {
  Z as ServerOrgChart
};
