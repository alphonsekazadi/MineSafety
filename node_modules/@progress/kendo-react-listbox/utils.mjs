/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const k = (t = [], e = [], I, c) => {
  let r = [], i = [], s = [];
  const f = { listBoxOneData: t, listBoxTwoData: e };
  switch (I) {
    case "moveUp":
      r = [...t], r.forEach((n, o) => {
        n[c] && (r = u(o, o - 1, r));
      }), s = [...e], s.forEach((n, o) => {
        n[c] && (s = u(o, o - 1, s));
      }), f.listBoxOneData = r, f.listBoxTwoData = s;
      break;
    case "moveDown":
      r = t.reverse(), r.forEach((n, o) => {
        n[c] && (r = u(o, o - 1, r));
      }), s = e.reverse(), s.forEach((n, o) => {
        n[c] && (s = u(o, o - 1, s));
      }), f.listBoxOneData = [...r].reverse(), f.listBoxTwoData = [...s].reverse();
      break;
    case "transferTo":
      r = t.filter((n) => !n[c]), i = t.filter((n) => n[c]), s = e.concat(i), f.listBoxOneData = r, f.listBoxTwoData = s;
      break;
    case "transferFrom":
      s = e.filter((n) => !n[c]), i = e.filter((n) => n[c]), r = t.concat(i), f.listBoxOneData = r, f.listBoxTwoData = s;
      break;
    case "transferAllTo":
      f.listBoxOneData = [], f.listBoxTwoData = e.concat(t);
      break;
    case "transferAllFrom":
      f.listBoxOneData = e.concat(t), f.listBoxTwoData = [];
      break;
    case "remove":
      s = e.filter((n) => !n[c]), r = t.filter((n) => !n[c]), f.listBoxOneData = r, f.listBoxTwoData = s;
      break;
  }
  return f;
}, u = (t, e, I) => {
  const c = I.splice(t, 1)[0];
  return I.splice(e, 0, c), I;
}, S = (t = [], e = [], I, c, r) => {
  const i = t.findIndex((a) => a[r] === I[r]), s = e.findIndex((a) => a[r] === I[r]), f = c !== null ? t.findIndex((a) => a[r] === c[r]) : -1, n = c !== null ? e.findIndex((a) => a[r] === c[r]) : -1, o = i >= 0, m = s >= 0, b = f >= 0, h = n >= 0, p = [...t], L = [...e];
  return o && b ? {
    listBoxOneData: u(i, f, t),
    listBoxTwoData: e
  } : m && h ? {
    listBoxOneData: t,
    listBoxTwoData: u(s, n, e)
  } : o && (h || c === null) ? (c === null ? L.push(t[i]) : L.splice(n + 1, 0, t[i]), p.splice(i, 1), {
    listBoxOneData: p,
    listBoxTwoData: L
  }) : m && (b || c === null) ? (c === null ? p.push(e[s]) : p.splice(f + 1, 0, e[s]), L.splice(s, 1), {
    listBoxOneData: p,
    listBoxTwoData: L
  }) : {
    listBoxOneData: t,
    listBoxTwoData: e
  };
};
export {
  u as moveItem,
  k as processListBoxData,
  S as processListBoxDragAndDrop
};
