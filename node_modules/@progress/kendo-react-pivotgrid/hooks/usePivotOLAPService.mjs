/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import * as u from "react";
import { fetchData as $, createDataState as j, fetchDiscover as f, addKPI as B, buildKPIMeasures as G } from "@progress/kendo-pivotgrid-common";
import { clone as J } from "@progress/kendo-react-common";
const Q = (e) => {
  const [r, m] = u.useState(!0), [p, U] = u.useState({ data: [], columns: [], rows: [] }), [C, w] = u.useState([]), [d, A] = u.useState(e.defaultColumnAxes || []), [h, b] = u.useState(e.defaultRowAxes || []), [x, N] = u.useState(e.defaultMeasureAxes || []), [F, v] = u.useState(e.defaultSort || []), [q, E] = u.useState(e.defaultFilter || []), g = (t) => {
    b(t.value);
  }, y = (t) => {
    A(t.value);
  }, I = (t) => {
    N(t.value);
  }, M = (t) => {
    v(t.value);
  }, K = (t) => {
    E(t.value);
  };
  u.useEffect(() => {
    m(!0);
    const t = {
      connection: {
        catalog: e.catalog,
        cube: e.cube
      },
      columnAxes: d.slice(),
      rowAxes: h.slice(),
      measureAxes: x,
      sort: F,
      filter: q
    };
    setTimeout(() => {
      $({ url: e.url }, J(t)).then(j).then((o) => {
        U(o), m(!1);
      });
    });
  }, [d, h, x, q, F, e.cube, e.catalog, e.url]), u.useEffect(() => {
    m(!0);
    const t = {
      connection: {
        catalog: e.catalog,
        cube: e.cube
      },
      restrictions: {
        catalogName: e.catalog,
        cubeName: e.cube
      },
      command: "schemaDimensions"
    };
    f({ url: e.url }, t).then((o) => {
      B(o), w(o), m(!1);
    });
  }, [e.catalog, e.cube, e.url]);
  const P = (t = [], o) => {
    for (let n = 0; n < t.length; n++) {
      const a = t[n];
      if (String(a.name) === String(o.name))
        return a;
    }
    return null;
  }, S = (t = [], o) => {
    for (let n = 0; n < t.length; n++) {
      const a = t[n];
      if (a.uniqueName === o.uniqueName)
        return a;
      const c = S(a.children, o);
      if (c !== null)
        return c;
    }
    return null;
  }, L = async (t) => {
    let o, n, a, c, l, s;
    t.name && (o = "schemaMembers", c = `${String(t.name)}.[(ALL)]`);
    const i = {
      connection: {
        catalog: e.catalog,
        cube: e.cube
      },
      restrictions: {
        catalogName: e.catalog,
        cubeName: e.cube,
        hierarchyUniqueName: a,
        dimensionUniqueName: n,
        levelUniqueName: c,
        memberUniqueName: l,
        treeOp: s
      },
      command: o
    };
    return f({ url: e.url }, i);
  }, R = async (t) => {
    let o, n, a, c, l, s;
    t.uniqueName && (o = "schemaMembers", l = t.uniqueName.replace(/\&/g, "&amp;"), s = 1);
    const i = {
      connection: {
        catalog: e.catalog,
        cube: e.cube
      },
      restrictions: {
        catalogName: e.catalog,
        cubeName: e.cube,
        hierarchyUniqueName: a,
        dimensionUniqueName: n,
        levelUniqueName: c,
        memberUniqueName: l,
        treeOp: s
      },
      command: o
    };
    return f({ url: e.url }, i);
  }, D = async (t) => {
    let o, n, a, c, l, s;
    t.type === 2 ? o = "schemaMeasures" : t.dimensionUniqueName ? (o = "schemaLevels", a = t.uniqueName) : (o = "schemaHierarchies", n = t.uniqueName);
    const i = {
      connection: {
        catalog: e.catalog,
        cube: e.cube
      },
      restrictions: {
        catalogName: e.catalog,
        cubeName: e.cube,
        hierarchyUniqueName: a,
        dimensionUniqueName: n,
        levelUniqueName: c,
        memberUniqueName: l,
        treeOp: s
      },
      command: o
    };
    return f({ url: e.url }, i);
  }, O = async () => {
    const t = {
      connection: {
        catalog: e.catalog,
        cube: e.cube
      },
      restrictions: {
        catalogName: e.catalog,
        cubeName: e.cube
      },
      command: "schemaKPIs"
    };
    return f({ url: e.url }, t);
  }, k = async (t) => {
    const o = C.slice(), n = S(o, t.value);
    if (n && n.uniqueName === "[KPIs]") {
      const a = V(await O());
      n.children = a;
    } else if (n && n.type === "kpi")
      n.children = G(n);
    else if (n && !n.children) {
      const a = await D(n);
      n.children = a;
    }
    w(o);
  }, z = async (t) => {
    if (!t)
      return;
    const o = {
      rowAxes: [h, b],
      columnAxes: [d, A],
      measureAxes: [x, N]
    }, [n, a] = o[t.target.props.axes], c = n.slice(), l = P(c, t.target.props.dataItem);
    if (l && !l.fields) {
      const s = await L(l);
      l.fields = s, a(c);
    }
  }, H = async (t) => {
    if (!t)
      return;
    const o = {
      rowAxes: [h, b],
      columnAxes: [d, A],
      measureAxes: [x, N]
    }, [n, a] = o[t.target.props.axes], c = n.slice(), l = P(c, t.target.props.dataItem);
    if (l) {
      const s = (l.fields || []).slice(), i = S(s, t.value);
      if (i && (!i.children || !i.children.length)) {
        const T = await R(i);
        i.children = T, l.fields = s, a(c);
      }
    }
  };
  return {
    pivotProps: {
      rowAxes: h,
      columnAxes: d,
      data: p.data,
      rows: p.rows,
      columns: p.columns,
      onRowAxesChange: g,
      onColumnAxesChange: y
    },
    configuratorProps: {
      sort: F,
      onSortChange: M,
      filter: q,
      onFilterChange: K,
      data: C,
      rowAxes: h,
      columnAxes: d,
      measureAxes: x,
      onRowAxesChange: g,
      onColumnAxesChange: y,
      onMeasureAxesChange: I,
      onFieldsEditorFieldExpand: k,
      onAxisFilterFieldExpand: H,
      onAxisFilterFieldsExpandChange: z
    },
    state: {
      loading: r
    }
  };
}, Y = (e) => {
  const r = Q(e);
  return e.children(r);
}, V = (e) => {
  for (let r = 0, m = e.length; r < m; r++)
    e[r].uniqueName = e[r].name, e[r].type = "kpi";
  return e;
};
export {
  Y as PivotOLAPService,
  Q as usePivotOLAPService
};
