/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import { TableMap as f } from "@progress/kendo-editor-common";
import { parentNode as i } from "../utils.mjs";
const d = /[\D]+$/, h = (e) => {
  const t = e.match(d);
  return t ? t[0] : "";
}, C = (e, t) => {
  var n;
  const s = u(((n = e.attrs) == null ? void 0 : n.style) || "")[t] || "";
  return {
    [t]: parseFloat(s) || null,
    [t + "Unit"]: h(s)
  };
}, u = (e) => (e || "").split(/\s*;\s*/).filter(Boolean).map((s) => {
  const n = s.split(/\s*:\s*/);
  return { [n[0]]: n[1] };
}).reduce((s, n) => ({ ...s, ...n }), {}), m = (e, t) => {
  const s = t.style, n = t.value, o = t.newValue;
  if (!e)
    return { changed: !1, style: null };
  const l = e.split(/\s*;\s*/).filter((r) => !!r), c = l.filter((r) => {
    const a = r.split(/\s*:\s*/);
    return !(a[0].toLowerCase() === s && n.test(a[1]));
  });
  return o && c.push(`${s}: ${o}`), {
    style: c.join("; ") + (c.length ? ";" : ""),
    changed: !!o || c.length !== l.length
  };
}, b = /^.+$/;
function N(e, t, s) {
  let n;
  if (new RegExp("[^-]?" + t + ":").test(e.style || "")) {
    const { style: o } = m(e.style || "", {
      style: t,
      value: b,
      newValue: s
    });
    n = { ...e, style: o };
  } else if (e.style) {
    const o = u(e.style);
    o[t] = s, n = {
      ...e,
      style: Object.keys(o).filter((l) => !!o[l]).reduce((l, c) => l + c + ": " + o[c] + "; ", "").trim()
    };
  } else
    s ? n = { ...e, style: t + ": " + s + ";" } : n = { ...e };
  return n;
}
const y = (e) => {
  const { doc: t, selection: s } = e, n = [];
  return s.ranges.forEach((o) => {
    const l = o.$from.pos, c = o.$to.pos;
    t.nodesBetween(l, c, (r, a, p, $) => {
      (r.type.name === "table_cell" || r.type.name === "table_header") && n.push({ node: r, pos: a });
    });
  }), n;
}, g = (e) => {
  const t = i(e.selection.$from, (n) => n.type.name === "table"), s = i(e.selection.$to, (n) => n.type.name === "table");
  return t && s && t.depth === s.depth && t.node.eq(s.node) ? y(e).filter(({ pos: o }) => {
    const l = i(e.doc.resolve(o), (c) => c.type.name === "table");
    return l && l.depth === t.depth && t.node.eq(l.node);
  }) : [];
}, w = (e) => {
  const t = [];
  if (g(e).length) {
    const s = e.selection.$from, n = i(s, (a) => a.type.spec.tableRole === "table");
    if (n === null)
      return t;
    const o = s.start(n.depth), l = n.node, c = f.get(l), r = e.doc;
    c.map.forEach((a) => {
      const p = a + o;
      t.push({ pos: p, node: r.nodeAt(p) });
    });
  }
  return t;
};
export {
  h as getUnit,
  C as nodeSize,
  u as parseStyle,
  d as reUnit,
  g as selectedCells,
  N as setNodeStyle,
  w as tableCells
};
