"use client";
import {
  require_server_browser,
  saveAs
} from "./chunk-UFAXF3LL.js";
import {
  Deflate,
  Inflate
} from "./chunk-6T67ERTR.js";
import {
  P,
  d5 as d,
  require_prop_types,
  w2 as w
} from "./chunk-TPJZDNMR.js";
import "./chunk-PJEEZAML.js";
import {
  require_react
} from "./chunk-DRWLMN53.js";
import {
  __export,
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/@progress/kendo-react-excel-export/ExcelExport.mjs
var i = __toESM(require_react(), 1);
var import_prop_types = __toESM(require_prop_types(), 1);

// node_modules/@progress/kendo-ooxml/dist/es/main.js
var main_exports = {};
__export(main_exports, {
  ExcelExporter: () => excel_exporter_default,
  IntlService: () => intl_service_default,
  TemplateService: () => template_service_default,
  Workbook: () => Workbook,
  Worksheet: () => Worksheet
});

// node_modules/@progress/kendo-ooxml/dist/es/services/template-service.js
var current = {
  compile: function(template) {
    return template;
  }
};
var TemplateService = class {
  static register(userImplementation) {
    current = userImplementation;
  }
  static compile(template) {
    return current.compile(template);
  }
};
var template_service_default = TemplateService;

// node_modules/@progress/kendo-ooxml/dist/es/utils/getter.js
var FIELD_REGEX = /\[(?:(\d+)|['"](.*?)['"])\]|((?:(?!\[.*?\]|\.).)+)/g;
var getterCache = {};
var UNDEFINED = "undefined";
getterCache[UNDEFINED] = function(obj) {
  return obj;
};
function getter(field) {
  if (getterCache[field]) {
    return getterCache[field];
  }
  const fields = [];
  field.replace(FIELD_REGEX, function(match, index, indexAccessor, field2) {
    fields.push(typeof index !== UNDEFINED ? index : indexAccessor || field2);
  });
  getterCache[field] = function(obj) {
    let result = obj;
    for (let idx = 0; idx < fields.length && result; idx++) {
      result = result[fields[idx]];
    }
    return result;
  };
  return getterCache[field];
}

// node_modules/@progress/kendo-ooxml/dist/es/utils/map.js
function map(array, func) {
  return array.reduce((result, el, i2) => {
    const val = func(el, i2);
    if (val != null) {
      result.push(val);
    }
    return result;
  }, []);
}

// node_modules/@progress/kendo-ooxml/dist/es/excel-exporter.js
function defaultGroupHeaderTemplate(data) {
  return `${data.title}: ${data.value}`;
}
function createArray(length, callback) {
  const result = [];
  for (let idx = 0; idx < length; idx++) {
    result.push(callback(idx));
  }
  return result;
}
function defaultItemId(item) {
  return item.id;
}
var ExcelExporter = class {
  constructor(options) {
    options.columns = this._trimColumns(options.columns || []);
    this.allColumns = map(this._leafColumns(options.columns || []), this._prepareColumn);
    this.columns = this._visibleColumns(this.allColumns);
    this.options = options;
    this.data = options.data || [];
    this.aggregates = options.aggregates || {};
    this.groups = [].concat(options.groups || []);
    this.hasGroups = this.groups.length > 0;
    this.hierarchy = options.hierarchy;
    this.hasGroupHeaderColumn = this.columns.some((column) => column.groupHeaderColumnTemplate);
    this.collapsible = this.options.collapsible;
  }
  workbook() {
    const workbook = {
      sheets: [{
        columns: this._columns(),
        rows: this.hierarchy ? this._hierarchyRows() : this._rows(),
        freezePane: this._freezePane(),
        filter: this._filter()
      }]
    };
    return workbook;
  }
  _trimColumns(columns) {
    return columns.filter((column) => {
      let result = Boolean(column.field);
      if (!result && column.columns) {
        result = this._trimColumns(column.columns).length > 0;
      }
      return result;
    });
  }
  _leafColumns(columns) {
    let result = [];
    for (let idx = 0; idx < columns.length; idx++) {
      if (!columns[idx].columns) {
        result.push(columns[idx]);
      } else {
        result = result.concat(this._leafColumns(columns[idx].columns));
      }
    }
    return result;
  }
  _prepareColumn(column) {
    if (!column.field) {
      return null;
    }
    let value = function(dataItem) {
      return getter(column.field, true)(dataItem);
    };
    let values = null;
    if (column.values) {
      values = {};
      column.values.forEach(function(item) {
        values[item.value] = item.text;
      });
      value = function(dataItem) {
        return values[getter(column.field, true)(dataItem)];
      };
    }
    return Object.assign({}, column, {
      value,
      values,
      groupHeaderTemplate: column.groupHeaderTemplate ? template_service_default.compile(column.groupHeaderTemplate) : defaultGroupHeaderTemplate,
      groupHeaderColumnTemplate: column.groupHeaderColumnTemplate ? template_service_default.compile(column.groupHeaderColumnTemplate) : null,
      groupFooterTemplate: column.groupFooterTemplate ? template_service_default.compile(column.groupFooterTemplate) : null,
      footerTemplate: column.footerTemplate ? template_service_default.compile(column.footerTemplate) : null
    });
  }
  _filter() {
    if (!this.options.filterable) {
      return null;
    }
    const depth = this._depth();
    return {
      from: depth,
      to: depth + this.columns.length - 1
    };
  }
  _createPaddingCells(length) {
    return createArray(length, () => Object.assign({
      background: "#dfdfdf",
      color: "#333"
    }, this.options.paddingCellOptions));
  }
  _dataRow(dataItem, level, depth) {
    let cells = this._createPaddingCells(level);
    if (this.hasGroups && depth && dataItem.items) {
      cells = cells.concat(this._groupHeaderCells(dataItem, level, depth));
      const rows = this._dataRows(dataItem.items, level + 1);
      rows.unshift({
        type: "group-header",
        cells,
        level: this.collapsible ? level : null
      });
      return rows.concat(this._footer(dataItem, level));
    }
    const dataCells = [];
    for (let cellIdx = 0; cellIdx < this.columns.length; cellIdx++) {
      dataCells[cellIdx] = this._cell(dataItem, this.columns[cellIdx]);
    }
    if (this.hierarchy) {
      dataCells[0].colSpan = depth - level + 1;
    }
    return [{
      type: "data",
      cells: cells.concat(dataCells),
      level: this.collapsible ? level : null
    }];
  }
  _groupHeaderCells(dataItem, level, depth) {
    const cells = [];
    const column = this.allColumns.filter(function(column2) {
      return column2.field === dataItem.field;
    })[0] || {};
    const title = column && column.title ? column.title : dataItem.field;
    const template = column ? column.groupHeaderTemplate || column.groupHeaderColumnTemplate : null;
    const group = Object.assign({
      title,
      field: dataItem.field,
      value: column && column.values ? column.values[dataItem.value] : dataItem.value,
      aggregates: dataItem.aggregates,
      items: dataItem.items
    }, dataItem.aggregates[dataItem.field]);
    const value = template ? template(group) : `${title}: ${dataItem.value}`;
    cells.push(Object.assign({
      value,
      background: "#dfdfdf",
      color: "#333",
      colSpan: (this.hasGroupHeaderColumn ? 1 : this.columns.length) + depth - level
    }, column.groupHeaderCellOptions));
    if (this.hasGroupHeaderColumn) {
      this.columns.forEach(function(column2, index) {
        if (index > 0) {
          cells.push(Object.assign({
            background: "#dfdfdf",
            color: "#333",
            value: column2.groupHeaderColumnTemplate ? column2.groupHeaderColumnTemplate(Object.assign({ group }, group, dataItem.aggregates[column2.field])) : void 0
          }, column2.groupHeaderCellOptions));
        }
      });
    }
    return cells;
  }
  _dataRows(dataItems, level) {
    const depth = this._depth();
    const rows = [];
    for (let idx = 0; idx < dataItems.length; idx++) {
      rows.push.apply(rows, this._dataRow(dataItems[idx], level, depth));
    }
    return rows;
  }
  _hierarchyRows() {
    const depth = this._depth();
    const data = this.data;
    const itemLevel = this.hierarchy.itemLevel;
    const itemId = this.hierarchy.itemId || defaultItemId;
    const hasFooter = this._hasFooterTemplate();
    const rows = [];
    const parents = [];
    let previousLevel = 0;
    let previousItemId;
    if (!hasFooter) {
      this.collapsible = false;
    }
    for (let idx = 0; idx < data.length; idx++) {
      const item = data[idx];
      const level = itemLevel(item, idx);
      if (hasFooter) {
        if (level > previousLevel) {
          parents.push({ id: previousItemId, level: previousLevel });
        } else if (level < previousLevel) {
          rows.push.apply(rows, this._hierarchyFooterRows(parents, level, depth));
        }
        previousLevel = level;
        previousItemId = itemId(item, idx);
      }
      rows.push.apply(rows, this._dataRow(item, level + 1, depth));
    }
    if (hasFooter) {
      rows.push.apply(rows, this._hierarchyFooterRows(parents, 0, depth));
      const rootAggregate = data.length ? this.aggregates[data[0].parentId] : {};
      rows.push(this._hierarchyFooter(rootAggregate, 0, depth));
    }
    this._prependHeaderRows(rows);
    return rows;
  }
  _hierarchyFooterRows(parents, currentLevel, depth) {
    const rows = [];
    while (parents.length && parents[parents.length - 1].level >= currentLevel) {
      const parent = parents.pop();
      rows.push(this._hierarchyFooter(this.aggregates[parent.id], parent.level + 1, depth));
    }
    return rows;
  }
  _hasFooterTemplate() {
    const columns = this.columns;
    for (let idx = 0; idx < columns.length; idx++) {
      if (columns[idx].footerTemplate) {
        return true;
      }
    }
  }
  _hierarchyFooter(aggregates, level, depth) {
    const cells = this.columns.map(function(column, index) {
      const colSpan = index ? 1 : depth - level + 1;
      if (column.footerTemplate) {
        const fieldAggregates = (aggregates || {})[column.field];
        return Object.assign({
          background: "#dfdfdf",
          color: "#333",
          colSpan,
          value: column.footerTemplate(Object.assign({ aggregates }, fieldAggregates))
        }, column.footerCellOptions);
      }
      return Object.assign({
        background: "#dfdfdf",
        color: "#333",
        colSpan
      }, column.footerCellOptions);
    });
    return {
      type: "footer",
      cells: this._createPaddingCells(level).concat(cells),
      level: this.collapsible ? level : null
    };
  }
  _footer(dataItem, level) {
    const rows = [];
    const footer = this.columns.some((column) => column.groupFooterTemplate);
    let templateData, group;
    if (footer) {
      group = {
        group: {
          items: dataItem.items,
          field: dataItem.field,
          value: dataItem.value
        }
      };
      templateData = {};
      Object.keys(dataItem.aggregates).forEach((key) => {
        templateData[key] = Object.assign({}, dataItem.aggregates[key], group);
      });
    }
    const cells = this.columns.map((column) => {
      if (column.groupFooterTemplate) {
        let data = Object.assign({}, templateData, dataItem.aggregates[column.field], group);
        return Object.assign({
          background: "#dfdfdf",
          color: "#333",
          value: column.groupFooterTemplate(data)
        }, column.groupFooterCellOptions);
      }
      return Object.assign({
        background: "#dfdfdf",
        color: "#333"
      }, column.groupFooterCellOptions);
    });
    if (footer) {
      rows.push({
        type: "group-footer",
        cells: this._createPaddingCells(this.groups.length).concat(cells),
        level: this.collapsible ? level : null
      });
    }
    return rows;
  }
  _isColumnVisible(column) {
    return this._visibleColumns([column]).length > 0 && (column.field || column.columns);
  }
  _visibleColumns(columns) {
    return columns.filter((column) => {
      let exportable = column.exportable;
      if (typeof exportable === "object") {
        exportable = column.exportable.excel;
      }
      const visibleInExport = !column.hidden && exportable !== false;
      const visibleInExportOnly = column.hidden && exportable === true;
      let visible = visibleInExport || visibleInExportOnly;
      if (visible && column.columns) {
        visible = this._visibleColumns(column.columns).length > 0;
      }
      return visible;
    });
  }
  _headerRow(row, groups) {
    const headers = row.cells.map(function(cell) {
      return Object.assign(cell, {
        colSpan: cell.colSpan > 1 ? cell.colSpan : 1,
        rowSpan: row.rowSpan > 1 && !cell.colSpan ? row.rowSpan : 1
      });
    });
    if (this.hierarchy && headers[0].firstCell) {
      headers[0].colSpan += this._depth();
    }
    return {
      type: "header",
      cells: createArray(groups.length, () => Object.assign({
        background: "#7a7a7a",
        color: "#fff"
      }, this.options.headerPaddingCellOptions)).concat(headers)
    };
  }
  _prependHeaderRows(rows) {
    const groups = this.groups;
    const headerRows = [{ rowSpan: 1, cells: [], index: 0 }];
    this._prepareHeaderRows(headerRows, this.options.columns);
    for (let idx = headerRows.length - 1; idx >= 0; idx--) {
      rows.unshift(this._headerRow(headerRows[idx], groups));
    }
  }
  _prepareHeaderRows(rows, columns, parentCell, parentRow) {
    const row = parentRow || rows[rows.length - 1];
    let childRow = rows[row.index + 1];
    let totalColSpan = 0;
    for (let idx = 0; idx < columns.length; idx++) {
      const column = columns[idx];
      if (this._isColumnVisible(column)) {
        const cell = Object.assign({
          background: "#7a7a7a",
          color: "#fff",
          value: column.title || column.field,
          colSpan: 0,
          firstCell: idx === 0 && (!parentCell || parentCell.firstCell)
        }, column.headerCellOptions);
        row.cells.push(cell);
        if (column.columns && column.columns.length) {
          if (!childRow) {
            childRow = { rowSpan: 0, cells: [], index: rows.length };
            rows.push(childRow);
          }
          cell.colSpan = this._trimColumns(this._visibleColumns(column.columns)).length;
          this._prepareHeaderRows(rows, column.columns, cell, childRow);
          totalColSpan += cell.colSpan - 1;
          row.rowSpan = rows.length - row.index;
        }
      }
    }
    if (parentCell) {
      parentCell.colSpan += totalColSpan;
    }
  }
  _rows() {
    const rows = this._dataRows(this.data, 0);
    if (this.columns.length) {
      this._prependHeaderRows(rows);
      let footer = false;
      const cells = this.columns.map((column) => {
        if (column.footerTemplate) {
          footer = true;
          return Object.assign({
            background: "#dfdfdf",
            color: "#333",
            value: column.footerTemplate(Object.assign({}, this.aggregates, this.aggregates[column.field]))
          }, column.footerCellOptions);
        }
        return Object.assign({
          background: "#dfdfdf",
          color: "#333"
        }, column.footerCellOptions);
      });
      if (footer) {
        rows.push({
          type: "footer",
          cells: this._createPaddingCells(this.groups.length).concat(cells)
        });
      }
    }
    return rows;
  }
  _headerDepth(columns) {
    const result = 1;
    let max = 0;
    for (let idx = 0; idx < columns.length; idx++) {
      if (columns[idx].columns) {
        const temp = this._headerDepth(columns[idx].columns);
        if (temp > max) {
          max = temp;
        }
      }
    }
    return result + max;
  }
  _freezePane() {
    const columns = this._visibleColumns(this.options.columns || []);
    const colSplit = this._visibleColumns(this._trimColumns(this._leafColumns(columns.filter(function(column) {
      return column.locked;
    })))).length;
    return {
      rowSplit: this._headerDepth(columns),
      colSplit: colSplit ? colSplit + this.groups.length : 0
    };
  }
  _cell(dataItem, column) {
    return Object.assign({
      value: column.value(dataItem)
    }, column.cellOptions);
  }
  _depth() {
    let depth = 0;
    if (this.hierarchy) {
      depth = this.hierarchy.depth;
    } else {
      depth = this.groups.length;
    }
    return depth;
  }
  _columns() {
    const depth = this._depth();
    const columns = createArray(depth, () => ({ width: 20 }));
    return columns.concat(this.columns.map(function(column) {
      return {
        width: parseInt(column.width, 10),
        autoWidth: column.width ? false : true
      };
    }));
  }
};
var excel_exporter_default = ExcelExporter;

// node_modules/@progress/kendo-ooxml/dist/es/services/intl-service.js
var current2 = {
  toString: (value) => value
};
var IntlService = class {
  static register(userImplementation) {
    current2 = userImplementation;
  }
  static toString(value, format) {
    return current2.toString(value, format);
  }
};
var intl_service_default = IntlService;

// node_modules/@progress/jszip-esm/dist/jszip-esm5.js
var external = {
  Promise
};
var support = {
  base64: true,
  array: true,
  string: true,
  nodebuffer: false,
  nodestream: false,
  get arraybuffer() {
    return typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
  },
  // Returns true if JSZip can read/generate Uint8Array, false otherwise.
  get uint8array() {
    return typeof Uint8Array !== "undefined";
  },
  get blob() {
    return blob();
  }
};
var blob = function() {
  var supported;
  if (typeof ArrayBuffer === "undefined") {
    supported = false;
  } else {
    var buffer = new ArrayBuffer(0);
    try {
      supported = new Blob([buffer], {
        type: "application/zip"
      }).size === 0;
    } catch (e6) {
      supported = false;
    }
  }
  blob = function() {
    return supported;
  };
  return supported;
};
var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
var encode = function(input) {
  var output = [];
  var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
  var i2 = 0, len = input.length, remainingBytes = len;
  var isArray = typeof input !== "string";
  while (i2 < input.length) {
    remainingBytes = len - i2;
    if (!isArray) {
      chr1 = input.charCodeAt(i2++);
      chr2 = i2 < len ? input.charCodeAt(i2++) : 0;
      chr3 = i2 < len ? input.charCodeAt(i2++) : 0;
    } else {
      chr1 = input[i2++];
      chr2 = i2 < len ? input[i2++] : 0;
      chr3 = i2 < len ? input[i2++] : 0;
    }
    enc1 = chr1 >> 2;
    enc2 = (chr1 & 3) << 4 | chr2 >> 4;
    enc3 = remainingBytes > 1 ? (chr2 & 15) << 2 | chr3 >> 6 : 64;
    enc4 = remainingBytes > 2 ? chr3 & 63 : 64;
    output.push(_keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4));
  }
  return output.join("");
};
var decode = function(input) {
  var chr1, chr2, chr3;
  var enc1, enc2, enc3, enc4;
  var i2 = 0, resultIndex = 0;
  var dataUrlPrefix = "data:";
  if (input.substr(0, dataUrlPrefix.length) === dataUrlPrefix) {
    throw new Error("Invalid base64 input, it looks like a data url.");
  }
  input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
  var totalLength = input.length * 3 / 4;
  if (input.charAt(input.length - 1) === _keyStr.charAt(64)) {
    totalLength--;
  }
  if (input.charAt(input.length - 2) === _keyStr.charAt(64)) {
    totalLength--;
  }
  if (totalLength % 1 !== 0) {
    throw new Error("Invalid base64 input, bad content length.");
  }
  var output;
  if (support.uint8array) {
    output = new Uint8Array(totalLength | 0);
  } else {
    output = new Array(totalLength | 0);
  }
  while (i2 < input.length) {
    enc1 = _keyStr.indexOf(input.charAt(i2++));
    enc2 = _keyStr.indexOf(input.charAt(i2++));
    enc3 = _keyStr.indexOf(input.charAt(i2++));
    enc4 = _keyStr.indexOf(input.charAt(i2++));
    chr1 = enc1 << 2 | enc2 >> 4;
    chr2 = (enc2 & 15) << 4 | enc3 >> 2;
    chr3 = (enc3 & 3) << 6 | enc4;
    output[resultIndex++] = chr1;
    if (enc3 !== 64) {
      output[resultIndex++] = chr2;
    }
    if (enc4 !== 64) {
      output[resultIndex++] = chr3;
    }
  }
  return output;
};
function string2binary(str) {
  var result = null;
  if (support.uint8array) {
    result = new Uint8Array(str.length);
  } else {
    result = new Array(str.length);
  }
  return stringToArrayLike(str, result);
}
var newBlob = function(part, type) {
  checkSupport("blob");
  return new Blob([part], {
    type
  });
};
function identity(input) {
  return input;
}
function stringToArrayLike(str, array) {
  for (var i2 = 0; i2 < str.length; ++i2) {
    array[i2] = str.charCodeAt(i2) & 255;
  }
  return array;
}
function stringifyByChunk(array, type, chunk) {
  var result = [], k = 0, len = array.length;
  if (len <= chunk) {
    return String.fromCharCode.apply(null, array);
  }
  while (k < len) {
    if (type === "array") {
      result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len))));
    } else {
      result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len))));
    }
    k += chunk;
  }
  return result.join("");
}
function stringifyByChar(array) {
  var resultStr = "";
  for (var i2 = 0; i2 < array.length; i2++) {
    resultStr += String.fromCharCode(array[i2]);
  }
  return resultStr;
}
var fromCharCodeSupportsTypedArrays = function() {
  var supported;
  try {
    supported = support.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
  } catch (e6) {
    supported = false;
  }
  fromCharCodeSupportsTypedArrays = function() {
    return supported;
  };
  return supported;
};
function arrayLikeToString(array) {
  var chunk = 65536, type = getTypeOf(array), canUseApply = true;
  if (type === "uint8array") {
    canUseApply = fromCharCodeSupportsTypedArrays();
  }
  if (canUseApply) {
    while (chunk > 1) {
      try {
        return stringifyByChunk(array, type, chunk);
      } catch (e6) {
        chunk = Math.floor(chunk / 2);
      }
    }
  }
  return stringifyByChar(array);
}
var applyFromCharCode = arrayLikeToString;
function arrayLikeToArrayLike(arrayFrom, arrayTo) {
  for (var i2 = 0; i2 < arrayFrom.length; i2++) {
    arrayTo[i2] = arrayFrom[i2];
  }
  return arrayTo;
}
var transform = {
  // string to ?
  "string": {
    "string": identity,
    "array": function(input) {
      return stringToArrayLike(input, new Array(input.length));
    },
    "arraybuffer": function(input) {
      return transform["string"]["uint8array"](input).buffer;
    },
    "uint8array": function(input) {
      return stringToArrayLike(input, new Uint8Array(input.length));
    }
  },
  // array to ?
  "array": {
    "string": arrayLikeToString,
    "array": identity,
    "arraybuffer": function(input) {
      return new Uint8Array(input).buffer;
    },
    "uint8array": function(input) {
      return new Uint8Array(input);
    }
  },
  // arraybuffer to ?
  "arraybuffer": {
    "string": function(input) {
      return arrayLikeToString(new Uint8Array(input));
    },
    "array": function(input) {
      return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));
    },
    "arraybuffer": identity,
    "uint8array": function(input) {
      return new Uint8Array(input);
    }
  },
  // uint8array to ?
  "uint8array": {
    "string": arrayLikeToString,
    "array": function(input) {
      return arrayLikeToArrayLike(input, new Array(input.length));
    },
    "arraybuffer": function(input) {
      return input.buffer;
    },
    "uint8array": identity
  }
};
var transformTo = function(outputType, input) {
  if (!input) {
    input = "";
  }
  if (!outputType) {
    return input;
  }
  checkSupport(outputType);
  var inputType = getTypeOf(input);
  var result = transform[inputType][outputType](input);
  return result;
};
var resolve = function(path) {
  var parts = path.split("/");
  var result = [];
  for (var index = 0; index < parts.length; index++) {
    var part = parts[index];
    if (part === "." || part === "" && index !== 0 && index !== parts.length - 1) {
      continue;
    } else if (part === "..") {
      result.pop();
    } else {
      result.push(part);
    }
  }
  return result.join("/");
};
var getTypeOf = function(input) {
  if (typeof input === "string") {
    return "string";
  }
  if (Object.prototype.toString.call(input) === "[object Array]") {
    return "array";
  }
  if (support.uint8array && input instanceof Uint8Array) {
    return "uint8array";
  }
  if (support.arraybuffer && input instanceof ArrayBuffer) {
    return "arraybuffer";
  }
};
var checkSupport = function(type) {
  var supported = support[type.toLowerCase()];
  if (!supported) {
    throw new Error(type + " is not supported by this platform");
  }
};
var MAX_VALUE_16BITS = 65535;
var MAX_VALUE_32BITS = -1;
var pretty = function(str) {
  var res = "", code, i2;
  for (i2 = 0; i2 < (str || "").length; i2++) {
    code = str.charCodeAt(i2);
    res += "\\x" + (code < 16 ? "0" : "") + code.toString(16).toUpperCase();
  }
  return res;
};
var delay = function(callback, args, self) {
  setTimeout(function() {
    callback.apply(self || null, args || []);
  }, 0);
};
var extend = function() {
  var arguments$1 = arguments;
  var result = {}, i2, attr;
  for (i2 = 0; i2 < arguments.length; i2++) {
    for (attr in arguments[i2]) {
      if (Object.hasOwnProperty.call(arguments$1[i2], attr) && typeof result[attr] === "undefined") {
        result[attr] = arguments$1[i2][attr];
      }
    }
  }
  return result;
};
var prepareContent = function(name, inputData, isBinary, isOptimizedBinaryString, isBase64) {
  var promise = external.Promise.resolve(inputData).then(function(data) {
    var isBlob = support.blob && (data instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(data)) !== -1);
    if (isBlob && typeof FileReader !== "undefined") {
      return new external.Promise(function(resolve2, reject) {
        var reader = new FileReader();
        reader.onload = function(e6) {
          resolve2(e6.target.result);
        };
        reader.onerror = function(e6) {
          reject(e6.target.error);
        };
        reader.readAsArrayBuffer(data);
      });
    } else {
      return data;
    }
  });
  return promise.then(function(data) {
    var dataType = getTypeOf(data);
    if (!dataType) {
      return external.Promise.reject(
        new Error("Can't read the data of '" + name + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?")
      );
    }
    if (dataType === "arraybuffer") {
      data = transformTo("uint8array", data);
    } else if (dataType === "string") {
      if (isBase64) {
        data = decode(data);
      } else if (isBinary) {
        if (isOptimizedBinaryString !== true) {
          data = string2binary(data);
        }
      }
    }
    return data;
  });
};
var GenericWorker = function GenericWorker2(name) {
  this.name = name || "default";
  this.streamInfo = {};
  this.generatedError = null;
  this.extraStreamInfo = {};
  this.isPaused = true;
  this.isFinished = false;
  this.isLocked = false;
  this._listeners = {
    "data": [],
    "end": [],
    "error": []
  };
  this.previous = null;
};
GenericWorker.prototype.push = function push(chunk) {
  this.emit("data", chunk);
};
GenericWorker.prototype.end = function end() {
  if (this.isFinished) {
    return false;
  }
  this.flush();
  try {
    this.emit("end");
    this.cleanUp();
    this.isFinished = true;
  } catch (e6) {
    this.emit("error", e6);
  }
  return true;
};
GenericWorker.prototype.error = function error(e6) {
  if (this.isFinished) {
    return false;
  }
  if (this.isPaused) {
    this.generatedError = e6;
  } else {
    this.isFinished = true;
    this.emit("error", e6);
    if (this.previous) {
      this.previous.error(e6);
    }
    this.cleanUp();
  }
  return true;
};
GenericWorker.prototype.on = function on(name, listener) {
  this._listeners[name].push(listener);
  return this;
};
GenericWorker.prototype.cleanUp = function cleanUp() {
  this.streamInfo = this.generatedError = this.extraStreamInfo = null;
  this._listeners = [];
};
GenericWorker.prototype.emit = function emit(name, arg) {
  if (this._listeners[name]) {
    for (var i2 = 0; i2 < this._listeners[name].length; i2++) {
      this._listeners[name][i2].call(this, arg);
    }
  }
};
GenericWorker.prototype.pipe = function pipe(next) {
  return next.registerPrevious(this);
};
GenericWorker.prototype.registerPrevious = function registerPrevious(previous) {
  if (this.isLocked) {
    throw new Error("The stream '" + this + "' has already been used.");
  }
  this.streamInfo = previous.streamInfo;
  this.mergeStreamInfo();
  this.previous = previous;
  var self = this;
  previous.on("data", function(chunk) {
    self.processChunk(chunk);
  });
  previous.on("end", function() {
    self.end();
  });
  previous.on("error", function(e6) {
    self.error(e6);
  });
  return this;
};
GenericWorker.prototype.pause = function pause() {
  if (this.isPaused || this.isFinished) {
    return false;
  }
  this.isPaused = true;
  if (this.previous) {
    this.previous.pause();
  }
  return true;
};
GenericWorker.prototype.resume = function resume() {
  if (!this.isPaused || this.isFinished) {
    return false;
  }
  this.isPaused = false;
  var withError = false;
  if (this.generatedError) {
    this.error(this.generatedError);
    withError = true;
  }
  if (this.previous) {
    this.previous.resume();
  }
  return !withError;
};
GenericWorker.prototype.flush = function flush() {
};
GenericWorker.prototype.processChunk = function processChunk(chunk) {
  this.push(chunk);
};
GenericWorker.prototype.withStreamInfo = function withStreamInfo(key, value) {
  this.extraStreamInfo[key] = value;
  this.mergeStreamInfo();
  return this;
};
GenericWorker.prototype.mergeStreamInfo = function mergeStreamInfo() {
  for (var key in this.extraStreamInfo) {
    if (!this.extraStreamInfo.hasOwnProperty(key)) {
      continue;
    }
    this.streamInfo[key] = this.extraStreamInfo[key];
  }
};
GenericWorker.prototype.lock = function lock() {
  if (this.isLocked) {
    throw new Error("The stream '" + this + "' has already been used.");
  }
  this.isLocked = true;
  if (this.previous) {
    this.previous.lock();
  }
};
GenericWorker.prototype.toString = function toString() {
  var me = "Worker " + this.name;
  if (this.previous) {
    return this.previous + " -> " + me;
  } else {
    return me;
  }
};
var utf8len = function(c) {
  var _utf8len = new Array(256);
  for (var i2 = 0; i2 < 256; i2++) {
    _utf8len[i2] = i2 >= 252 ? 6 : i2 >= 248 ? 5 : i2 >= 240 ? 4 : i2 >= 224 ? 3 : i2 >= 192 ? 2 : 1;
  }
  _utf8len[254] = _utf8len[254] = 1;
  utf8len = function(c2) {
    return _utf8len[c2];
  };
  return _utf8len[c];
};
var string2buf = function(str) {
  var buf, c, c2, m_pos, i2, str_len = str.length, buf_len = 0;
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
  }
  if (support.uint8array) {
    buf = new Uint8Array(buf_len);
  } else {
    buf = new Array(buf_len);
  }
  for (i2 = 0, m_pos = 0; i2 < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    if (c < 128) {
      buf[i2++] = c;
    } else if (c < 2048) {
      buf[i2++] = 192 | c >>> 6;
      buf[i2++] = 128 | c & 63;
    } else if (c < 65536) {
      buf[i2++] = 224 | c >>> 12;
      buf[i2++] = 128 | c >>> 6 & 63;
      buf[i2++] = 128 | c & 63;
    } else {
      buf[i2++] = 240 | c >>> 18;
      buf[i2++] = 128 | c >>> 12 & 63;
      buf[i2++] = 128 | c >>> 6 & 63;
      buf[i2++] = 128 | c & 63;
    }
  }
  return buf;
};
var utf8border = function(buf, max) {
  var pos;
  max = max || buf.length;
  if (max > buf.length) {
    max = buf.length;
  }
  pos = max - 1;
  while (pos >= 0 && (buf[pos] & 192) === 128) {
    pos--;
  }
  if (pos < 0) {
    return max;
  }
  if (pos === 0) {
    return max;
  }
  return pos + utf8len(buf[pos]) > max ? pos : max;
};
var buf2string = function(buf) {
  var i2, out, c, c_len;
  var len = buf.length;
  var utf16buf = new Array(len * 2);
  for (out = 0, i2 = 0; i2 < len; ) {
    c = buf[i2++];
    if (c < 128) {
      utf16buf[out++] = c;
      continue;
    }
    c_len = utf8len(c);
    if (c_len > 4) {
      utf16buf[out++] = 65533;
      i2 += c_len - 1;
      continue;
    }
    c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
    while (c_len > 1 && i2 < len) {
      c = c << 6 | buf[i2++] & 63;
      c_len--;
    }
    if (c_len > 1) {
      utf16buf[out++] = 65533;
      continue;
    }
    if (c < 65536) {
      utf16buf[out++] = c;
    } else {
      c -= 65536;
      utf16buf[out++] = 55296 | c >> 10 & 1023;
      utf16buf[out++] = 56320 | c & 1023;
    }
  }
  if (utf16buf.length !== out) {
    if (utf16buf.subarray) {
      utf16buf = utf16buf.subarray(0, out);
    } else {
      utf16buf.length = out;
    }
  }
  return applyFromCharCode(utf16buf);
};
var utf8encode = function utf8encode2(str) {
  return string2buf(str);
};
var utf8decode = function utf8decode2(buf) {
  buf = transformTo(support.uint8array ? "uint8array" : "array", buf);
  return buf2string(buf);
};
var Utf8DecodeWorker = function(GenericWorker3) {
  function Utf8DecodeWorker2() {
    GenericWorker3.call(this, "utf-8 decode");
    this.leftOver = null;
  }
  Utf8DecodeWorker2.__proto__ = GenericWorker3;
  Utf8DecodeWorker2.prototype = Object.create(GenericWorker3.prototype);
  Utf8DecodeWorker2.prototype.constructor = Utf8DecodeWorker2;
  Utf8DecodeWorker2.prototype.processChunk = function processChunk2(chunk) {
    var data = transformTo(support.uint8array ? "uint8array" : "array", chunk.data);
    if (this.leftOver && this.leftOver.length) {
      if (support.uint8array) {
        var previousData = data;
        data = new Uint8Array(previousData.length + this.leftOver.length);
        data.set(this.leftOver, 0);
        data.set(previousData, this.leftOver.length);
      } else {
        data = this.leftOver.concat(data);
      }
      this.leftOver = null;
    }
    var nextBoundary = utf8border(data);
    var usableData = data;
    if (nextBoundary !== data.length) {
      if (support.uint8array) {
        usableData = data.subarray(0, nextBoundary);
        this.leftOver = data.subarray(nextBoundary, data.length);
      } else {
        usableData = data.slice(0, nextBoundary);
        this.leftOver = data.slice(nextBoundary, data.length);
      }
    }
    this.push({
      data: utf8decode(usableData),
      meta: chunk.meta
    });
  };
  Utf8DecodeWorker2.prototype.flush = function flush2() {
    if (this.leftOver && this.leftOver.length) {
      this.push({
        data: utf8decode(this.leftOver),
        meta: {}
      });
      this.leftOver = null;
    }
  };
  return Utf8DecodeWorker2;
}(GenericWorker);
var Utf8EncodeWorker = function(GenericWorker3) {
  function Utf8EncodeWorker2() {
    GenericWorker3.call(this, "utf-8 encode");
  }
  Utf8EncodeWorker2.__proto__ = GenericWorker3;
  Utf8EncodeWorker2.prototype = Object.create(GenericWorker3.prototype);
  Utf8EncodeWorker2.prototype.constructor = Utf8EncodeWorker2;
  Utf8EncodeWorker2.prototype.processChunk = function processChunk2(chunk) {
    this.push({
      data: utf8encode(chunk.data),
      meta: chunk.meta
    });
  };
  return Utf8EncodeWorker2;
}(GenericWorker);
var ConvertWorker = function(GenericWorker3) {
  function ConvertWorker2(destType) {
    GenericWorker3.call(this, "ConvertWorker to " + destType);
    this.destType = destType;
  }
  ConvertWorker2.__proto__ = GenericWorker3;
  ConvertWorker2.prototype = Object.create(GenericWorker3.prototype);
  ConvertWorker2.prototype.constructor = ConvertWorker2;
  ConvertWorker2.prototype.processChunk = function processChunk2(chunk) {
    this.push({
      data: transformTo(this.destType, chunk.data),
      meta: chunk.meta
    });
  };
  return ConvertWorker2;
}(GenericWorker);
function transformZipOutput(type, content, mimeType) {
  switch (type) {
    case "blob":
      return newBlob(transformTo("arraybuffer", content), mimeType);
    case "base64":
      return encode(content);
    default:
      return transformTo(type, content);
  }
}
function concat(type, dataArray) {
  var i2, index = 0, res = null, totalLength = 0;
  for (i2 = 0; i2 < dataArray.length; i2++) {
    totalLength += dataArray[i2].length;
  }
  switch (type) {
    case "string":
      return dataArray.join("");
    case "array":
      return Array.prototype.concat.apply([], dataArray);
    case "uint8array":
      res = new Uint8Array(totalLength);
      for (i2 = 0; i2 < dataArray.length; i2++) {
        res.set(dataArray[i2], index);
        index += dataArray[i2].length;
      }
      return res;
    default:
      throw new Error("concat : unsupported type '" + type + "'");
  }
}
function accumulate(helper, updateCallback) {
  return new external.Promise(function(resolve2, reject) {
    var dataArray = [];
    var chunkType = helper._internalType, resultType = helper._outputType, mimeType = helper._mimeType;
    helper.on("data", function(data, meta) {
      dataArray.push(data);
      if (updateCallback) {
        updateCallback(meta);
      }
    }).on("error", function(err) {
      dataArray = [];
      reject(err);
    }).on("end", function() {
      try {
        var result = transformZipOutput(resultType, concat(chunkType, dataArray), mimeType);
        resolve2(result);
      } catch (e6) {
        reject(e6);
      }
      dataArray = [];
    }).resume();
  });
}
var StreamHelper = function StreamHelper2(worker, outputType, mimeType) {
  var internalType = outputType;
  switch (outputType) {
    case "blob":
    case "arraybuffer":
      internalType = "uint8array";
      break;
    case "base64":
      internalType = "string";
      break;
  }
  try {
    this._internalType = internalType;
    this._outputType = outputType;
    this._mimeType = mimeType;
    checkSupport(internalType);
    this._worker = worker.pipe(new ConvertWorker(internalType));
    worker.lock();
  } catch (e6) {
    this._worker = new GenericWorker("error");
    this._worker.error(e6);
  }
};
StreamHelper.prototype.accumulate = function accumulate$1(updateCb) {
  return accumulate(this, updateCb);
};
StreamHelper.prototype.on = function on2(evt, fn) {
  var self = this;
  if (evt === "data") {
    this._worker.on(evt, function(chunk) {
      fn.call(self, chunk.data, chunk.meta);
    });
  } else {
    this._worker.on(evt, function() {
      delay(fn, arguments, self);
    });
  }
  return this;
};
StreamHelper.prototype.resume = function resume2() {
  delay(this._worker.resume, [], this._worker);
  return this;
};
StreamHelper.prototype.pause = function pause2() {
  this._worker.pause();
  return this;
};
var base64 = false;
var binary = false;
var dir = false;
var createFolders = true;
var date = null;
var compression = null;
var compressionOptions = null;
var comment = null;
var unixPermissions = null;
var dosPermissions = null;
var defaults = Object.freeze({
  __proto__: null,
  base64,
  binary,
  comment,
  compression,
  compressionOptions,
  createFolders,
  date,
  dir,
  dosPermissions,
  unixPermissions
});
var DEFAULT_BLOCK_SIZE = 16 * 1024;
var DataWorker = function(GenericWorker3) {
  function DataWorker2(dataP) {
    GenericWorker3.call(this, "DataWorker");
    var self = this;
    this.dataIsReady = false;
    this.index = 0;
    this.max = 0;
    this.data = null;
    this.type = "";
    this._tickScheduled = false;
    dataP.then(function(data) {
      self.dataIsReady = true;
      self.data = data;
      self.max = data && data.length || 0;
      self.type = getTypeOf(data);
      if (!self.isPaused) {
        self._tickAndRepeat();
      }
    }, function(e6) {
      self.error(e6);
    });
  }
  DataWorker2.__proto__ = GenericWorker3;
  DataWorker2.prototype = Object.create(GenericWorker3.prototype);
  DataWorker2.prototype.constructor = DataWorker2;
  DataWorker2.prototype.cleanUp = function cleanUp2() {
    GenericWorker3.prototype.cleanUp.call(this);
    this.data = null;
  };
  DataWorker2.prototype.resume = function resume3() {
    if (!GenericWorker3.prototype.resume.call(this)) {
      return false;
    }
    if (!this._tickScheduled && this.dataIsReady) {
      this._tickScheduled = true;
      delay(this._tickAndRepeat, [], this);
    }
    return true;
  };
  DataWorker2.prototype._tickAndRepeat = function _tickAndRepeat() {
    this._tickScheduled = false;
    if (this.isPaused || this.isFinished) {
      return;
    }
    this._tick();
    if (!this.isFinished) {
      delay(this._tickAndRepeat, [], this);
      this._tickScheduled = true;
    }
  };
  DataWorker2.prototype._tick = function _tick() {
    if (this.isPaused || this.isFinished) {
      return false;
    }
    var size = DEFAULT_BLOCK_SIZE;
    var data = null, nextIndex = Math.min(this.max, this.index + size);
    if (this.index >= this.max) {
      return this.end();
    } else {
      switch (this.type) {
        case "string":
          data = this.data.substring(this.index, nextIndex);
          break;
        case "uint8array":
          data = this.data.subarray(this.index, nextIndex);
          break;
        case "array":
          data = this.data.slice(this.index, nextIndex);
          break;
      }
      this.index = nextIndex;
      return this.push({
        data,
        meta: {
          percent: this.max ? this.index / this.max * 100 : 0
        }
      });
    }
  };
  return DataWorker2;
}(GenericWorker);
var DataLengthProbe = function(GenericWorker3) {
  function DataLengthProbe2(propName) {
    GenericWorker3.call(this, "DataLengthProbe for " + propName);
    this.propName = propName;
    this.withStreamInfo(propName, 0);
  }
  DataLengthProbe2.__proto__ = GenericWorker3;
  DataLengthProbe2.prototype = Object.create(GenericWorker3.prototype);
  DataLengthProbe2.prototype.constructor = DataLengthProbe2;
  DataLengthProbe2.prototype.processChunk = function processChunk2(chunk) {
    if (chunk) {
      var length = this.streamInfo[this.propName] || 0;
      this.streamInfo[this.propName] = length + chunk.data.length;
    }
    GenericWorker3.prototype.processChunk.call(this, chunk);
  };
  return DataLengthProbe2;
}(GenericWorker);
var makeTable = function() {
  var table = [];
  for (var n3 = 0; n3 < 256; n3++) {
    var c = n3;
    for (var k = 0; k < 8; k++) {
      c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
    }
    table[n3] = c;
  }
  makeTable = function() {
    return table;
  };
  return table;
};
function crc32(crc, buf, len, pos) {
  var t2 = makeTable();
  var end2 = pos + len;
  crc = crc ^ -1;
  for (var i2 = pos; i2 < end2; i2++) {
    crc = crc >>> 8 ^ t2[(crc ^ buf[i2]) & 255];
  }
  return crc ^ -1;
}
function crc32str(crc, str, len, pos) {
  var t2 = makeTable();
  var end2 = pos + len;
  crc = crc ^ -1;
  for (var i2 = pos; i2 < end2; i2++) {
    crc = crc >>> 8 ^ t2[(crc ^ str.charCodeAt(i2)) & 255];
  }
  return crc ^ -1;
}
function crc32wrapper(input, crc) {
  if (typeof input === "undefined" || !input.length) {
    return 0;
  }
  var isArray = getTypeOf(input) !== "string";
  if (isArray) {
    return crc32(crc | 0, input, input.length, 0);
  } else {
    return crc32str(crc | 0, input, input.length, 0);
  }
}
var Crc32Probe = function(GenericWorker3) {
  function Crc32Probe2() {
    GenericWorker3.call(this, "Crc32Probe");
    this.withStreamInfo("crc32", 0);
  }
  Crc32Probe2.__proto__ = GenericWorker3;
  Crc32Probe2.prototype = Object.create(GenericWorker3.prototype);
  Crc32Probe2.prototype.constructor = Crc32Probe2;
  Crc32Probe2.prototype.processChunk = function processChunk2(chunk) {
    this.streamInfo.crc32 = crc32wrapper(chunk.data, this.streamInfo.crc32 || 0);
    this.push(chunk);
  };
  return Crc32Probe2;
}(GenericWorker);
var CompressedObject = function CompressedObject2(compressedSize, uncompressedSize, crc322, compression2, data) {
  this.compressedSize = compressedSize;
  this.uncompressedSize = uncompressedSize;
  this.crc32 = crc322;
  this.compression = compression2;
  this.compressedContent = data;
};
CompressedObject.prototype.getContentWorker = function getContentWorker() {
  var worker = new DataWorker(external.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new DataLengthProbe("data_length"));
  var that = this;
  worker.on("end", function() {
    if (this.streamInfo["data_length"] !== that.uncompressedSize) {
      throw new Error("Bug : uncompressed data size mismatch");
    }
  });
  return worker;
};
CompressedObject.prototype.getCompressedWorker = function getCompressedWorker() {
  return new DataWorker(external.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
};
CompressedObject.createWorkerFrom = function createWorkerFrom(uncompressedWorker, compression2, compressionOptions2) {
  return uncompressedWorker.pipe(new Crc32Probe()).pipe(new DataLengthProbe("uncompressedSize")).pipe(compression2.compressWorker(compressionOptions2)).pipe(new DataLengthProbe("compressedSize")).withStreamInfo("compression", compression2);
};
var ZipObject = function ZipObject2(name, data, options) {
  this.name = name;
  this.dir = options.dir;
  this.date = options.date;
  this.comment = options.comment;
  this.unixPermissions = options.unixPermissions;
  this.dosPermissions = options.dosPermissions;
  this._data = data;
  this._dataBinary = options.binary;
  this.options = {
    compression: options.compression,
    compressionOptions: options.compressionOptions
  };
};
ZipObject.prototype.internalStream = function internalStream(type) {
  var result = null, outputType = "string";
  try {
    if (!type) {
      throw new Error("No output type specified.");
    }
    outputType = type.toLowerCase();
    var askUnicodeString = outputType === "string" || outputType === "text";
    if (outputType === "binarystring" || outputType === "text") {
      outputType = "string";
    }
    result = this._decompressWorker();
    var isUnicodeString = !this._dataBinary;
    if (isUnicodeString && !askUnicodeString) {
      result = result.pipe(new Utf8EncodeWorker());
    }
    if (!isUnicodeString && askUnicodeString) {
      result = result.pipe(new Utf8DecodeWorker());
    }
  } catch (e6) {
    result = new GenericWorker("error");
    result.error(e6);
  }
  return new StreamHelper(result, outputType, "");
};
ZipObject.prototype.async = function async(type, onUpdate) {
  return this.internalStream(type).accumulate(onUpdate);
};
ZipObject.prototype._compressWorker = function _compressWorker(compression2, compressionOptions2) {
  if (this._data instanceof CompressedObject && this._data.compression.magic === compression2.magic) {
    return this._data.getCompressedWorker();
  } else {
    var result = this._decompressWorker();
    if (!this._dataBinary) {
      result = result.pipe(new Utf8EncodeWorker());
    }
    return CompressedObject.createWorkerFrom(result, compression2, compressionOptions2);
  }
};
ZipObject.prototype._decompressWorker = function _decompressWorker() {
  if (this._data instanceof CompressedObject) {
    return this._data.getContentWorker();
  } else if (this._data instanceof GenericWorker) {
    return this._data;
  } else {
    return new DataWorker(this._data);
  }
};
var arrayType = function() {
  var useTypedArray = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Uint32Array !== "undefined";
  var resolved = useTypedArray ? "uint8array" : "array";
  arrayType = function() {
    return resolved;
  };
};
var FlateWorker = function(GenericWorker3) {
  function FlateWorker2(action, options) {
    GenericWorker3.call(this, "FlateWorker/" + action);
    this._pako = null;
    this._pakoAction = action;
    this._pakoOptions = options;
    this.meta = {};
  }
  FlateWorker2.__proto__ = GenericWorker3;
  FlateWorker2.prototype = Object.create(GenericWorker3.prototype);
  FlateWorker2.prototype.constructor = FlateWorker2;
  FlateWorker2.prototype.processChunk = function processChunk2(chunk) {
    this.meta = chunk.meta;
    if (this._pako === null) {
      this._createPako();
    }
    this._pako.push(transformTo(arrayType(), chunk.data), false);
  };
  FlateWorker2.prototype.flush = function flush2() {
    GenericWorker3.prototype.flush.call(this);
    if (this._pako === null) {
      this._createPako();
    }
    this._pako.push([], true);
  };
  FlateWorker2.prototype.cleanUp = function cleanUp2() {
    GenericWorker3.prototype.cleanUp.call(this);
    this._pako = null;
  };
  FlateWorker2.prototype._createPako = function _createPako() {
    var this$1$1 = this;
    var params = {
      raw: true,
      level: this._pakoOptions.level || -1
      // default compression
    };
    this._pako = this._pakoAction === "Deflate" ? new Deflate(params) : new Inflate(params);
    this._pako.onData = function(data) {
      this$1$1.push({
        data,
        meta: this$1$1.meta
      });
    };
  };
  return FlateWorker2;
}(GenericWorker);
var DEFLATE = {
  magic: "\b\0",
  compressWorker: function(compressionOptions2) {
    return new FlateWorker("Deflate", compressionOptions2);
  },
  uncompressWorker: function() {
    return new FlateWorker("Inflate", {});
  }
};
var STORE = {
  magic: "\0\0",
  compressWorker: function() {
    return new GenericWorker("STORE compression");
  },
  uncompressWorker: function() {
    return new GenericWorker("STORE decompression");
  }
};
var compressions = {
  STORE,
  DEFLATE
};
var LOCAL_FILE_HEADER = "PK";
var CENTRAL_FILE_HEADER = "PK";
var CENTRAL_DIRECTORY_END = "PK";
var ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07";
var ZIP64_CENTRAL_DIRECTORY_END = "PK";
var DATA_DESCRIPTOR = "PK\x07\b";
var decToHex = function(dec, bytes) {
  var hex = "", i2;
  for (i2 = 0; i2 < bytes; i2++) {
    hex += String.fromCharCode(dec & 255);
    dec = dec >>> 8;
  }
  return hex;
};
var generateUnixExternalFileAttr = function(unixPermissions2, isDir) {
  var result = unixPermissions2;
  if (!unixPermissions2) {
    result = isDir ? 16893 : 33204;
  }
  return (result & 65535) << 16;
};
var generateDosExternalFileAttr = function(dosPermissions2, isDir) {
  return (dosPermissions2 || 0) & 63;
};
var generateZipParts = function(streamInfo, streamedContent, streamingEnded, offset, platform, encodeFileName) {
  var file2 = streamInfo["file"], compression2 = streamInfo["compression"], useCustomEncoding = encodeFileName !== utf8encode, encodedFileName = transformTo("string", encodeFileName(file2.name)), utfEncodedFileName = transformTo("string", utf8encode(file2.name)), comment2 = file2.comment, encodedComment = transformTo("string", encodeFileName(comment2)), utfEncodedComment = transformTo("string", utf8encode(comment2)), useUTF8ForFileName = utfEncodedFileName.length !== file2.name.length, useUTF8ForComment = utfEncodedComment.length !== comment2.length, dosTime, dosDate, extraFields = "", unicodePathExtraField = "", unicodeCommentExtraField = "", dir2 = file2.dir, date2 = file2.date;
  var dataInfo = {
    crc32: 0,
    compressedSize: 0,
    uncompressedSize: 0
  };
  if (!streamedContent || streamingEnded) {
    dataInfo.crc32 = streamInfo["crc32"];
    dataInfo.compressedSize = streamInfo["compressedSize"];
    dataInfo.uncompressedSize = streamInfo["uncompressedSize"];
  }
  var bitflag = 0;
  if (streamedContent) {
    bitflag |= 8;
  }
  if (!useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment)) {
    bitflag |= 2048;
  }
  var extFileAttr = 0;
  var versionMadeBy = 0;
  if (dir2) {
    extFileAttr |= 16;
  }
  if (platform === "UNIX") {
    versionMadeBy = 798;
    extFileAttr |= generateUnixExternalFileAttr(file2.unixPermissions, dir2);
  } else {
    versionMadeBy = 20;
    extFileAttr |= generateDosExternalFileAttr(file2.dosPermissions);
  }
  dosTime = date2.getUTCHours();
  dosTime = dosTime << 6;
  dosTime = dosTime | date2.getUTCMinutes();
  dosTime = dosTime << 5;
  dosTime = dosTime | date2.getUTCSeconds() / 2;
  dosDate = date2.getUTCFullYear() - 1980;
  dosDate = dosDate << 4;
  dosDate = dosDate | date2.getUTCMonth() + 1;
  dosDate = dosDate << 5;
  dosDate = dosDate | date2.getUTCDate();
  if (useUTF8ForFileName) {
    unicodePathExtraField = // Version
    decToHex(1, 1) + // NameCRC32
    decToHex(crc32wrapper(encodedFileName), 4) + // UnicodeName
    utfEncodedFileName;
    extraFields += // Info-ZIP Unicode Path Extra Field
    "up" + // size
    decToHex(unicodePathExtraField.length, 2) + // content
    unicodePathExtraField;
  }
  if (useUTF8ForComment) {
    unicodeCommentExtraField = // Version
    decToHex(1, 1) + // CommentCRC32
    decToHex(crc32wrapper(encodedComment), 4) + // UnicodeName
    utfEncodedComment;
    extraFields += // Info-ZIP Unicode Path Extra Field
    "uc" + // size
    decToHex(unicodeCommentExtraField.length, 2) + // content
    unicodeCommentExtraField;
  }
  var header = "";
  header += "\n\0";
  header += decToHex(bitflag, 2);
  header += compression2.magic;
  header += decToHex(dosTime, 2);
  header += decToHex(dosDate, 2);
  header += decToHex(dataInfo.crc32, 4);
  header += decToHex(dataInfo.compressedSize, 4);
  header += decToHex(dataInfo.uncompressedSize, 4);
  header += decToHex(encodedFileName.length, 2);
  header += decToHex(extraFields.length, 2);
  var fileRecord = LOCAL_FILE_HEADER + header + encodedFileName + extraFields;
  var dirRecord = CENTRAL_FILE_HEADER + // version made by (00: DOS)
  decToHex(versionMadeBy, 2) + // file header (common to file and central directory)
  header + // file comment length
  decToHex(encodedComment.length, 2) + // disk number start
  "\0\0\0\0" + // external file attributes
  decToHex(extFileAttr, 4) + // relative offset of local header
  decToHex(offset, 4) + // file name
  encodedFileName + // extra field
  extraFields + // file comment
  encodedComment;
  return {
    fileRecord,
    dirRecord
  };
};
var generateCentralDirectoryEnd = function(entriesCount, centralDirLength, localDirLength, comment2, encodeFileName) {
  var dirEnd = "";
  var encodedComment = transformTo("string", encodeFileName(comment2));
  dirEnd = CENTRAL_DIRECTORY_END + // number of this disk
  "\0\0\0\0" + // total number of entries in the central directory on this disk
  decToHex(entriesCount, 2) + // total number of entries in the central directory
  decToHex(entriesCount, 2) + // size of the central directory   4 bytes
  decToHex(centralDirLength, 4) + // offset of start of central directory with respect to the starting disk number
  decToHex(localDirLength, 4) + // .ZIP file comment length
  decToHex(encodedComment.length, 2) + // .ZIP file comment
  encodedComment;
  return dirEnd;
};
var generateDataDescriptors = function(streamInfo) {
  var descriptor = "";
  descriptor = DATA_DESCRIPTOR + // crc-32                          4 bytes
  decToHex(streamInfo["crc32"], 4) + // compressed size                 4 bytes
  decToHex(streamInfo["compressedSize"], 4) + // uncompressed size               4 bytes
  decToHex(streamInfo["uncompressedSize"], 4);
  return descriptor;
};
var ZipFileWorker = function(GenericWorker3) {
  function ZipFileWorker2(streamFiles, comment2, platform, encodeFileName) {
    GenericWorker3.call(this, "ZipFileWorker");
    this.bytesWritten = 0;
    this.zipComment = comment2;
    this.zipPlatform = platform;
    this.encodeFileName = encodeFileName;
    this.streamFiles = streamFiles;
    this.accumulate = false;
    this.contentBuffer = [];
    this.dirRecords = [];
    this.currentSourceOffset = 0;
    this.entriesCount = 0;
    this.currentFile = null;
    this._sources = [];
  }
  ZipFileWorker2.__proto__ = GenericWorker3;
  ZipFileWorker2.prototype = Object.create(GenericWorker3.prototype);
  ZipFileWorker2.prototype.constructor = ZipFileWorker2;
  ZipFileWorker2.prototype.push = function push2(chunk) {
    var currentFilePercent = chunk.meta.percent || 0;
    var entriesCount = this.entriesCount;
    var remainingFiles = this._sources.length;
    if (this.accumulate) {
      this.contentBuffer.push(chunk);
    } else {
      this.bytesWritten += chunk.data.length;
      GenericWorker3.prototype.push.call(this, {
        data: chunk.data,
        meta: {
          currentFile: this.currentFile,
          percent: entriesCount ? (currentFilePercent + 100 * (entriesCount - remainingFiles - 1)) / entriesCount : 100
        }
      });
    }
  };
  ZipFileWorker2.prototype.openedSource = function openedSource(streamInfo) {
    this.currentSourceOffset = this.bytesWritten;
    this.currentFile = streamInfo["file"].name;
    var streamedContent = this.streamFiles && !streamInfo["file"].dir;
    if (streamedContent) {
      var record = generateZipParts(streamInfo, streamedContent, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
      this.push({
        data: record.fileRecord,
        meta: { percent: 0 }
      });
    } else {
      this.accumulate = true;
    }
  };
  ZipFileWorker2.prototype.closedSource = function closedSource(streamInfo) {
    this.accumulate = false;
    var streamedContent = this.streamFiles && !streamInfo["file"].dir;
    var record = generateZipParts(streamInfo, streamedContent, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
    this.dirRecords.push(record.dirRecord);
    if (streamedContent) {
      this.push({
        data: generateDataDescriptors(streamInfo),
        meta: { percent: 100 }
      });
    } else {
      this.push({
        data: record.fileRecord,
        meta: { percent: 0 }
      });
      while (this.contentBuffer.length) {
        this.push(this.contentBuffer.shift());
      }
    }
    this.currentFile = null;
  };
  ZipFileWorker2.prototype.flush = function flush2() {
    var localDirLength = this.bytesWritten;
    for (var i2 = 0; i2 < this.dirRecords.length; i2++) {
      this.push({
        data: this.dirRecords[i2],
        meta: { percent: 100 }
      });
    }
    var centralDirLength = this.bytesWritten - localDirLength;
    var dirEnd = generateCentralDirectoryEnd(this.dirRecords.length, centralDirLength, localDirLength, this.zipComment, this.encodeFileName);
    this.push({
      data: dirEnd,
      meta: { percent: 100 }
    });
  };
  ZipFileWorker2.prototype.prepareNextSource = function prepareNextSource() {
    this.previous = this._sources.shift();
    this.openedSource(this.previous.streamInfo);
    if (this.isPaused) {
      this.previous.pause();
    } else {
      this.previous.resume();
    }
  };
  ZipFileWorker2.prototype.registerPrevious = function registerPrevious2(previous) {
    this._sources.push(previous);
    var self = this;
    previous.on("data", function(chunk) {
      self.processChunk(chunk);
    });
    previous.on("end", function() {
      self.closedSource(self.previous.streamInfo);
      if (self._sources.length) {
        self.prepareNextSource();
      } else {
        self.end();
      }
    });
    previous.on("error", function(e6) {
      self.error(e6);
    });
    return this;
  };
  ZipFileWorker2.prototype.resume = function resume3() {
    if (!GenericWorker3.prototype.resume.call(this)) {
      return false;
    }
    if (!this.previous && this._sources.length) {
      this.prepareNextSource();
      return true;
    }
    if (!this.previous && !this._sources.length && !this.generatedError) {
      this.end();
      return true;
    }
  };
  ZipFileWorker2.prototype.error = function error2(e6) {
    var sources = this._sources;
    if (!GenericWorker3.prototype.error.call(this, e6)) {
      return false;
    }
    for (var i2 = 0; i2 < sources.length; i2++) {
      try {
        sources[i2].error(e6);
      } catch (e$1) {
      }
    }
    return true;
  };
  ZipFileWorker2.prototype.lock = function lock2() {
    GenericWorker3.prototype.lock.call(this);
    var sources = this._sources;
    for (var i2 = 0; i2 < sources.length; i2++) {
      sources[i2].lock();
    }
  };
  return ZipFileWorker2;
}(GenericWorker);
var getCompression = function(fileCompression, zipCompression) {
  var compressionName = fileCompression || zipCompression;
  var compression2 = compressions[compressionName];
  if (!compression2) {
    throw new Error(compressionName + " is not a valid compression method !");
  }
  return compression2;
};
var generateWorker = function(zip, options, comment2) {
  var zipFileWorker = new ZipFileWorker(options.streamFiles, comment2, options.platform, options.encodeFileName);
  var entriesCount = 0;
  try {
    zip.forEach(function(relativePath, file2) {
      entriesCount++;
      var compression2 = getCompression(file2.options.compression, options.compression);
      var compressionOptions2 = file2.options.compressionOptions || options.compressionOptions || {};
      var dir2 = file2.dir, date2 = file2.date;
      file2._compressWorker(compression2, compressionOptions2).withStreamInfo("file", {
        name: relativePath,
        dir: dir2,
        date: date2,
        comment: file2.comment || "",
        unixPermissions: file2.unixPermissions,
        dosPermissions: file2.dosPermissions
      }).pipe(zipFileWorker);
    });
    zipFileWorker.entriesCount = entriesCount;
  } catch (e6) {
    zipFileWorker.error(e6);
  }
  return zipFileWorker;
};
var DataReader = function DataReader2(data) {
  this.data = data;
  this.length = data.length;
  this.index = 0;
  this.zero = 0;
};
DataReader.prototype.checkOffset = function checkOffset(offset) {
  this.checkIndex(this.index + offset);
};
DataReader.prototype.checkIndex = function checkIndex(newIndex) {
  if (this.length < this.zero + newIndex || newIndex < 0) {
    throw new Error("End of data reached (data length = " + this.length + ", asked index = " + newIndex + "). Corrupted zip ?");
  }
};
DataReader.prototype.setIndex = function setIndex(newIndex) {
  this.checkIndex(newIndex);
  this.index = newIndex;
};
DataReader.prototype.skip = function skip(n3) {
  this.setIndex(this.index + n3);
};
DataReader.prototype.byteAt = function byteAt(i2) {
};
DataReader.prototype.readInt = function readInt(size) {
  var result = 0, i2;
  this.checkOffset(size);
  for (i2 = this.index + size - 1; i2 >= this.index; i2--) {
    result = (result << 8) + this.byteAt(i2);
  }
  this.index += size;
  return result;
};
DataReader.prototype.readString = function readString(size) {
  return transformTo("string", this.readData(size));
};
DataReader.prototype.readData = function readData(size) {
};
DataReader.prototype.lastIndexOfSignature = function lastIndexOfSignature(sig) {
};
DataReader.prototype.readAndCheckSignature = function readAndCheckSignature(sig) {
};
DataReader.prototype.readDate = function readDate() {
  var dostime = this.readInt(4);
  return new Date(Date.UTC(
    (dostime >> 25 & 127) + 1980,
    // year
    (dostime >> 21 & 15) - 1,
    // month
    dostime >> 16 & 31,
    // day
    dostime >> 11 & 31,
    // hour
    dostime >> 5 & 63,
    // minute
    (dostime & 31) << 1
  ));
};
var ArrayReader = function(DataReader3) {
  function ArrayReader2(data) {
    DataReader3.call(this, data);
    for (var i2 = 0; i2 < this.data.length; i2++) {
      data[i2] = data[i2] & 255;
    }
  }
  ArrayReader2.__proto__ = DataReader3;
  ArrayReader2.prototype = Object.create(DataReader3.prototype);
  ArrayReader2.prototype.constructor = ArrayReader2;
  ArrayReader2.prototype.byteAt = function byteAt2(i2) {
    return this.data[this.zero + i2];
  };
  ArrayReader2.prototype.lastIndexOfSignature = function lastIndexOfSignature2(sig) {
    var sig0 = sig.charCodeAt(0), sig1 = sig.charCodeAt(1), sig2 = sig.charCodeAt(2), sig3 = sig.charCodeAt(3);
    for (var i2 = this.length - 4; i2 >= 0; --i2) {
      if (this.data[i2] === sig0 && this.data[i2 + 1] === sig1 && this.data[i2 + 2] === sig2 && this.data[i2 + 3] === sig3) {
        return i2 - this.zero;
      }
    }
    return -1;
  };
  ArrayReader2.prototype.readAndCheckSignature = function readAndCheckSignature2(sig) {
    var sig0 = sig.charCodeAt(0), sig1 = sig.charCodeAt(1), sig2 = sig.charCodeAt(2), sig3 = sig.charCodeAt(3), data = this.readData(4);
    return sig0 === data[0] && sig1 === data[1] && sig2 === data[2] && sig3 === data[3];
  };
  ArrayReader2.prototype.readData = function readData2(size) {
    this.checkOffset(size);
    if (size === 0) {
      return [];
    }
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
  };
  return ArrayReader2;
}(DataReader);
var StringReader = function(DataReader3) {
  function StringReader2(data) {
    DataReader3.call(this, data);
  }
  StringReader2.__proto__ = DataReader3;
  StringReader2.prototype = Object.create(DataReader3.prototype);
  StringReader2.prototype.constructor = StringReader2;
  StringReader2.prototype.byteAt = function byteAt2(i2) {
    return this.data.charCodeAt(this.zero + i2);
  };
  StringReader2.prototype.lastIndexOfSignature = function lastIndexOfSignature2(sig) {
    return this.data.lastIndexOf(sig) - this.zero;
  };
  StringReader2.prototype.readAndCheckSignature = function readAndCheckSignature2(sig) {
    var data = this.readData(4);
    return sig === data;
  };
  StringReader2.prototype.readData = function readData2(size) {
    this.checkOffset(size);
    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
  };
  return StringReader2;
}(DataReader);
var Uint8ArrayReader = function(ArrayReader2) {
  function Uint8ArrayReader2(data) {
    ArrayReader2.call(this, data);
  }
  Uint8ArrayReader2.__proto__ = ArrayReader2;
  Uint8ArrayReader2.prototype = Object.create(ArrayReader2.prototype);
  Uint8ArrayReader2.prototype.constructor = Uint8ArrayReader2;
  Uint8ArrayReader2.prototype.readData = function readData2(size) {
    this.checkOffset(size);
    if (size === 0) {
      return new Uint8Array(0);
    }
    var result = this.data.subarray(this.zero + this.index, this.zero + this.index + size);
    this.index += size;
    return result;
  };
  return Uint8ArrayReader2;
}(ArrayReader);
function readerFor(data) {
  var type = getTypeOf(data);
  checkSupport(type);
  if (type === "string" && !support.uint8array) {
    return new StringReader(data);
  }
  if (support.uint8array) {
    return new Uint8ArrayReader(transformTo("uint8array", data));
  }
  return new ArrayReader(transformTo("array", data));
}
var MADE_BY_DOS = 0;
var MADE_BY_UNIX = 3;
var findCompression = function(compressionMethod) {
  for (var method in compressions) {
    if (!compressions.hasOwnProperty(method)) {
      continue;
    }
    if (compressions[method].magic === compressionMethod) {
      return compressions[method];
    }
  }
  return null;
};
var ZipEntry = function ZipEntry2(options, loadOptions) {
  this.options = options;
  this.loadOptions = loadOptions;
};
ZipEntry.prototype.isEncrypted = function isEncrypted() {
  return (this.bitFlag & 1) === 1;
};
ZipEntry.prototype.useUTF8 = function useUTF8() {
  return (this.bitFlag & 2048) === 2048;
};
ZipEntry.prototype.readLocalPart = function readLocalPart(reader) {
  var compression2, localExtraFieldsLength;
  reader.skip(22);
  this.fileNameLength = reader.readInt(2);
  localExtraFieldsLength = reader.readInt(2);
  this.fileName = reader.readData(this.fileNameLength);
  reader.skip(localExtraFieldsLength);
  if (this.compressedSize === -1 || this.uncompressedSize === -1) {
    throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
  }
  compression2 = findCompression(this.compressionMethod);
  if (compression2 === null) {
    throw new Error("Corrupted zip : compression " + pretty(this.compressionMethod) + " unknown (inner file : " + transformTo("string", this.fileName) + ")");
  }
  this.decompressed = new CompressedObject(this.compressedSize, this.uncompressedSize, this.crc32, compression2, reader.readData(this.compressedSize));
};
ZipEntry.prototype.readCentralPart = function readCentralPart(reader) {
  this.versionMadeBy = reader.readInt(2);
  reader.skip(2);
  this.bitFlag = reader.readInt(2);
  this.compressionMethod = reader.readString(2);
  this.date = reader.readDate();
  this.crc32 = reader.readInt(4);
  this.compressedSize = reader.readInt(4);
  this.uncompressedSize = reader.readInt(4);
  var fileNameLength = reader.readInt(2);
  this.extraFieldsLength = reader.readInt(2);
  this.fileCommentLength = reader.readInt(2);
  this.diskNumberStart = reader.readInt(2);
  this.internalFileAttributes = reader.readInt(2);
  this.externalFileAttributes = reader.readInt(4);
  this.localHeaderOffset = reader.readInt(4);
  if (this.isEncrypted()) {
    throw new Error("Encrypted zip are not supported");
  }
  reader.skip(fileNameLength);
  this.readExtraFields(reader);
  this.parseZIP64ExtraField(reader);
  this.fileComment = reader.readData(this.fileCommentLength);
};
ZipEntry.prototype.processAttributes = function processAttributes() {
  this.unixPermissions = null;
  this.dosPermissions = null;
  var madeBy = this.versionMadeBy >> 8;
  this.dir = this.externalFileAttributes & 16 ? true : false;
  if (madeBy === MADE_BY_DOS) {
    this.dosPermissions = this.externalFileAttributes & 63;
  }
  if (madeBy === MADE_BY_UNIX) {
    this.unixPermissions = this.externalFileAttributes >> 16 & 65535;
  }
  if (!this.dir && this.fileNameStr.slice(-1) === "/") {
    this.dir = true;
  }
};
ZipEntry.prototype.parseZIP64ExtraField = function parseZIP64ExtraField(reader) {
  if (!this.extraFields[1]) {
    return;
  }
  var extraReader = readerFor(this.extraFields[1].value);
  if (this.uncompressedSize === MAX_VALUE_32BITS) {
    this.uncompressedSize = extraReader.readInt(8);
  }
  if (this.compressedSize === MAX_VALUE_32BITS) {
    this.compressedSize = extraReader.readInt(8);
  }
  if (this.localHeaderOffset === MAX_VALUE_32BITS) {
    this.localHeaderOffset = extraReader.readInt(8);
  }
  if (this.diskNumberStart === MAX_VALUE_32BITS) {
    this.diskNumberStart = extraReader.readInt(4);
  }
};
ZipEntry.prototype.readExtraFields = function readExtraFields(reader) {
  var end2 = reader.index + this.extraFieldsLength, extraFieldId, extraFieldLength, extraFieldValue;
  if (!this.extraFields) {
    this.extraFields = {};
  }
  while (reader.index < end2) {
    extraFieldId = reader.readInt(2);
    extraFieldLength = reader.readInt(2);
    extraFieldValue = reader.readData(extraFieldLength);
    this.extraFields[extraFieldId] = {
      id: extraFieldId,
      length: extraFieldLength,
      value: extraFieldValue
    };
  }
};
ZipEntry.prototype.handleUTF8 = function handleUTF8() {
  var decodeParamType = support.uint8array ? "uint8array" : "array";
  if (this.useUTF8()) {
    this.fileNameStr = utf8decode(this.fileName);
    this.fileCommentStr = utf8decode(this.fileComment);
  } else {
    var upath = this.findExtraFieldUnicodePath();
    if (upath !== null) {
      this.fileNameStr = upath;
    } else {
      var fileNameByteArray = transformTo(decodeParamType, this.fileName);
      this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);
    }
    var ucomment = this.findExtraFieldUnicodeComment();
    if (ucomment !== null) {
      this.fileCommentStr = ucomment;
    } else {
      var commentByteArray = transformTo(decodeParamType, this.fileComment);
      this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);
    }
  }
};
ZipEntry.prototype.findExtraFieldUnicodePath = function findExtraFieldUnicodePath() {
  var upathField = this.extraFields[28789];
  if (upathField) {
    var extraReader = readerFor(upathField.value);
    if (extraReader.readInt(1) !== 1) {
      return null;
    }
    if (crc32wrapper(this.fileName) !== extraReader.readInt(4)) {
      return null;
    }
    return utf8decode(extraReader.readData(upathField.length - 5));
  }
  return null;
};
ZipEntry.prototype.findExtraFieldUnicodeComment = function findExtraFieldUnicodeComment() {
  var ucommentField = this.extraFields[25461];
  if (ucommentField) {
    var extraReader = readerFor(ucommentField.value);
    if (extraReader.readInt(1) !== 1) {
      return null;
    }
    if (crc32wrapper(this.fileComment) !== extraReader.readInt(4)) {
      return null;
    }
    return utf8decode(extraReader.readData(ucommentField.length - 5));
  }
  return null;
};
var ZipEntries = function ZipEntries2(loadOptions) {
  this.files = [];
  this.loadOptions = loadOptions;
};
ZipEntries.prototype.checkSignature = function checkSignature(expectedSignature) {
  if (!this.reader.readAndCheckSignature(expectedSignature)) {
    this.reader.index -= 4;
    var signature = this.reader.readString(4);
    throw new Error("Corrupted zip or bug: unexpected signature (" + pretty(signature) + ", expected " + pretty(expectedSignature) + ")");
  }
};
ZipEntries.prototype.isSignature = function isSignature(askedIndex, expectedSignature) {
  var currentIndex = this.reader.index;
  this.reader.setIndex(askedIndex);
  var signature = this.reader.readString(4);
  var result = signature === expectedSignature;
  this.reader.setIndex(currentIndex);
  return result;
};
ZipEntries.prototype.readBlockEndOfCentral = function readBlockEndOfCentral() {
  this.diskNumber = this.reader.readInt(2);
  this.diskWithCentralDirStart = this.reader.readInt(2);
  this.centralDirRecordsOnThisDisk = this.reader.readInt(2);
  this.centralDirRecords = this.reader.readInt(2);
  this.centralDirSize = this.reader.readInt(4);
  this.centralDirOffset = this.reader.readInt(4);
  this.zipCommentLength = this.reader.readInt(2);
  var zipComment = this.reader.readData(this.zipCommentLength);
  var decodeParamType = support.uint8array ? "uint8array" : "array";
  var decodeContent = transformTo(decodeParamType, zipComment);
  this.zipComment = this.loadOptions.decodeFileName(decodeContent);
};
ZipEntries.prototype.readBlockZip64EndOfCentral = function readBlockZip64EndOfCentral() {
  this.zip64EndOfCentralSize = this.reader.readInt(8);
  this.reader.skip(4);
  this.diskNumber = this.reader.readInt(4);
  this.diskWithCentralDirStart = this.reader.readInt(4);
  this.centralDirRecordsOnThisDisk = this.reader.readInt(8);
  this.centralDirRecords = this.reader.readInt(8);
  this.centralDirSize = this.reader.readInt(8);
  this.centralDirOffset = this.reader.readInt(8);
  this.zip64ExtensibleData = {};
  var extraDataSize = this.zip64EndOfCentralSize - 44, index = 0, extraFieldId, extraFieldLength, extraFieldValue;
  while (index < extraDataSize) {
    extraFieldId = this.reader.readInt(2);
    extraFieldLength = this.reader.readInt(4);
    extraFieldValue = this.reader.readData(extraFieldLength);
    this.zip64ExtensibleData[extraFieldId] = {
      id: extraFieldId,
      length: extraFieldLength,
      value: extraFieldValue
    };
  }
};
ZipEntries.prototype.readBlockZip64EndOfCentralLocator = function readBlockZip64EndOfCentralLocator() {
  this.diskWithZip64CentralDirStart = this.reader.readInt(4);
  this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);
  this.disksCount = this.reader.readInt(4);
  if (this.disksCount > 1) {
    throw new Error("Multi-volumes zip are not supported");
  }
};
ZipEntries.prototype.readLocalFiles = function readLocalFiles() {
  var i2, file2;
  for (i2 = 0; i2 < this.files.length; i2++) {
    file2 = this.files[i2];
    this.reader.setIndex(file2.localHeaderOffset);
    this.checkSignature(LOCAL_FILE_HEADER);
    file2.readLocalPart(this.reader);
    file2.handleUTF8();
    file2.processAttributes();
  }
};
ZipEntries.prototype.readCentralDir = function readCentralDir() {
  var file2;
  this.reader.setIndex(this.centralDirOffset);
  while (this.reader.readAndCheckSignature(CENTRAL_FILE_HEADER)) {
    file2 = new ZipEntry({
      zip64: this.zip64
    }, this.loadOptions);
    file2.readCentralPart(this.reader);
    this.files.push(file2);
  }
  if (this.centralDirRecords !== this.files.length) {
    if (this.centralDirRecords !== 0 && this.files.length === 0) {
      throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
    }
  }
};
ZipEntries.prototype.readEndOfCentral = function readEndOfCentral() {
  var offset = this.reader.lastIndexOfSignature(CENTRAL_DIRECTORY_END);
  if (offset < 0) {
    var isGarbage = !this.isSignature(0, LOCAL_FILE_HEADER);
    if (isGarbage) {
      throw new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
    } else {
      throw new Error("Corrupted zip: can't find end of central directory");
    }
  }
  this.reader.setIndex(offset);
  var endOfCentralDirOffset = offset;
  this.checkSignature(CENTRAL_DIRECTORY_END);
  this.readBlockEndOfCentral();
  if (this.diskNumber === MAX_VALUE_16BITS || this.diskWithCentralDirStart === MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === MAX_VALUE_16BITS || this.centralDirRecords === MAX_VALUE_16BITS || this.centralDirSize === MAX_VALUE_32BITS || this.centralDirOffset === MAX_VALUE_32BITS) {
    this.zip64 = true;
    offset = this.reader.lastIndexOfSignature(ZIP64_CENTRAL_DIRECTORY_LOCATOR);
    if (offset < 0) {
      throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
    }
    this.reader.setIndex(offset);
    this.checkSignature(ZIP64_CENTRAL_DIRECTORY_LOCATOR);
    this.readBlockZip64EndOfCentralLocator();
    if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, ZIP64_CENTRAL_DIRECTORY_END)) {
      this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(ZIP64_CENTRAL_DIRECTORY_END);
      if (this.relativeOffsetEndOfZip64CentralDir < 0) {
        throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
      }
    }
    this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);
    this.checkSignature(ZIP64_CENTRAL_DIRECTORY_END);
    this.readBlockZip64EndOfCentral();
  }
  var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;
  if (this.zip64) {
    expectedEndOfCentralDirOffset += 20;
    expectedEndOfCentralDirOffset += 12 + this.zip64EndOfCentralSize;
  }
  var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;
  if (extraBytes > 0) {
    if (this.isSignature(endOfCentralDirOffset, CENTRAL_FILE_HEADER)) ;
    else {
      this.reader.zero = extraBytes;
    }
  } else if (extraBytes < 0) {
    throw new Error("Corrupted zip: missing " + Math.abs(extraBytes) + " bytes.");
  }
};
ZipEntries.prototype.prepareReader = function prepareReader(data) {
  this.reader = readerFor(data);
};
ZipEntries.prototype.load = function load(data) {
  this.prepareReader(data);
  this.readEndOfCentral();
  this.readCentralDir();
  this.readLocalFiles();
};
function checkEntryCRC32(zipEntry) {
  return new external.Promise(function(resolve2, reject) {
    var worker = zipEntry.decompressed.getContentWorker().pipe(new Crc32Probe());
    worker.on("error", function(e6) {
      reject(e6);
    }).on("end", function() {
      if (worker.streamInfo.crc32 !== zipEntry.decompressed.crc32) {
        reject(new Error("Corrupted zip : CRC32 mismatch"));
      } else {
        resolve2();
      }
    }).resume();
  });
}
function load2(data, options) {
  var zip = this;
  options = extend(options || {}, {
    base64: false,
    checkCRC32: false,
    optimizedBinaryString: false,
    createFolders: false,
    decodeFileName: utf8decode
  });
  return prepareContent("the loaded zip file", data, true, options.optimizedBinaryString, options.base64).then(function(data2) {
    var zipEntries = new ZipEntries(options);
    zipEntries.load(data2);
    return zipEntries;
  }).then(function checkCRC32(zipEntries) {
    var promises = [external.Promise.resolve(zipEntries)];
    var files = zipEntries.files;
    if (options.checkCRC32) {
      for (var i2 = 0; i2 < files.length; i2++) {
        promises.push(checkEntryCRC32(files[i2]));
      }
    }
    return external.Promise.all(promises);
  }).then(function addFiles(results) {
    var zipEntries = results.shift();
    var files = zipEntries.files;
    for (var i2 = 0; i2 < files.length; i2++) {
      var input = files[i2];
      var unsafeName = input.fileNameStr;
      var safeName = resolve(input.fileNameStr);
      zip.file(safeName, input.decompressed, {
        binary: true,
        optimizedBinaryString: true,
        date: input.date,
        dir: input.dir,
        comment: input.fileCommentStr.length ? input.fileCommentStr : null,
        unixPermissions: input.unixPermissions,
        dosPermissions: input.dosPermissions,
        createFolders: options.createFolders
      });
      if (!input.dir) {
        zip.file(safeName).unsafeOriginalName = unsafeName;
      }
    }
    if (zipEntries.zipComment.length) {
      zip.comment = zipEntries.zipComment;
    }
    return zip;
  });
}
var fileAdd = function(name, data, originalOptions) {
  var dataType = getTypeOf(data), parent;
  var o4 = extend(originalOptions || {}, defaults);
  o4.date = o4.date || /* @__PURE__ */ new Date();
  if (o4.compression !== null) {
    o4.compression = o4.compression.toUpperCase();
  }
  if (typeof o4.unixPermissions === "string") {
    o4.unixPermissions = parseInt(o4.unixPermissions, 8);
  }
  if (o4.unixPermissions && o4.unixPermissions & 16384) {
    o4.dir = true;
  }
  if (o4.dosPermissions && o4.dosPermissions & 16) {
    o4.dir = true;
  }
  if (o4.dir) {
    name = forceTrailingSlash(name);
  }
  if (o4.createFolders && (parent = parentFolder(name))) {
    folderAdd.call(this, parent, true);
  }
  var isUnicodeString = dataType === "string" && o4.binary === false && o4.base64 === false;
  if (!originalOptions || typeof originalOptions.binary === "undefined") {
    o4.binary = !isUnicodeString;
  }
  var isCompressedEmpty = data instanceof CompressedObject && data.uncompressedSize === 0;
  if (isCompressedEmpty || o4.dir || !data || data.length === 0) {
    o4.base64 = false;
    o4.binary = true;
    data = "";
    o4.compression = "STORE";
    dataType = "string";
  }
  var zipObjectContent = null;
  if (data instanceof CompressedObject || data instanceof GenericWorker) {
    zipObjectContent = data;
  } else {
    zipObjectContent = prepareContent(name, data, o4.binary, o4.optimizedBinaryString, o4.base64);
  }
  var object = new ZipObject(name, zipObjectContent, o4);
  this.files[name] = object;
};
var parentFolder = function(path) {
  if (path.slice(-1) === "/") {
    path = path.substring(0, path.length - 1);
  }
  var lastSlash = path.lastIndexOf("/");
  return lastSlash > 0 ? path.substring(0, lastSlash) : "";
};
var forceTrailingSlash = function(path) {
  if (path.slice(-1) !== "/") {
    path += "/";
  }
  return path;
};
var folderAdd = function(name, createFolders$1) {
  createFolders$1 = typeof createFolders$1 !== "undefined" ? createFolders$1 : createFolders;
  name = forceTrailingSlash(name);
  if (!this.files[name]) {
    fileAdd.call(this, name, null, {
      dir: true,
      createFolders: createFolders$1
    });
  }
  return this.files[name];
};
function isRegExp(object) {
  return Object.prototype.toString.call(object) === "[object RegExp]";
}
var JSZip = function JSZip2() {
  if (arguments.length) {
    throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
  }
  this.files = /* @__PURE__ */ Object.create(null);
  this.comment = null;
  this.root = "";
  this.clone = function() {
    var newObj = new JSZip2();
    for (var i2 in this) {
      if (typeof this[i2] !== "function") {
        newObj[i2] = this[i2];
      }
    }
    return newObj;
  };
};
var staticAccessors = { support: { configurable: true }, defaults: { configurable: true }, version: { configurable: true }, external: { configurable: true } };
JSZip.prototype.load = function load3() {
  throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
};
JSZip.prototype.forEach = function forEach(cb) {
  var filename, relativePath, file2;
  for (filename in this.files) {
    file2 = this.files[filename];
    relativePath = filename.slice(this.root.length, filename.length);
    if (relativePath && filename.slice(0, this.root.length) === this.root) {
      cb(relativePath, file2);
    }
  }
};
JSZip.prototype.filter = function filter(search) {
  var result = [];
  this.forEach(function(relativePath, entry) {
    if (search(relativePath, entry)) {
      result.push(entry);
    }
  });
  return result;
};
JSZip.prototype.file = function file(name, data, o4) {
  if (arguments.length === 1) {
    if (isRegExp(name)) {
      var regexp = name;
      return this.filter(function(relativePath, file2) {
        return !file2.dir && regexp.test(relativePath);
      });
    } else {
      var obj = this.files[this.root + name];
      if (obj && !obj.dir) {
        return obj;
      } else {
        return null;
      }
    }
  } else {
    name = this.root + name;
    fileAdd.call(this, name, data, o4);
  }
  return this;
};
JSZip.prototype.folder = function folder(arg) {
  if (!arg) {
    return this;
  }
  if (isRegExp(arg)) {
    return this.filter(function(relativePath, file2) {
      return file2.dir && arg.test(relativePath);
    });
  }
  var name = this.root + arg;
  var newFolder = folderAdd.call(this, name);
  var ret = this.clone();
  ret.root = newFolder.name;
  return ret;
};
JSZip.prototype.remove = function remove(name) {
  name = this.root + name;
  var file2 = this.files[name];
  if (!file2) {
    if (name.slice(-1) !== "/") {
      name += "/";
    }
    file2 = this.files[name];
  }
  if (file2 && !file2.dir) {
    delete this.files[name];
  } else {
    var kids = this.filter(function(relativePath, file3) {
      return file3.name.slice(0, name.length) === name;
    });
    for (var i2 = 0; i2 < kids.length; i2++) {
      delete this.files[kids[i2].name];
    }
  }
  return this;
};
JSZip.prototype.generate = function generate(options) {
  throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
};
JSZip.prototype.generateInternalStream = function generateInternalStream(options) {
  var worker, opts = {};
  try {
    opts = extend(options || {}, {
      streamFiles: false,
      compression: "STORE",
      compressionOptions: null,
      type: "",
      platform: "DOS",
      comment: null,
      mimeType: "application/zip",
      encodeFileName: utf8encode
    });
    opts.type = opts.type.toLowerCase();
    opts.compression = opts.compression.toUpperCase();
    if (opts.type === "binarystring") {
      opts.type = "string";
    }
    if (!opts.type) {
      throw new Error("No output type specified.");
    }
    checkSupport(opts.type);
    if (opts.platform === "darwin" || opts.platform === "freebsd" || opts.platform === "linux" || opts.platform === "sunos") {
      opts.platform = "UNIX";
    }
    if (opts.platform === "win32") {
      opts.platform = "DOS";
    }
    var comment2 = opts.comment || this.comment || "";
    worker = generateWorker(this, opts, comment2);
  } catch (e6) {
    worker = new GenericWorker("error");
    worker.error(e6);
  }
  return new StreamHelper(worker, opts.type || "string", opts.mimeType);
};
JSZip.prototype.generateAsync = function generateAsync(options, onUpdate) {
  return this.generateInternalStream(options).accumulate(onUpdate);
};
JSZip.prototype.loadAsync = function loadAsync(data, options) {
  return load2.apply(this, [data, options]);
};
JSZip.loadAsync = function loadAsync2(content, options) {
  return new JSZip().loadAsync(content, options);
};
staticAccessors.support.get = function() {
  return support;
};
staticAccessors.defaults.get = function() {
  return defaults;
};
staticAccessors.version.get = function() {
  return "3.2.2-esm";
};
staticAccessors.external.get = function() {
  return external;
};
Object.defineProperties(JSZip, staticAccessors);

// node_modules/@progress/kendo-ooxml/dist/es/utils/create-zip.js
function createZip() {
  return new JSZip();
}

// node_modules/@progress/kendo-ooxml/dist/es/utils/time.js
function dateToJulianDays(y, m, d4) {
  return (1461 * (y + 4800 + ((m - 13) / 12 | 0)) / 4 | 0) + (367 * (m - 1 - 12 * ((m - 13) / 12 | 0)) / 12 | 0) - (3 * ((y + 4900 + ((m - 13) / 12 | 0)) / 100 | 0) / 4 | 0) + d4 - 32075;
}
var BASE_DATE = dateToJulianDays(1900, 0, -1);
function packDate(year, month, date2) {
  return dateToJulianDays(year, month, date2) - BASE_DATE;
}
function packTime(hh, mm, ss, ms) {
  return (hh + (mm + (ss + ms / 1e3) / 60) / 60) / 24;
}
function dateToSerial(date2) {
  const time = packTime(
    date2.getHours(),
    date2.getMinutes(),
    date2.getSeconds(),
    date2.getMilliseconds()
  );
  const serial = packDate(
    date2.getFullYear(),
    date2.getMonth(),
    date2.getDate()
  );
  return serial < 0 ? serial - 1 + time : serial + time;
}

// node_modules/@progress/kendo-ooxml/dist/es/ooxml.js
var MIME_TYPE = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
var DATA_URL_PREFIX = `data:${MIME_TYPE};base64,`;
var DATA_URL_OPTIONS = { compression: "DEFLATE", type: "base64" };
var BLOB_OPTIONS = { compression: "DEFLATE", type: "blob" };
var ARRAYBUFFER_OPTIONS = { compression: "DEFLATE", type: "arraybuffer" };
function toDataURI(content) {
  return DATA_URL_PREFIX + content;
}
function indexOf(thing, array) {
  return array.indexOf(thing);
}
var parseJSON = JSON.parse.bind(JSON);
function ESC(val) {
  return String(val).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\"/g, "&quot;").replace(/\'/g, "&#39;");
}
function repeat(count, func) {
  let str = "";
  for (let i2 = 0; i2 < count; ++i2) {
    str += func(i2);
  }
  return str;
}
function foreach(arr, func) {
  let str = "";
  if (arr != null) {
    if (Array.isArray(arr)) {
      for (let i2 = 0; i2 < arr.length; ++i2) {
        str += func(arr[i2], i2);
      }
    } else if (typeof arr == "object") {
      Object.keys(arr).forEach((key, i2) => {
        str += func(arr[key], key, i2);
      });
    }
  }
  return str;
}
var XMLHEAD = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\r';
var RELS = `${XMLHEAD}
            <Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
               <Relationship Id="rId3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties" Target="docProps/app.xml"/>
               <Relationship Id="rId2" Type="http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties" Target="docProps/core.xml"/>
               <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="xl/workbook.xml"/>
            </Relationships>`;
var CORE = ({ creator, lastModifiedBy, created, modified }) => `${XMLHEAD}
 <cp:coreProperties xmlns:cp="http://schemas.openxmlformats.org/package/2006/metadata/core-properties"
   xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/"
   xmlns:dcmitype="http://purl.org/dc/dcmitype/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
   <dc:creator>${ESC(creator)}</dc:creator>
   <cp:lastModifiedBy>${ESC(lastModifiedBy)}</cp:lastModifiedBy>
   <dcterms:created xsi:type="dcterms:W3CDTF">${ESC(created)}</dcterms:created>
   <dcterms:modified xsi:type="dcterms:W3CDTF">${ESC(modified)}</dcterms:modified>
</cp:coreProperties>`;
var APP = ({ sheets }) => `${XMLHEAD}
<Properties xmlns="http://schemas.openxmlformats.org/officeDocument/2006/extended-properties" xmlns:vt="http://schemas.openxmlformats.org/officeDocument/2006/docPropsVTypes">
  <Application>Microsoft Excel</Application>
  <DocSecurity>0</DocSecurity>
  <ScaleCrop>false</ScaleCrop>
  <HeadingPairs>
    <vt:vector size="2" baseType="variant">
      <vt:variant>
        <vt:lpstr>Worksheets</vt:lpstr>
      </vt:variant>
      <vt:variant>
        <vt:i4>${sheets.length}</vt:i4>
      </vt:variant>
    </vt:vector>
  </HeadingPairs>
  <TitlesOfParts>
    <vt:vector size="${sheets.length}" baseType="lpstr">${foreach(
  sheets,
  (sheet, i2) => sheet.options.title ? `<vt:lpstr>${ESC(sheet.options.title)}</vt:lpstr>` : `<vt:lpstr>Sheet${i2 + 1}</vt:lpstr>`
)}</vt:vector>
  </TitlesOfParts>
  <LinksUpToDate>false</LinksUpToDate>
  <SharedDoc>false</SharedDoc>
  <HyperlinksChanged>false</HyperlinksChanged>
  <AppVersion>14.0300</AppVersion>
</Properties>`;
var CONTENT_TYPES = ({ sheetCount, commentFiles, drawingFiles }) => `${XMLHEAD}
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
  <Default Extension="png" ContentType="image/png"/>
  <Default Extension="gif" ContentType="image/gif"/>
  <Default Extension="jpg" ContentType="image/jpeg"/>
  <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml" />
  <Default Extension="xml" ContentType="application/xml" />
  <Default Extension="vml" ContentType="application/vnd.openxmlformats-officedocument.vmlDrawing"/>
  <Override PartName="/xl/workbook.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml" />
  <Override PartName="/xl/styles.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml"/>
  <Override PartName="/xl/sharedStrings.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml"/>
  ${repeat(sheetCount, (idx) => `<Override PartName="/xl/worksheets/sheet${idx + 1}.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml" />`)}
  ${foreach(commentFiles, (filename) => `<Override PartName="/xl/${filename}" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml"/>`)}
  ${foreach(drawingFiles, (filename) => `<Override PartName="/xl/drawings/${filename}" ContentType="application/vnd.openxmlformats-officedocument.drawing+xml"/>`)}
  <Override PartName="/docProps/core.xml" ContentType="application/vnd.openxmlformats-package.core-properties+xml" />
  <Override PartName="/docProps/app.xml" ContentType="application/vnd.openxmlformats-officedocument.extended-properties+xml" />
</Types>`;
var WORKBOOK = ({ sheets, filterNames, userNames }) => `${XMLHEAD}
<workbook xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">
  <fileVersion appName="xl" lastEdited="5" lowestEdited="5" rupBuild="9303" />
  <workbookPr defaultThemeVersion="124226" />
  <bookViews>
    <workbookView xWindow="240" yWindow="45" windowWidth="18195" windowHeight="7995" />
  </bookViews>
  <sheets>
  ${foreach(sheets, ({ options }, i2) => {
  const name = options.name || options.title || `Sheet${i2 + 1}`;
  const state = options.state || "visible";
  return `<sheet name="${ESC(name)}" state="${state}" sheetId="${i2 + 1}" r:id="rId${i2 + 1}" />`;
})}
  </sheets>
  ${filterNames.length || userNames.length ? `
    <definedNames>
      ${foreach(filterNames, (f2) => `
         <definedName name="_xlnm._FilterDatabase" hidden="1" localSheetId="${f2.localSheetId}">${ESC(quoteSheet(f2.name))}!${ESC(f2.from)}:${ESC(f2.to)}</definedName>`)}
      ${foreach(userNames, (f2) => `
         <definedName name="${f2.name}" hidden="${f2.hidden ? 1 : 0}" ${f2.localSheetId != null ? `localSheetId="${f2.localSheetId}"` : ""}>${ESC(f2.value)}</definedName>`)}
    </definedNames>` : ""}
  <calcPr fullCalcOnLoad="1" calcId="145621" />
</workbook>`;
var WORKSHEET = ({
  frozenColumns,
  frozenRows,
  columns,
  defaults: defaults2,
  data,
  index,
  mergeCells,
  autoFilter,
  filter: filter2,
  showGridLines,
  hyperlinks,
  validations,
  defaultCellStyleId,
  rtl,
  legacyDrawing,
  drawing,
  lastRow,
  lastCol,
  hasDisabledCells
}) => `${XMLHEAD}
<worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships" xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac" mc:Ignorable="x14ac">
   ${lastRow && lastCol ? `<dimension ref="A1:${ref(lastRow - 1, lastCol - 1)}" />` : ""}

   <sheetViews>
     <sheetView ${rtl ? 'rightToLeft="1"' : ""} ${index === 0 ? 'tabSelected="1"' : ""} workbookViewId="0" ${showGridLines === false ? 'showGridLines="0"' : ""}>
     ${frozenRows || frozenColumns ? `
       <pane state="frozen"
         ${frozenColumns ? `xSplit="${frozenColumns}"` : ""}
         ${frozenRows ? `ySplit="${frozenRows}"` : ""}
         topLeftCell="${String.fromCharCode(65 + (frozenColumns || 0)) + ((frozenRows || 0) + 1)}"
       />` : ""}
     </sheetView>
   </sheetViews>

   <sheetFormatPr x14ac:dyDescent="0.25" ${!defaults2.skipCustomHeight ? 'customHeight="1"' : ""} defaultRowHeight="${defaults2.rowHeight ? defaults2.rowHeight * 0.75 : 15}"
     ${defaults2.columnWidth ? `defaultColWidth="${toWidth(defaults2.columnWidth)}"` : ""} />

   ${defaultCellStyleId != null || columns && columns.length > 0 ? `
     <cols>
       ${!columns || !columns.length ? `
         <col min="1" max="16384" style="${defaultCellStyleId}"
              ${defaults2.columnWidth ? `width="${toWidth(defaults2.columnWidth)}"` : ""} /> ` : ""}
       ${foreach(columns, (column, ci) => {
  const columnIndex = typeof column.index === "number" ? column.index + 1 : ci + 1;
  if (column.width === 0) {
    return `<col ${defaultCellStyleId != null ? `style="${defaultCellStyleId}"` : ""}
                        min="${columnIndex}" max="${columnIndex}" hidden="1" customWidth="1" />`;
  }
  return `<col ${defaultCellStyleId != null ? `style="${defaultCellStyleId}"` : ""}
                      min="${columnIndex}" max="${columnIndex}" customWidth="1"
                      ${column.autoWidth ? `width="${(column.width * 7 + 5) / 7 * 256 / 256}" bestFit="1"` : `width="${toWidth(column.width)}"`} />`;
})}
     </cols>` : ""}

   <sheetData>
     ${foreach(data, (row, ri) => {
  const rowIndex = typeof row.index === "number" ? row.index + 1 : ri + 1;
  return `
         <row r="${rowIndex}" x14ac:dyDescent="0.25"
              ${row.level ? `outlineLevel="${row.level}"` : ""}
              ${row.height === 0 ? 'hidden="1"' : row.height ? `ht="${toHeight(row.height)}" customHeight="1"` : ""}>
           ${foreach(row.data, (cell) => `
             <c r="${cell.ref}" ${cell.style ? `s="${cell.style}"` : ""} ${cell.type ? `t="${cell.type}"` : ""}>
               ${cell.formula != null ? writeFormula(cell.formula) : ""}
               ${cell.value != null ? `<v>${ESC(cell.value)}</v>` : ""}
             </c>`)}
         </row>
       `;
})}
   </sheetData>

   ${hasDisabledCells ? `<sheetProtection sheet="1" objects="1" scenarios="1"/>` : ""}

   ${autoFilter ? `<autoFilter ref="${autoFilter.from}:${autoFilter.to}"/>` : filter2 ? spreadsheetFilters(filter2) : ""}

   ${mergeCells.length ? `
     <mergeCells count="${mergeCells.length}">
       ${foreach(mergeCells, (ref2) => `<mergeCell ref="${ref2}"/>`)}
     </mergeCells>` : ""}

   ${validations.length ? `
     <dataValidations>
       ${foreach(validations, (val) => `
         <dataValidation sqref="${val.sqref.join(" ")}"
                         showErrorMessage="${val.showErrorMessage}"
                         type="${ESC(val.type)}"
                         ${val.type !== "list" ? `operator="${ESC(val.operator)}"` : ""}
                         allowBlank="${val.allowBlank}"
                         showDropDown="${val.showDropDown}"
                         ${val.error ? `error="${ESC(val.error)}"` : ""}
                         ${val.errorTitle ? `errorTitle="${ESC(val.errorTitle)}"` : ""}>
           ${val.formula1 ? `<formula1>${ESC(val.formula1)}</formula1>` : ""}
           ${val.formula2 ? `<formula2>${ESC(val.formula2)}</formula2>` : ""}
         </dataValidation>`)}
     </dataValidations>` : ""}

   ${hyperlinks.length ? `
     <hyperlinks>
       ${foreach(hyperlinks, (link) => `
         <hyperlink ref="${link.ref}" r:id="${link.rId}"/>`)}
     </hyperlinks>` : ""}

   <pageMargins left="0.7" right="0.7" top="0.75" bottom="0.75" header="0.3" footer="0.3" />
   ${drawing ? `<drawing r:id="${drawing}"/>` : ""}
   ${legacyDrawing ? `<legacyDrawing r:id="${legacyDrawing}"/>` : ""}
</worksheet>`;
var WORKBOOK_RELS = ({ count }) => `${XMLHEAD}
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  ${repeat(count, (idx) => `
    <Relationship Id="rId${idx + 1}" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet" Target="worksheets/sheet${idx + 1}.xml" />`)}
  <Relationship Id="rId${count + 1}" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles" Target="styles.xml" />
  <Relationship Id="rId${count + 2}" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings" Target="sharedStrings.xml" />
</Relationships>`;
var WORKSHEET_RELS = ({ hyperlinks, comments, sheetIndex, drawings }) => `${XMLHEAD}
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  ${foreach(hyperlinks, (link) => `
    <Relationship Id="${link.rId}" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink" Target="${ESC(link.target)}" TargetMode="External" />`)}
  ${!comments.length ? "" : `
    <Relationship Id="comment${sheetIndex}" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/comments" Target="../comments${sheetIndex}.xml"/>
    <Relationship Id="vml${sheetIndex}" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/vmlDrawing" Target="../drawings/vmlDrawing${sheetIndex}.vml"/>`}
  ${!drawings.length ? "" : `
    <Relationship Id="drw${sheetIndex}" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/drawing" Target="../drawings/drawing${sheetIndex}.xml"/>`}
</Relationships>`;
var COMMENTS_XML = ({ comments }) => `${XMLHEAD}
<comments xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main">
  <authors>
    <author></author>
  </authors>
  <commentList>
    ${foreach(comments, (comment2) => `
      <comment ref="${comment2.ref}" authorId="0">
        <text>
          <r>
            <rPr>
              <sz val="8"/>
              <color indexed="81"/>
              <rFont val="Tahoma"/>
              <charset val="1"/>
            </rPr>
            <t>${ESC(comment2.text)}</t>
          </r>
        </text>
      </comment>`)}
  </commentList>
</comments>`;
var LEGACY_DRAWING = ({ comments }) => `<xml xmlns:v="urn:schemas-microsoft-com:vml"
     xmlns:o="urn:schemas-microsoft-com:office:office"
     xmlns:x="urn:schemas-microsoft-com:office:excel">
  <v:shapetype coordsize="21600,21600" id="_x0000_t202" path="m,l,21600r21600,l21600,xe">
    <v:stroke joinstyle="miter"/>
    <v:path gradientshapeok="t" o:connecttype="rect"/>
  </v:shapetype>
  ${foreach(comments, (comment2) => `
    <v:shape type="#_x0000_t202" style="visibility: hidden" fillcolor="#ffffe1" o:insetmode="auto">
      <v:shadow on="t" color="black" obscured="t"/>
      <x:ClientData ObjectType="Note">
        <x:MoveWithCells/>
        <x:SizeWithCells/>
        <x:Anchor>${comment2.anchor}</x:Anchor>
        <x:AutoFill>False</x:AutoFill>
        <x:Row>${comment2.row}</x:Row>
        <x:Column>${comment2.col}</x:Column>
      </x:ClientData>
    </v:shape>`)}
</xml>`;
var DRAWINGS_XML = (drawings) => `${XMLHEAD}
<xdr:wsDr xmlns:xdr="http://schemas.openxmlformats.org/drawingml/2006/spreadsheetDrawing"
          xmlns:a="http://schemas.openxmlformats.org/drawingml/2006/main"
          xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">
  ${foreach(drawings, (drawing, index) => `
    <xdr:oneCellAnchor editAs="oneCell">
      <xdr:from>
        <xdr:col>${drawing.col}</xdr:col>
        <xdr:colOff>${drawing.colOffset}</xdr:colOff>
        <xdr:row>${drawing.row}</xdr:row>
        <xdr:rowOff>${drawing.rowOffset}</xdr:rowOff>
      </xdr:from>
      <xdr:ext cx="${drawing.width}" cy="${drawing.height}" />
      <xdr:pic>
        <xdr:nvPicPr>
          <xdr:cNvPr id="${index + 1}" name="Picture ${index + 1}"/>
          <xdr:cNvPicPr/>
        </xdr:nvPicPr>
        <xdr:blipFill>
          <a:blip r:embed="${drawing.imageId}"/>
          <a:stretch>
            <a:fillRect/>
          </a:stretch>
        </xdr:blipFill>
        <xdr:spPr>
          <a:prstGeom prst="rect">
            <a:avLst/>
          </a:prstGeom>
        </xdr:spPr>
      </xdr:pic>
      <xdr:clientData/>
    </xdr:oneCellAnchor>`)}
</xdr:wsDr>`;
var DRAWINGS_RELS_XML = (rels) => `${XMLHEAD}
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
  ${foreach(rels, (rel) => `
    <Relationship Id="${rel.rId}" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/image" Target="${rel.target}"/>`)}
</Relationships>`;
var SHARED_STRINGS = ({ count, uniqueCount, indexes }) => `${XMLHEAD}
<sst xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" count="${count}" uniqueCount="${uniqueCount}">
  ${foreach(Object.keys(indexes), (index) => `
    <si><t xml:space="preserve">${ESC(index.substring(1))}</t></si>`)}
</sst>`;
var STYLES = ({
  formats,
  fonts,
  fills,
  borders,
  styles
}) => `${XMLHEAD}
<styleSheet
    xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    mc:Ignorable="x14ac"
    xmlns:x14ac="http://schemas.microsoft.com/office/spreadsheetml/2009/9/ac">
  <numFmts count="${formats.length}">
  ${foreach(formats, (format, fi) => `
    <numFmt formatCode="${ESC(format.format)}" numFmtId="${165 + fi}" />`)}
  </numFmts>
  <fonts count="${fonts.length + 1}" x14ac:knownFonts="1">
    <font>
       <sz val="11" />
       <color theme="1" />
       <name val="Calibri" />
       <family val="2" />
       <scheme val="minor" />
    </font>
    ${foreach(fonts, (font) => `
    <font>
      ${font.bold ? "<b/>" : ""}
      ${font.italic ? "<i/>" : ""}
      ${font.underline ? "<u/>" : ""}
      <sz val="${font.fontSize || 11}" />
      ${font.color ? `<color rgb="${ESC(font.color)}" />` : '<color theme="1" />'}
      ${font.fontFamily ? `
        <name val="${ESC(font.fontFamily)}" />
        <family val="2" />
      ` : `
        <name val="Calibri" />
        <family val="2" />
        <scheme val="minor" />
      `}
    </font>`)}
  </fonts>
  <fills count="${fills.length + 2}">
      <fill><patternFill patternType="none"/></fill>
      <fill><patternFill patternType="gray125"/></fill>
    ${foreach(fills, (fill) => `
      ${fill.background ? `
        <fill>
          <patternFill patternType="solid">
              <fgColor rgb="${ESC(fill.background)}"/>
          </patternFill>
        </fill>
      ` : ""}`)}
  </fills>
  <borders count="${borders.length + 1}">
    <border><left/><right/><top/><bottom/><diagonal/></border>
    ${foreach(borders, borderTemplate)}
  </borders>
  <cellStyleXfs count="1">
    <xf borderId="0" fillId="0" fontId="0" />
  </cellStyleXfs>
  <cellXfs count="${styles.length + 1}">
    <xf numFmtId="0" fontId="0" fillId="0" borderId="0" xfId="0" />
    ${foreach(styles, (style) => `
      <xf xfId="0"
          ${style.fontId ? `fontId="${style.fontId}" applyFont="1"` : ""}
          ${style.fillId ? `fillId="${style.fillId}" applyFill="1"` : ""}
          ${style.numFmtId ? `numFmtId="${style.numFmtId}" applyNumberFormat="1"` : ""}
          ${style.textAlign || style.verticalAlign || style.wrap ? 'applyAlignment="1"' : ""}
          ${style.borderId ? `borderId="${style.borderId}" applyBorder="1"` : ""}
          ${style.disabled != null ? `applyProtection="1"` : ""}>
        ${style.textAlign || style.verticalAlign || style.wrap ? `
        <alignment
          ${style.textAlign ? `horizontal="${ESC(style.textAlign)}"` : ""}
          ${style.verticalAlign ? `vertical="${ESC(style.verticalAlign)}"` : ""}
          ${style.indent ? `indent="${ESC(style.indent)}"` : ""}
          ${style.wrap ? 'wrapText="1"' : ""} />
        ` : ""}
        ${style.disabled != null ? `
        <protection locked="${style.disabled ? 1 : 0}" />
        ` : ""}
      </xf>
    `)}
  </cellXfs>
  <cellStyles count="1">
    <cellStyle name="Normal" xfId="0" builtinId="0"/>
  </cellStyles>
  <dxfs count="0" />
  <tableStyles count="0" defaultTableStyle="TableStyleMedium2" defaultPivotStyle="PivotStyleMedium9" />
</styleSheet>`;
function writeFormula(formula) {
  if (typeof formula == "string") {
    return `<f>${ESC(formula)}</f>`;
  }
  return `<f t="array" ref="${formula.ref}">${ESC(formula.src)}</f>`;
}
function numChar(colIndex) {
  const letter = Math.floor(colIndex / 26) - 1;
  return (letter >= 0 ? numChar(letter) : "") + String.fromCharCode(65 + colIndex % 26);
}
function ref(rowIndex, colIndex) {
  return numChar(colIndex) + (rowIndex + 1);
}
function $ref(rowIndex, colIndex) {
  return "$" + numChar(colIndex) + "$" + (rowIndex + 1);
}
function filterRowIndex(options) {
  const frozenRows = options.frozenRows || (options.freezePane || {}).rowSplit || 1;
  return frozenRows - 1;
}
function toWidth(px) {
  const maximumDigitWidth = 7;
  return px / maximumDigitWidth - Math.floor(128 / maximumDigitWidth) / 256;
}
function toHeight(px) {
  return px * 0.75;
}
function stripFunnyChars(value) {
  return String(value).replace(/[\x00-\x09\x0B\x0C\x0E-\x1F]/g, "").replace(/\r?\n/g, "\r\n");
}
var Worksheet = class {
  constructor(options, sharedStrings, styles, borders) {
    this.options = options;
    this._strings = sharedStrings;
    this._styles = styles;
    this._borders = borders;
    this._validations = {};
    this._comments = [];
    this._drawings = options.drawings || [];
    this._hyperlinks = (this.options.hyperlinks || []).map(
      (link, i2) => Object.assign({}, link, { rId: `link${i2}` })
    );
  }
  relsToXML() {
    const hyperlinks = this._hyperlinks;
    const comments = this._comments;
    const drawings = this._drawings;
    if (hyperlinks.length || comments.length || drawings.length) {
      return WORKSHEET_RELS({
        hyperlinks,
        comments,
        sheetIndex: this.options.sheetIndex,
        drawings
      });
    }
  }
  toXML(index) {
    const mergeCells = this.options.mergedCells || [];
    const rows = this.options.rows || [];
    const data = inflate(rows, mergeCells);
    this._readCells(data);
    let autoFilter = this.options.filter;
    let filter2;
    if (autoFilter && typeof autoFilter.from === "number" && typeof autoFilter.to === "number") {
      autoFilter = {
        from: ref(filterRowIndex(this.options), autoFilter.from),
        to: ref(filterRowIndex(this.options), autoFilter.to)
      };
    } else if (autoFilter && autoFilter.ref && autoFilter.columns) {
      filter2 = autoFilter;
      autoFilter = null;
    }
    const validations = [];
    for (let i2 in this._validations) {
      if (Object.prototype.hasOwnProperty.call(this._validations, i2)) {
        validations.push(this._validations[i2]);
      }
    }
    let defaultCellStyleId = null;
    let defaultCellStyle = this.options.defaultCellStyle;
    if (this._hasDisabledCells) {
      if (!defaultCellStyle) {
        defaultCellStyle = { disabled: false };
      } else {
        defaultCellStyle = Object.assign({ disabled: false }, defaultCellStyle);
      }
    }
    if (defaultCellStyle) {
      defaultCellStyleId = this._lookupStyle(defaultCellStyle);
    }
    const freezePane = this.options.freezePane || {};
    const defaults2 = this.options.defaults || {};
    const lastRow = this.options.rows ? this._getLastRow() : 1;
    const lastCol = this.options.rows ? this._getLastCol() : 1;
    return WORKSHEET({
      frozenColumns: this.options.frozenColumns || freezePane.colSplit,
      frozenRows: this.options.frozenRows || freezePane.rowSplit,
      columns: this.options.columns,
      defaults: defaults2,
      data,
      index,
      mergeCells,
      autoFilter,
      filter: filter2,
      showGridLines: this.options.showGridLines,
      hyperlinks: this._hyperlinks,
      validations,
      defaultCellStyleId,
      rtl: this.options.rtl !== void 0 ? this.options.rtl : defaults2.rtl,
      legacyDrawing: this._comments.length ? `vml${this.options.sheetIndex}` : null,
      drawing: this._drawings.length ? `drw${this.options.sheetIndex}` : null,
      lastRow,
      lastCol,
      hasDisabledCells: this._hasDisabledCells
    });
  }
  commentsXML() {
    if (this._comments.length) {
      return COMMENTS_XML({ comments: this._comments });
    }
  }
  drawingsXML(images) {
    if (this._drawings.length) {
      let rels = {};
      let main = this._drawings.map((drw) => {
        let ref2 = parseRef(drw.topLeftCell);
        let img = rels[drw.image];
        if (!img) {
          img = rels[drw.image] = {
            rId: `img${drw.image}`,
            target: images[drw.image].target
          };
        }
        return {
          col: ref2.col,
          colOffset: pixelsToExcel(drw.offsetX),
          row: ref2.row,
          rowOffset: pixelsToExcel(drw.offsetY),
          width: pixelsToExcel(drw.width),
          height: pixelsToExcel(drw.height),
          imageId: img.rId
        };
      });
      return {
        main: DRAWINGS_XML(main),
        rels: DRAWINGS_RELS_XML(rels)
      };
    }
  }
  legacyDrawing() {
    if (this._comments.length) {
      return LEGACY_DRAWING({ comments: this._comments });
    }
  }
  _lookupString(value) {
    const key = "$" + value;
    const index = this._strings.indexes[key];
    let result;
    if (index !== void 0) {
      result = index;
    } else {
      result = this._strings.indexes[key] = this._strings.uniqueCount;
      this._strings.uniqueCount++;
    }
    this._strings.count++;
    return result;
  }
  _lookupStyle(style) {
    const json = JSON.stringify(style);
    if (json === "{}") {
      return 0;
    }
    let index = indexOf(json, this._styles);
    if (index < 0) {
      index = this._styles.push(json) - 1;
    }
    return index + 1;
  }
  _lookupBorder(border) {
    const json = JSON.stringify(border);
    if (json === "{}") {
      return;
    }
    let index = indexOf(json, this._borders);
    if (index < 0) {
      index = this._borders.push(json) - 1;
    }
    return index + 1;
  }
  _readCells(rowData) {
    for (let i2 = 0; i2 < rowData.length; i2++) {
      const row = rowData[i2];
      const cells = row.cells;
      row.data = [];
      for (let j = 0; j < cells.length; j++) {
        const cellData = this._cell(cells[j], row.index, j);
        if (cellData) {
          row.data.push(cellData);
        }
      }
    }
  }
  _cell(data, rowIndex, cellIndex) {
    if (!data || data === EMPTY_CELL) {
      return null;
    }
    let value = data.value;
    let border = {};
    if (data.borderLeft) {
      border.left = data.borderLeft;
    }
    if (data.borderRight) {
      border.right = data.borderRight;
    }
    if (data.borderTop) {
      border.top = data.borderTop;
    }
    if (data.borderBottom) {
      border.bottom = data.borderBottom;
    }
    if (data.dBorders) {
      border.diagonal = data.dBorders;
    }
    border = this._lookupBorder(border);
    const defStyle = this.options.defaultCellStyle || {};
    let style = { borderId: border };
    ((add) => {
      add("color");
      add("background");
      add("bold");
      add("italic");
      add("underline");
      if (!add("fontFamily")) {
        add("fontName", "fontFamily");
      }
      add("fontSize");
      add("format");
      if (!add("textAlign")) {
        add("hAlign", "textAlign");
      }
      if (!add("verticalAlign")) {
        add("vAlign", "verticalAlign");
      }
      add("wrap");
      add("indent");
      if (!add("disabled")) {
        if (add("enable")) {
          style.disabled = !style.enable;
          delete style.enable;
        }
      }
      if (style.disabled) {
        this._hasDisabledCells = true;
      }
    })((prop, target) => {
      let val = data[prop];
      if (val === void 0) {
        val = defStyle[prop];
      }
      if (val !== void 0) {
        style[target || prop] = val;
        return true;
      }
    });
    const columns = this.options.columns || [];
    const column = columns[cellIndex];
    let type = typeof value;
    if (column && column.autoWidth && (!data.colSpan || data.colSpan === 1)) {
      let displayValue = value;
      if (type === "number") {
        displayValue = intl_service_default.toString(value, data.format);
      }
      column.width = Math.max(column.width || 0, String(displayValue).length);
    }
    if (type === "string") {
      value = stripFunnyChars(value);
      value = this._lookupString(value);
      type = "s";
    } else if (type === "number") {
      type = "n";
    } else if (type === "boolean") {
      type = "b";
      value = Number(value);
    } else if (value && value.getTime) {
      type = null;
      value = dateToSerial(value);
      if (!style.format) {
        style.format = "mm-dd-yy";
      }
    } else {
      type = null;
      value = null;
    }
    style = this._lookupStyle(style);
    const cellName = ref(rowIndex, cellIndex);
    if (data.validation) {
      this._addValidation(data.validation, cellName);
    }
    if (data.comment) {
      let anchor = [
        cellIndex + 1,
        // start column
        15,
        // start column offset
        rowIndex,
        // start row
        10,
        // start row offset
        cellIndex + 3,
        // end column
        15,
        // end column offset
        rowIndex + 3,
        // end row
        4
        // end row offset
      ];
      this._comments.push({
        ref: cellName,
        text: data.comment,
        row: rowIndex,
        col: cellIndex,
        anchor: anchor.join(", ")
      });
    }
    return {
      value,
      formula: data.formula,
      type,
      style,
      ref: cellName
    };
  }
  _addValidation(v, ref2) {
    const tmp = {
      showErrorMessage: v.type === "reject" ? 1 : 0,
      formula1: v.from,
      formula2: v.to,
      type: MAP_EXCEL_TYPE[v.dataType] || v.dataType,
      operator: MAP_EXCEL_OPERATOR[v.comparerType] || v.comparerType,
      allowBlank: v.allowNulls ? 1 : 0,
      showDropDown: v.showButton ? 0 : 1,
      // LOL, Excel!
      error: v.messageTemplate,
      errorTitle: v.titleTemplate
    };
    const json = JSON.stringify(tmp);
    if (!this._validations[json]) {
      this._validations[json] = tmp;
      tmp.sqref = [];
    }
    this._validations[json].sqref.push(ref2);
  }
  _getLastRow() {
    return countData(this.options.rows);
  }
  _getLastCol() {
    let last = 0;
    this.options.rows.forEach(function(row) {
      if (row.cells) {
        last = Math.max(last, countData(row.cells));
      }
    });
    return last;
  }
};
function countData(data) {
  let last = data.length;
  data.forEach(function(el) {
    if (el.index && el.index >= last) {
      last = el.index + 1;
    }
  });
  return last;
}
var MAP_EXCEL_OPERATOR = {
  // includes only what differs; key is our operator, value is Excel
  // operator.
  greaterThanOrEqualTo: "greaterThanOrEqual",
  lessThanOrEqualTo: "lessThanOrEqual"
};
var MAP_EXCEL_TYPE = {
  // eslint-disable-next-line id-denylist
  number: "decimal"
};
var defaultFormats = {
  "General": 0,
  "0": 1,
  "0.00": 2,
  "#,##0": 3,
  "#,##0.00": 4,
  "0%": 9,
  "0.00%": 10,
  "0.00E+00": 11,
  "# ?/?": 12,
  "# ??/??": 13,
  "mm-dd-yy": 14,
  "d-mmm-yy": 15,
  "d-mmm": 16,
  "mmm-yy": 17,
  "h:mm AM/PM": 18,
  "h:mm:ss AM/PM": 19,
  "h:mm": 20,
  "h:mm:ss": 21,
  "m/d/yy h:mm": 22,
  "#,##0 ;(#,##0)": 37,
  "#,##0 ;[Red](#,##0)": 38,
  "#,##0.00;(#,##0.00)": 39,
  "#,##0.00;[Red](#,##0.00)": 40,
  "mm:ss": 45,
  "[h]:mm:ss": 46,
  "mmss.0": 47,
  "##0.0E+0": 48,
  "@": 49,
  "[$-404]e/m/d": 27,
  "m/d/yy": 30,
  "t0": 59,
  "t0.00": 60,
  "t#,##0": 61,
  "t#,##0.00": 62,
  "t0%": 67,
  "t0.00%": 68,
  "t# ?/?": 69,
  "t# ??/??": 70
};
function maybeRGB(value) {
  function hex(val) {
    let x = parseInt(val, 10).toString(16);
    return x.length < 2 ? "0" + x : x;
  }
  let m = /^rgba?\((\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*([0-9.]+)\s*)?\)/i.exec(value.trim());
  if (m) {
    let opacity = (m[4] ? parseFloat(m[4]) : 1) * 255 | 0;
    return "#" + hex(opacity) + hex(m[1]) + hex(m[2]) + hex(m[3]);
  }
  return value;
}
function convertColor(value) {
  let color = maybeRGB(value);
  if (color.length < 6) {
    color = color.replace(/(\w)/g, function($0, $1) {
      return $1 + $1;
    });
  }
  color = color.substring(1).toUpperCase();
  if (color.length < 8) {
    color = "FF" + color;
  }
  return color;
}
var Workbook = class {
  constructor(options) {
    this.options = options || {};
    this._strings = {
      indexes: {},
      count: 0,
      uniqueCount: 0
    };
    this._styles = [];
    this._borders = [];
    this._images = this.options.images;
    this._imgId = 0;
    this._sheets = map(this.options.sheets || [], (options2, i2) => {
      options2.defaults = this.options;
      options2.sheetIndex = i2 + 1;
      return new Worksheet(options2, this._strings, this._styles, this._borders);
    });
  }
  imageFilename(mimeType) {
    const id = ++this._imgId;
    switch (mimeType) {
      case "image/jpg":
      case "image/jpeg":
        return `image${id}.jpg`;
      case "image/png":
        return `image${id}.png`;
      case "image/gif":
        return `image${id}.gif`;
      default:
        return `image${id}.bin`;
    }
  }
  toZIP() {
    const zip = createZip();
    const docProps = zip.folder("docProps");
    docProps.file("core.xml", CORE({
      creator: this.options.creator || "Kendo UI",
      lastModifiedBy: this.options.creator || "Kendo UI",
      created: this.options.date || (/* @__PURE__ */ new Date()).toJSON(),
      modified: this.options.date || (/* @__PURE__ */ new Date()).toJSON()
    }));
    const sheetCount = this._sheets.length;
    docProps.file("app.xml", APP({ sheets: this._sheets }));
    const rels = zip.folder("_rels");
    rels.file(".rels", RELS);
    const xl = zip.folder("xl");
    const xlRels = xl.folder("_rels");
    xlRels.file("workbook.xml.rels", WORKBOOK_RELS({ count: sheetCount }));
    if (this._images) {
      const media = xl.folder("media");
      Object.keys(this._images).forEach((id) => {
        const img = this._images[id];
        const filename = this.imageFilename(img.type);
        media.file(filename, img.data);
        img.target = `../media/${filename}`;
      });
    }
    const sheetIds = {};
    xl.file("workbook.xml", WORKBOOK({
      sheets: this._sheets,
      filterNames: map(this._sheets, function(sheet, index) {
        const options = sheet.options;
        const sheetName = options.name || options.title || "Sheet" + (index + 1);
        sheetIds[sheetName.toLowerCase()] = index;
        const filter2 = options.filter;
        if (filter2) {
          if (filter2.ref) {
            let a3 = filter2.ref.split(":");
            let from = parseRef(a3[0]);
            let to = parseRef(a3[1]);
            return {
              localSheetId: index,
              name: sheetName,
              from: $ref(from.row, from.col),
              to: $ref(to.row, to.col)
            };
          } else if (typeof filter2.from !== "undefined" && typeof filter2.to !== "undefined") {
            return {
              localSheetId: index,
              name: sheetName,
              from: $ref(filterRowIndex(options), filter2.from),
              to: $ref(filterRowIndex(options), filter2.to)
            };
          }
        }
      }),
      userNames: map(this.options.names || [], function(def) {
        return {
          name: def.localName,
          localSheetId: def.sheet ? sheetIds[def.sheet.toLowerCase()] : null,
          value: def.value,
          hidden: def.hidden
        };
      })
    }));
    const worksheets = xl.folder("worksheets");
    const drawings = xl.folder("drawings");
    const drawingsRels = drawings.folder("_rels");
    const sheetRels = worksheets.folder("_rels");
    const commentFiles = [];
    const drawingFiles = [];
    let hasDisabledCells = false;
    for (let idx = 0; idx < sheetCount; idx++) {
      const sheet = this._sheets[idx];
      const sheetName = `sheet${idx + 1}.xml`;
      const sheetXML = sheet.toXML(idx);
      const relsXML = sheet.relsToXML();
      const commentsXML = sheet.commentsXML();
      const legacyDrawing = sheet.legacyDrawing();
      const drawingsXML = sheet.drawingsXML(this._images);
      if (sheet._hasDisabledCells) {
        hasDisabledCells = true;
      }
      if (relsXML) {
        sheetRels.file(sheetName + ".rels", relsXML);
      }
      if (commentsXML) {
        let name = `comments${sheet.options.sheetIndex}.xml`;
        xl.file(name, commentsXML);
        commentFiles.push(name);
      }
      if (legacyDrawing) {
        drawings.file(`vmlDrawing${sheet.options.sheetIndex}.vml`, legacyDrawing);
      }
      if (drawingsXML) {
        let name = `drawing${sheet.options.sheetIndex}.xml`;
        drawings.file(name, drawingsXML.main);
        drawingsRels.file(`${name}.rels`, drawingsXML.rels);
        drawingFiles.push(name);
      }
      worksheets.file(sheetName, sheetXML);
    }
    const borders = map(this._borders, parseJSON);
    const styles = map(this._styles, parseJSON);
    const hasFont = function(style) {
      return style.underline || style.bold || style.italic || style.color || style.fontFamily || style.fontSize;
    };
    const convertFontSize = function(value) {
      let fontInPx = Number(value);
      let fontInPt;
      if (fontInPx) {
        fontInPt = fontInPx * 3 / 4;
      }
      return fontInPt;
    };
    const fonts = map(styles, function(style) {
      if (style.fontSize) {
        style.fontSize = convertFontSize(style.fontSize);
      }
      if (style.color) {
        style.color = convertColor(style.color);
      }
      if (hasFont(style)) {
        return style;
      }
    });
    const formats = map(styles, function(style) {
      if (style.format && defaultFormats[style.format] === void 0) {
        return style;
      }
    });
    const fills = map(styles, function(style) {
      if (style.background) {
        style.background = convertColor(style.background);
        return style;
      }
    });
    xl.file("styles.xml", STYLES({
      fonts,
      fills,
      formats,
      borders,
      styles: map(styles, function(style) {
        const result = {};
        if (hasFont(style)) {
          result.fontId = indexOf(style, fonts) + 1;
        }
        if (style.background) {
          result.fillId = indexOf(style, fills) + 2;
        }
        result.textAlign = style.textAlign;
        result.indent = style.indent;
        result.verticalAlign = style.verticalAlign;
        result.wrap = style.wrap;
        result.borderId = style.borderId;
        if (style.format) {
          if (defaultFormats[style.format] !== void 0) {
            result.numFmtId = defaultFormats[style.format];
          } else {
            result.numFmtId = 165 + indexOf(style, formats);
          }
        }
        if (hasDisabledCells) {
          result.disabled = !!style.disabled;
        }
        return result;
      })
    }));
    xl.file("sharedStrings.xml", SHARED_STRINGS(this._strings));
    zip.file("[Content_Types].xml", CONTENT_TYPES({
      sheetCount,
      commentFiles,
      drawingFiles
    }));
    return zip;
  }
  toDataURL() {
    const zip = this.toZIP();
    return zip.generateAsync ? zip.generateAsync(DATA_URL_OPTIONS).then(toDataURI) : toDataURI(zip.generate(DATA_URL_OPTIONS));
  }
  toBlob() {
    const zip = this.toZIP();
    if (zip.generateAsync) {
      return zip.generateAsync(BLOB_OPTIONS);
    }
    return new Blob([zip.generate(ARRAYBUFFER_OPTIONS)], { type: MIME_TYPE });
  }
};
function borderStyle(width) {
  let alias = "thin";
  if (width === 2) {
    alias = "medium";
  } else if (width === 3) {
    alias = "thick";
  }
  return alias;
}
function borderSideTemplate(name, style) {
  let result = "";
  if (style) {
    result += "<" + name + ' style="' + borderStyle(style.size) + '">';
    if (style.color) {
      result += '<color rgb="' + convertColor(style.color) + '"/>';
    }
    result += "</" + name + ">";
  }
  return result;
}
function borderTemplate(border) {
  let diag = border.diagonal ? border.diagonal.type : 0;
  return `<border ${diag & 2 ? 'diagonalUp="true"' : ""} ${diag & 1 ? 'diagonalDown="true"' : ""}>
      ${borderSideTemplate("left", border.left)}
      ${borderSideTemplate("right", border.right)}
      ${borderSideTemplate("top", border.top)}
      ${borderSideTemplate("bottom", border.bottom)}
      ${borderSideTemplate("diagonal", border.diagonal)}
    </border>`;
}
var EMPTY_CELL = {};
function inflate(rows, mergedCells) {
  const rowData = [];
  const rowsByIndex = [];
  indexRows(rows, function(row, index) {
    const data = {
      _source: row,
      index,
      height: row.height,
      level: row.level,
      cells: []
    };
    rowData.push(data);
    rowsByIndex[index] = data;
  });
  const sorted = sortByIndex(rowData).slice(0);
  const ctx = {
    rowData,
    rowsByIndex,
    mergedCells
  };
  for (let i2 = 0; i2 < sorted.length; i2++) {
    fillCells(sorted[i2], ctx);
    delete sorted[i2]._source;
  }
  return sortByIndex(rowData);
}
function indexRows(rows, callback) {
  for (let i2 = 0; i2 < rows.length; i2++) {
    const row = rows[i2];
    if (!row) {
      continue;
    }
    let index = row.index;
    if (typeof index !== "number") {
      index = i2;
    }
    callback(row, index);
  }
}
function sortByIndex(items) {
  return items.sort(function(a3, b2) {
    return a3.index - b2.index;
  });
}
function pushUnique(array, el) {
  if (array.indexOf(el) < 0) {
    array.push(el);
  }
}
function getSpan(mergedCells, ref2) {
  for (let i2 = 0; i2 < mergedCells.length; ++i2) {
    const range = mergedCells[i2];
    const a3 = range.split(":");
    let topLeft = a3[0];
    if (topLeft === ref2) {
      let bottomRight = a3[1];
      topLeft = parseRef(topLeft);
      bottomRight = parseRef(bottomRight);
      return {
        rowSpan: bottomRight.row - topLeft.row + 1,
        colSpan: bottomRight.col - topLeft.col + 1
      };
    }
  }
}
function parseRef(ref2) {
  function getcol(str) {
    let upperStr = str.toUpperCase();
    let col = 0;
    for (let i2 = 0; i2 < upperStr.length; ++i2) {
      col = col * 26 + upperStr.charCodeAt(i2) - 64;
    }
    return col - 1;
  }
  function getrow(str) {
    return parseInt(str, 10) - 1;
  }
  const m = /^([a-z]+)(\d+)$/i.exec(ref2);
  return {
    row: getrow(m[2]),
    col: getcol(m[1])
  };
}
function pixelsToExcel(px) {
  return Math.round(px * 9525);
}
function fillCells(data, ctx) {
  const row = data._source;
  const rowIndex = data.index;
  const cells = row.cells;
  const cellData = data.cells;
  if (!cells) {
    return;
  }
  for (let i2 = 0; i2 < cells.length; i2++) {
    const cell = cells[i2] || EMPTY_CELL;
    let rowSpan = cell.rowSpan || 1;
    let colSpan = cell.colSpan || 1;
    const cellIndex = insertCell(cellData, cell);
    const topLeftRef = ref(rowIndex, cellIndex);
    if (rowSpan === 1 && colSpan === 1) {
      const tmp = getSpan(ctx.mergedCells, topLeftRef);
      if (tmp) {
        colSpan = tmp.colSpan;
        rowSpan = tmp.rowSpan;
      }
    }
    spanCell(cell, cellData, cellIndex, colSpan);
    if (rowSpan > 1 || colSpan > 1) {
      pushUnique(
        ctx.mergedCells,
        topLeftRef + ":" + ref(
          rowIndex + rowSpan - 1,
          cellIndex + colSpan - 1
        )
      );
    }
    if (rowSpan > 1) {
      for (let ri = rowIndex + 1; ri < rowIndex + rowSpan; ri++) {
        let nextRow = ctx.rowsByIndex[ri];
        if (!nextRow) {
          nextRow = ctx.rowsByIndex[ri] = { index: ri, cells: [] };
          ctx.rowData.push(nextRow);
        }
        spanCell(cell, nextRow.cells, cellIndex - 1, colSpan + 1);
      }
    }
  }
}
function insertCell(data, cell) {
  let index;
  if (typeof cell.index === "number") {
    index = cell.index;
    insertCellAt(data, cell, cell.index);
  } else {
    index = appendCell(data, cell);
  }
  return index;
}
function insertCellAt(data, cell, index) {
  data[index] = cell;
}
function appendCell(data, cell) {
  let index = data.length;
  for (let i2 = 0; i2 < data.length + 1; i2++) {
    if (!data[i2]) {
      data[i2] = cell;
      index = i2;
      break;
    }
  }
  return index;
}
function spanCell(cell, row, startIndex, colSpan) {
  for (let i2 = 1; i2 < colSpan; i2++) {
    const tmp = {
      borderTop: cell.borderTop,
      borderRight: cell.borderRight,
      borderBottom: cell.borderBottom,
      borderLeft: cell.borderLeft
    };
    insertCellAt(row, tmp, startIndex + i2);
  }
}
var SPREADSHEET_FILTERS = ({ ref: ref2, columns, generators }) => `
<autoFilter ref="${ref2}">
  ${foreach(columns, (col) => `
    <filterColumn colId="${col.index}">
      ${generators[col.filter](col)}
    </filterColumn>
  `)}
</autoFilter>`;
var SPREADSHEET_CUSTOM_FILTER = ({ logic, criteria }) => `
<customFilters ${logic === "and" ? 'and="1"' : ""}>
${foreach(criteria, (f2) => {
  let op = spreadsheetFilters.customOperator(f2);
  let val = spreadsheetFilters.customValue(f2);
  return `<customFilter ${op ? `operator="${op}"` : ""} val="${val}"/>`;
})}
</customFilters>`;
var SPREADSHEET_DYNAMIC_FILTER = ({ type }) => `<dynamicFilter type="${spreadsheetFilters.dynamicFilterType(type)}" />`;
var SPREADSHEET_TOP_FILTER = ({ type, value }) => `<top10 percent="${/percent$/i.test(type) ? 1 : 0}"
       top="${/^top/i.test(type) ? 1 : 0}"
       val="${value}" />`;
var SPREADSHEET_VALUE_FILTER = ({ blanks, values }) => `<filters ${blanks ? 'blank="1"' : ""}>
    ${foreach(values, (value) => `
      <filter val="${value}" />`)}
  </filters>`;
function spreadsheetFilters(filter2) {
  return SPREADSHEET_FILTERS({
    ref: filter2.ref,
    columns: filter2.columns,
    generators: {
      custom: SPREADSHEET_CUSTOM_FILTER,
      dynamic: SPREADSHEET_DYNAMIC_FILTER,
      top: SPREADSHEET_TOP_FILTER,
      value: SPREADSHEET_VALUE_FILTER
    }
  });
}
spreadsheetFilters.customOperator = function(f2) {
  return {
    eq: "equal",
    gt: "greaterThan",
    gte: "greaterThanOrEqual",
    lt: "lessThan",
    lte: "lessThanOrEqual",
    ne: "notEqual",
    // These are not in the spec, but seems to be how Excel does
    // it (see customValue below).  For the non-negated versions,
    // the operator attribute is missing completely.
    doesnotstartwith: "notEqual",
    doesnotendwith: "notEqual",
    doesnotcontain: "notEqual",
    doesnotmatch: "notEqual"
  }[f2.operator.toLowerCase()];
};
function quoteSheet(name) {
  if (/^\'/.test(name)) {
    return name;
  }
  if (/^[a-z_][a-z0-9_]*$/i.test(name)) {
    return name;
  }
  return "'" + name.replace(/\x27/g, "\\'") + "'";
}
spreadsheetFilters.customValue = function(f2) {
  function esc(str) {
    return str.replace(/([*?])/g, "~$1");
  }
  switch (f2.operator.toLowerCase()) {
    case "startswith":
    case "doesnotstartwith":
      return esc(f2.value) + "*";
    case "endswith":
    case "doesnotendwith":
      return "*" + esc(f2.value);
    case "contains":
    case "doesnotcontain":
      return "*" + esc(f2.value) + "*";
    default:
      return f2.value;
  }
};
spreadsheetFilters.dynamicFilterType = function(type) {
  return {
    quarter1: "Q1",
    quarter2: "Q2",
    quarter3: "Q3",
    quarter4: "Q4",
    january: "M1",
    february: "M2",
    march: "M3",
    april: "M4",
    may: "M5",
    june: "M6",
    july: "M7",
    august: "M8",
    september: "M9",
    october: "M10",
    november: "M11",
    december: "M12"
  }[type.toLowerCase()] || type;
};

// node_modules/@progress/kendo-react-excel-export/ooxml/ExporterColumns.mjs
var g = __toESM(require_react(), 1);
var n = __toESM(require_server_browser(), 1);
var d2 = (t2, e6, r4) => (l) => {
  r4(e6, l);
  const s = n.renderToStaticMarkup(g.createElement(t2, { ...e6 })), o4 = Number(s);
  return isNaN(o4) ? s : o4;
};
var f = (t2, e6) => {
  t2.$implicit = t2.group = e6, t2.field = e6.field, t2.value = e6.value, t2.aggregates = e6.aggregates;
};
var u = (t2, e6) => {
  t2.group = e6.group, t2.$implicit = t2.aggregates = e6;
};
var C = (t2, e6) => {
};
var F = (t2) => {
  const e6 = [];
  let r4 = 0;
  const p2 = (l, s, o4) => {
    l.forEach((i2) => {
      if (i2.level === o4) {
        const a3 = new O(i2, r4);
        if (s.push(a3), i2.children && i2.children.length > 1) {
          const h2 = a3.columns = [];
          p2(i2.children, h2, o4 + 1);
        } else
          r4++;
      }
    });
  };
  return p2(t2, e6, 0), e6;
};
var O = class {
  constructor(e6, r4) {
    this.columns = null, this.title = e6.title, this.field = e6.field, this.hidden = e6.hidden, this.locked = e6.locked, this.width = e6.width, this.headerCellOptions = e6.headerCellOptions, this.cellOptions = e6.cellOptions, this.groupHeaderCellOptions = e6.groupHeaderCellOptions, this.groupFooterCellOptions = e6.groupFooterCellOptions, this.footerCellOptions = e6.footerCellOptions, e6.footer && (this.footerTemplate = d2(
      e6.footer,
      {
        $implicit: e6,
        column: e6,
        columnIndex: r4
      },
      C
    )), e6.groupFooter && (this.groupFooterTemplate = d2(
      e6.groupFooter,
      {
        column: e6,
        field: e6.field
      },
      u
    )), e6.groupHeader && (this.groupHeaderTemplate = d2(e6.groupHeader, {}, f));
  }
};

// node_modules/@progress/kendo-react-excel-export/ooxml/workbook.mjs
var d3 = (e6) => Math.max(...e6.map((r4) => r4.level)) + 1;
var p = (e6) => {
  const r4 = F(e6.columns), t2 = new excel_exporter_default({
    columns: r4,
    data: e6.data,
    filterable: e6.filterable,
    groups: e6.group,
    paddingCellOptions: e6.paddingCellOptions,
    headerPaddingCellOptions: e6.headerPaddingCellOptions,
    hierarchy: e6.hierarchy ? { depth: d3(e6.data), itemLevel: (l) => l.level } : null,
    collapsible: e6.collapsible
  }).workbook();
  return t2.creator = e6.creator, t2.date = e6.date, t2.rtl = e6.dir === "rtl", t2;
};
var b = (e6) => new Workbook(e6).toDataURL();
var h = (e6) => e6 && e6.sheets;

// node_modules/@progress/kendo-react-excel-export/package-metadata.mjs
var e = Object.freeze({
  name: "@progress/kendo-react-excel-export",
  productName: "KendoReact",
  productCode: "KENDOUIREACT",
  productCodes: ["KENDOUIREACT"],
  publishDate: 1755016528,
  version: "11.4.0",
  licensingDocsUrl: "https://www.telerik.com/kendo-react-ui/components/my-license/"
});

// node_modules/@progress/kendo-react-excel-export/ExcelExport.mjs
var a = class a2 extends i.Component {
  constructor(o4) {
    super(o4), this.showLicenseWatermark = false, this.saveFile = (t2) => {
      saveAs(t2, this.props.fileName, {
        forceProxy: this.props.forceProxy,
        proxyURL: this.props.proxyURL
      });
    }, this.extractColumns = (t2, s = 0) => Array.isArray(t2) ? t2.map((e6) => this.extractChild(e6, s)) : [t2, this.extractChild(t2, s)], this.extractChild = (t2, s = 0) => i.isValidElement(t2) ? {
      ...t2.props,
      width: t2.props.width && parseInt(`${t2.props.width}`, 10),
      level: s,
      children: t2.props.children && this.extractColumns(t2.props.children, s + 1)
    } : {
      ...t2,
      level: s,
      children: t2.children && this.extractColumns(t2.children, s + 1)
    }, this.getExportData = (t2) => {
      let s;
      return t2 ? Array.isArray(t2) ? s = {
        data: t2
      } : s = t2 : s = {
        data: this.props.data,
        group: this.props.group
      }, s;
    }, this.showLicenseWatermark = !d(e, { component: "ExcelExport" }), this.licenseMessage = w(e), this.save = this.save.bind(this), this.toDataURL = this.toDataURL.bind(this), this.workbookOptions = this.workbookOptions.bind(this);
  }
  /**
   * Saves the data to Excel.
   *
   * @param exportData - An optional parameter. Can be the data that will be exported or the [`WorkbookOptions`]({% slug api_excel-export_kendoooxml %}#toc-workbookoptions).
   * @param columns - An optional parameter. If present, it will be used instead of the columns prop or the child column components.
   */
  save(o4, t2) {
    this.toDataURL(o4, t2).then((...s) => {
      this.props.onExportComplete && this.props.onExportComplete.call(void 0, { target: this }), this.saveFile(...s);
    });
  }
  /**
   * Returns a promise which will be resolved with the file data URI.
   *
   * @param exportData - The optional data or the [`WorkbookOptions`]({% slug api_excel-export_kendoooxml %}#toc-workbookoptions) that will be used to generate the data URI.
   * @param externalColumns - The optional columns that will be used.
   * @returns {Promise<string>} - The promise that will be resolved by the file data URI.
   */
  toDataURL(o4, t2) {
    const s = h(o4) ? o4 : this.workbookOptions(o4, t2);
    return b(s);
  }
  /**
   * Based on the specified columns and data, returns [`WorkbookOptions`]({% slug api_excel-export_kendoooxml %}#toc-workbookoptions).
   *
   * @param exportData - The optional data that will be exported.
   * @param externalColumns - The optional columns that will be used.
   * @returns {WorkbookOptions} - The workbook options.
   */
  // tslint:enable:max-line-length
  workbookOptions(o4, t2) {
    const s = this.getExportData(o4), e6 = this.props.children, h2 = e6 && e6.type && e6.type.displayName === "KendoReactGrid" && e6.props && i.Children.toArray(e6.props.children), l = this.extractColumns(
      h2 || t2 || this.props.columns || i.Children.toArray(e6)
    );
    return p({
      columns: l,
      data: s.data,
      group: s.group,
      filterable: this.props.filterable,
      creator: this.props.creator,
      date: this.props.date,
      dir: this.props.dir,
      hierarchy: this.props.hierarchy,
      paddingCellOptions: this.props.paddingCellOptions,
      headerPaddingCellOptions: this.props.headerPaddingCellOptions,
      collapsible: this.props.collapsible
    });
  }
  /**
   * @hidden
   */
  render() {
    return i.createElement(i.Fragment, null, this.props.children || null, this.showLicenseWatermark && i.createElement(P, { message: this.licenseMessage }));
  }
};
a.propTypes = {
  children: import_prop_types.default.any,
  columns: import_prop_types.default.arrayOf(import_prop_types.default.any),
  creator: import_prop_types.default.string,
  data: import_prop_types.default.any,
  date: import_prop_types.default.any,
  filterable: import_prop_types.default.bool,
  fileName: import_prop_types.default.string,
  forceProxy: import_prop_types.default.bool,
  group: import_prop_types.default.any,
  headerPaddingCellOptions: import_prop_types.default.any,
  paddingCellOptions: import_prop_types.default.any,
  proxyURL: import_prop_types.default.string,
  dir: import_prop_types.default.string,
  hierarchy: import_prop_types.default.bool,
  collapsible: import_prop_types.default.bool
}, a.defaultProps = {
  fileName: "Export.xlsx",
  forceProxy: false,
  collapsible: false
};
var n2 = a;

// node_modules/@progress/kendo-react-excel-export/ExcelExportColumn.mjs
var import_prop_types2 = __toESM(require_prop_types(), 1);
var o = (n3) => null;
o.propTypes = {
  cellOptions: import_prop_types2.default.any,
  field: import_prop_types2.default.string,
  footerCellOptions: import_prop_types2.default.any,
  footer: import_prop_types2.default.oneOfType([import_prop_types2.default.func, import_prop_types2.default.element]),
  groupFooterCellOptions: import_prop_types2.default.any,
  groupFooter: import_prop_types2.default.oneOfType([import_prop_types2.default.func, import_prop_types2.default.element]),
  groupHeaderCellOptions: import_prop_types2.default.any,
  groupHeader: import_prop_types2.default.oneOfType([import_prop_types2.default.func, import_prop_types2.default.element]),
  headerCellOptions: import_prop_types2.default.any,
  hidden: import_prop_types2.default.bool,
  level: import_prop_types2.default.number,
  locked: import_prop_types2.default.bool,
  title: import_prop_types2.default.string,
  width: import_prop_types2.default.number
};

// node_modules/@progress/kendo-react-excel-export/ExcelExportColumnGroup.mjs
var import_prop_types3 = __toESM(require_prop_types(), 1);
var o2 = (l) => null;
o2.propTypes = {
  children: import_prop_types3.default.oneOfType([import_prop_types3.default.arrayOf(import_prop_types3.default.element), import_prop_types3.default.element]),
  headerCellOptions: import_prop_types3.default.any,
  hidden: import_prop_types3.default.bool,
  level: import_prop_types3.default.number,
  locked: import_prop_types3.default.bool,
  title: import_prop_types3.default.string,
  width: import_prop_types3.default.number
};

// node_modules/@progress/kendo-react-excel-export/templates/ExcelExportFooter.mjs
var e4 = __toESM(require_react(), 1);
var t = class extends e4.PureComponent {
};

// node_modules/@progress/kendo-react-excel-export/templates/ExcelExportGroupFooter.mjs
var o3 = __toESM(require_react(), 1);
var r2 = class extends o3.PureComponent {
};

// node_modules/@progress/kendo-react-excel-export/templates/ExcelExportGroupHeader.mjs
var e5 = __toESM(require_react(), 1);
var r3 = class extends e5.PureComponent {
};
export {
  n2 as ExcelExport,
  o as ExcelExportColumn,
  o2 as ExcelExportColumnGroup,
  t as ExcelExportFooter,
  r2 as ExcelExportGroupFooter,
  r3 as ExcelExportGroupHeader,
  main_exports as KendoOoxml,
  h as isWorkbookOptions,
  b as toDataURL,
  p as workbookOptions
};
/*! Bundled license information:

@progress/kendo-react-excel-export/ooxml/ExporterColumns.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-excel-export/ooxml/workbook.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-excel-export/package-metadata.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-excel-export/ExcelExport.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-excel-export/ExcelExportColumn.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-excel-export/ExcelExportColumnGroup.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-excel-export/templates/ExcelExportFooter.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-excel-export/templates/ExcelExportGroupFooter.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-excel-export/templates/ExcelExportGroupHeader.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)

@progress/kendo-react-excel-export/index.mjs:
  (**
   * @license
   *-------------------------------------------------------------------------------------------
   * Copyright  2025 Progress Software Corporation. All rights reserved.
   * Licensed under commercial license. See LICENSE.md in the package root for more information
   *-------------------------------------------------------------------------------------------
   *)
*/
//# sourceMappingURL=@progress_kendo-react-excel-export.js.map
