/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import * as n from "react";
import { InstanceObserver as h } from "@progress/kendo-charts";
import { TooltipPopup as u } from "./Popup.mjs";
import { MapContext as m } from "../MapContext.mjs";
const p = class p extends n.Component {
  constructor() {
    super(...arguments), this.context = null, this.state = {
      popupShown: !1
    };
  }
  componentDidMount() {
    this.mapObserver = new h(this, {
      showTooltip: "onShowTooltip",
      hideTooltip: "onHideTooltip"
    }), this.context.observersStore.dispatch({
      type: "add",
      payload: this.mapObserver
    });
  }
  render() {
    const { popupContext: t, shared: o, className: r, ...e } = this.state;
    if (!t || !this.state.popupShown)
      return null;
    const a = t.layerIndex, s = this.findRenderFunctionByLayer(a);
    if (!s)
      return null;
    const l = () => /* @__PURE__ */ n.createElement("div", { className: "k-tooltip-content" }, s(t)), c = `k-map-${t.type}-tooltip`;
    return /* @__PURE__ */ n.createElement(u, { ...e, popupContent: l, className: c });
  }
  componentWillUnmount() {
    this.context.observersStore.dispatch({
      type: "remove",
      payload: this.mapObserver
    });
  }
  onShowTooltip(t) {
    const { anchor: o, className: r } = t, e = this.createTooltipContext(t);
    this.setState({
      popupShown: !0,
      popupAlign: { vertical: "bottom", horizontal: "center" },
      popupOffset: o,
      popupContext: e,
      popupStyles: { position: "relative" },
      className: r
    });
  }
  onHideTooltip() {
    this.setState({
      popupShown: !1,
      popupStyles: {},
      className: void 0
    });
  }
  createTooltipContext(t) {
    return t;
  }
  findRenderFunctionByLayer(t) {
    const o = this.context.optionsStore.getState().layers;
    return o !== void 0 && Array.isArray(o) && o[t] !== void 0 && o[t].hasOwnProperty("tooltip") && o[t].tooltip.hasOwnProperty("render") ? o[t].tooltip.render : null;
  }
};
p.contextType = m;
let i = p;
export {
  i as MapTooltip
};
