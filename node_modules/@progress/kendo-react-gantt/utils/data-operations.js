/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const d=require("@progress/kendo-react-common"),D=require("./index.js"),N=l=>{const{dependencyData:t,dependencyModelFields:n,defaultDataItem:p,fromId:c,toId:r,type:o}=l,s=t.map(m=>({...m})),h=d.setter(n.fromId),e=d.setter(n.toId),a=d.setter(n.type),g=p?{...p}:{};return h(g,c),e(g,r),a(g,o),s.push(g),s},z=l=>{const{defaultDataItem:t,selectedDataItem:n,direction:p,taskModelFields:c,dataTree:r,slotStart:o,slotEnd:s}=l,h=D.mapTree(r,c.children,I=>({...I})),e=d.setter(c.start),a=d.setter(c.end),g=d.getter(c.start),m=d.getter(c.end),k=d.setter(c.parentId||""),i=t?{...t}:{},u=g(i)&&m(i);if(!n||p==="none")u||(e(i,o),a(i,s)),c.parentId&&k(i,null),h.unshift(i);else{const I=[{task:{[c.children]:h},childrenIndex:0}],x=d.getter(c.id),v=d.getter(c.children),O=d.setter(c.children),R=x(n);for(;I.length>0;){const f=I[I.length-1],w=f.task,y=x(w),T=v(w);if(y&&y===R)break;T&&T.length&&T.length>f.childrenIndex?(I.push({task:T[f.childrenIndex],childrenIndex:0}),f.childrenIndex++):I.pop()}if(I.length>1){const f=I[I.length-1].task,w=I[I.length-2].childrenIndex,T=I[I.length-2].task,P=v(T);switch(p){case"child":{let C=v(f);C||(C=[],O(f,C)),u||(e(i,new Date(g(f).getTime())),a(i,new Date(m(f).getTime()))),C.push(i),k(i,x(f)),S(I.splice(1,I.length-1).map(j=>j.task),c);break}case"above":{g(T)&&m(T)&&!u?(e(i,new Date(g(f).getTime())),a(i,new Date(m(f).getTime()))):(e(i,o),a(i,s)),P.splice(w-1,0,i),k(i,x(T)),S(I.splice(1,I.length-2).map(C=>C.task),c);break}case"below":{g(T)&&m(T)&&!u?(e(i,new Date(g(f).getTime())),a(i,new Date(m(f).getTime()))):(e(i,o),a(i,s)),P.splice(w,0,i),k(i,x(T)),S(I.splice(1,I.length-2).map(C=>C.task),c);break}}}}return h},A=l=>{const{updatedDataItem:t,taskModelFields:n,dataTree:p}=l,c=d.getter(n.id),r=d.getter(n.children),o=c(t);let s;const h=D.mapTree(p,n.children,a=>c(a)===o?(s=a,{...t}):{...a});let e=[{task:{[n.children]:h},childrenIndex:0}];for(;e.length>0;){const a=e[e.length-1],g=a.task,m=c(g),k=r(g);if(m&&m===o)break;k&&k.length&&k.length>a.childrenIndex?(e.push({task:k[a.childrenIndex],childrenIndex:0}),a.childrenIndex++):e.pop()}if(e.length>1){e=e.splice(1,e.length-2);const a=d.getter(n.start),g=d.getter(n.end),m=d.getter(n.percentComplete),k=d.getter(n.parentId||"");if(a(s).getTime()!==a(t).getTime()){b(e.map(u=>u.task),n);const i=a(t).getTime()-a(s).getTime();J(r(t),n,i)}if(g(s).getTime()!==g(t).getTime()&&E(e.map(i=>i.task),n),m(s)!==m(t)&&q(e.map(i=>i.task),n),n.parentId&&k(s)!==k(t)){let i;return e.length?G(e.map(u=>u.task),n,s):i=h.filter(u=>c(u)!==c(t)),H(i||h,n,t)}}return h},B=l=>{const{removedDataItem:t,taskModelFields:n,dataTree:p}=l,c=D.mapTree(p,n.children,e=>({...e}));let r=[{task:{[n.children]:c},childrenIndex:0}];const o=d.getter(n.id),s=d.getter(n.children),h=o(t);for(;r.length>0;){const e=r[r.length-1],a=e.task,g=o(a),m=s(a);if(g&&g===h)break;m&&m.length&&m.length>e.childrenIndex?(r.push({task:m[e.childrenIndex],childrenIndex:0}),e.childrenIndex++):r.pop()}if(r.length>1){const e=r[r.length-2],a=e.task;s(a).splice(e.childrenIndex-1,1),r=r.splice(1,r.length-2),S(r.map(m=>m.task),n)}return c},S=(l,t)=>{b(l,t),E(l,t),q(l,t)},G=(l,t,n)=>{const p=d.getter(t.children),c=d.setter(t.children);for(let r=l.length-1;r>=0;r--){const o=l[r],s=p(o);if(n.parentId===o.id){const h=s.filter(e=>e.parentId===o.id);c(o,h)}}},H=(l,t,n)=>{const p=d.getter(t.children),c=d.setter(t.children);return n.parentId===null?[...l,n]:(l=D.mapTree(l,t.children,r=>{if(r.id===n.parentId){const o=p(r)||[];c(r,[...o,n])}return{...r}}),l)},b=(l,t)=>{if(!l.length)return;const n=d.getter(t.children),p=d.getter(t.start),c=d.setter(t.start);for(let r=l.length-1;r>=0;r--){const o=l[r],s=n(o);if(s&&s.length){const h=s.reduce((e,a)=>Math.min(e,p(a).getTime()),p(s[0]).getTime());c(o,new Date(h))}}},E=(l,t)=>{if(!l.length)return;const n=d.getter(t.children),p=d.getter(t.end),c=d.setter(t.end);for(let r=l.length-1;r>=0;r--){const o=l[r],s=n(o);if(s&&s.length){const h=s.reduce((e,a)=>Math.max(e,p(a).getTime()),p(s[0]).getTime());c(o,new Date(h))}}},q=(l,t)=>{if(!l.length)return;const n=d.getter(t.children),p=d.getter(t.percentComplete),c=d.setter(t.percentComplete),r=({avg:o,n:s},h)=>({avg:((p(h)||0)+s*o)/(s+1),n:s+1});for(let o=l.length-1;o>=0;o--){const s=l[o],h=n(s);if(h&&h.length){const e=h.reduce(r,{avg:0,n:0}).avg;c(s,e)}}},J=(l,t,n)=>{if(!l)return;const p=d.getter(t.children),c=d.getter(t.start),r=d.setter(t.start),o=d.getter(t.end),s=d.setter(t.end),h=l.map(e=>({task:e,childrenIndex:0}));for(;h.length>0;){const e=h[h.length-1],a=e.task,g=p(a);g&&g.length&&g.length>e.childrenIndex?(h.push({task:g[e.childrenIndex],childrenIndex:0}),e.childrenIndex++):(h.pop(),r(a,new Date(c(a).getTime()+n)),s(a,new Date(o(a).getTime()+n)))}};exports.addDependency=N;exports.addTask=z;exports.removeTask=B;exports.updateTask=A;
