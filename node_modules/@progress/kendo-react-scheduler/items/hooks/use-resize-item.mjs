/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import { clone as u } from "@progress/kendo-react-common";
import * as k from "react";
import { useControlledState as C } from "../../hooks/useControlledState.mjs";
import { setField as i, getField as m, slotDive as _ } from "../../utils/index.mjs";
import { DATA_ACTION as b } from "../../constants/index.mjs";
import { useSchedulerViewSelectedItemsContext as Z } from "../../context/SchedulerViewContext.mjs";
import { useSchedulerFieldsContext as L } from "../../context/SchedulerContext.mjs";
var P = /* @__PURE__ */ ((t) => (t.set = "RESIZE_ITEM_SET", t.start = "RESIZE_ITEM_START", t.startDrag = "RESIZE_ITEM_START_DRAG", t.startDragSelected = "RESIZE_ITEM_START_DRAG_SELECTED", t.endDrag = "RESIZE_ITEM_END_DRAG", t.endDragSelected = "RESIZE_ITEM_END_DRAG_SELECTED", t.complete = "RESIZE_ITEM_COMPLETE", t.completeOccurrence = "RESIZE_ITEM_COMPLETE_OCCURRENCE", t.completeSeries = "RESIZE_ITEM_COMPLETE_SERIES", t.reset = "RESIZE_ITEM_RESET", t))(P || {});
const F = (t, M) => {
  const p = k.useRef(null), [d, A] = C(...M), [y] = Z(), r = L();
  return [d, A, (c, T) => {
    let o = d;
    switch (c.type) {
      case "RESIZE_ITEM_SET":
        o = c.payload;
        break;
      case "RESIZE_ITEM_RESET":
        o = null;
        break;
      case "RESIZE_ITEM_START": {
        if (T.stopPropagation(), !o)
          return;
        const s = c.payload.x, a = c.payload.y, e = _(s, a, 7);
        if (!e || e === p.current)
          return;
        const l = e.getAttribute("data-slot-start"), E = new Date(Number(l)), n = u(t.dataItem);
        if (E >= m(n, r.end))
          return;
        i(n, r.start, E), p.current = e, o = n;
        break;
      }
      case "RESIZE_ITEM_START_DRAG_SELECTED": {
        T.stopPropagation();
        const s = c.payload.x, a = c.payload.y, e = u(t.dataItem), l = _(s, a, 7);
        if (!l || l === p.current)
          return;
        const E = l.getAttribute("data-slot-start"), n = new Date(m(e, r.start)), f = new Date(Number(E)).getTime() - n.getTime();
        let D = !1;
        const w = y.map((I) => {
          if (!I.current)
            return null;
          const S = u(I.current.props.dataItem), R = new Date(I.current.props.start.getTime() + f);
          if (R >= m(S, r.end)) {
            D = !0;
            return;
          }
          return i(S, r.start, R), S;
        }).filter(Boolean);
        D || (o = [...w]);
        break;
      }
      case "RESIZE_ITEM_START_DRAG": {
        const s = c.payload.x, a = c.payload.y, e = _(s, a, 7);
        if (!e || e === p.current)
          return;
        const l = e.getAttribute("data-slot-start"), E = new Date(Number(l)), n = u(t.dataItem);
        if (E >= n.end)
          return;
        i(n, r.start, E), p.current = e, o = n;
        break;
      }
      case "RESIZE_ITEM_END_DRAG": {
        const s = c.payload.x, a = c.payload.y, e = _(s, a, 7);
        if (!e || e === p.current)
          return;
        const l = e.getAttribute("data-slot-end"), E = new Date(Number(l)), n = u(t.dataItem);
        if (E <= n.start)
          return;
        i(n, r.end, E), p.current = e, o = n;
        break;
      }
      case "RESIZE_ITEM_END_DRAG_SELECTED": {
        T.stopPropagation();
        const s = c.payload.x, a = c.payload.y, e = u(t.dataItem), l = _(s, a, 7);
        if (!l || l === p.current)
          return;
        const E = l.getAttribute("data-slot-start"), n = new Date(m(e, r.end)), f = new Date(Number(E)).getTime() - n.getTime();
        let D;
        const w = y.map((I) => {
          if (!I.current)
            return null;
          const S = u(I.current.props.dataItem), R = new Date(I.current.props.end.getTime() + f);
          if (R <= m(S, r.start)) {
            D = !0;
            return;
          }
          return i(S, r.end, R), S;
        }).filter(Boolean);
        D || (o = [...w]);
        break;
      }
      case "RESIZE_ITEM_COMPLETE": {
        o = null, t.onDataAction && d && t.onDataAction.call(void 0, {
          type: b.update,
          series: !1,
          dataItem: d
        });
        break;
      }
      case "RESIZE_ITEM_COMPLETE_OCCURRENCE": {
        o = null, t.onDataAction && d && t.onDataAction.call(void 0, {
          type: b.update,
          series: !1,
          dataItem: d
        });
        break;
      }
      case "RESIZE_ITEM_COMPLETE_SERIES": {
        o = null;
        let s;
        if (Array.isArray(d))
          s = d.map((a) => {
            const e = u(a);
            return i(e, r.start, m(a, r.start)), i(e, r.end, m(a, r.end)), e;
          });
        else {
          const a = u(d);
          i(a, r.start, m(d, r.start)), i(a, r.end, m(d, r.end)), s = a;
        }
        t.onDataAction && s && t.onDataAction.call(void 0, {
          type: b.update,
          series: !0,
          dataItem: s
        });
        break;
      }
      default:
        o = null;
        break;
    }
    A(o);
  }];
};
export {
  P as RESIZE_ITEM_ACTION,
  F as useResizeItem
};
