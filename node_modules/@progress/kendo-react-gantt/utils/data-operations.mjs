/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import { setter as k, getter as p } from "@progress/kendo-react-common";
import { mapTree as v } from "./index.mjs";
const J = (l) => {
  const { dependencyData: t, dependencyModelFields: n, defaultDataItem: g, fromId: s, toId: r, type: d } = l, c = t.map((m) => ({ ...m })), i = k(n.fromId), e = k(n.toId), a = k(n.type), h = g ? { ...g } : {};
  return i(h, s), e(h, r), a(h, d), c.push(h), c;
}, K = (l) => {
  const { defaultDataItem: t, selectedDataItem: n, direction: g, taskModelFields: s, dataTree: r, slotStart: d, slotEnd: c } = l, i = v(r, s.children, (I) => ({ ...I })), e = k(s.start), a = k(s.end), h = p(s.start), m = p(s.end), T = k(s.parentId || ""), o = t ? { ...t } : {}, C = h(o) && m(o);
  if (!n || g === "none")
    C || (e(o, d), a(o, c)), s.parentId && T(o, null), i.unshift(o);
  else {
    const I = [
      {
        task: { [s.children]: i },
        childrenIndex: 0
      }
    ], w = p(s.id), y = p(s.children), R = k(s.children), j = w(n);
    for (; I.length > 0; ) {
      const f = I[I.length - 1], S = f.task, P = w(S), u = y(S);
      if (P && P === j)
        break;
      u && u.length && u.length > f.childrenIndex ? (I.push({
        task: u[f.childrenIndex],
        childrenIndex: 0
      }), f.childrenIndex++) : I.pop();
    }
    if (I.length > 1) {
      const f = I[I.length - 1].task, S = I[I.length - 2].childrenIndex, u = I[I.length - 2].task, E = y(u);
      switch (g) {
        case "child": {
          let x = y(f);
          x || (x = [], R(f, x)), C || (e(o, new Date(h(f).getTime())), a(o, new Date(m(f).getTime()))), x.push(o), T(o, w(f)), D(
            I.splice(1, I.length - 1).map((q) => q.task),
            s
          );
          break;
        }
        case "above": {
          h(u) && m(u) && !C ? (e(o, new Date(h(f).getTime())), a(o, new Date(m(f).getTime()))) : (e(o, d), a(o, c)), E.splice(S - 1, 0, o), T(o, w(u)), D(
            I.splice(1, I.length - 2).map((x) => x.task),
            s
          );
          break;
        }
        case "below": {
          h(u) && m(u) && !C ? (e(o, new Date(h(f).getTime())), a(o, new Date(m(f).getTime()))) : (e(o, d), a(o, c)), E.splice(S, 0, o), T(o, w(u)), D(
            I.splice(1, I.length - 2).map((x) => x.task),
            s
          );
          break;
        }
      }
    }
  }
  return i;
}, L = (l) => {
  const { updatedDataItem: t, taskModelFields: n, dataTree: g } = l, s = p(n.id), r = p(n.children), d = s(t);
  let c;
  const i = v(g, n.children, (a) => s(a) === d ? (c = a, { ...t }) : { ...a });
  let e = [
    {
      task: { [n.children]: i },
      childrenIndex: 0
    }
  ];
  for (; e.length > 0; ) {
    const a = e[e.length - 1], h = a.task, m = s(h), T = r(h);
    if (m && m === d)
      break;
    T && T.length && T.length > a.childrenIndex ? (e.push({
      task: T[a.childrenIndex],
      childrenIndex: 0
    }), a.childrenIndex++) : e.pop();
  }
  if (e.length > 1) {
    e = e.splice(1, e.length - 2);
    const a = p(n.start), h = p(n.end), m = p(n.percentComplete), T = p(n.parentId || "");
    if (a(c).getTime() !== a(t).getTime()) {
      b(
        e.map((C) => C.task),
        n
      );
      const o = a(t).getTime() - a(c).getTime();
      B(r(t), n, o);
    }
    if (h(c).getTime() !== h(t).getTime() && N(
      e.map((o) => o.task),
      n
    ), m(c) !== m(t) && O(
      e.map((o) => o.task),
      n
    ), n.parentId && T(c) !== T(t)) {
      let o;
      return e.length ? z(
        e.map((C) => C.task),
        n,
        c
      ) : o = i.filter((C) => s(C) !== s(t)), A(o || i, n, t);
    }
  }
  return i;
}, Q = (l) => {
  const { removedDataItem: t, taskModelFields: n, dataTree: g } = l, s = v(g, n.children, (e) => ({ ...e }));
  let r = [
    {
      task: { [n.children]: s },
      childrenIndex: 0
    }
  ];
  const d = p(n.id), c = p(n.children), i = d(t);
  for (; r.length > 0; ) {
    const e = r[r.length - 1], a = e.task, h = d(a), m = c(a);
    if (h && h === i)
      break;
    m && m.length && m.length > e.childrenIndex ? (r.push({
      task: m[e.childrenIndex],
      childrenIndex: 0
    }), e.childrenIndex++) : r.pop();
  }
  if (r.length > 1) {
    const e = r[r.length - 2], a = e.task;
    c(a).splice(e.childrenIndex - 1, 1), r = r.splice(1, r.length - 2), D(
      r.map((m) => m.task),
      n
    );
  }
  return s;
}, D = (l, t) => {
  b(l, t), N(l, t), O(l, t);
}, z = (l, t, n) => {
  const g = p(t.children), s = k(t.children);
  for (let r = l.length - 1; r >= 0; r--) {
    const d = l[r], c = g(d);
    if (n.parentId === d.id) {
      const i = c.filter((e) => e.parentId === d.id);
      s(d, i);
    }
  }
}, A = (l, t, n) => {
  const g = p(t.children), s = k(t.children);
  return n.parentId === null ? [...l, n] : (l = v(l, t.children, (r) => {
    if (r.id === n.parentId) {
      const d = g(r) || [];
      s(r, [...d, n]);
    }
    return { ...r };
  }), l);
}, b = (l, t) => {
  if (!l.length)
    return;
  const n = p(t.children), g = p(t.start), s = k(t.start);
  for (let r = l.length - 1; r >= 0; r--) {
    const d = l[r], c = n(d);
    if (c && c.length) {
      const i = c.reduce(
        (e, a) => Math.min(e, g(a).getTime()),
        g(c[0]).getTime()
      );
      s(d, new Date(i));
    }
  }
}, N = (l, t) => {
  if (!l.length)
    return;
  const n = p(t.children), g = p(t.end), s = k(t.end);
  for (let r = l.length - 1; r >= 0; r--) {
    const d = l[r], c = n(d);
    if (c && c.length) {
      const i = c.reduce(
        (e, a) => Math.max(e, g(a).getTime()),
        g(c[0]).getTime()
      );
      s(d, new Date(i));
    }
  }
}, O = (l, t) => {
  if (!l.length)
    return;
  const n = p(t.children), g = p(t.percentComplete), s = k(t.percentComplete), r = ({ avg: d, n: c }, i) => ({
    avg: ((g(i) || 0) + c * d) / (c + 1),
    n: c + 1
  });
  for (let d = l.length - 1; d >= 0; d--) {
    const c = l[d], i = n(c);
    if (i && i.length) {
      const e = i.reduce(r, { avg: 0, n: 0 }).avg;
      s(c, e);
    }
  }
}, B = (l, t, n) => {
  if (!l)
    return;
  const g = p(t.children), s = p(t.start), r = k(t.start), d = p(t.end), c = k(t.end), i = l.map((e) => ({ task: e, childrenIndex: 0 }));
  for (; i.length > 0; ) {
    const e = i[i.length - 1], a = e.task, h = g(a);
    h && h.length && h.length > e.childrenIndex ? (i.push({
      task: h[e.childrenIndex],
      childrenIndex: 0
    }), e.childrenIndex++) : (i.pop(), r(a, new Date(s(a).getTime() + n)), c(a, new Date(d(a).getTime() + n)));
  }
};
export {
  J as addDependency,
  K as addTask,
  Q as removeTask,
  L as updateTask
};
