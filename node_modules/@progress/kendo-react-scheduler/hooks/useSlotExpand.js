/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const x=require("react"),p=require("../views/common/utils.js"),E=require("../constants/index.js"),O=require("@progress/kendo-react-common"),S=require("../context/SchedulerContext.js");function j(e){const t=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(e){for(const c in e)if(c!=="default"){const f=Object.getOwnPropertyDescriptor(e,c);Object.defineProperty(t,c,f.get?f:{enumerable:!0,get:()=>e[c]})}}return t.default=e,Object.freeze(t)}const i=j(x),q=(e,t)=>{const c=i.useRef(void 0),f=i.useRef(0),m=S.useSchedulerElementContext(),w=()=>{if(!e.current)return;const n=e.current.element;n&&(f.current=n.clientHeight)},d=i.useCallback(()=>{if(!t||!e.current)return;const n=e.current.element,g=e.current.props;if(!n)return;const a=p.getPadding(n),r=new Map,o=g.items.filter(u=>u._ref.current);o.forEach(u=>{var v,R,y;if(!u._ref.current)return;const{height:l}=p.getRect(u._ref.current.element),_=(R=(v=u._ref.current)==null?void 0:v._order)!=null?R:-1;((y=r.get(_))!=null?y:0)<l&&r.set(_,l)});const s=Array.from(r.values()).reduce((u,l)=>u+l,0),b=o.length*E.BORDER_WIDTH*2+s-(a||0)+(typeof t=="object"&&t.offsetTop?t.offsetTop:0)+(typeof t=="object"&&t.offsetBottom?t.offsetBottom:0);o.length?b>f.current-a&&p.setRect(n,{height:b},!0):n&&(n.style.minHeight="")},[t,e]),h=i.useCallback(()=>{c.current!==void 0&&window.cancelAnimationFrame(c.current),c.current=window.requestAnimationFrame(()=>{d()})},[d]);O.useIsomorphicLayoutEffect(w,[]),i.useEffect(d,[e,e.current&&e.current.props,t]),i.useEffect(()=>{if(!e.current)return;const a=e.current.props.items.filter(r=>r._ref.current).map(r=>{if(!r._ref.current||!r._ref.current.element||!m.current)return;const o=window.ResizeObserver,s=o&&new o(h);return s&&s.observe(r._ref.current.element),()=>{s&&s.disconnect()}});return()=>{a.forEach(r=>r&&r())}},[h,m,e])};exports.useSlotExpand=q;
