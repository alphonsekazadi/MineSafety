/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
const l = (t, o = 0, e = 0, f = []) => {
  if (t.length <= o)
    return [f];
  const i = [];
  return t[o].data.map((n) => {
    i.push(
      ...l(t, o + 1, e + 1, [
        ...f,
        {
          ...n,
          field: t[o].field,
          valueField: t[o].valueField,
          colorField: t[o].colorField,
          multiple: t[o].multiple
        }
      ])
    );
  }), i;
};
function a(t, o) {
  const e = [];
  if (!o || !o.length)
    return e;
  if (t && t.resources && t.resources.length) {
    const f = t.resources;
    for (let i = 0; i < f.length; i++) {
      const n = o.find((h) => h.name === f[i]);
      e.push(n);
    }
  }
  return e;
}
const p = (t, o = t.length - 1) => {
  const e = Math.max(0, o), f = [];
  t && t.length || (t = [{}]);
  const i = (t[e].data || []).map((d) => ({
    ...d,
    text: d[t[e].textField]
  })) || [], n = i.length;
  let h = 1;
  for (let d = 0; d <= e; d++)
    h *= (t[d].data || []).length || 1;
  for (let d = 0; d < h; d++)
    i[d % n] && f.push(i[d % n]);
  return f;
}, g = (t) => {
  if (!t)
    return { top: 0, left: 0, width: 0, height: 0, right: 0 };
  const o = t.offsetTop, e = t.offsetLeft, f = t.offsetParent ? t.offsetParent.offsetWidth - (t.offsetLeft + t.offsetWidth) : 0, i = t.offsetWidth, n = t.offsetHeight;
  return {
    top: o,
    left: e,
    right: f,
    width: i,
    height: n
  };
}, s = (t, o = !1) => parseFloat(window.getComputedStyle(t)[o ? "paddingLeft" : "paddingTop"] || "0") + parseFloat(window.getComputedStyle(t)[o ? "paddingRight" : "paddingBottom"] || "0"), u = (t, o = !1) => parseFloat(window.getComputedStyle(t)[o ? "borderLeftWidth" : "borderTopWidth"] || "0") + parseFloat(window.getComputedStyle(t)[o ? "borderRightWidth" : "borderBottomWidth"] || "0"), r = (t, o, e = !1) => {
  t && (o.top !== void 0 && (t.style.top = `${o.top}px`), o.left !== void 0 && (t.style.left = `${o.left}px`), o.width !== void 0 && (t.style.width = `${o.width}px`), o.height !== void 0 && !e && (t.style.height = typeof o.height == "number" ? `${o.height}px` : o.height), e && (t.style.minHeight = o.height !== void 0 && o.height > 0 ? `${o.height}px` : ""));
};
export {
  p as expandResources,
  u as getBorders,
  s as getPadding,
  g as getRect,
  r as setRect,
  l as toFlatGroupResources,
  a as toGroupResources
};
